<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的博客</title>
  <icon>https://www.gravatar.com/avatar/5e6c22ad69915102664d6eb06cca090f</icon>
  <subtitle>扬帆起航</subtitle>
  <link href="http://www.saily.top/atom.xml" rel="self"/>
  
  <link href="http://www.saily.top/"/>
  <updated>2021-01-04T10:00:55.832Z</updated>
  <id>http://www.saily.top/</id>
  
  <author>
    <name>帆</name>
    <email>hyyangfan@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发源码-线程池</title>
    <link href="http://www.saily.top/2021/01/04/jdk/%E5%B9%B6%E5%8F%9106/"/>
    <id>http://www.saily.top/2021/01/04/jdk/%E5%B9%B6%E5%8F%9106/</id>
    <published>2021-01-04T13:00:37.000Z</published>
    <updated>2021-01-04T10:00:55.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>JDK为我们提供了4种构造线程池的方式，分别是</p><ul><li>newFixedThreadPool<ul><li>固定数量的线程</li></ul></li><li>newSingleThreadExecutor<ul><li>只有一个线程的线程池</li></ul></li><li>newCachedThreadPool<ul><li>线程数量不固定，不停的创建线程，用完了以后又回收</li></ul></li><li>newScheduledThreadPool<ul><li>提交任务后，在指定的时间去执行</li></ul></li></ul><p>我们也可以构造自己的线程池，来实现一些我们想要的一些功能。</p><a id="more"></a><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>来看看这个fixed线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着这个线程池，看一下ThreadPoolExecutor的构造函数，corePoolSize和maximumPoolSize都是指定的值，然后队列是用的无界队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize：线程池里应该有多少个线程</p></li><li><p>maximumPoolSize：如果线程池里的线程不够用了，等待队列还塞满了，可能会增加一些线程，但是最多把线程数量增加到maximumPoolSize指定的数量</p></li><li><p>keepAliveTime + TimeUnit：如果线程数量超出了corePoolSize的话，超出corePoolSize指定数量的线程，就会在空闲keepAliveTime毫秒之后，就会自动被释放掉</p></li><li><p>workQueue：线程池的等待队列</p></li><li><p>threadFactory：在线程池里创建线程的时候，指定一个线程工厂，按照自己的方式创建线程出来</p></li><li><p>RejectedExecutionHandler：如果线程池里的线程都在执行任务，然后等待队列满了，此时增加额外线程也达到了maximumPoolSize指定的数量了，这个时候实在无法承载更多的任务了，此时就会执行这个</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;p&gt;JDK为我们提供了4种构造线程池的方式，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;newFixedThreadPool&lt;ul&gt;
&lt;li&gt;固定数量的线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor&lt;ul&gt;
&lt;li&gt;只有一个线程的线程池&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;newCachedThreadPool&lt;ul&gt;
&lt;li&gt;线程数量不固定，不停的创建线程，用完了以后又回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool&lt;ul&gt;
&lt;li&gt;提交任务后，在指定的时间去执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们也可以构造自己的线程池，来实现一些我们想要的一些功能。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发源码-并发工具包</title>
    <link href="http://www.saily.top/2020/12/24/jdk/%E5%B9%B6%E5%8F%9105/"/>
    <id>http://www.saily.top/2020/12/24/jdk/%E5%B9%B6%E5%8F%9105/</id>
    <published>2020-12-24T13:00:37.000Z</published>
    <updated>2021-01-04T09:22:19.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;Long&gt; requestId = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">        requestId.set(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(requestId.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal在并发编程里，非常常用，每个线程执行的时候，都保存一个变量的副本，每个线程自己用自己的，互不影响，经常用于保存一些上下文信息，或者请求的id之类的。</p><a id="more"></a><p>在Thread里，有个变量 <code>ThreadLocal.ThreadLocalMap threadLocals</code>，是一个map，这个就可以用于保存，每一个线程独有的一份数据。可以保存多个ThreadLocal的变量副本。</p><p>这个map的key就是ThreadLocal，value就是对应的变量副本。</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>有时候面试可能会问到，说ThreadLocal有内存泄漏的问题。</p><p>ThreadLocal的内部是ThreadLocalMap。ThreadLocalMap内部是由一个Entry数组组成。Entry类的构造函数为 Entry（弱引用的ThreadLocal对象， Object value对象）。因为Entry的key是一个弱引用的ThreadLocal对象，所以在 垃圾回收 之前，将会清除此Entry对象的key。那么， ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value。这些 value 被Entry对象引用，所以value所占内存不会被释放。</p><p>所以一定要记得调用remove方法，及时清除不用的对象，并且也会清理key为null的value。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1开始执行，休眠2秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1准备执行countDown操作&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1完成countDown操作&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2开始执行，休眠2秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2准备执行countDown操作&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2完成countDown操作&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程准备执行countDownLatch的await操作，将同步阻塞等待&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程完成countDown操作，阻塞等待结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch还是基于AQS来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个state，在初始化的时候，指定了就是2，其实countDown，就是把state -1</span></span><br><span class="line">    <span class="comment">// 结合上面的demo，new CountDownLatch(2)，这里的值应该是2</span></span><br><span class="line">    <span class="comment">// 所以肯定是返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 这个时候，p应该是空Node</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接阻塞挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>state != 0</li><li>将main线程封装为一个node，加入AQS的等待队列</li><li>调用LockSupport.park()操作，挂起main线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// state - 1</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 出队并唤醒线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 如果等于0了，说明countDown结束了</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从AQS的队列中，将之前阻塞的Node，也就是main线程唤醒。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown，就是把state -1，直到减为0的时候。就调用doReleaseShared()，从队列里将阻塞的Node唤醒。</p><ol><li>await()，触发了一个线程入队阻塞等待</li><li>countDown()，如果state == 0，唤醒队列里等待的所有的线程</li><li>所有线程被唤醒，发现state == 0，就从await()方法里退出</li></ol><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程都完成了自己的任务，现在可以合并结果&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1执行一部分自己工作&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;最终结果合并完成，线程1可以退出&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2执行一部分自己工作&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;最终结果合并完成，线程2可以退出&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2执行一部分自己工作&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;最终结果合并完成，线程3可以退出&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑都在await方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 搞了一个锁，保证并发安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个是3，所以调用一次await()，这个就会-1</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 如果都为0，说明await调用满了，会触发动作的执行</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 这里有调用Condition的signalAll方法，唤醒所有阻塞的线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 否则就死循环，利用Condition的await，将当前线程阻塞</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// 被唤醒以后，发现这个对象已经发生了变化，返回退出了</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 可以重复利用再来一轮</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个源码看下来，还是比较简单，就基于lock就实现了和condition就实现了。</p><p>线程1：</p><ol><li><p>ReentrantLock，加锁，保证多线程并发安全</p></li><li><p>count = 3，–count = 2</p></li><li><p>Condition.await()，底层，其实是释放了当前的lock锁，触发了把当前线程加入condition等待队列里，挂起当前线程</p></li></ol><p>线程2： </p><ol><li><p>ReentrantLock，加锁，保证多线程并发安全</p></li><li><p>count = 2，–count = 1</p></li><li><p>Condition.await()，底层，其实是释放了当前的lock锁，触发了把当前线程加入condition等待队列里，挂起当前线程</p></li></ol><p>线程3： </p><ol><li><p>ReentrantLock，加锁，保证多线程并发安全</p></li><li><p>count = 1，–count = 0</p></li><li><p>Condition.await()，底层，其实是释放了当前的lock锁，触发了把当前线程加入condition等待队列里，挂起当前线程。然后执行构造方法传入的action，并唤醒所有阻塞的线程，也就是把condition队列里的线程全部唤醒。</p></li></ol><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>这个是等待指定的线程完成任务，触发退出条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1执行一个计算任务&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2执行一个计算任务&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待一个线程完成任务即可&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有一个线程完成，阻塞的acquire代码就会得到继续执行。</p><p><code>new Semaphore(0);</code>这行代码，在就是给state传了了一个0。</p><p>然后acquire，是获取一个读锁，最后是调用到了acquireSharedInterruptibly方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 刚调用，就肯定是-1</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 尝试获取锁，阻塞等待</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 这里是0</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 0 - 1 = -1，</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// 所以返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，就是相当于有一个线程，在等待获取锁。然后在线程release的时候，会把state +1，然后唤醒阻塞的线程。</p><p>因为有死循环，被唤醒的线程，再次获取锁，此时</p><p><code>int remaining = available - acquires;</code> -&gt; <code>1 - 1 = 0</code>，拿到了锁。程序继续执行。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>HashMap在并发的情况下，会有bug，比如说死循环，然后导致数据丢失。所以在并发情况下，一定要去使用ConcurrentHashMap来编程。</p><p>那这个ConcurrentHashMap的解决方案，实际上就是分段加锁，HashMap底层源码不是数组么，如果每次操作都加锁的话，肯定性能不好，所以ConcurrentHashMap就提供了分段加锁的方案，把一份数据拆分为多个segment，对每个段设置一把小锁，put操作只对某个段的segment进行加锁。然后其他线程操作其他的数据，是没有锁竞争的，大大的提高了安全性和并发的效率。</p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>分析一下最核心的put方法，看看ConcurrentHashMap的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 和HashMap一样，将hashcode做一个运算，让高低16位都参与到运算中</span></span><br><span class="line">    <span class="comment">// (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// i = (n - 1) &amp; hash 位运算，相当于取模</span></span><br><span class="line">        <span class="comment">// tabAt，(Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用CAS操作对数组进行插入，成功后就break了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 走到这里，表示数组的某个位置已经有Node了，发生了hash冲突，要追加链表，或者往红黑树挂节点</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// f就是数组上某个位置链表上的第一个Node，对某一个段进行加锁</span></span><br><span class="line">            <span class="comment">// 加锁后的操作都是线程安全的</span></span><br><span class="line">            <span class="comment">// 所以默认，是可以16个线程并发操作的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 对红黑树的处理</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 如果一个链表的元素的数量超过了8，达到了一个阈值之后，就会将链表转换为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在treeifyBin方法中，还包含了对是否需要扩容的判断，扩容后，数组的size必须是原来的2的倍数，这样hash运算才能能定位到对应的位置。</p><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>同时，get方法和size方法是不需要加锁的，因为都是通过valotile的方式去读取的值，有了可见性的保证，线程在读取数据的时候，load屏障，因为有MESI机制的存在，会先嗅探一下无效队列，如果某个数据被其他线程修改了，此时马上过期掉本地高速缓存里的缓存数据，invalid（I），然后再读的时候，就需要发送read消息到总线，从其他线程修改修改这个值的线程的高速缓存里，必须这个加载到最新的值，不需要加锁。</p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>ArrayList是线程不安全的，取而代之是的CopyOnWriteArrayList，写时复制的ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        list.get(<span class="number">0</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList，底层维护了一个volatile的数组变量，保证了多线程读写的可见性，只要有一个线程修改了这个数组，其他线程马上能感知到变化。</p><p>每一个数组，还维护了一把ReentrantLock锁，用独占锁来保证，在修改数组里的数组的时候，只有一个线程获取到锁进行操作。所以CopyOnWriteArrayList的并发写性能不好，只能有一个线程可以进行写操作。</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 先用Arrays.copyOf复制出来一个数组，然后对复制后的数组，进行添加操作</span></span><br><span class="line">        <span class="comment">// 然后再将新数组，设置到volatile修饰的数组中 </span></span><br><span class="line">        <span class="comment">// 这就是所谓的写时复制</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>接下来看修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制一个新数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 对新数组的值做修改</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置回去，写时复制</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是删除的最后面的元素，直接只复制前面的部分到新数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除中间的元素，就把该元素前后的部分复制到新数组中</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>读操作的源码很简单，这里没有加锁，因为读的就是volatile的变量，增删改，有独占锁来保证只有一个线程会修改，并且每次都是复制一个新的数组，修改完毕后再设置到数组变量中，同时因为数组变量是volatile修饰的，所以读操作的线程每次都能及时的读到变化，或者修改操作还没有来得及完成写入变量，我读到的也是老数组的值，不存在锁竞争的操作，性能很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>迭代器的方法较多，就不全部复制了，他的理念和读操作是类似的，在获取迭代器的时候，将老数组的值作为一个snapshot存下来，进行循环迭代，所以这个snapshot，是不允许修改或者删除的，只能遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>它的核心理念是弱一致性提升读并发，多个线程并发读写这个list，中间肯定是有复制后的数组被修改好了，但是还没有来得及写入到array变量中，这个时候读到的肯定就是老数组里的数据，在这个过程中，多个线程读到的数据可能是不一样的，但是数据的最终是一致的。</p><p>优点：读和写不互斥的，写和写互斥，同一时间就一个线程可以写，但是写的同时可以允许其他所有人来读；读和读也是并发的；比读写锁机制还要好；他也不涉及到Unsafe.getObjectVolatile</p><p>使用场景：多线程并发安全性，可以选用他；尽可能是<strong>读多写少</strong>的场景，大量的读是不被影响的；可能有一个线程刚刚发起了写，此时别的线程读到的还是旧的数据，也有这种可能</p><p>缺点：空间换时间，写的时候，经常内存里会出现复制出来的一模一样的副本，对内存消耗过大，副本机制保证了保证读写并发优化，大量的并发读不需要锁互斥，list如果很大，要考虑在线上运行的时候，内存占用会是list大小的几倍。</p><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>线程安全的链表队列，有链表，底层肯定就是基于Node的链表，在源码中大量用到了cas和volatile变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentLinkedQueue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        queue.offer(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        queue.poll();</span><br><span class="line">        queue.peek();</span><br><span class="line">        queue.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.size();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的Node数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 利用UNSAFE通过偏移量来设置</span></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h2><p>入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// 重新获取tail节点，继续相同逻辑</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// cas操作，只有一个线程会成功，没有加锁，保证只有一个线程会入队成功</span></span><br><span class="line">            <span class="comment">// 如果另外线程失败了，重新进入循环，变化指针，将指针往后挪，一直重试到成功为止</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"><span class="comment">// 同样的，通过cas将队头出队，然后将下一个节点变成队头，只有一个线程会成功</span></span><br><span class="line">            <span class="comment">// 如果失败了，就重新获取队头，循环一直到成功为止</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p>peek，也是获取队头的数据，但是他并不出队，就是获取了看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> || (q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h2><p>删除，删除队列里某一个元素，这个是需要遍历整个队列，如果发现相同的元素，就利用cas设置为null，然后通过指针变换，将这个元素删除掉，在使用队列的场景，删除是比较少用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123;</span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>)</span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pred = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>获取队列的大小，将队列进行遍历，然后计算得出一个队列的大小，所以说这个大小并不是实时的，完全有可能在遍历的过程中，数据就发生了很大的变化，大部分的并发工具类，为了并发的效率，都在一定程度上舍弃了数据的一致性，只保留了最终一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h2><p>查询是否包含某个数据，也是一样的遍历，有可能在遍历过程中，数据发生了改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123;</span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; o.equals(item))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>大多数情况下，我们直接用并发包的工具就行了，如果想要数据完全保证一致性的数据结构，只能是自己采用加锁的方式去使用。</p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>ConcurrentLinkedQueue是无界队列，他是单向链表，不停往里面塞，可能会导致内存溢出。</p><p>LinkedBlockingQueue是有界队列，也是链表，但是限制了链表的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        queue.take();</span><br><span class="line">        queue.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.size();</span><br><span class="line">        queue.iterator();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><p>LinkedBlockingQueue，大量运用了锁的API来进行阻塞和唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 一个put，独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">// 当前队列的大小</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// capacity就是有界队列的大小，如果以及满了，就阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 这个是putLock对应的Condition</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有满，那么就从队尾入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 此时判断一下别的线程有没有可能消费了，队列有空间，唤醒正在阻塞的putLock线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c == 0也就是全部被消费完了，说明有线程正在阻塞了，尝试唤醒所有等待takeLock的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><p>出队也是一样，锁+阻塞和唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列空了，阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 队列里还有，再尝试唤醒一个正在等待的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列是满的，说明有put的线程在阻塞等待，take以后尝试唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h2><p>AtomicInteger维护的size，本来就是线程安全的，而且由于put和take都是基于锁来操作的，所以这个size是实时的，并且是准确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>这个也是有界队列，但是是基于数组实现的，队列的长度，就是数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        queue.put(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        queue.take();</span><br><span class="line">        queue.size();</span><br><span class="line">        queue.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 同样也是加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 直接获取数组的长度用于比较，数组满了以后，就直接阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">  <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="comment">// 因为有锁，所以可以直接修改数组里的值</span></span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 每放入一个元素后，就往后挪一位，直到数组所有索引都被使用过以后，又从头开始</span></span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 唤醒正在阻塞take的线程</span></span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="take-1"><a href="#take-1" class="headerlink" title="take"></a>take</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列是空的，take线程会阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">  <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="comment">// 从0开始往后读取</span></span><br><span class="line">  E x = (E) items[takeIndex];</span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 读到队尾后，又从头开始读</span></span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">    itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 唤醒正在put阻塞的线程</span></span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size和iterator"><a href="#size和iterator" class="headerlink" title="size和iterator"></a>size和iterator</h2><p>size和iterator，是直接加独占锁，此时此刻是没有任何一个线程可以出队或者是入队的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadLocalDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ThreadLocal&amp;lt;Long&amp;gt; requestId = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Long&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        requestId.set(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(requestId.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;ThreadLocal在并发编程里，非常常用，每个线程执行的时候，都保存一个变量的副本，每个线程自己用自己的，互不影响，经常用于保存一些上下文信息，或者请求的id之类的。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发源码-锁</title>
    <link href="http://www.saily.top/2020/10/23/jdk/%E5%B9%B6%E5%8F%9103/"/>
    <id>http://www.saily.top/2020/10/23/jdk/%E5%B9%B6%E5%8F%9103/</id>
    <published>2020-10-23T13:00:37.000Z</published>
    <updated>2020-12-25T09:06:22.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized就是加锁，一旦加锁以后，就只能当前线程访问和修改加锁的变量，其他线程只能阻塞等待，这就保证了原子性。</p><p>synchronized可以锁两种对象，一种是对某个实例对象进行加锁，一种是对类进行加锁。对类加锁，本质上也是对实例加锁，只不过是对class对象进行加锁。</p><p>如果用synchronized修饰普通方法，那就是对当前类的实例进行加锁。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用synchronized修饰静态方法，那就是对当前类的class对象进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(Demo.class) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized涉及到jvm底层的两个指令，分别是monitorenter和monitorexit两个指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line"><span class="comment">// 代码对应的指令</span></span><br><span class="line">monitorexit</span><br></pre></td></tr></table></figure><p>每个对象都有一个关联的monitor属性，比如一个对象实例就有一个monitor，一个类的class对象也有一个monitor，如果要对这个对象进行加锁，那么必须获取这个对象关联的monitor的lock锁。</p><p>原理大概就是，monitor里有一个从0开始的计数器，如果一个线程要获取monitor的锁，就看他的计数器是不是0，如果是0，说明没人获取锁，然后拿到锁以后就加1。</p><p>同时，monitor是支持重入锁的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line"><span class="comment">// 一大堆的代码</span></span><br><span class="line">  <span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line">  <span class="comment">// 一大堆的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就对同一个对象，加了两次锁，猜一下就知道，他原理肯定是每次进到synchronized(myObject)代码的时候，先看对象的monitor里的计数器是不是0，如果是0，就直接获取锁，并把对象里的monitor的计数器加1，如果不是0，看加锁的时候是不是同一个线程，如果是，就再加1，如果不是同一个线程呢，那就阻塞等待吧。</p><p>然后执行代码代码块退出的时候，会执行monitorexit的指令，此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0。</p><p>然后之前阻塞的线程，再次竞争锁，但是只有一个线程可以拿到锁。</p><p><img src="/img/jdk/image-20201022162819834.png" alt="image-20201022162819834"></p><h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p>对于有锁的代码，也就离不开wait和notify的使用，在加锁的代码中，可以wait挂起线程，并释放锁，除非其他线程对同一个对象调用notify，线程被唤醒，然后再次尝试获取锁。</p><p>wait与notify，跟synchronized是同样的原理，都是monitor，对象的monitor里，除了计数器，还有一个叫wait set的变量，加锁的时候，会对对象的monitor的计数器+1，如果调用wait方法，会将当前线程的id之类的东西，加入到monitor的wait set中，如果对这个对象调用notifyAll()，就会清空wait set，并同时唤醒所有线程。</p><p><img src="/img/jdk/image-20201022163420129.png" alt="image-20201022163420129"></p><p>面试有个经常问的问题，wait与sleep的区别：前者释放锁，后者不释放锁</p><p>wait()，必须是有人notify唤醒他</p><p>wait(timeout)，阻塞一段时间，然后自己唤醒，继续争抢锁</p><p>wait与notify，必须在synchronized代码块中使用，因为必须是拥有monitor lock的线程才可以执行wait与notify操作</p><p>因此wait与notify，必须与synchornized一起，对同一个对象进行使用，这样他们对应的monitor才是一样的</p><p> notify()与notifyall()：前者就唤醒block状态的一个线程，后者唤醒block状态的所有线程</p><h2 id="synchronized能不能保证可见性"><a href="#synchronized能不能保证可见性" class="headerlink" title="synchronized能不能保证可见性"></a>synchronized能不能保证可见性</h2><p>synchronized是可以保证可见性的，那么单例模式双检锁的volatile，是做什么用的呢？看下面的解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile在这里的作用是为了防止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = <span class="keyword">new</span> Socket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized本身就是可以保证可见性的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                    <span class="comment">// 对象的初始化是分为几个步骤的：初始化一块内存空间，给对象里的变量进行初始化，执行构造方法等等</span></span><br><span class="line">                    <span class="comment">// 有可能会出现指令重排，有可能会导致DoubleCheckSingleton里的字段还没有在构造函数里初始化，比如socket，还是null</span></span><br><span class="line">                    <span class="comment">// 但是内存空间已经分配好了，指针也分配了，也就是instance变量不是null</span></span><br><span class="line">                    <span class="comment">// 此时另外一个线程来调用的时候，发现instance不是null，然后返回，马上进行相关调用，结果发现socket是null，调用失败</span></span><br><span class="line">                    <span class="comment">// volatile有内存屏障，写操作后有storeload屏障，会保证写完之前不能被读到</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加锁的原理"><a href="#加锁的原理" class="headerlink" title="加锁的原理"></a>加锁的原理</h2><p>加锁的原理，和Lock加锁的原理类似，只不过它是基于C++的程序来实现的。</p><p>Java对象分为对象头和实例变量两块，其中实例变量就是平时看到的对象里的那些变量数据。然后对象头包含了两块东西，一个是Mark Word（包含hashCode、锁数据、GC数据，等等），另一个是Class Metadata Address（包含了指向类的元数据的指针）。</p><p>在Mark Word里有一个指针，指向了这个对象实例关联的monitor的地址，这个monitor是c++实现的，不是java实现的。这个monitor实际上是c++实现的一个ObjectMonitor对象，里面包含了一个<code>_owner</code>指针，指向了持有锁的线程。</p><p>ObjectMonitor里有一个entrylist，想要加锁的线程全部先进入这个entrylist等待获取机会尝试加锁，实际有机会加锁的线程，就会设置<code>_owner</code>指针指向自己，然后对_count计数器累加1次。</p><p>各个线程尝试竞争进行加锁，此时竞争加锁是在JDK 1.6以后优化成了基于CAS来进行加锁，理解为跟之前的Lock API的加锁机制是类似的，CAS操作，操作<code>_count</code>计数器，比如说将_<code>_count</code>值尝试从0变为1。</p><p>如果成功了，那么加锁成功了；如果失败了，那么加锁失败了。</p><p>然后释放锁的时候，先是对<code>_count</code>计数器递减1，如果为0了就会设置<code>_owner</code>为null，不再指向自己，代表自己彻底释放锁。</p><p>如果获取锁的线程执行wait，就会将计数器递减，同时<code>_owner</code>设置为null，然后自己进入waitset中等待唤醒，别人获取了锁执行notify的时候就会唤醒waitset中的线程竞争尝试获取锁。特别在JDk 1.6之后，对synchronized内的加锁机制做了大量的优化，优化为CAS加锁。 </p><p>如果把ReentrantLock底层的源码都读懂了，AQS的机制都读懂了之后，那么synchronized底层的实现差不多的，synchronized的ObjectMonitor的地位就跟ReentrantLock里的AQS是差不多的。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>java的并发技术底层很多都对应了内存屏障的使用，包括synchronized，他底层也是依托于各种不同的内存屏障来保证可见性和有序性的。</p><p>synchronized(this) { -&gt; monitorenter </p><p>Load内存屏障</p><p>Acquire内存屏障 </p><p>int a = b;</p><p>c = 1; =&gt; synchronized代码块里面还是可能会发生指令重排</p><p>Release内存屏障</p><p>} -&gt; monitorexit</p><p>Store内存屏障</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>按照可见性来划分的话，内存屏障可以分为Load屏障和Store屏障。</p><p>Load屏障的作用是执行refresh处理器缓存的操作，说白了就是对别的处理器更新过的变量，从其他处理器的高速缓存（或者主内存）加载数据到自己的高速缓存来，确保自己看到的是最新的数据。 </p><p>Store屏障的作用是执行flush处理器缓存的操作，说白了就是把自己当前处理器更新的变量的值，都刷新到高速缓存（或者主内存）里去。</p><p>在monitorexit指令之后，会有一个Store屏障，让线程把自己在同步代码块里修改的变量的值都执行flush处理器缓存的操作，刷到高速缓存（或者主内存）里去；然后在monitorenter指令之后会加一个Load屏障，执行refresh处理器缓存的操作，把别的处理器修改过的最新值加载到自己高速缓存里来</p><p>所以说通过Load屏障和Store屏障，就可以让synchronized保证可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>按照有序性保障来划分的话，还可以分为Acquire屏障和Release屏障。</p><p>在monitorenter指令之后，Load屏障之后，会加一个Acquire屏障，这个屏障的作用是禁止读操作和读写操作之间发生指令重排序。在monitorexit指令之前，会加一个Release屏障，这个屏障的作用是禁止写操作和读写操作之间发生重排序。 </p><p>所以说，通过 Acquire屏障和Release屏障，就可以让synchronzied保证有序性，只有synchronized内部的指令可以重排序，但是绝对不会跟外部的指令发生重排序。</p><p>synchronized： </p><p>（1）原子性：加锁和释放锁，ObjectMonitor</p><p>（2）可见性：加了Load屏障和Store屏障，释放锁flush数据，加锁会refresh数据</p><p>（3）有序性：Acquire屏障和Release屏障，保证同步代码块内部的指令可以重排，但是同步代码块内部的指令和外面的指令是不能重排的</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是JIT编译器对synchronized锁做的优化，在编译的时候，JIT会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被一个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不用加入monitorenter和monitorexit的指令。</p><p>如果只有一个线程在获取锁，就可以消除这个锁了，不涉及到多个线程来竞争。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁，就是锁粗化，把一个锁给搞粗了，避免频繁多次加锁释放锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>monitorenter和monitorexit是要使用CAS操作加锁和释放锁的，开销较大，因此如果发现大概率只有一个线程会主要竞争一个锁，那么会给这个锁维护一个偏好（Bias），后面他加锁和释放锁，基于Bias来执行，不需要通过CAS。性能会提升很多。</p><p>但是如果有偏好之外的线程来竞争锁，就要收回之前分配的偏好。可能只有一个线程会来竞争一个锁，但是也有可能会有其他的线程来竞争这个锁，但是其他线程唉竞争锁的概率很小。如果有其他的线程来竞争这个锁，此时就会收回之前那个线程分配的那个Bias偏好。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>如果偏向锁没能成功实现，就是因为不同线程竞争锁太频繁了，此时就会尝试采用轻量级锁的方式来加锁，就是将对象头的Mark Word里有一个轻量级锁指针，尝试指向持有锁的线程，然后判断一下是不是自己加的锁。如果是自己加的锁，那就执行代码就好了。如果不是自己加的锁，那就是加锁失败，说明有其他人加了锁，这个时候就是升级为重量级锁。</p><h4 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h4><p>这是JIT编译器对锁做的另外一个优化，如果各个线程持有锁的时间很短，那么一个线程竞争锁不到，就会暂停，发生上下文切换，让其他线程来执行。但是其他线程很快释放锁了，然后暂停的线程再次被唤醒。也就是说在这种情况下，线程会频繁的上下文切换，导致开销过大。所以对这种线程持有锁时间很短的情况，是可以采取忙等策略的，也就是一个线程没竞争到锁，进入一个while循环不停等待，不会暂停不会发生线程上下文切换，等到机会获取锁就继续执行好了。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java除了使用关键字synchronized外，还可以使用ReentrantLock实现独占锁的功能。而且ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。而且ReentrantLock还支持读写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻一下ReentrantLock的源码，发现它是基于<strong>AbstractQueuedSynchronizer</strong>做的，也就是我们平常说的AQS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认就构造了一个非公平锁，NonfairSync是基于AQS实现的组件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock的lock方法， 也是直接调用了sync的lock()方法，ReentrantLock在加锁的时候，就是直接基于Sync来实现的lock操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Sync，是一个抽象的静态类，他继承自AbstractQueuedSynchronizer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><strong>AbstractQueuedSynchronizer</strong>，抽象队列同步器。</p><p>ReentractLock和ReadWriteReentractLock，这个锁的API都是基于AQS来实现的，我们一般也没有直接用AQS的API来做开发，但是并发包里的很多类，都是基于AQS来实现的。截图看下，除了锁，还有Semaphore，CountDownLatch，ThreadPoolExecutor这些。</p><p><img src="/img/jdk/image-20201027140545860.png" alt="image-20201027140545860"></p><p>AQS是一个双向链表，或者说一个双端队列，原理大致如图，通过state核心变量控制是否加锁成功，并记录加锁的线程，等待锁的线程，放入队列中</p><p><img src="/img/jdk/image-20201027154725975.png" alt="image-20201027154725975"></p><h3 id="lock加锁"><a href="#lock加锁" class="headerlink" title="lock加锁"></a>lock加锁</h3><p>AQS中使用了大量的CAS操作来实现加锁和释放锁的代码，AQS里有一个核心变量，state，代表了锁的状态，0就是没线程加锁，1就是有线程加锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>所以加锁的代码其实很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cas操作修改state变量，state=1表示已经有线程获取到了锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 当前获取到锁的线程是谁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 没有获取到锁，排队</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h4><p>acquire(1); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用到NonfairSync的tryAcquire()方法，通过不复杂的代码，实现了锁的重入，如果加锁的线程和当前线程是同一个线程，就state+1，并返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// volatile在JDK源码中得到了大量的运用</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 同一个线程调用lock方法，所以state不为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并且当前线程和加锁的线程是相同的，那就再次加锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 所以state + 1 = 2</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改state，volatile保证了可见性</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他线程，就走到这了，加锁失败了，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回false以后，就要执行addWaiter，构造AQS等待队列里的等待节点了</p><h4 id="入队等待"><a href="#入队等待" class="headerlink" title="入队等待"></a>入队等待</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个加锁失败</span></span><br><span class="line">    <span class="comment">// 调用acquireQueued入队</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// addWaiter(Node.EXCLUSIVE),表示这是一个独占锁的等待节点，另外的还有共享锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成了一个Node，mode = EXCLUSIVE（排他锁，尝试获取一个排他锁，但是失败了）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// tail刚开始是null，把当前队列的尾巴，设置当前节点的pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个入队的线程直接到这里来了</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下Node的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一个线程无法获取到锁的话，会进入一个阻塞等待的状态</span></span><br><span class="line"><span class="comment">// 卡住不动，线程挂起，阻塞状态又细分为很多种不同的阻塞状态：</span></span><br><span class="line"><span class="comment">// CANCELED、SIGNAL、CONDITION、PROPAGATE</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="comment">// 一个节点可以有上一个节点，prev指针，指向了Node的上一个Node</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="comment">// 一个节点还可以有下一个节点，next指针，指向了Node的下一个Node</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">// Node里面封装了一个线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"><span class="comment">// 可以认为是下一个等待线程</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure><p>加锁失败的话，就将当前线程封装成一个Node，并且有prev何next指针，所以如果有多个处于阻塞等待状态的线程，封装后的Node组成了一个双向链表，也就成了一个队列。</p><p><img src="/img/jdk/AQS%E5%8E%9F%E7%90%86-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="AQS原理-双向链表"></p><p>接着看一下入队的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1:第一个入队的Node，tail是null</span></span><br><span class="line">        <span class="comment">// 3: 循环第二次，tail=空Node</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 2:走到这里，用cas将head设置为空节点，然后tail也是空节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 循环没有退出，继续执行循环</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4:node.prev=空Node</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 5：用cas将当前节点设置为tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 6：讲当前节点设置为之前tail的next</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是**addWaiter(Node.EXCLUSIVE)**的逻辑，构造完Node节点后，其实节点就已经入队了，接下来就再次获取锁，如果不能获取，就挂起阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取到node的前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 再尝试一次加锁，如果加锁成功了，那当前节点就变成head了</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次尝试加锁也失败了，判断当前线程是否需要挂起，阻塞等待</span></span><br><span class="line">            <span class="comment">// 如果需要，就调用park方法挂起等待</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pred是一个空node，那么ws就是空或者0</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 空node的waitStatus设置为Node.SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前线程挂起，阻塞了，必须由别的线程调用unpark操作唤醒</span></span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>公平锁就是，排队，一个一个的获取到锁，非公平锁就是抢占式的。</p><p>而ReentrantLock，默认就是非公平锁，看下构造方法就知道，不同的锁，是不同是Sync类实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码里面，判断是不是非公平锁，就一行代码。我们看一下FairSync的tryAcquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 就是这个hasQueuedPredecessors方法，加锁之前判断一下，队列里是不是有在等待的的线程，如果有，就先不尝试加锁了，直接入队</span></span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">  <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">  <span class="comment">// thread is first in queue.</span></span><br><span class="line">  Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">  Node h = head;</span><br><span class="line">  Node s;</span><br><span class="line">  <span class="comment">// h != t 说明队列不为空</span></span><br><span class="line">  <span class="comment">// h.next 不为空，拿到排队的s节点，s不是自己，返回true</span></span><br><span class="line">  <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">    ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="release释放锁"><a href="#release释放锁" class="headerlink" title="release释放锁"></a>release释放锁</h3><p>加锁的过程看完了，接下来是释放锁，释放锁是release方法，释放锁以后修改status变量，然后唤醒队列里等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先释放锁</span></span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 然后唤醒队列里的node</span></span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// state就是加锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 必须得是同一个线程来进行锁的释放</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cas操作，设置state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 找到当前节点的下一个节点唤醒</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 否则从队列尾部，往前找node，然后进行唤醒</span></span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">      <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么唤醒之后呢？别忘了acquireQueued方法里，线程阻塞的地方，是一个死循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 重新唤醒后，再次尝试加锁，会加锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 那么在这里被唤醒以后，重新执行for循环</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        lock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁，读锁和写锁是分开的。</p><p>读锁和写锁是互斥的，加了读锁之后，就不能加写锁；如果加了写锁，就不能加读锁。</p><p>如果有人加了读锁之后，别人可以同时加读锁。</p><p>如果有人在读数据，就不能有人写数据，读锁 -&gt; 写锁 -&gt; 互斥</p><p>如果有人在写数据，别人不能写数据，写锁 -&gt; 写锁 -&gt; 互斥；如果有人在写数据，别人也不能读数据，写锁 -&gt; 读锁 &gt; 互斥</p><p>在源码里，两个方法对应两把锁，默认是非公平锁的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">     selfInterrupt();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认是非公平锁</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 用来控制锁状态的state变量</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 这个方法，将数字拆成了32位的二进制</span></span><br><span class="line">    <span class="comment">// 二进制里的高低16位，分别代表了读锁和写锁</span></span><br><span class="line">    <span class="comment">// 这里是获取写锁的数量，也就是获取的是state的低16位的值，代表了写锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c!=0，说明有人加过锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果写锁是0，说明肯定至少有一个读锁，就不能再加写锁了，线程会排队阻塞</span></span><br><span class="line">        <span class="comment">// 如果写锁不是0，那么当前线程必须和占用写锁的线程是同一个线程，这里就是可重入锁的判断了！</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 锁的数量是否超过限制</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 将</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里c=0，如果是非公平锁，所以直接加锁</span></span><br><span class="line">    <span class="comment">// 如果是公平锁，此时会判断如果队列中有等待线程，就不加锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本跟之前看到的是一样的，如果加写锁的话，state += 1，锁占用线程</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>如果之前加过锁了，必须是同一个线程再次加锁，实现了可重入锁</p><p>特别要注意这个高低16位的细节</p><p><img src="/img/jdk/image-20201222162725152.png" alt="image-20201222162725152"></p><p>在已经有锁的情况下，线程2来加锁呢，那么tryAcquire方法肯定就是返回false。</p><p>然后就会执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><p>这里和之前加锁的逻辑，没有太大区别</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的代码，和普通的锁释放也没有什么区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 锁释放成功后，将队列里的node，唤醒</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断一下当前线程和加锁的线程是否是同一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 本次释放锁后，判断是否写锁已经全部释放完毕，然后清空占用锁的线程</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读写锁互斥，如果有写锁，就不能加读锁了</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取高16位的值来获取读锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        <span class="comment">// cas操作成功，即认为读锁加成功</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则就进入死循环，加锁成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">  HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">      <span class="comment">// would cause deadlock.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">      <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">          rh = cachedHoldCounter;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">              readHolds.remove();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">// 还是利用cas加锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">        firstReader = current;</span><br><span class="line">        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        firstReaderHoldCount++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">          rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">          rh = readHolds.get();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">          readHolds.set(rh);</span><br><span class="line">        rh.count++;</span><br><span class="line">        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依然是利用cas，释放锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒队列里等待的线程，也就是等待写锁的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/jdk/1748.png" alt="1748.png"></p><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>Condition可以实现wait和notify的效果，需要在加锁以后，进行阻塞操作，在底层源码里也是基于AQS来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionWaitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;第一个线程加锁&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;第一个线程阻塞&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;第一个线程被唤醒&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;第一个线程释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;第二个线程加锁&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;第二个线程唤醒第一个线程&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;第二个线程释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>加锁成功以后，将自己加入condition等待队列、释放锁、挂起自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 加入condition等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起自己</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒以后，还要继续竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/jdk/1758.png" alt="1758"></p><h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h2><p>signal方法的唤醒，是把condition等待队列中的元素，转化为一个加锁等待队列中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 关键代码就在 transferForSignal</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改node的waitStatus从CONDITION -&gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 这个就是将Node入队到，加锁队列中</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 在入队以后，将阻塞的线程唤醒，然后继续去竞争写锁</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition的源码， 相对来说还是比较简单。</p><p>总结一下，ReentrantLock是基于AQS来实现的，而AQS是一个双端的队列，加锁后需要在队列里排队，这里运用了大量的CAS操作来保证并发安全。读写锁分离，就是利用了state变量的高低16位，高16位，是读锁，低16位，是写锁。</p><p>Condition，是一个单独的Condition队列，在调用await挂起后，会入队，调用signal唤醒后，会入队到加锁的队列里，重新去竞争锁。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;synchronized就是加锁，一旦加锁以后，就只能当前线程访问和修改加锁的变量，其他线程只能阻塞等待，这就保证了原子性。&lt;/p&gt;
&lt;p&gt;synchronized可以锁两种对象，一种是对某个实例对象进行加锁，一种是对类进行加锁。对类加锁，本质上也是对实例加锁，只不过是对class对象进行加锁。&lt;/p&gt;
&lt;p&gt;如果用synchronized修饰普通方法，那就是对当前类的实例进行加锁。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发源码-volatile</title>
    <link href="http://www.saily.top/2020/10/22/jdk/%E5%B9%B6%E5%8F%9102/"/>
    <id>http://www.saily.top/2020/10/22/jdk/%E5%B9%B6%E5%8F%9102/</id>
    <published>2020-10-22T13:00:37.000Z</published>
    <updated>2020-12-25T08:47:24.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>先说结论，volatile是非常常用的东西，他保证了可见性和有序性。这2个特性分别涉及了JVM的底层原理，最常用的场景，就是共享变量加volatile修饰，这样不同的线程来修改的时候，才能即时的识别到改变，比如标志位、开关等。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务实例是否在运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主内存以及cpu的多级缓存模型"><a href="#主内存以及cpu的多级缓存模型" class="headerlink" title="主内存以及cpu的多级缓存模型"></a>主内存以及cpu的多级缓存模型</h2><p>先看下计算机CPU的多级缓存模型，为什么要讲这个，因为这个就是volatile的基本原理。</p><p>volatile的作用就是一个线程修改了一个变量的值以后，另外一个变量立马就能看到最新的值。</p><p>我们得先知道，为什么在不加volatile的情况下，它不一定能看到最新的值。</p><p>计算机如果频繁的跟主内存做交互的话，性能也是比较差的，所以CPU有自己的缓存，用来提升CPU计算的效率，我们买电脑，也会看到CPU参数里有L1,L2,L3缓存的。</p><p>然后CPU读写数据，会先从主内存读取到缓存中，然后频繁的读写，都是在缓存里操作的，缓存的数据会不定时的刷入到主内存中。</p><p><img src="/img/jdk/image-20201022104203084.png" alt="image-20201022104203084"></p><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>那么这么设计有什么问题呢，在正常情况下是没有问题的，但是在多线程并发的情况下，就会有问题了，可能每个线程持有flag的值，是不一样的。</p><p>比如线程0先读取了falg=1，然后线程1写入了flag=7， 这时候主内存里已经是flag=7了，线程0和线程1看到flag的值，就是不一样的。</p><p><img src="/img/jdk/image-20201022105039663.png" alt="image-20201022105039663"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>最早的时候，有一个总线加锁的机制，有点类似于悲观锁，一个CPU读取了一个数据后，会通过一个总线，就对这块内存（数据）进行加锁，然后其他CPU就无法再读和写这个数据了，只有当这个CPU修改完成后，其他CPU就可以读到最新的数据，这个效率比较低下，基本成串行化执行了。</p><p>所以后面就有了MESI协议，缓存一致性协议。</p><p>在MESI缓存一致性协议的保证下，就能保证在多线程并发读写变量，及时感知到了。</p><h2 id="可见性涉及的硬件概念"><a href="#可见性涉及的硬件概念" class="headerlink" title="可见性涉及的硬件概念"></a>可见性涉及的硬件概念</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>每个处理器都有自己的寄存器（register），所以多个处理器各自运行一个线程的时候，可能导致某个变量给放到寄存器里去，接着就会导致各个线程没法看到其他处理器寄存器里的变量的值修改了。</p><p>所以在寄存器这里，就有可能会导致变量副本的更新，无法被其他线程看到。</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>一个处理器运行的线程对变量的写操作都是针对写缓冲来的（store buffer）并不是直接更新主内存，所以很可能导致一个线程更新了变量，但是仅仅是在写缓冲区里罢了，没有更新到主内存里去。</p><p>这个时候，其他处理器的线程是没法读到他的写缓冲区的变量值的，所以此时就是会有可见性的问题，这是第二个可见性发生的场景。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>即使这个时候一个处理器的线程更新了写缓冲区之后，将更新同步到了自己的高速缓存里（cache，或者是主内存），然后还把这个更新通知给了其他的处理器，但是其他处理器可能就是把这个更新放到无效队列里去，没有更新他的高速缓存，此时其他处理器的线程从高速缓存里读数据的时候，读到的还是过时的旧值。</p><p><img src="/img/jdk/image-20201225131810021.png" alt="image-20201225131810021"></p><h3 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h3><p>要实现可见性，其中一个方法就是MESI协议，这个协议有很多不同的实现，根据底层硬件的不同，实现方式也不同。</p><h4 id="flush处理器缓存"><a href="#flush处理器缓存" class="headerlink" title="flush处理器缓存"></a>flush处理器缓存</h4><p>flush处理器缓存，是把自己更新的值刷新到高速缓存里去（或者是主内存），因为必须要刷到高速缓存（或者是主内存）里，才有可能在后续通过一些特殊的机制让其他的处理器从自己的高速缓存（或者是主内存）里读取到更新的值。</p><p>除了flush以外，他还会发送一个消息到总线（bus），通知其他处理器，某个变量的值被他给修改了。</p><h4 id="refresh处理器缓存"><a href="#refresh处理器缓存" class="headerlink" title="refresh处理器缓存"></a>refresh处理器缓存</h4><p>refresh处理器缓存，是指处理器中的线程在读取一个变量的值的时候，如果发现其他处理器的线程更新了变量的值，必须从其他处理器的高速缓存（或者是主内存）里，读取这个最新的值，更新到自己的高速缓存中。</p><p>所以为了保证可见性，在底层是通过MESI协议、flush处理器缓存和refresh处理器缓存，这一整套机制来保障的。</p><p><strong>要记住，flush和refresh，这两个操作，flush是强制刷新数据到高速缓存（主内存），不要仅仅停留在写缓冲器里面；refresh，是从总线嗅探发现某个变量被修改，必须强制从其他处理器的高速缓存（或者主内存）加载变量的最新值到自己的高速缓存里去。</strong></p><p><img src="/img/jdk/image-20201225143117638.png" alt="image-20201225143117638"></p><p>对一个变量加了volatile修饰之后，对这个变量的写操作，会执行flush处理器缓存，把数据刷到高速缓存（或者是主内存）中，然后对这个变量的读操作，会执行refresh处理器缓存，从其他处理器的高速缓存（或者是主内存）中，读取最新的值。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型跟CPU缓存模型是类似的，它是基于CPU模型来建立的Java内存模型，只是Java内存模型是标准化的，屏蔽了底层计算机和操作系统的区别。</p><p>在Java里，内存分线程工作内存和主内存，他们之间的读写，是用JVM底层的指令完成的。</p><ul><li>read（从主存读取）</li><li>load（将主存读取到的值写入工作内存）</li><li>use（从工作内存读取数据来计算）</li><li>assign（将计算好的值重新赋值到工作内存中）</li><li>store（将工作内存数据写入主存）</li><li>write（将store过去的变量值赋值给主存中的变量）</li></ul><p><img src="/img/jdk/image-20201022135613828.png" alt="image-20201022135613828"></p><p>以这个图为例，线程1从主内存读取flag变量，并进行了修改，写入到了工作内存，有可能它只是在工作内存中，没有存入主内存，也就是还没有执行store和write指令，那么线程2来读取flag变量，读到的就依然还是0。</p><h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><p>如果变量加了volatile修饰，他就能保证<strong>线程1在执行了assign指令后，马上就跟着执行store+write指令</strong>，将数据写入到主内存中，然后还<strong>将其他线程的工作内存中值，标记为过期</strong>。线程2在发现变量过期以后，会<strong>重新从主内存中读取新的值</strong>，从而保证可见性。</p><h2 id="volatile无法保证原子性"><a href="#volatile无法保证原子性" class="headerlink" title="volatile无法保证原子性"></a>volatile无法保证原子性</h2><p>在Java里，像i++这种操作，他在底层执行的时候是多个指令，分别是读取和写入，既然涉及2个操作，就完全有可能在2个线程都读取后，一个线程才完成写入操作，他们读取和写入值，就是一样的。</p><h2 id="volatile底层原理"><a href="#volatile底层原理" class="headerlink" title="volatile底层原理"></a>volatile底层原理</h2><h3 id="lock指令"><a href="#lock指令" class="headerlink" title="lock指令"></a>lock指令</h3><p>前面说了volatile是如何保证可见性的，但是在计算机底层，到底发送了什么指令来实现的效果呢？</p><p>对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改。</p><p>如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了。</p><p>lock前缀指令 + MESI缓存一致性协议保证了可见性。</p><h3 id="内存屏障：禁止重排序"><a href="#内存屏障：禁止重排序" class="headerlink" title="内存屏障：禁止重排序"></a>内存屏障：禁止重排序</h3><p>volatile可以保证有序性，那么它是如何做到的呢？</p><p>它是通过内存屏障来实现的，有这么几种内存屏障，分别对应几种场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Load1：</span><br><span class="line"><span class="keyword">int</span> localVar = <span class="keyword">this</span>.variable</span><br><span class="line">LoadLoad屏障</span><br><span class="line">Load2：</span><br><span class="line"><span class="keyword">int</span> localVar = <span class="keyword">this</span>.variable2</span><br></pre></td></tr></table></figure><p><strong>LoadLoad屏障</strong>：Load1；LoadLoad；Load2，确保Load1数据的装载先于Load2后所有装载指令，他的意思，Load1对应的代码和Load2对应的代码，是不能指令重排的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Store1：</span><br><span class="line"><span class="keyword">this</span>.variable = <span class="number">1</span></span><br><span class="line">StoreStore屏障</span><br><span class="line">Store2：</span><br><span class="line"><span class="keyword">this</span>.variable2 = <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>StoreStore屏障</strong>：Store1；StoreStore；Store2，确保Store1的数据一定刷回主存，对其他cpu可见，先于Store2以及后续指令</p><p>以及</p><p><strong>LoadStore屏障</strong>：Load1；LoadStore；Store2，确保Load1指令的数据装载，先于Store2以及后续指令</p><p><strong>StoreLoad屏障</strong>：Store1；StoreLoad；Load2，确保Store1指令的数据一定刷回主存，对其他cpu可见，先于Load2以及后续指令的数据装载</p><p>怎么理解这几个屏障呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> variable = <span class="number">1</span></span><br><span class="line"><span class="comment">// StoreStore屏障</span></span><br><span class="line"><span class="comment">// 写入变量，这是store操作</span></span><br><span class="line"><span class="keyword">this</span>.variable = <span class="number">2</span>  </span><br><span class="line"><span class="comment">// StoreLoad屏障</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 从主内存中读取变量，是load操作</span></span><br><span class="line"><span class="keyword">int</span> localVariable = <span class="keyword">this</span>.variable</span><br><span class="line"><span class="comment">// LoadLoad屏障</span></span><br><span class="line"><span class="comment">// LoadStore屏障</span></span><br></pre></td></tr></table></figure><p>对于volatile修饰变量的读写操作，都会加入内存屏障。</p><p>每个volatile写操作前面，都会加入StoreStore屏障，禁止普通写和volatile写重排，每个volatile写操作后面，会加入StoreLoad屏障，禁止跟后面的volatile读/写重排。</p><p>每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止后面的普通写和volatile读重排</p><p><img src="/img/jdk/07_volatile%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="07_volatile和内存屏障"></p><h3 id="再谈内存屏障"><a href="#再谈内存屏障" class="headerlink" title="再谈内存屏障"></a>再谈内存屏障</h3><p>线程1：</p><p>Release屏障</p><p>isRunning = false;</p><p>Store屏障</p><p>线程2： </p><p>Load屏障</p><p>while(isRunning) {</p><p>Acquire屏障</p><p>// 代码逻辑</p><p>}</p><p>在volatile变量写操作的前面会加入一个Release屏障，然后在之后会加入一个Store屏障，这样就可以保证volatile写跟Release屏障之前的任何读写操作都不会指令重排，然后Store屏障保证了，写完数据之后，立马会执行flush处理器缓存的操作</p><p>在volatile变量读操作的前面会加入一个Load屏障，这样就可以保证对这个变量的读取时，如果被别的处理器修改过了，必须得从其他处理器的高速缓存（或者主内存）中加载到自己本地高速缓存里，保证读到的是最新数据；在之后会加入一个Acquire屏障，禁止volatile读操作之后的任何读写操作会跟volatile读指令重排序。</p><p>其实Acquire屏障就是LoadLoad屏障 + LoadStore屏障，Release屏障其实就是StoreLoad屏障 + StoreStore屏障。</p><p>不同版本的JVM，不同的底层硬件，都可能会导致加的内存屏障有一些区别，这个本来就没完全一致的。只要知道内存屏障是如何保证volatile的可见性和有序性的就可以了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h1&gt;&lt;p&gt;先说结论，volatile是非常常用的东西，他保证了可见性和有序性。这2个特性分别涉及了JVM的底层原理，最常用的场景，就是共享变量加volatile修饰，这样不同的线程来修改的时候，才能即时的识别到改变，比如标志位、开关等。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发源码-Atomic</title>
    <link href="http://www.saily.top/2020/10/22/jdk/%E5%B9%B6%E5%8F%9104/"/>
    <id>http://www.saily.top/2020/10/22/jdk/%E5%B9%B6%E5%8F%9104/</id>
    <published>2020-10-22T13:00:37.000Z</published>
    <updated>2020-11-19T08:47:11.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h1><p>AtomicInteger，可实现原子化的操作，不需要加锁，他底层是通过CAS实现的，看下使用方式</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger j = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        synchronizedAdd();</span><br><span class="line"></span><br><span class="line">        atomicAdd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 加锁后变慢</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (AtomicIntegerDemo.class) &#123;</span><br><span class="line">                        System.out.println(++i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(j.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicLong、AtomicBoolean、AtomicReference、LongAdder等类，都是不加锁的，效率比较高，在项目中可以多用下。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><blockquote><p>判断此时此刻是否是某个值，如果是，则修改，如果不是则重新查询一个最新的值，再次执行判断，这个操作叫做CAS，Compare and Set。</p></blockquote><p>Atomic原子类底层核心的原理就是CAS，每次尝试修改的时候都先对比一下，有没有人修改过这个值，没有人修改就自己修改，如果有人修改过，就重新查出来最新的值，再次重复那个过程。</p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Atomic原子类，底层是通过JDK提供的Unsafe类去实现的，这个类不能由用户来实例化的，我们在自己的代码也无法去使用它的方法，他会在源码检查类加载器类型，如果非Bootstrap classloader就会抛异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 这里有判断，如果类加载器不对，就报错了</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后他具体实现Unsafe封装了一些不安全的操作，例如CAS操作的代码，比较底层，下面开始看下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录了当前对象里value在内存中的偏移量</span></span><br><span class="line">        <span class="comment">// 这个偏移量，是不会发生变化的，后续的CAS操作，会用到这个值，非常关键</span></span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体保存int值的变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>incrementAndGet源码，是如何完成原子操作的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用了Unsafe的方法，并将自己传入</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var1 = AtomicInteger</span></span><br><span class="line"><span class="comment">// var2 = valueOffset</span></span><br><span class="line"><span class="comment">// var4 = 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 会用getIntVolatile方法</span></span><br><span class="line"><span class="comment">// 从AtomicInteger对象实例，根据valueOffset偏移量，知道了value这个字段的位置</span></span><br><span class="line"><span class="comment">// 去获取到当前的value的值</span></span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    <span class="comment">// compareAndSwapInt()，CAS方法，是Native的方法</span></span><br><span class="line">    <span class="comment">// var5，也就是原始值，假设是1，他会用这个值，和AtomicInteger的value值compare，如果是一样</span></span><br><span class="line">    <span class="comment">// 就会set，也就是将value的值给设置为：var5=l（之前拿到的值） + 1（递增的值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果var5=l（获取到的值），跟AtomicInteger + valueOffset获取到的当前的值，不一样的话</span></span><br><span class="line">    <span class="comment">// 此时compareAndSwapInt方法就会返回false，然后while循环就会自动进入下一轮</span></span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="comment">// 如果是cas成功后，还是会返回一个var5=l，这是旧的值，所以incrementAndGet()最后会自己+1再返回</span></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS底层，是通过CPU指令来完成的，对一小块内存进行加锁，保证他的原子性。</p><h2 id="Atomic类CAS的三个缺点"><a href="#Atomic类CAS的三个缺点" class="headerlink" title="Atomic类CAS的三个缺点"></a>Atomic类CAS的三个缺点</h2><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>比如本来这个值，一开始是A，后来变成了B，然后又变成了A，假设代码期望A就设置新的值，结果线程1A-&gt;B-&gt;，他将值设置了回去，然后线程2发现确实是A，然后就cas成功了，他无法识别值是否发生过变化。从 Java 1.5 开始，JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题，会比较两个值的引用是否一致，如果一致，才会设置新值。</p><h4 id="无限循环问题"><a href="#无限循环问题" class="headerlink" title="无限循环问题"></a>无限循环问题</h4><p>上面源码看了，cas在有无限循环在里面的，在高并发场景下，多线程频繁并发修改，可能有的线程就会循环很多次才能cas成功，这个问题在JDK 1.8引入了LongAdder来解决，他采用分段CAS的思路。</p><h4 id="多变量原子问题"><a href="#多变量原子问题" class="headerlink" title="多变量原子问题"></a>多变量原子问题</h4><p>AtomicInteger，只保证了一个int变量的原子操作，多个变量可以用AtomicReference，将多个变量封装到一个对象里，然后他会检查这个对象的引用是不是一个。</p><h1 id="LongAddr"><a href="#LongAddr" class="headerlink" title="LongAddr"></a>LongAddr</h1><p>针对无线循环的问题JDK 1.8引入了LongAdder，我们来看一下他是如何提升性能的。</p><p>LongAdder里面有一个cell数组，cell是在Striped64中的静态内部类，每个cell维护自己的value，AtomicInteger中仅维护一个全局的value，调用sum将所有cell的value和base相加就是最终的值。</p><p>这样就实现了分段CAS，减少并发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/jdk/image-20201022193908559.png" alt="image-20201022193908559"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AtomicInteger&quot;&gt;&lt;a href=&quot;#AtomicInteger&quot; class=&quot;headerlink&quot; title=&quot;AtomicInteger&quot;&gt;&lt;/a&gt;AtomicInteger&lt;/h1&gt;&lt;p&gt;AtomicInteger，可实现原子化的操作，不需要加锁，他底层是通过CAS实现的，看下使用方式&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发源码-线程</title>
    <link href="http://www.saily.top/2020/10/19/jdk/%E5%B9%B6%E5%8F%9101/"/>
    <id>http://www.saily.top/2020/10/19/jdk/%E5%B9%B6%E5%8F%9101/</id>
    <published>2020-10-19T06:00:37.000Z</published>
    <updated>2020-10-22T06:31:51.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程篇知识，主要包括并发编程方面，JUC并发包下的类的源码学习。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>执行main方法后，就会开启一个jvm进程了，进程里，又有很多线程，main线程就是执行程序的第一个线程，然后我们又创建了一个子线程，来执行另外的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>多个线程的执行，是没有先后顺序的，他们会争夺和抢占的CPU的时间，谁先抢到，谁就先执行。</p><p>并发编程，无非就是在多线程的情况下去操作同一份数据，或者不同的线程之间需要通信。</p><h3 id="Thread-Group"><a href="#Thread-Group" class="headerlink" title="Thread Group"></a>Thread Group</h3><p>ThreadGroup就是线程组，可以把一堆线程放入一个组里，作为一个整体统一管理和设置，这个一般不怎么用。</p><p>每一个线程都是会属于一个线程组的，如果在创建线程的时候没有设置，默认就是父线程的线程组。</p><p>比如main线程创建的子线程，子线程的线程组就是main ThreadGroup。</p><p>默认线程会加入父线程的ThreadGroup，也可以手动创建ThreadGroup，ThreadGroup也有父ThreadGroup，ThreadGroup可以包裹一大堆的线程，然后统一做一些操作，比如统一复制、停止、销毁，等等。</p><p>enumerate()：复制线程组里的线程</p><p>activeCount()：获取线程组里活跃的线程</p><p>getName()、getParent()、list()，等等</p><p>interrupt()：打断所有的线程</p><p>destroy()：一次性destroy所有的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程的线程组</span></span><br><span class="line">        <span class="comment">// 输出：main</span></span><br><span class="line">        System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 子线程默认加入父线程的group</span></span><br><span class="line">            <span class="comment">// 输出：main</span></span><br><span class="line">            System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        ThreadGroup custom = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;custom&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造方法可以指定线程组</span></span><br><span class="line">        <span class="keyword">new</span> Thread(custom, () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加入了指定的custom线程组</span></span><br><span class="line">            <span class="comment">// 输出：custom</span></span><br><span class="line">            System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>优先级一般是在1~10之间，默认优先级是5，一般不设置，默认就是5，因为设置了，CPU也不一定按照这个来执行。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>看源码，一般就先扫一眼变量，或者从构造方法开始看起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常会看到日志打印里，线程名字都是Thread-0，Thread-1这样的，来源的代码就在这里了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="comment">// 因为线程还没有被创建，所以这里获取到的是父线程的对象，也就是main Thread</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="comment">// 如果没有传ThreadGroup，就用父线程的ThreadGroup</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）创建你的线程，就是你的父线程</p><p>（2）如果你没有指定ThreadGroup，你的ThreadGroup就是父线程的ThreadGroup</p><p>（3）你的daemon状态默认是父线程的daemon状态</p><p>（4）你的优先级默认是父线程的优先级</p><p>（5）如果你没有指定线程的名称，那么默认就是Thread-0格式的名称</p><p>（6）你的线程id是全局递增的，从1开始</p><p>这是初始化的代码，接着看下start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动后状态会发生变化，一个线程不能被启动2次</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 初始化的时候分配的group</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Native方法来启动线程，然后执行run方法()</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>Thread.sleep(500),可以让线程停顿一段时间，然后恢复运行，在很多场景都可能会用到，比如在死循环中，通过sleep方法来达到一个定时执行的效果。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>这也是一个Native的方法，很少看到有人会用到，它的意思就是让出CPU执行时间，让别的线程先去执行一下。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>mian线程里创建线程start后，就会并发执行了，如果要实现等待的效果，可以调用线程的join方法，会阻塞等待子线程的逻辑执行完成，main线程继续往下走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程会阻塞等待，等待thread1执行完成后，继续执行main线程后面的内容</span></span><br><span class="line">    thread1.join();</span><br><span class="line">  </span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>这个方法，叫打断，实际上他并不会中断线程的执行，只是给线程设置一个标志位，然后isInterrupted就能返回true了。一个最常见的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种情况，就是一个正在sleep的线程，如果调用interrupt的话，也会中断睡眠，抛出一个java.lang.InterruptedException: sleep interrupted的异常。</p><p>线程的使用，基本上就是这些了，后面就是基于线程的并发编程。</p><h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>在并发编程中，有三类问题，分别是可见性、原子性、有序性。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>就是一个线程修改了变量值，另外一个线程读取到的还是原来的值的问题，在Java中一般用volatile关键字来解决，或者加锁。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>比如i++的操作，他就是不保证原子性的，因为i++在底层是拆分成了多个指令，包含了读取，计算，写入，不同的线程在对同一个变量执行i++的时候，可能拿到的值是相同的，然后i++完成后都写入，导致最后的结果就不对了，比如i=1，2个线程i++开始读到的都是1，然后++完了，你以为最后应该是3了，其实都是2。</p><p>有人在会在网上说什么volatile是轻量级的锁，这是不对的，他并不能保证原子性，原子性只能通过加锁去解决，比如synchronize、lock，锁住变量，只能自己访问，操作串行化，保证多个操作之间的原子性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性，就是指令重排序的问题，编译器和指令器，有时候会对代码进行优化，在前后逻辑不影响的情况下，他可能会优化代码的执行顺序，比如下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">prepare();<span class="comment">//准备资源</span></span><br><span class="line">flag=<span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">execute();<span class="comment">// 基于线程1准备的资源进行操作</span></span><br></pre></td></tr></table></figure><p>那么重排序之后，有可能flag=true，就先执行了，可能就会导致线程2的代码， 执行异常。</p><p><strong>基于happens-before保证有序性</strong></p><p>指令重排序，不是乱排的，有个happens-before原则，只要符合happens-before原则的情况，就不能乱排。</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><p>满足这8个原则的情况下，才能对指令进行重排序。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;p&gt;线程篇知识，主要包括并发编程方面，JUC并发包下的类的源码学习。&lt;/p&gt;
&lt;h2 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerlink&quot; title=&quot;Thread&quot;&gt;&lt;/a&gt;Thread&lt;/h2&gt;&lt;p&gt;执行main方法后，就会开启一个jvm进程了，进程里，又有很多线程，main线程就是执行程序的第一个线程，然后我们又创建了一个子线程，来执行另外的任务。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;子线程。。&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="并发" scheme="http://www.saily.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="并发" scheme="http://www.saily.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK集合源码-Map</title>
    <link href="http://www.saily.top/2020/10/16/jdk/jdk02/"/>
    <id>http://www.saily.top/2020/10/16/jdk/jdk02/</id>
    <published>2020-10-16T06:00:37.000Z</published>
    <updated>2020-10-20T06:12:22.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map源码"><a href="#Map源码" class="headerlink" title="Map源码"></a>Map源码</h1><p>Map是集合里一个非常重要的数据结构，面试也是会经常问到源码的。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>简单描述一下HashMap的原理，它的结构就是数组+链表+红黑树。</p><p>put的时候，对key进行hash，找到对应的数组位置放在里面，然后hash冲突了就组成链表往后追加。查询的时候也是一样，对key进行hash，然后用equals去比较链表上key的值。</p><p>JDK1.8优化了hashmap的数据结构，如果链表过长，达到8以后，就会转变成红黑树。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这个数组的初始化长度，是16，和ArrayList不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组变量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 初始数组大小，默认是16</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后他有个，负载因子是0.75，意思就是默认情况下，如果数组占用达到了<code>16 * 0.75 = 12</code>，就会开始执行扩容操作了。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 这个就是负载因子值了，默认就是上边这个0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// next指针，就形成了链表</span></span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>看这个put方法的源码，就是有一个hash(key)的方法，用来做key做hash计算，然后定位数组索引用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h4><p>这个hash(key)，并不是简单对hashCode取模得到的一个值，它这里是一个非常高性能的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，key.hashCode()，直接获取到了key的hash值，然后和 h &gt;&gt;&gt; 16做了一个异或的运算。</p><p>h &gt;&gt;&gt; 16，就是二进制右移16位，举例，下面是一个hash值的2进制</p><p><code>1111 1111 1111 1111 1111 1010 0111 1100</code></p><p>右移16位后，高位补0，他就变成了</p><p><code>0000 0000 0000 0000 1111 1111 1111 1111</code></p><p>然后再做异或操作，也就是<code>h ^ (h &gt;&gt;&gt; 16)</code></p><blockquote><p>异或：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p></blockquote><p>所以异或之后的结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1010 0111 1100</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line">1111 1111 1111 1111 0000 0101 1000 0011</span><br></pre></td></tr></table></figure><p>发现没有，这么做，就实现了int值的，高16位和低16位异或运算，为什么要这么做呢，是跟后面的代码有关系。</p><p>在定位数组索引的时候，也用到了一个位运算，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p>n就是数组的长度，这个值一般情况下，是比较小的，比如n=16的二进制</p><p><code>0000 0000 0000 0000 0000 0000 0001 0000</code></p><p>这个值如果去和原始的hash值做位运算，肯定始终都是只会在低16位做运算，高16位，就用不上了。所以提前用hash()方法将高16位和低16位做了位运算后，就能保证在定位数组索引的时候，无论这个n值的大小，也能让hash的高低16位都参与到运算中。</p><p>为什么要这样做呢？因为这样做可以<strong>降低hash冲突的概率</strong>，如果说老是用低16位去做运算定位数组索引的话，就会导致一定的hash冲突。</p><p>继续看put的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 刚开始，数组都是空的，这里就分配一个默认的大小，也就是16</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// (n - 1) &amp; hash 通过位运算，来实现了一个取模的效果，而且每次扩容，都是2的n次方，只要保证数组的大小是2的n次方，就能保证(n - 1) &amp; hash和 hash % 数组.length取模是一样的效果</span></span><br><span class="line"><span class="comment">// 比直接取模，效率高很多</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>这个取模的优化，是hashmap非常重要的优化点</p><h4 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h4><p>接着看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 这个 (n - 1) &amp; hash 很重要</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 满足这个条件，说明是相同的key，覆盖旧的值就好</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 处理红黑树的情况</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的总长度达到了8，那么链表就要转变成红黑树了</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相同的key，替换新的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>这个红黑树的具体算法，非常复杂，有什么翻转，变色什么的，就当成黑盒来看吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环的方式，先转成双向链表，然后转成成一棵树</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前面的源码看，如果put的时候发现一家是一个红黑树了，那么就是直接往红黑树上挂节点了。</p><p><code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code></p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>HashMap基于数组的数据结构，那么必然会有扩容的问题，它的原理就是，达到负载因子的的数量后，就进行2倍扩容，然后rehash，每一个key-value对，都会基于key的hash值重新寻址找到新数组的新的位置。</p><p>比如他之前的长度是16，新的数组长度是32</p><p>之前那些key的hash可能之前对16取模的位置是5，那么对32取模后，他的位置就变成了11，位置发生了变化。</p><p>这是1.7之前的原理，1.8以后，他就不是直接取模了，用的是与运算的位操作来实现高性能的取模操作，但是这个就要求数组的长度必须是2的n次方。</p><p>举一个扩容的例子。</p><p>还记得寻址的算法么：<code>tab[i = (n - 1) &amp; hash]</code></p><p>此时，n=16</p><p>第一个key</p><p>n - 1    0000 0000 0000 0000 0000 0000 0000 1111</p><p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p><p>&amp;结果  0000 0000 0000 0000 0000 0000 0000 0101  = 5（index = 5的位置）</p><p>第二个key</p><p>n - 1 0000 0000 0000 0000 0000 0000 0000 1111</p><p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p>他们就是在同一个位置，然后数组扩容，变成了32</p><p>此时，n=32</p><p>第一个key</p><p>n-1 0000 0000 0000 0000 0000 0000 0001 1111</p><p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p> 第二个key</p><p>n-1      0000 0000 0000 0000 0000 0000 0001 1111</p><p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 21的位置）</p><p>第一个位置没有变，但是第二个就变成了21。</p><p>所以规律是什么？</p><ol><li>首先，数组的长度肯定是2的倍数，16-&gt;32-&gt;64-&gt;128</li><li>扩容之后，key要么在之前的index位置，要么就变成了之前的index（5） + oldCap（16） = 21的位置</li></ol><p>贴下扩容的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 这就是数组2倍扩容了</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// e.next是null，说明就是一个单节点，直接重新计算一下hash放过去就好了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，就基于红黑树的算法讲每一个节点都重新hash寻址，找到各自的新数组位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 这里就是链表了</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 还是在之前的位置</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 如果是链表，它在新数组的位置就是之前的index+oldCap </span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>HashMap看完了，LinkedHashMap也就简单了，它就是多了一个功能，它会记录你插入的顺序，如果你去遍历LinkedHashMap，是按照你插入的顺序来遍历的。</p><p>如果面试官问，LinkedHashMap和TreeMap，都可以维持key顺序，那区别是什么？LinkedHashMap是基于链表实现的，它的顺序是key的插入顺序，TreeMap的基于红黑树实现的，它的顺序是基于key的某个排序算法来排序的。</p><p>LinkedHashMap和HashMap的原理，大致是一样的，区别就是在插入、更新、删除的时候，他会记录一下key的顺序。他的put方法，其实也还是调用的HashMap的put方法，但是在执行结束之后，有一个<code>afterNodeInsertion(evict);</code>方法，这个方法在HashMap的实现中是空实现。但是在LinkedHashMap中，他就覆盖了这个方法，其实一共有3个方法在不同的地方会被回调到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>他用了一个链表的结构，来存储了key插入的顺序，这个数据结构就是，直接继承了HashMap的Node，然后增加了before和after参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后每次都会调用linkNodeLast方法， 将这个节点挂在链表的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么覆盖，会不会改变他的顺序呢，默认是不会的，</p><p>LInkedHashMap有一个字段，accessOrder，可在构造方法的时候传入，如果为true，则访问后也会刷新位置，否则只是插入才会记录位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>为true，get和put方法，都会导致这个key对应的Entry移动到链表的尾部去，删除元素的时候，也会从链表里删除。</p><p>迭代的时候，就会从链表的头部，也就是head节点开始按顺序迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>![image-20201020131704780](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201020131704780.png)</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是用红黑树做的数据结构，用红黑树维护了key的顺序，可以按照指定顺序进行迭代。</p><p>它有自己的Entry结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，TreeMap是按照自然排序，也就是字典序来对key进行排序的。如果想定制排序规则的话，可以在构造方法中参数排序比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashSet、LinkedHashSet、TreeSet"><a href="#HashSet、LinkedHashSet、TreeSet" class="headerlink" title="HashSet、LinkedHashSet、TreeSet"></a>HashSet、LinkedHashSet、TreeSet</h2><p>Set的源码，没什么好说的，他其实就是继承自HashMap，然后只用了key的结构，value都是空值。</p><p>比如HashSet，LinkedHashSet，TreeSet都是。</p><p>HashSet，就是无序的，LinkedHashSet就是插入顺序，TreeSet就是可排序的，都是不可重复的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Map源码&quot;&gt;&lt;a href=&quot;#Map源码&quot; class=&quot;headerlink&quot; title=&quot;Map源码&quot;&gt;&lt;/a&gt;Map源码&lt;/h1&gt;&lt;p&gt;Map是集合里一个非常重要的数据结构，面试也是会经常问到源码的。&lt;/p&gt;
&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;p&gt;简单描述一下HashMap的原理，它的结构就是数组+链表+红黑树。&lt;/p&gt;
&lt;p&gt;put的时候，对key进行hash，找到对应的数组位置放在里面，然后hash冲突了就组成链表往后追加。查询的时候也是一样，对key进行hash，然后用equals去比较链表上key的值。&lt;/p&gt;
&lt;p&gt;JDK1.8优化了hashmap的数据结构，如果链表过长，达到8以后，就会转变成红黑树。&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;这个数组的初始化长度，是16，和ArrayList不一样。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// aka 16	&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始数组大小，默认是16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JDK源码" scheme="http://www.saily.top/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="JDK源码" scheme="http://www.saily.top/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK集合源码-List</title>
    <link href="http://www.saily.top/2020/10/13/jdk/jdk01/"/>
    <id>http://www.saily.top/2020/10/13/jdk/jdk01/</id>
    <published>2020-10-13T06:00:37.000Z</published>
    <updated>2020-10-20T05:54:29.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK集合源码"><a href="#JDK集合源码" class="headerlink" title="JDK集合源码"></a>JDK集合源码</h1><p>准备写一些文章，把集合、并发、网络相关的JDK工具的使用和源码都在这里记录一下。首先从简单的集合源码开始。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>基于数组的集合，默认的构造函数，给了一个空数组，Object[]， {}，默认的初始化大小为10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般在构造ArrayList，建议指定一个大小，避免频繁扩容带来的开销。</p></blockquote><p>每次往ArrayList中插入数据的时候，都会判断当前数组的元素是否塞满了，如果塞满的话，此时就会扩容这个数组，然后将老数组中的元素拷贝到新数组中去，确保说数组一定是可以承受足够多的元素的。</p><a id="more"></a><h4 id="add-方法的源码"><a href="#add-方法的源码" class="headerlink" title="add()方法的源码"></a>add()方法的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经满了，会扩容大约1.5倍</span></span><br><span class="line">    <span class="comment">// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span><br><span class="line">    <span class="comment">// 然后利用Arrays.copyOf，将老数据复制到新数组中</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// 大约是1.5倍</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  <span class="comment">// 将老数据的数据复制到新的数组里</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-方法的源码"><a href="#set-方法的源码" class="headerlink" title="set()方法的源码"></a>set()方法的源码</h4><p>set源码比较简单，就是检查索引是否超出边界，然后做一个值的替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-index-element-方法的源码"><a href="#add-index-element-方法的源码" class="headerlink" title="add(index, element)方法的源码"></a>add(index, element)方法的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查索引是否越界</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  <span class="comment">// 检查容量是否够了</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">// 关键代码，将某个索引后的数据往数组后面复制，也就是相当于数据往后移动一位</span></span><br><span class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                   size - index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法的源码"><a href="#get-方法的源码" class="headerlink" title="get()方法的源码"></a>get()方法的源码</h4><p>这个简单，就是直接根据索引返回数组里的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-方法的源码"><a href="#remove-方法的源码" class="headerlink" title="remove()方法的源码"></a>remove()方法的源码</h4><p>删除某一个元素，就是从某一个元素开始往前移动一位，然后将最后一位重置为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 往前移动</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>remove()<br>add(index, element)</p><p>这个两个方法，都会导致数组的拷贝，大量元素的挪动，性能都不是太高，基于数组来做这种随机位置的插入和删除，其实性能真的不是太高</p><p>add()、add(index, element)，这两个方法，都可能会导致数组需要扩容，数组长度是固定的，默认初始大小是10个元素，如果不停的往数组里塞入数据，可能会导致瞬间数组不停的扩容，影响系统的性能</p><p>set()、get()，定位到随机的位置，替换那个元素，或者是获取那个元素，这个其实还是比较靠谱的，基于数组来实现随机位置的定位，性能是很高的</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList，是一个双向链表。</p><p>![image-20201013184959422](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013184959422.png)</p><p>add()，默认就是在队列的尾部插入一个元素，在那个双向链表的尾部插入一个元素<br>add(index, element)，是在队列的中间插入一个元素<br>addFirst()，在队列的头部插入一个元素<br>addLast()，跟add()方法是一样的，也是在尾部插入一个元素</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>在往中间插入数据的时候，会根据传入的索引，找到对应的节点，然后设置到节点的before变量中，那么在查找这个节点的过程中，实际上是一个遍历的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果索引在列表的前半部分，则从前往后开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则从后往前遍历查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过一些指针的变换操作，来完成插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert succ != null;</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">  succ.prev = newNode;</span><br><span class="line">  <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20201013185212959](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185212959.png)</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>**getFirst() == peek()**：获取头部的元素，直接返回first指针指向的那个Node里面的数据，他们都是返回头部的元素。getFirst()如果是对空list调用，会抛异常；peek()对空list调用，会返回null</p><p>**getLast()**：获取尾部的元素</p><p>get(int index)，需要用到node(index)方法来定位元素，也就是先判断索引在前半部分还是在后半部分，然后遍历来获得元素，性能较低。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>removeLast()</strong><br><strong>removeFirst() == poll()</strong><br><strong>remove(int index)</strong></p><p>删除，也是通过一些指针的替换，将节点脱离出来，item设置为null，然后等待被回收掉。</p><p>![image-20201013185444906](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185444906.png)</p><h3 id="Vector和Stack"><a href="#Vector和Stack" class="headerlink" title="Vector和Stack"></a>Vector和Stack</h3><p>Stack是基于数组的栈结构，而Vector是基于数组的有序集合，Stack是继承于Vector。</p><p>栈：先进后出</p><p>Stack的push方法，几乎和ArrayList的add一样，顺序设置数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[elementCount++] = obj;</span><br></pre></td></tr></table></figure><p>但是，ArrayList每次扩容是1.5倍，<code>capacity + (capacity &gt;&gt; 1) = 1.5</code>，Vector每次扩容默认是2倍。</p><p>pop()方法，从栈顶弹出一个元素，就是返回最后一个元素，然后删除最后一个元数据，这里会涉及到利用System.arraycopy拷贝数组元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>一个最常见的场景，就是在迭代这个集合的时候，对集合进行remove操作，就一定会遇到这个错误。</p><p>这个是集合迭代器的fail-fast机制，每一种集合的数据结构，都有一个modCount的字段，新增和删除元素的时候，会对这个字段进行modCount++操作。</p><p>然后在初始化迭代器的时候，会记录初始化的会记录modCount的值到expectedModCount中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 初始化的时候记录modCount的值</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure><p>然后在后面迭代的的回收，会判断值是否发生改变，如果改变了，就直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK集合源码&quot;&gt;&lt;a href=&quot;#JDK集合源码&quot; class=&quot;headerlink&quot; title=&quot;JDK集合源码&quot;&gt;&lt;/a&gt;JDK集合源码&lt;/h1&gt;&lt;p&gt;准备写一些文章，把集合、并发、网络相关的JDK工具的使用和源码都在这里记录一下。首先从简单的集合源码开始。&lt;/p&gt;
&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;p&gt;基于数组的集合，默认的构造函数，给了一个空数组，Object[]， {}，默认的初始化大小为10。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Constructs an empty list with an initial capacity of ten.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;一般在构造ArrayList，建议指定一个大小，避免频繁扩容带来的开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次往ArrayList中插入数据的时候，都会判断当前数组的元素是否塞满了，如果塞满的话，此时就会扩容这个数组，然后将老数组中的元素拷贝到新数组中去，确保说数组一定是可以承受足够多的元素的。&lt;/p&gt;</summary>
    
    
    
    <category term="JDK源码" scheme="http://www.saily.top/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="JDK源码" scheme="http://www.saily.top/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</title>
    <link href="http://www.saily.top/2020/06/04/springcloud/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B9%B6%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.saily.top/2020/06/04/springcloud/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B9%B6%E8%A7%A3%E5%86%B3/</id>
    <published>2020-06-04T13:55:39.000Z</published>
    <updated>2020-06-04T14:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次线上故障排查并解决-Spring-Cloud健康检查的坑"><a href="#记一次线上故障排查并解决-Spring-Cloud健康检查的坑" class="headerlink" title="记一次线上故障排查并解决(Spring Cloud健康检查的坑)"></a>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</h1><p>今天下班在回家路上的时候，同事反馈他们的生产环境项目不停的在输出错误日志，一时半会没有找到原因，让我帮忙看看。我到家后登录VPN，打开了kibana查看日志，确实一直在报错，错误日志如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: 断开的管道    </span><br><span class="line">at sun.nio.ch.FileDispatcherImpl.write0(Native Method)    </span><br><span class="line">at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:<span class="number">47</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:<span class="number">93</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.write(IOUtil.java:<span class="number">65</span>)    </span><br><span class="line">at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:<span class="number">471</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:<span class="number">134</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:<span class="number">101</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:<span class="number">157</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:<span class="number">1276</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:<span class="number">670</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:<span class="number">607</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:<span class="number">597</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:<span class="number">646</span>)    </span><br><span class="line">at org.apache.coyote.http11.filters.ChunkedOutputFilter.flush(ChunkedOutputFilter.java:<span class="number">169</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:<span class="number">252</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:<span class="number">1564</span>)    </span><br><span class="line">at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:<span class="number">352</span>)    </span><br><span class="line">at org.apache.coyote.Response.action(Response.java:<span class="number">173</span>)    </span><br><span class="line">at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:<span class="number">317</span>)    </span><br><span class="line">... <span class="number">92</span> more </span><br></pre></td></tr></table></figure><p>搜索<code>ERROR</code>级别日志，看到的全是这个日志，而且有两个项目都在输出这个错误日志，询问同事后确定了几个问题：</p><ol><li>项目近期没有升级</li><li>这两个项目当前都没有人访问，也就是没有接口流量</li><li>这个日志似乎是有周期性的输出，1分钟~3分钟不等</li></ol><p>记录一下我自己的排查思路，首先项目没有流量，也没有人访问，<strong>但是这个错明显是有接口请求，并且是因为客户端主动断开链接导致的，这一点可以确定</strong>。那么再结合周期性的错误日志输出，我首先想到的是不是采集监控的端点，或者是健康检查的端点出问题了，于是我登录堡垒机，测试了一下问题项目的采集监控数据的接口，没有问题，健康检查端点也没有问题，都是可以访问的。</p><p>我们的项目是SpringCloud的，所以健康检查端点是：<code>/actuator/health</code>，但是我多刷新了几次，发现有的时候很慢，有的时候很快，慢的时候能达到十几二十秒，健康检查的结果才出来。因为我们的项目是接入了prometheus的，紧接着我又去看了下监控，没有发现问题（监控排除了健康检查端点的访问情况，因为如果是SLB的话每秒会检查10+次），于是我将Grafana中的条件做了调整，得到了健康检查端点的耗时情况。</p><p><img src="/img/spring-cloud/image-20200604221611065.png" alt="image-20200604221611065"></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>可以看得出来，健康检查端点的耗时确实很长，基本可以确定，上面异常产生的原因是因为consul在对服务进行心跳检查的时候，<strong>超时了</strong>。所以consul的agent主动断开了<code>/actuator/health</code>的请求，所以得到了 <code>java.io.IOException: Broken pipe</code>的错误。</p><p><img src="/img/spring-cloud/image-20200604222132779.png" alt="image-20200604222132779"></p><p>这一点从监控数据原文里也得到了确认，是健康检查的端点在输出异常日志。</p><h2 id="为什么健康检查端点会超时"><a href="#为什么健康检查端点会超时" class="headerlink" title="为什么健康检查端点会超时"></a>为什么健康检查端点会超时</h2><p>现在知道了原因，但是这只是表面现象，为什么健康检查会超时？这不太正常，之前都是好好的，为什么突然开始就一直超时了，于是我开始观察健康检查里都有些什么内容，发现有一个可能会比较耗时的东西。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mail&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;xxx.com:-1&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我对比了这两个出问题的项目，他们都有邮件的健康检查，我问了下同事，是不是只有这两个项目会用到发邮件的功能，而其他项目没有，同事确认说是的。</p><p>基本可以确认，就是因为邮件的健康检查导致的，可能因为网络或是什么原因，导致邮件服务器的健康检查比较慢，从而导致健康检查的端点也非常耗时。</p><p>所以联系了运维的同事，加上了以下配置，关闭了邮件的健康检查。因为邮件并不是核心的功能，所以先关闭掉，验证一下是否能解决问题。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.health.mail.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>在加入配置关闭邮件服务器的健康检查以后，重启服务，观察了5分钟日志，发现一切恢复如初，没有产生新的异常日志，健康检查的端点，也变得非常快了。</p><p><img src="/img/spring-cloud/image-20200604223511793.png" alt="image-20200604223511793"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本次故障是因为邮件服务器的健康检查很慢，导致consul对服务进行心跳检查的时候超时，主动断开连接，然后定期的输出了 <code>java.io.IOException: Broken pipe</code>的异常日志。</p><p>关于SpringCloud提供的健康检查机制，其实大多数情况下，好多功能的检查都可以关闭，按需打开，举个例子，如果Redis挂掉了，这里整个服务的健康检查就会是<strong>DOWN</strong>了，会直接导致其他服务无法调用，但是实际上在业务中如果Redis挂掉的话，我们是会去做降级从数据库查询的，仍然可以为其他服务提供调用。</p><p>所以我们在项目里，完全可以把这些第三方中间件的健康检查默认给关闭掉。按需打开必要的健康检查选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">health:</span></span><br><span class="line">    <span class="attr">defaults:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 按需打开db或者redis等中间件健康检查</span></span><br><span class="line">    <span class="attr">db:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记一次线上故障排查并解决-Spring-Cloud健康检查的坑&quot;&gt;&lt;a href=&quot;#记一次线上故障排查并解决-Spring-Cloud健康检查的坑&quot; class=&quot;headerlink&quot; title=&quot;记一次线上故障排查并解决(Spring Cloud健康检查的坑)&quot;&gt;&lt;/a&gt;记一次线上故障排查并解决(Spring Cloud健康检查的坑)&lt;/h1&gt;&lt;p&gt;今天下班在回家路上的时候，同事反馈他们的生产环境项目不停的在输出错误日志，一时半会没有找到原因，让我帮忙看看。我到家后登录VPN，打开了kibana查看日志，确实一直在报错，错误日志如下：&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Netflix生产实践</title>
    <link href="http://www.saily.top/2020/05/17/springcloud/SpringCloud%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.saily.top/2020/05/17/springcloud/SpringCloud%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-05-17T12:57:58.000Z</published>
    <updated>2020-05-27T14:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务注册生产实践"><a href="#服务注册生产实践" class="headerlink" title="服务注册生产实践"></a>服务注册生产实践</h1><h2 id="服务注册的时效性（毫秒级）"><a href="#服务注册的时效性（毫秒级）" class="headerlink" title="服务注册的时效性（毫秒级）"></a>服务注册的时效性（毫秒级）</h2><p>服务在启动后，会向eureka server发起注册，应该是在1秒以内的。</p><p>会通过SpringCloud额外封装的<code>EurekaAutoServiceRegistration#start()</code>发起注册，这个类的实例被EurekaClientAutoConfiguration定义。</p><h2 id="服务发现的时效性（毫秒级和分钟级）"><a href="#服务发现的时效性（毫秒级和分钟级）" class="headerlink" title="服务发现的时效性（毫秒级和分钟级）"></a>服务发现的时效性（毫秒级和分钟级）</h2><p>一个服务启动后，发现其他所有的服务需要多长时间？如果其他服务新增了机器，那么又需要多长时间才能发现。</p><ol><li>服务启动后，会主动拉取全量注册表，可以发现已经注册的服务列表（毫秒级）</li><li>服务每隔30秒会拉取增量注册表（先走ALL_APPS_DELTA缓存，读不到查queue）</li><li>eureka server 二级缓存，定时任务30秒从readWriterCacheMap同步到readOnlyCacheMap</li><li>一个服务启动注册后，要30秒才会被其他服务发现（1分钟以内）</li></ol><a id="more"></a><p>eureka的服务发现是分钟级，可通过修改配置减少这个时间：</p><p>eureka client端(EurekaClientConfigBean)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.registryFetchIntervalSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><p>eureka server端(EurekaServerConfigBean)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.server.responseCacheUpdateIntervalMs</span>=<span class="string">30 * 1000</span></span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7%E5%88%86%E6%9E%90.png" alt="服务发现的时效性分析"></p><h2 id="服务心跳的时效性（30秒）"><a href="#服务心跳的时效性（30秒）" class="headerlink" title="服务心跳的时效性（30秒）"></a>服务心跳的时效性（30秒）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务心跳流程分析</a></p><p>服务启动以后，会定时发送心跳给eureka server，默认是30秒一次(EurekaInstanceConfigBean)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.instance.leaseRenewalIntervalInSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><h2 id="服务故障感知的时效性（5分）"><a href="#服务故障感知的时效性（5分）" class="headerlink" title="服务故障感知的时效性（5分）"></a>服务故障感知的时效性（5分）</h2><p><a href="%5Bhttp://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%5D(http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)">服务故障流程分析</a></p><p>在eureka server中，每隔60秒会执行一次evict task（加上JVM gc等原因的补偿时间），判断当前所有的服务实例是否有的实例出现了故障（一直没有发送心跳）。</p><p>这个任务的逻辑是，默认90s没有收到过心跳就认为已经过期，但是这里有bug，实际上是90s * 2 = 180s才会认为已经故障了，那么算到这里，eureka server可能要4分钟才能感知到一个服务宕机后认为是下线了。 （而且每次只会摘除最多15%数量的故障实例）,</p><p><strong>客户端</strong>：服务摘除后，会清空readWriteCacheMap的缓存，算eureka server的读写缓存30秒，然后每隔30秒会同步到readOnlyCacheMap里。所以宕机后要被客户端感知到，极端情况下可能要5分钟。</p><h2 id="服务下线感知的时效性（1分钟）"><a href="#服务下线感知的时效性（1分钟）" class="headerlink" title="服务下线感知的时效性（1分钟）"></a>服务下线感知的时效性（1分钟）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务下线流程分析</a></p><p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。逻辑也是从内存的map里删除，然后放入recentlyChangedQueue队列里，最后让缓存失效。</p><p>无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能<strong>60秒</strong>才能感知到服务的下线。</p><h2 id="eureka-server自我保护机制（不要用）"><a href="#eureka-server自我保护机制（不要用）" class="headerlink" title="eureka server自我保护机制（不要用）"></a>eureka server自我保护机制（不要用）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">服务自我保护机制</a></p><p>eureka的自我保护机制，充斥着大量的hash code硬编码，写死你的心跳间隔时间是30秒，1分钟2次，通过统计服务的心跳次数来判断自己是不是网络故障了。这个根本就是很严重的bug，无法在生产环境使用。</p><p>直接在配置中关闭</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.server.enableSelfPreservation</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><h2 id="eureka-server集群的负载均衡（按配置顺序）"><a href="#eureka-server集群的负载均衡（按配置顺序）" class="headerlink" title="eureka server集群的负载均衡（按配置顺序）"></a>eureka server集群的负载均衡（按配置顺序）</h2><p>服务在注册的时候，如果在yml里配置了多个eureka server，会按顺序用第一个eureka server的机器发起注册，只有在第一个机器挂掉的情况下，在重试一定次数失败以后，才会尝试用第二台机器。</p><p>那如果第一台又恢复了呢，其实还是会一直用第二台，除非第二台死掉了，才会重试别的机器。</p><p>这些重试的逻辑的源码，都在<code>RetryableEurekaHttpClient</code>类里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</span><br><span class="line">    List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</span><br><span class="line">        EurekaHttpClient currentHttpClient = delegate.get();</span><br><span class="line">        EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></span><br><span class="line">            <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateHosts = getHostCandidates();</span><br><span class="line">                <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;There is no known eureka server; cluster server list is empty&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></span><br><span class="line">            <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Cannot execute request on any known server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建候选的 EurekaHttpClient</span></span><br><span class="line">            currentEndpoint = candidateHosts.get(endpointIdx++);</span><br><span class="line">            currentHttpClient = clientFactory.newClient(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</span><br><span class="line">            <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></span><br><span class="line">            <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</span><br><span class="line">                delegate.set(currentHttpClient);</span><br><span class="line">                <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Request execution succeeded on retry #&#123;&#125;&quot;</span>, retry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failure with status code &#123;&#125;; retrying on another server if available&quot;</span>, response.getStatusCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failed with message: &#123;&#125;&quot;</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></span><br><span class="line">        <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></span><br><span class="line">        delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></span><br><span class="line">        <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quarantineSet.add(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Retry limit reached; giving up on completing the request&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eureka-server集群同步的时效性（1秒内）"><a href="#eureka-server集群同步的时效性（1秒内）" class="headerlink" title="eureka server集群同步的时效性（1秒内）"></a>eureka server集群同步的时效性（1秒内）</h2><p><a href="http://www.saily.top/2020/03/28/springcloud/eureka05/#%E6%B3%A8%E5%86%8C%E3%80%81%E4%B8%8B%E7%BA%BF%E3%80%81%E6%95%85%E9%9A%9C%E9%9B%86%E7%BE%A4%E9%97%B4%E5%90%8C%E6%AD%A5">集群间同步</a></p><p>在eureka server收到注册请求的时候，就会将注册数据同步到其他节点，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，并且这里包含了一个注册逻辑的批处理。</p><p><img src="http://www.saily.top/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p><p>可以看到，因为有一个批处理的机制，每500毫秒以内的请求会统一打包处理，所以集群间的数据同步，是一秒以内完成同步。</p><h1 id="服务调用生产实践"><a href="#服务调用生产实践" class="headerlink" title="服务调用生产实践"></a>服务调用生产实践</h1><h2 id="Ribbon-Eureka服务发现与故障的时效性"><a href="#Ribbon-Eureka服务发现与故障的时效性" class="headerlink" title="Ribbon+Eureka服务发现与故障的时效性"></a>Ribbon+Eureka服务发现与故障的时效性</h2><h3 id="服务正常上线-修改，最大可能会有60s滞后"><a href="#服务正常上线-修改，最大可能会有60s滞后" class="headerlink" title="服务正常上线/修改，最大可能会有60s滞后"></a>服务正常上线/修改，最大可能会有60s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br></pre></td></tr></table></figure><p>前面已经分析了Eureka本身的时效性，刚启动发现其他服务是毫秒级，发现新注册的服务是分钟级。那么在结合Ribbon使用后，他有一个PollingServerListUpdater，这个是每30秒从eureka client同步一次到Ribbon的缓存中，所以一个新注册的服务要被Ribbon感知到，极端情况下需要90秒。</p><h3 id="服务异常下线：最大可能会有300s滞后"><a href="#服务异常下线：最大可能会有300s滞后" class="headerlink" title="服务异常下线：最大可能会有300s滞后"></a>服务异常下线：最大可能会有300s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 定时清理任务每eureka.server.evictionIntervalTimerInMs(默认60)执行一次清理任务</span><br><span class="line">- 每次清理任务会把90秒(3个心跳周期，eureka.instance.leaseExpirationDurationInSeconds)没收到心跳的踢除，但是根据官方的说法 ，因为代码实现的bug，这个时间其实是两倍，即180秒，也就是说如果一个客户端因为网络问题或者主机问题异常下线，可能会在180秒后才剔除</span><br><span class="line">- 读取端，因为readOnlyCacheMap以及客户端缓存的存在，可能会在30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br><span class="line">- 所以极端情况最终可能会是60+180+90&#x3D;330</span><br></pre></td></tr></table></figure><p>那如果某一个服务宕机了，Eureka Client感知到的时间是5分钟，再加上Ribbon的PollingServerListUpdater的30秒，Ribbon在极端情况下是需要5.5分钟才能感知到。</p><h2 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h2><p>Ribbon默认是用ZoneAwareLoadBalancer，默认算法就是轮询</p><p><a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">负载均衡算法如何选择一个server</a></p><h2 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h2><p><a href="http://www.saily.top/2020/04/18/springcloud/feign04/">Feign超时和重试分析</a></p><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>feign的超时时间优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="Ribbon预加载"><a href="#Ribbon预加载" class="headerlink" title="Ribbon预加载"></a>Ribbon预加载</h2><p>网关的项目第一次访问的时候总是会超时，是因为在第一次访问的时候，Ribbon会去调用eureka-client里的服务列表，所以这里会消耗一些时间，而zuul默认超时时间又是1秒，所以加上下面的参数，让Ribbon提前加载好。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure><h2 id="Zuul-Ribbon-eureka感知服务上线和故障的时效性"><a href="#Zuul-Ribbon-eureka感知服务上线和故障的时效性" class="headerlink" title="Zuul+Ribbon+eureka感知服务上线和故障的时效性"></a>Zuul+Ribbon+eureka感知服务上线和故障的时效性</h2><p>这块儿和<a href="#Ribbon+Eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7">Ribbon+Eureka服务发现与故障的时效性</a>是一样的</p><h2 id="Zuul降级和异常"><a href="#Zuul降级和异常" class="headerlink" title="Zuul降级和异常"></a>Zuul降级和异常</h2><p>Error Filter错误处理和<a href="http://www.saily.top/2020/05/10/springcloud/zuul01/#hystrix%E9%85%8D%E7%BD%AE">降级</a></p><h2 id="Zuul超时"><a href="#Zuul超时" class="headerlink" title="Zuul超时"></a>Zuul超时</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Hystrix的超时时间应该大于Ribbon的超时时间，加上Ribbon的重试机制，基于上面的参数计算，(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)。</p><p>Hystrix的超时时间应该是设置为8秒。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;服务注册生产实践&quot;&gt;&lt;a href=&quot;#服务注册生产实践&quot; class=&quot;headerlink&quot; title=&quot;服务注册生产实践&quot;&gt;&lt;/a&gt;服务注册生产实践&lt;/h1&gt;&lt;h2 id=&quot;服务注册的时效性（毫秒级）&quot;&gt;&lt;a href=&quot;#服务注册的时效性（毫秒级）&quot; class=&quot;headerlink&quot; title=&quot;服务注册的时效性（毫秒级）&quot;&gt;&lt;/a&gt;服务注册的时效性（毫秒级）&lt;/h2&gt;&lt;p&gt;服务在启动后，会向eureka server发起注册，应该是在1秒以内的。&lt;/p&gt;
&lt;p&gt;会通过SpringCloud额外封装的&lt;code&gt;EurekaAutoServiceRegistration#start()&lt;/code&gt;发起注册，这个类的实例被EurekaClientAutoConfiguration定义。&lt;/p&gt;
&lt;h2 id=&quot;服务发现的时效性（毫秒级和分钟级）&quot;&gt;&lt;a href=&quot;#服务发现的时效性（毫秒级和分钟级）&quot; class=&quot;headerlink&quot; title=&quot;服务发现的时效性（毫秒级和分钟级）&quot;&gt;&lt;/a&gt;服务发现的时效性（毫秒级和分钟级）&lt;/h2&gt;&lt;p&gt;一个服务启动后，发现其他所有的服务需要多长时间？如果其他服务新增了机器，那么又需要多长时间才能发现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务启动后，会主动拉取全量注册表，可以发现已经注册的服务列表（毫秒级）&lt;/li&gt;
&lt;li&gt;服务每隔30秒会拉取增量注册表（先走ALL_APPS_DELTA缓存，读不到查queue）&lt;/li&gt;
&lt;li&gt;eureka server 二级缓存，定时任务30秒从readWriterCacheMap同步到readOnlyCacheMap&lt;/li&gt;
&lt;li&gt;一个服务启动注册后，要30秒才会被其他服务发现（1分钟以内）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Zuul02-核心流程和源码分析</title>
    <link href="http://www.saily.top/2020/05/11/springcloud/zuul02/"/>
    <id>http://www.saily.top/2020/05/11/springcloud/zuul02/</id>
    <published>2020-05-11T14:12:59.000Z</published>
    <updated>2020-05-13T15:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>在看Zuul的原理之前，要先熟透Ribbon和Hystrix的原理，因为Zuul就是基于这2个组件来做的。</p><p>画个图概括下:</p><p><img src="/img/spring-cloud/Zuul%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B.jpg" alt="Zuul的核心流程"></p><a id="more"></a><h1 id="EnableZuulProxy"><a href="#EnableZuulProxy" class="headerlink" title="@EnableZuulProxy"></a>@EnableZuulProxy</h1><p>会自动开启一个ZuulProxyAutoConfiguration的自动装配，里面定义了很多的Bean，包括RouteLocator、过滤器等和的一些组件。他的父类<code>ZuulServerAutoConfiguration</code>，也包含了很多配置的定义，其中就包括了ZuulServlet，这个是zuul核心请求的入口，拦截所有的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">zuulServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean servlet = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> ZuulServlet(),</span><br><span class="line">         <span class="keyword">this</span>.zuulProperties.getServletPattern());</span><br><span class="line">   <span class="comment">// The whole point of exposing this servlet is to provide a route that doesn&#x27;t</span></span><br><span class="line">   <span class="comment">// buffer requests.</span></span><br><span class="line">   servlet.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ZuulServlet"><a href="#ZuulServlet" class="headerlink" title="ZuulServlet"></a>ZuulServlet</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化RequestContext</span></span><br><span class="line">        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span></span><br><span class="line">        <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先调用pre 过滤器</span></span><br><span class="line">            preRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="comment">// 报错了，先是error过滤器</span></span><br><span class="line">            error(e);</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是 route 过滤器</span></span><br><span class="line">            route();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNHANDLED_EXCEPTION_&quot;</span> + e.getClass().getName()));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理掉ThreadLocal</span></span><br><span class="line">        RequestContext.getCurrentContext().unset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init方法，对RequestContext进行了初始化，他是用ThreadLocal实现的，用装饰器模式包装了Request和Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这个是用ThreadLocal实现的</span></span><br><span class="line">    RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    <span class="comment">// 这个默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (bufferRequests) &#123;</span><br><span class="line">        ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.setRequest(servletRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZuulServlet的代码就能看出来，过滤器的执行逻辑是先执行pre，然后是route，如果这2个filter报错了，就会先执行error，然后是post，但是如果在post阶段报错，就直接执行error。</p><p>然后还有一个类是<code>ZuulServletFilter</code>，这个类和<code>ZuulServlet</code>的代码几乎是一样的，只不过zuul提供了filter和servlet两种方式提供服务，默认情况下是<code>ZuulServlet</code>。</p><p>下面开始看Zuul自带的过滤器</p><h1 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h1><ul><li>-3：ServletDetectionFilter</li><li>-2：Servlet30WrapperFilter</li><li>-1：FromBodyWrapperFilter</li><li>1：DebugFilter</li><li>5：PreDecorationFilter</li></ul><p>所有的filter都是通过FilterProcessor.runFilters()方法来执行的，参数作为过滤器的类型来执行对应阶段的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runFilters(<span class="string">&quot;pre&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">        Debug.addRoutingDebug(<span class="string">&quot;Invoking &#123;&quot;</span> + sType + <span class="string">&quot;&#125; type filters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 根据指定的过滤器类型，比如pre，找到所有的pre类型的过滤器，并且是按照优先级排序的</span></span><br><span class="line">    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">            Object result = processZuulFilter(zuulFilter);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                bResult |= ((Boolean) result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServletDetectionFilter"><a href="#ServletDetectionFilter" class="headerlink" title="ServletDetectionFilter"></a>ServletDetectionFilter</h2><p>设置isDispatcherServletRequest=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 就判断了下，然后设置了一个标识</span></span><br><span class="line">   <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequestWrapper) </span><br><span class="line">         &amp;&amp; isDispatcherServletRequest(request)) &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet30WrapperFilter"><a href="#Servlet30WrapperFilter" class="headerlink" title="Servlet30WrapperFilter"></a>Servlet30WrapperFilter</h2><p>用Servlet30RequestWrapper包裹了下request，说Zuul 1.2.2里有个bug，HttpServletRequestWrapper没有返回原生的request，所以包裹了以后，getRequest()方法返回原生的request。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 不成立</span></span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      request = (HttpServletRequest) ReflectionUtils.getField(<span class="keyword">this</span>.requestField,</span><br><span class="line">            request);</span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用Servlet30RequestWrapper包装下</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (RequestUtils.isDispatcherServletRequest()) &#123;</span><br><span class="line">      <span class="comment">// If it&#x27;s going through the dispatcher we need to buffer the body</span></span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FormBodyWrapperFilter"><a href="#FormBodyWrapperFilter" class="headerlink" title="FormBodyWrapperFilter"></a>FormBodyWrapperFilter</h2><p>只有在请求content-type为APPLICATION_FORM_URLENCODED或者MULTIPART_FORM_DATA的时候，才会执行这个filter，他一样也是会将用request用FormBodyRequestWrapper包裹一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   FormBodyRequestWrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      HttpServletRequest wrapped = (HttpServletRequest) ReflectionUtils</span><br><span class="line">            .getField(<span class="keyword">this</span>.requestField, request);</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(wrapped);</span><br><span class="line">      ReflectionUtils.setField(<span class="keyword">this</span>.requestField, request, wrapper);</span><br><span class="line">      <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletRequestWrapper) &#123;</span><br><span class="line">         ReflectionUtils.setField(<span class="keyword">this</span>.servletRequestField, request, wrapper);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(request);</span><br><span class="line">      ctx.setRequest(wrapper);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ctx.getZuulRequestHeaders().put(<span class="string">&quot;content-type&quot;</span>, wrapper.getContentType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DebugFilter"><a href="#DebugFilter" class="headerlink" title="DebugFilter"></a>DebugFilter</h2><p>在http参数传一个?debug=true才会执行这个，然后就设置了2个属性，后续打日志的时候会用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HttpServletRequest request = RequestContext.getCurrentContext().getRequest();</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(request.getParameter(DEBUG_PARAMETER.get()))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ROUTING_DEBUG.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   ctx.setDebugRouting(<span class="keyword">true</span>);</span><br><span class="line">   ctx.setDebugRequest(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PreDecorationFilter"><a href="#PreDecorationFilter" class="headerlink" title="PreDecorationFilter"></a>PreDecorationFilter</h2><p>这个过滤器逻辑稍显复杂，也是核心的一个逻辑，承担了解析路由的工作</p><ol><li>解析请求url，拿到了请求的地址</li><li>根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置，这个routeLocator是SimpleRouteLocator，在这里可以做一定的定制化，将route给做到mysql里去。</li><li>将Route规则设置到RequestContext中，加了一些请求头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="comment">// 拿到了请求的url path</span></span><br><span class="line">   <span class="keyword">final</span> String requestURI = <span class="keyword">this</span>.urlPathHelper.getPathWithinApplication(ctx.getRequest());</span><br><span class="line">   <span class="comment">// 根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置</span></span><br><span class="line">   Route route = <span class="keyword">this</span>.routeLocator.getMatchingRoute(requestURI);</span><br><span class="line">   <span class="keyword">if</span> (route != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String location = route.getLocation();</span><br><span class="line">      <span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// route相关规则放进ctx</span></span><br><span class="line">         ctx.put(REQUEST_URI_KEY, route.getPath());</span><br><span class="line">         ctx.put(PROXY_KEY, route.getId());</span><br><span class="line">         <span class="keyword">if</span> (!route.isCustomSensitiveHeaders()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper</span><br><span class="line">                  .addIgnoredHeaders(<span class="keyword">this</span>.properties.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper.addIgnoredHeaders(route.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (route.getRetryable() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.put(RETRYABLE_KEY, route.getRetryable());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (location.startsWith(HTTP_SCHEME+<span class="string">&quot;:&quot;</span>) || location.startsWith(HTTPS_SCHEME+<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">            ctx.setRouteHost(getUrl(location));</span><br><span class="line">            <span class="comment">// 添加了一些header</span></span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(FORWARD_LOCATION_PREFIX)) &#123;</span><br><span class="line">            ctx.set(FORWARD_TO_KEY,</span><br><span class="line">                  StringUtils.cleanPath(location.substring(FORWARD_LOCATION_PREFIX.length()) + route.getPath()));</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// set serviceId for use in filters.route.RibbonRequest</span></span><br><span class="line">            ctx.set(SERVICE_ID_KEY, location);</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_ID_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddProxyHeaders()) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            addProxyHeaders(ctx, route);</span><br><span class="line">            String xforwardedfor = ctx.getRequest().getHeader(X_FORWARDED_FOR_HEADER);</span><br><span class="line">            String remoteAddr = ctx.getRequest().getRemoteAddr();</span><br><span class="line">            <span class="keyword">if</span> (xforwardedfor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               xforwardedfor = remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!xforwardedfor.contains(remoteAddr)) &#123; <span class="comment">// Prevent duplicates</span></span><br><span class="line">               xforwardedfor += <span class="string">&quot;, &quot;</span> + remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.addZuulRequestHeader(X_FORWARDED_FOR_HEADER, xforwardedfor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddHostHeader()) &#123;</span><br><span class="line">            ctx.addZuulRequestHeader(HttpHeaders.HOST, toHostHeader(ctx.getRequest()));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;No route found for uri: &quot;</span> + requestURI);</span><br><span class="line"></span><br><span class="line">      String fallBackUri = requestURI;</span><br><span class="line">      String fallbackPrefix = <span class="keyword">this</span>.dispatcherServletPath; <span class="comment">// default fallback</span></span><br><span class="line">                                             <span class="comment">// servlet is</span></span><br><span class="line">                                             <span class="comment">// DispatcherServlet</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (RequestUtils.isZuulServletRequest()) &#123;</span><br><span class="line">         <span class="comment">// remove the Zuul servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;zuulServletPath=&quot;</span> + <span class="keyword">this</span>.properties.getServletPath());</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.properties.getServletPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced Zuul servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// remove the DispatcherServlet servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;dispatcherServletPath=&quot;</span> + <span class="keyword">this</span>.dispatcherServletPath);</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.dispatcherServletPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced DispatcherServlet servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fallBackUri.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         fallBackUri = <span class="string">&quot;/&quot;</span> + fallBackUri;</span><br><span class="line">      &#125;</span><br><span class="line">      String forwardURI = fallbackPrefix + fallBackUri;</span><br><span class="line">      forwardURI = forwardURI.replaceAll(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">      ctx.set(FORWARD_TO_KEY, forwardURI);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleRouteLocator"><a href="#SimpleRouteLocator" class="headerlink" title="SimpleRouteLocator"></a>SimpleRouteLocator</h3><p>这个就是用来读取和保存路由规则的辅助了，用Map维护了一个<code>private AtomicReference&lt;Map&lt;String, ZuulRoute&gt;&gt; routes = new AtomicReference&lt;&gt;();</code>，主要需要关注它的locateRoutes方法，可以继承这个类，然后重写locateRoutes方法，改为从数据库读取路由配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, ZuulRoute&gt; <span class="title">locateRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LinkedHashMap&lt;String, ZuulRoute&gt; routesMap = <span class="keyword">new</span> LinkedHashMap&lt;String, ZuulRoute&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ZuulRoute route : <span class="keyword">this</span>.properties.getRoutes().values()) &#123;</span><br><span class="line">      routesMap.put(route.getPath(), route);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> routesMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="route过滤器"><a href="#route过滤器" class="headerlink" title="route过滤器"></a>route过滤器</h1><ul><li>10：RibbonRoutingFilter</li><li>100：SimpleHostRoutingFilter</li><li>500：SendForwardFilter</li></ul><h2 id="RibbonRoutingFilter"><a href="#RibbonRoutingFilter" class="headerlink" title="RibbonRoutingFilter"></a>RibbonRoutingFilter</h2><p>如果这个请求是转发给服务的，就会用这个Filter通过Ribbon和Hystrix去执行对应的http请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理Ribbon相关内容</span></span><br><span class="line">      RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">      <span class="comment">// 处理Hystrix，并发送请求</span></span><br><span class="line">      ClientHttpResponse response = forward(commandContext);</span><br><span class="line">      setResponse(response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RibbonCommandContext"><a href="#RibbonCommandContext" class="headerlink" title="RibbonCommandContext"></a>RibbonCommandContext</h3><p>对RequestContext里的数据做了解析，封装成了RibbonCommandContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RibbonCommandContext&#123;serviceId&#x3D;&#39;ServiceB&#39;, method&#x3D;&#39;GET&#39;, uri&#x3D;&#39;&#x2F;ServiceB&#x2F;user&#x2F;sayHello&#x2F;1&#39;, retryable&#x3D;false, headers&#x3D;&#123;accept&#x3D;[application&#x2F;json], cache-control&#x3D;[no-cache], user-agent&#x3D;[Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36], content-type&#x3D;[application&#x2F;json], accept-language&#x3D;[zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8], x-forwarded-host&#x3D;[localhost:9000], x-forwarded-proto&#x3D;[http], x-forwarded-prefix&#x3D;[&#x2F;demo], x-forwarded-port&#x3D;[9000], x-forwarded-for&#x3D;[0:0:0:0:0:0:0:1], Accept-Encoding&#x3D;[gzip]&#125;, params&#x3D;&#123;name&#x3D;[张三], age&#x3D;[20]&#125;, requestEntity&#x3D;com.netflix.zuul.http.ServletInputStreamWrapper@22453c1d, requestCustomizers&#x3D;[], contentLength&#x3D;-1, loadBalancerKey&#x3D;null&#125;</span><br></pre></td></tr></table></figure><h3 id="forward-commandContext"><a href="#forward-commandContext" class="headerlink" title="forward(commandContext);"></a>forward(commandContext);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">         context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">         context.getRequestEntity());</span><br><span class="line">   <span class="comment">// 这个代码没有什么新鲜的逻辑，看过Ribbon代码的话就知道，这里面就是封装了一个基于Ribbon和Hystrix的Command</span></span><br><span class="line">   RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ClientHttpResponse response = command.execute();</span><br><span class="line">      <span class="keyword">this</span>.helper.appendDebug(info, response.getRawStatusCode(), response.getHeaders());</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ribbonCommandFactory.create</code>最终创建的类是HttpClientRibbonCommand，这个类其实就是一个HystrixCommand，他实现了自己的run方法，在run方法里，就包含了执行请求的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRibbonCommand#run()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"></span><br><span class="line">   RQ request = createRequest();</span><br><span class="line">   RS response;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">boolean</span> retryableClient = <span class="keyword">this</span>.client <span class="keyword">instanceof</span> AbstractLoadBalancingClient</span><br><span class="line">         &amp;&amp; ((AbstractLoadBalancingClient)<span class="keyword">this</span>.client).isClientRetryable((ContextAwareRequest)request);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (retryableClient) &#123;</span><br><span class="line">      response = <span class="keyword">this</span>.client.execute(request, config);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用负载均衡客户端发起请求,这里面都是ribbon相关的代码了</span></span><br><span class="line">      response = <span class="keyword">this</span>.client.executeWithLoadBalancer(request, config);</span><br><span class="line">   &#125;</span><br><span class="line">   context.set(<span class="string">&quot;ribbonResponse&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Explicitly close the HttpResponse if the Hystrix command timed out to</span></span><br><span class="line">   <span class="comment">// release the underlying HTTP connection held by the response.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.isResponseTimedOut()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">         response.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RibbonHttpResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleHostRoutingFilter"><a href="#SimpleHostRoutingFilter" class="headerlink" title="SimpleHostRoutingFilter"></a>SimpleHostRoutingFilter</h2><p>如果请求是直接配host转发静态路由的，会走这个filter用apache http发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = context.getRequest();</span><br><span class="line">   MultiValueMap&lt;String, String&gt; headers = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestHeaders(request);</span><br><span class="line">   MultiValueMap&lt;String, String&gt; params = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestQueryParams(request);</span><br><span class="line">   String verb = getVerb(request);</span><br><span class="line">   InputStream requestEntity = getRequestBody(request);</span><br><span class="line">   <span class="keyword">if</span> (getContentLength(request) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      context.setChunkedRequestBody();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String uri = <span class="keyword">this</span>.helper.buildZuulRequestURI(request);</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 利用Apache HttpComponent发送请求</span></span><br><span class="line">      CloseableHttpResponse response = forward(<span class="keyword">this</span>.httpClient, verb, uri, request,</span><br><span class="line">            headers, params, requestEntity);</span><br><span class="line">      setResponse(response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SendForwardFilter"><a href="#SendForwardFilter" class="headerlink" title="SendForwardFilter"></a>SendForwardFilter</h2><p>转发到自己本地的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      String path = (String) ctx.get(FORWARD_TO_KEY);</span><br><span class="line">      RequestDispatcher dispatcher = ctx.getRequest().getRequestDispatcher(path);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_FORWARD_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            dispatcher.forward(ctx.getRequest(), ctx.getResponse());</span><br><span class="line">            ctx.getResponse().flushBuffer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h1><ul><li>900：LocationRewriteFilter</li><li>1000：SendResponseFilter </li></ul><h2 id="LocationRewriteFilter"><a href="#LocationRewriteFilter" class="headerlink" title="LocationRewriteFilter"></a>LocationRewriteFilter</h2><p>默认不执行，看响应结果是否需要重定向，如果是的话才会执行。</p><h2 id="SendResponseFilter"><a href="#SendResponseFilter" class="headerlink" title="SendResponseFilter"></a>SendResponseFilter</h2><p>这个就是添加了一些请求头，然后将响应写入Response，</p><ol><li>优先写入RequestContext.getCurrentContext().getResponseBody()的内容</li><li>然后才是context.getResponseDataStream()，也就是应用返回的内容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      addResponseHeaders();</span><br><span class="line">      writeResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeResponse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"><span class="comment">// there is no body to send</span></span><br><span class="line"><span class="keyword">if</span> (context.getResponseBody() == <span class="keyword">null</span></span><br><span class="line">&amp;&amp; context.getResponseDataStream() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HttpServletResponse servletResponse = context.getResponse();</span><br><span class="line"><span class="keyword">if</span> (servletResponse.getCharacterEncoding() == <span class="keyword">null</span>) &#123; <span class="comment">// only set if not set</span></span><br><span class="line">servletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">OutputStream outStream = servletResponse.getOutputStream();</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 优先写入RequestContext.getCurrentContext().getResponseBody()的内容</span></span><br><span class="line"><span class="keyword">if</span> (RequestContext.getCurrentContext().getResponseBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">String body = RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">writeResponse(</span><br><span class="line"><span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">outStream);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> isGzipRequested = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> String requestEncoding = context.getRequest()</span><br><span class="line">.getHeader(ZuulHeaders.ACCEPT_ENCODING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestEncoding != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; HTTPRequestUtils.getInstance().isGzipped(requestEncoding)) &#123;</span><br><span class="line">isGzipRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 然后才是context.getResponseDataStream()，也就是应用返回的内容</span></span><br><span class="line">is = context.getResponseDataStream();</span><br><span class="line">InputStream inputStream = is;</span><br><span class="line">      <span class="comment">// ....省略部分代码</span></span><br></pre></td></tr></table></figure><h1 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h1><ul><li>0：SendErrorFilter</li></ul><h2 id="SendErrorFilter"><a href="#SendErrorFilter" class="headerlink" title="SendErrorFilter"></a>SendErrorFilter</h2><p>直接转发到<code>/error</code>路径，这个就是BasicErrorController的路径，所以要想定制异常消息，继承这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      ZuulException exception = findZuulException(ctx.getThrowable());</span><br><span class="line">      HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>, exception.nStatusCode);</span><br><span class="line"></span><br><span class="line">      log.warn(<span class="string">&quot;Error during filtering&quot;</span>, exception);</span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, exception);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(exception.errorCause)) &#123;</span><br><span class="line">         request.setAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>, exception.errorCause);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 直接转发到/error路径，这个就是BasicErrorController，所以要想定制异常消息，继承这个类</span></span><br><span class="line">      RequestDispatcher dispatcher = request.getRequestDispatcher(</span><br><span class="line">            <span class="keyword">this</span>.errorPath);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_ERROR_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            ctx.setResponseStatusCode(exception.nStatusCode);</span><br><span class="line">            dispatcher.forward(request, ctx.getResponse());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h1><p>![Zuul源码分析 (/img/spring-cloud/Zuul源码分析 (1).jpg)](/../../../Downloads/Zuul源码分析 (1).jpg)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;核心流程&quot;&gt;&lt;a href=&quot;#核心流程&quot; class=&quot;headerlink&quot; title=&quot;核心流程&quot;&gt;&lt;/a&gt;核心流程&lt;/h1&gt;&lt;p&gt;在看Zuul的原理之前，要先熟透Ribbon和Hystrix的原理，因为Zuul就是基于这2个组件来做的。&lt;/p&gt;
&lt;p&gt;画个图概括下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/Zuul%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B.jpg&quot; alt=&quot;Zuul的核心流程&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="zuul" scheme="http://www.saily.top/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>Zuul01-网关介绍和基本使用</title>
    <link href="http://www.saily.top/2020/05/10/springcloud/zuul01/"/>
    <id>http://www.saily.top/2020/05/10/springcloud/zuul01/</id>
    <published>2020-05-10T03:23:59.000Z</published>
    <updated>2020-05-11T15:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么微服务需要网关"><a href="#为什么微服务需要网关" class="headerlink" title="为什么微服务需要网关"></a>为什么微服务需要网关</h1><p>在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中聚合数据，而且服务的划分位置结构可能会有所改变。网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。</p><a id="more"></a><p>当然这只是网关众多功能中的一部分，它还可以做负载均衡，统一鉴权，协议转换，监控监测等一系列功能。</p><ol><li>统一安全认证</li><li>统一限流</li><li>统一降级</li><li>统一异常处理</li><li>统一请求统计</li><li>统一超时</li></ol><p><img src="/img/spring-cloud/sgxpes8edv.png" alt="sgxpes8edv"></p><h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>用一张图过一下zuul的核心原理，Zuul是一个责任链模式</p><p><img src="/img/spring-cloud/Zuul%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Zuul核心原理"></p><p>过滤器前面的数字，表示执行的时候的顺序</p><h2 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h2><ul><li><p>-3：ServletDetectionFilter</p></li><li><p>-2：Servlet30WrapperFilter</p></li><li><p>-1：FromBodyWrapperFilter</p></li><li><p>1：DebugFilter</p></li><li><p>5：PreDecorationFilter</p></li></ul><h2 id="routing过滤器"><a href="#routing过滤器" class="headerlink" title="routing过滤器"></a>routing过滤器</h2><ul><li><p>10：RibbonRoutingFilter</p></li><li><p>100：SimpleHostRoutingFilter</p></li><li><p>500：SendForwardFilter</p></li></ul><h2 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h2><ul><li>1000：SendResponseFilter </li></ul><h2 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h2><ul><li>0：SendErrorFilter</li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="路由规则配置"><a href="#路由规则配置" class="headerlink" title="路由规则配置"></a>路由规则配置</h2><h3 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h3><p>SimpleHostRoutingFilter 往指定的地址路由</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SimpleHostRoutingFilter 往指定的地址跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/ServiceB/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">http://localhost:9090/ServiceB</span></span><br><span class="line"><span class="comment"># 这是配置连接到目标主机的最大http连接数，是用来配置http连接池的，默认是200</span></span><br><span class="line"><span class="meta">zuul.host.maxTotalConnections</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 就是每个主机的初始连接数，默认是20</span></span><br><span class="line"><span class="meta">zuul.host.maxPerRouteConnections</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure><h3 id="跳转路由"><a href="#跳转路由" class="headerlink" title="跳转路由"></a>跳转路由</h3><p>SendForwardFilter 往自己的接口跳转</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SendForwardFilter 往自己的接口跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">forward: /gateway/sayHello</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon路由"><a href="#Ribbon路由" class="headerlink" title="Ribbon路由"></a>Ribbon路由</h3><p>RibbonRoutingFilter 基于Ribbon的服务路由</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RibbonRoutingFilter</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.serviceId</span>=<span class="string">ServiceB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h3><p>请求：test/**的路径，转发给zuul-test-service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRouteRuleConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">patternServiceRouteMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(<span class="string">&quot;(zuul)-(?&lt;test&gt;.+)-(service)&quot;</span>, <span class="string">&quot;$&#123;test&#125;/**&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="忽略路由"><a href="#忽略路由" class="headerlink" title="忽略路由"></a>忽略路由</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.ignoredPatterns</span>=<span class="string">/ServiceB/test</span></span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="请求头配置"><a href="#请求头配置" class="headerlink" title="请求头配置"></a>请求头配置</h3><p>默认情况下，zuul有些敏感的请求头不会转发给下游的服务，比如：Cookie、Set-Cookie、Authorization，也可以自己配置敏感请求头</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.sensitiveHeaders</span>=<span class="string">accept-language, cookie</span></span><br><span class="line"><span class="meta">zuul.routes.demo.sensitiveHeaders</span>=<span class="string">cookie</span></span><br></pre></td></tr></table></figure><h3 id="路由映射信息"><a href="#路由映射信息" class="headerlink" title="路由映射信息"></a>路由映射信息</h3><p>在Zuul项目中，引入actuator依赖，然后在配置文件中，将<code>management.security.enabled</code>设置为false，就可以访问<code>/actuator/routes</code>地址，然后可以看到路由的映射信息</p><h3 id="hystrix配置"><a href="#hystrix配置" class="headerlink" title="hystrix配置"></a>hystrix配置</h3><p>与Ribbon整合的时候，会使用Hystrix，可以在网关写统一的降级实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBFallbackProvider</span> <span class="keyword">implements</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 服务名，一般都设置全局的降级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;fallback&quot;</span>.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(MediaType.TEXT_PLAIN);</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ZuulFallbackProvider <span class="title">fallbackProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceBFallbackProvider();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ribbon客户端预加载"><a href="#ribbon客户端预加载" class="headerlink" title="ribbon客户端预加载"></a>ribbon客户端预加载</h3><p>默认情况下，第一次请求zuul才会初始化ribbon客户端，所以可以配置预加载</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.ribbon.eager-load.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><p>Zuul用的是ribbon+Hystrix，所以设置超时得考虑这2个组件的配置，而且hystrix的超时要考虑ribbon的重试次数和单次超时时间。</p><p>hystrix的超时时间计算公式如下：</p><p>(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ribbon.ReadTimeout</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">ribbon.ConnectTimeout</span>=<span class="string">500</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetries</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetriesNextServer</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>如果不配置ribbon的超时时间，默认的hystrix超时时间是4000ms</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否要执行过滤器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">publici Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行过滤器&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在哪个阶段执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FilterConstants.ROUTE_TYPE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是过滤器的优先级</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyFilter <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="groovy动态加载过滤器"><a href="#groovy动态加载过滤器" class="headerlink" title="groovy动态加载过滤器"></a>groovy动态加载过滤器</h3><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.groovy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加代码配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zuulInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterLoader.getInstance().setCompiler(<span class="keyword">new</span> GroovyCompiler());</span><br><span class="line">    String scriptRoot = System.getProperty(<span class="string">&quot;zuul.filter.root&quot;</span>, <span class="string">&quot;groovy/filters&quot;</span>);</span><br><span class="line">    String refreshInterval = System.getProperty(<span class="string">&quot;zuul.filter.refreshInterval&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(scriptRoot.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        scriptRoot = scriptRoot + File.separator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FilterFileManager.setFilenameFilter(<span class="keyword">new</span> GroovyFileFilter());</span><br><span class="line">        FilterFileManager.init(Integer.parseInt(refreshInterval), scriptRoot + <span class="string">&quot;pre&quot;</span>, scriptRoot + <span class="string">&quot;route&quot;</span>, scriptRoot + <span class="string">&quot;post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.filter.root</span>=<span class="string">groovy/filters</span></span><br><span class="line"><span class="meta">zuul.filter.refreshInterval</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure><p>然后将groovy编写的过滤器，放在<code>groovy/filters</code>文件夹下，几秒后就会生效。</p><h3 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.SendForwardFilter.route.disable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="EnableZuulServer"><a href="#EnableZuulServer" class="headerlink" title="@EnableZuulServer"></a>@EnableZuulServer</h3><p>会自动禁用掉PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter等过滤器</p><h3 id="error过滤器-1"><a href="#error过滤器-1" class="headerlink" title="error过滤器"></a>error过滤器</h3><p>在自定义的过滤器有异常可以抛一个ZuulException，然后写一个MyErrorController，继承BasicErrorController，统一处理异常。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么微服务需要网关&quot;&gt;&lt;a href=&quot;#为什么微服务需要网关&quot; class=&quot;headerlink&quot; title=&quot;为什么微服务需要网关&quot;&gt;&lt;/a&gt;为什么微服务需要网关&lt;/h1&gt;&lt;p&gt;在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中聚合数据，而且服务的划分位置结构可能会有所改变。网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="zuul" scheme="http://www.saily.top/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>HystrixCommand执行源码分析</title>
    <link href="http://www.saily.top/2020/05/09/springcloud/hystrix06/"/>
    <id>http://www.saily.top/2020/05/09/springcloud/hystrix06/</id>
    <published>2020-05-09T13:03:59.000Z</published>
    <updated>2020-05-10T14:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HystrixCommand-execute源码细节"><a href="#HystrixCommand-execute源码细节" class="headerlink" title="HystrixCommand.execute源码细节"></a>HystrixCommand.execute源码细节</h1><p>HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Future returned by Observable.toBlocking().toFuture() does not implement the</span></span><br><span class="line"><span class="comment"> * interruption of the execution thread when the &quot;mayInterrupt&quot; flag of Future.cancel(boolean) is set to true;</span></span><br><span class="line"><span class="comment"> * thus, to comply with the contract of Future, we must wrap around it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</span><br></pre></td></tr></table></figure><p>toObservable().toBlocking().toFuture();这行代码已经把command扔到线程池里去执行了，并且拿到了一个Future对象，没有办法在异常情况下终止Future对象对应的线程的执行，所以要对Future做一个包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>然后接下来就是对delegate做了包装，实现了一下cancel等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.get();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure><p>f.isDone()，通过future判断对应的那个线程是否完成了command的执行，然后调用f.get()会阻塞住，获取到Thread执行command返回的结果。</p><p>那我们就发现，在调用queue()方法后，就会通过线程池去执行command，然后在queue()方法中，会等待线程执行结束，如果线程执行结束了，就会返回future；即使执行失败了，也会根据情况，返回future，要不就是抛异常。</p><p>下面，我们接着分析<code>toObservable().toBlocking().toFuture();</code>核心逻辑，它实现了Hystrix几乎所有的核心逻辑，包括请求缓存、熔断、队列+线程池、线程异步执行、超时检测、异常处理、异常统计、熔断开关等。</p><h2 id="toObservable"><a href="#toObservable" class="headerlink" title="toObservable()"></a>toObservable()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Used <span class="keyword">for</span> asynchronous execution of command with a callback by subscribing to the &#123;<span class="meta">@link</span> Observable&#125;.</span><br></pre></td></tr></table></figure><p>获取到Observable后，Command还没有立即开始执行，只是将Command封装到了Observable对象。如果订阅了Observable对象，提供了回调接口，才会触发执行，并根据Command执行结果回调提供的接口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An eager &#123;@link Observable&#125; can be obtained from &#123;@link #observe()&#125;.</span><br></pre></td></tr></table></figure><p>如果希望获取到Observable对象就立即执行内部的Command的话，就不要调用toObservable()方法，可以去调用observe()方法</p><p>声明了一堆匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态是OBSERVABLE_CHAIN_CREATED</span></span><br><span class="line">        <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成false，并且用户的代码没有被执行过（HystrixCommand.run）</span></span><br><span class="line">            handleCommandEnd(<span class="keyword">false</span>); <span class="comment">//user code never ran</span></span><br><span class="line">          <span class="comment">// 如果状态是USER_CODE_EXECUTED</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成true，并且用户的代码已经运行过了（HystrixCommand.run）</span></span><br><span class="line">          handleCommandEnd(<span class="keyword">true</span>); <span class="comment">//user code did run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unsubscribeCommandCleanup</p><p>applyHystrixSemantics</p><p>wrapWithAllOnNextHooks</p><p>fireOnCompletedHook</p><p>然后基于上面的这些回调，去创建了Observable对象，因为创建Observable对象后，并不会被立马执行，所以在调用toBlocking()方法之后，才会触发执行call方法，再依次去执行上面的5个回调方法。因为Observable是rxjava的代码，所以toBlocking()的源码这里就不再跟进去看了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="comment">// 调用toBlocking方法后就会触发执行这里的代码了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个Command命令只能被执行一次，所以Command对象每次都是new</span></span><br><span class="line">        <span class="comment">// 刚开始状态是NOT_STARTED</span></span><br><span class="line">         <span class="comment">/* this is a stateful object so can only be used once */</span></span><br><span class="line">        <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</span><br><span class="line">            IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This instance can only be executed once. Please instantiate a new instance.&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO make a new error type for this</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">&quot; command executed multiple times - this is not permitted.&quot;</span>, ex, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 命令开始的时间戳</span></span><br><span class="line">        commandStartTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日志</span></span><br><span class="line">        <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</span><br><span class="line">            <span class="comment">// log this command execution regardless of what happened</span></span><br><span class="line">            <span class="comment">// 请求日志</span></span><br><span class="line">            <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentRequestLog.addExecutedCommand(_cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</span><br><span class="line">        <span class="keyword">final</span> String cacheKey = getCacheKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存RequestCache</span></span><br><span class="line">        <span class="comment">/* try from cache first */</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用回调创建了Observable对象</span></span><br><span class="line">        Observable&lt;R&gt; hystrixObservable =</span><br><span class="line">                Observable.defer(applyHystrixSemantics)</span><br><span class="line">                        .map(wrapWithAllOnNextHooks);</span><br><span class="line"></span><br><span class="line">        Observable&lt;R&gt; afterCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Request cache</span></span><br><span class="line">        <span class="comment">// put in cache</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// wrap it for caching</span></span><br><span class="line">            HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// another thread beat us so we&#x27;ll use the cached value instead</span></span><br><span class="line">                toCache.unsubscribe();</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we just created an ObservableCommand so we cast and return it</span></span><br><span class="line">                afterCache = toCache.toObservable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            afterCache = hystrixObservable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> afterCache</span><br><span class="line">                .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></span><br><span class="line">                .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></span><br><span class="line">                .doOnCompleted(fireOnCompletedHook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>刚开始命令的状态是NOT_STARTED，设置为OBSERVABLE_CHAIN_CREATED</li><li>记录请求日志（默认启用，但是不处理）</li><li>从缓存读取（默认没有启用缓存）</li><li>得到Observable对象，将5个回调设置到对应doOnCompleted、doOnUnsubscribe等的方法里</li></ol><p>那实际上真正执行Command的代码，是在applyHystrixSemantics的回调里</p><h2 id="applyHystrixSemantics"><a href="#applyHystrixSemantics" class="headerlink" title="applyHystrixSemantics"></a>applyHystrixSemantics</h2><ol><li>applyHystrixSemantics.call()调用applyHystrixSemantics方法 </li><li>判断断路器是否打开</li><li>拿到一个信号量</li><li>执行executeCommandAndObserve</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mark that we&#x27;re starting execution on the ExecutionHook</span></span><br><span class="line">    <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></span><br><span class="line">    <span class="comment">// 这个类是ExecutionHookDeprecationWrapper，是内部类</span></span><br><span class="line">    executionHook.onStart(_cmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断路器是否打开，打开的话直接走降级逻辑</span></span><br><span class="line">    <span class="comment">/* determine if we&#x27;re allowed to execute */</span></span><br><span class="line">    <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</span><br><span class="line">        <span class="comment">// 这里会拿到信号量，如果不是使用SEMAPHORE的话，这里拿到的是一个什么都不干的TryableSemaphoreNoOp.DEFAULT</span></span><br><span class="line">        <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    executionSemaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* used to track userThreadExecutionTime */</span></span><br><span class="line">                executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br><span class="line">                <span class="comment">// 核心逻辑在executeCommandAndObserve里</span></span><br><span class="line">                <span class="keyword">return</span> executeCommandAndObserve(_cmd)</span><br><span class="line">                        .doOnError(markExceptionThrown)</span><br><span class="line">                        .doOnTerminate(singleSemaphoreRelease)</span><br><span class="line">                        .doOnUnsubscribe(singleSemaphoreRelease);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleShortCircuitViaFallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the TryableSemaphore this HystrixCommand should use for execution if not running in a separate thread.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> TryableSemaphore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果不是信号量的话，返回TryableSemaphoreNoOp.DEFAULT，啥也不干</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用SEMAPHORE</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// we didn&#x27;t find one cache so setup</span></span><br><span class="line">                executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</span><br><span class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></span><br><span class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> _s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return NoOp implementation since we&#x27;re not using SEMAPHORE isolation</span></span><br><span class="line">        <span class="comment">// 不用SEMAPHORE</span></span><br><span class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executeCommandAndObserve"><a href="#executeCommandAndObserve" class="headerlink" title="executeCommandAndObserve"></a>executeCommandAndObserve</h2><p>executeCommandAndObserve代码，又是一堆回调，先把回调记录下来</p><ol><li>markEmits</li><li>markOnCompleted</li><li>handleFallback</li><li>setRequestContext</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This decorates &quot;Hystrix&quot; functionality around the run() Observable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> R</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandAndObserve</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;R&gt; markEmits = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</span><br><span class="line">                executionResult = executionResult.addEvent(HystrixEventType.EMIT);</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action0 markOnCompleted = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            circuitBreaker.markNonSuccess();</span><br><span class="line">            Exception e = getExceptionFromThrowable(t);</span><br><span class="line">            executionResult = executionResult.setExecutionException(e);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                    eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</span><br><span class="line">            setRequestContextIfNeeded(currentRequestContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Observable&lt;R&gt; execution;</span><br><span class="line">    <span class="comment">// 是否开启超时，用线程池隔离去执行</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionTimeoutEnabled().get()) &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd)</span><br><span class="line">                .lift(<span class="keyword">new</span> HystrixObservableTimeoutOperator&lt;R&gt;(_cmd));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execution.doOnNext(markEmits)</span><br><span class="line">            .doOnCompleted(markOnCompleted)</span><br><span class="line">            .onErrorResumeNext(handleFallback)</span><br><span class="line">            .doOnEach(setRequestContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executeCommandWithSpecifiedIsolation"><a href="#executeCommandWithSpecifiedIsolation" class="headerlink" title="executeCommandWithSpecifiedIsolation"></a>executeCommandWithSpecifiedIsolation</h2><p>继续往executeCommandWithSpecifiedIsolation方法里跟，到这里，就发现了他会判断你如果隔离策略是Thread，执行线程池相关逻辑，如果是信号量，执行信号量相关逻辑。</p><p>我们在这个代码里，去找一下跟线程池有关的代码到底在哪里，肯定是有一个队列+线程池。</p><ol><li>默认是线程隔离</li><li>命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是就报错</li><li>记录监控数据，命令开始</li><li>判断是否已经超时了（在执行run方法之前，就已经超时）</li><li>调用startCurrentThreadExecutingCommand方法，将要执行的一个命令，压入一个栈中</li><li>调用getUserExecutionObservable方法，在这个方法里，最终会去执行run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandWithSpecifiedIsolation</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认就是线程隔离的</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;</span><br><span class="line">        <span class="comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span></span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="comment">// 命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是花就报错</span></span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 监控</span></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;</span><br><span class="line">                    <span class="comment">// the command timed out in the wrapping thread so we will return immediately</span></span><br><span class="line">                    <span class="comment">// and not increment any of the counters below or other such logic</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;timed out before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断线程的状态，从NOT_USING_THREAD，切换到STARTED</span></span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;</span><br><span class="line">                    <span class="comment">//we have not been unsubscribed, so should proceed</span></span><br><span class="line">                    HystrixCounters.incrementGlobalConcurrentThreads();</span><br><span class="line">                    threadPool.markThreadExecution();</span><br><span class="line">                    <span class="comment">// store the command that is being run</span></span><br><span class="line">                    <span class="comment">// 将要执行的一个命令，压入一个栈中</span></span><br><span class="line">                    endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                    executionResult = executionResult.setExecutedInThread();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这几行代码也没干啥</span></span><br><span class="line">                        executionHook.onThreadStart(_cmd);</span><br><span class="line">                        executionHook.onRunStart(_cmd);</span><br><span class="line">                        executionHook.onExecutionStart(_cmd);</span><br><span class="line">                        <span class="comment">// run方法最终执行的地方</span></span><br><span class="line">                        <span class="keyword">return</span> getUserExecutionObservable(_cmd);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//command has already been unsubscribed, so return immediately</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;unsubscribed before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnTerminate(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and received terminal, then no need to clean up (I don&#x27;t think this is possible)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was unsubscribed, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and was cancelled, then no need to clean up</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was terminal, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</span><br><span class="line">                <span class="comment">// semaphore isolated</span></span><br><span class="line">                <span class="comment">// store the command that is being run</span></span><br><span class="line">                endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executionHook.onRunStart(_cmd);</span><br><span class="line">                    executionHook.onExecutionStart(_cmd);</span><br><span class="line">                    <span class="keyword">return</span> getUserExecutionObservable(_cmd);  <span class="comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn&#x27;t throw</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//If the above hooks throw, then use that as the result of the run method</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getUserExecutionObservable"><a href="#getUserExecutionObservable" class="headerlink" title="getUserExecutionObservable"></a>getUserExecutionObservable</h2><p>看到这里后，run方法就已经执行了，但是回过头想一下，这个Hystrix是基于队列和线程池去执行的，那怎么没看见跟线程池有关的代码呢在哪呢，前面一个又一个的Observable，互相触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getUserExecutionObservable</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    Observable&lt;R&gt; userObservable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这行代码里的Func0.call()会执行HystrixCommand的run方法</span></span><br><span class="line">        userObservable = getExecutionObservable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// the run() method is a user provided implementation so can throw instead of using Observable.onError</span></span><br><span class="line">        <span class="comment">// so we catch it here and turn it into Observable.error</span></span><br><span class="line">        userObservable = Observable.error(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userObservable</span><br><span class="line">            .lift(<span class="keyword">new</span> ExecutionHookApplication(_cmd))</span><br><span class="line">            .lift(<span class="keyword">new</span> DeprecatedOnRunHookApplication(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里就是执行HystrixCommand的run方法了</span></span><br><span class="line">                <span class="keyword">return</span> Observable.just(run());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span></span><br><span class="line">            executionThread.set(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那从代码执行的层面没有找到，我们去找一下，threadPool这个变量，是在什么时候被使用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</span><br></pre></td></tr></table></figure><h1 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h1><p>在AbstractCommand的构造方法中，就有一行初始化线程池的代码initThreadPool，这就会根据threadPoolKey去创建对应的线程池，线程池的相关参数来自于HystrixThreadPoolProperties.Setter，维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池。</p><p>可配置的属性：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hystrix.threadpool.ServiceA.allowMaximumSizeToDivergeFromCoreSize</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.keepAliveTimeMinutes</span> = <span class="string">1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maximumSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.coreSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maxQueueSize</span> = <span class="string">-1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.queueSizeRejectionThreshold</span> = <span class="string">5</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.numBuckets</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.timeInMilliseconds</span> = <span class="string">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixThreadPool <span class="title">initThreadPool</span><span class="params">(HystrixThreadPool fromConstructor, HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get the default implementation of HystrixThreadPool</span></span><br><span class="line">        <span class="keyword">return</span> HystrixThreadPool.Factory.getInstance(threadPoolKey, threadPoolPropertiesDefaults);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromConstructor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="comment">// 维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池</span></span><br><span class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> HystrixThreadPool <span class="title">getInstance</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work</span></span><br><span class="line">    String key = threadPoolKey.name();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should find it for all but the first time</span></span><br><span class="line">    HystrixThreadPool previouslyCached = threadPools.get(key);</span><br><span class="line">    <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> previouslyCached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we get here this is the first time so we need to initialize</span></span><br><span class="line">    <span class="keyword">synchronized</span> (HystrixThreadPool.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!threadPools.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 创建线程池</span></span><br><span class="line">            threadPools.put(key, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadPools.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolDefault</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);</span><br><span class="line">    HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">this</span>.queueSize = properties.maxQueueSize().get();</span><br><span class="line"><span class="comment">// 用这个线程池</span></span><br><span class="line">    <span class="keyword">this</span>.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,</span><br><span class="line">            concurrencyStrategy.getThreadPool(threadPoolKey, properties),</span><br><span class="line">            properties);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.metrics.getThreadPool();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">this</span>.threadPool.getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* strategy: HystrixMetricsPublisherThreadPool */</span></span><br><span class="line">    HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, <span class="keyword">this</span>.metrics, <span class="keyword">this</span>.properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池初始化的参数，线程池大小的设置"><a href="#线程池初始化的参数，线程池大小的设置" class="headerlink" title="线程池初始化的参数，线程池大小的设置"></a>线程池初始化的参数，线程池大小的设置</h2><p>仔细看一下线程池构造的代码：</p><ol><li>构建了一个 ThreadFactory，这个就是为了给线程起名字，Hystrix开头的名字</li><li>hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队，如果满了就reject了。否则就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去queue排队，如果queue也满了，就会增加core-size到maximumSize，还不够就reject掉了。</li><li>默认配置：线程池：10，不可动态增加线程（hystrix.threadpool.ServiceA.maximumSize无效），queue：SynchronousQueue，不支持排队。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(<span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadFactory这个就是为了给线程起名字，Hystrix开头的名字</span></span><br><span class="line">    <span class="keyword">final</span> ThreadFactory threadFactory = getThreadFactory(threadPoolKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dynamicCoreSize = threadPoolProperties.coreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxQueueSize = threadPoolProperties.maxQueueSize().get();</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = getBlockingQueue(maxQueueSize);</span><br><span class="line">  <span class="comment">// 默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (allowMaximumSizeToDivergeFromCoreSize) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dynamicMaximumSize = threadPoolProperties.maximumSize().get();</span><br><span class="line">        <span class="keyword">if</span> (dynamicCoreSize &gt; dynamicMaximumSize) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Hystrix ThreadPool configuration at startup for : &quot;</span> + threadPoolKey.name() + <span class="string">&quot; is trying to set coreSize = &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot; and maximumSize = &quot;</span> + dynamicMaximumSize + <span class="string">&quot;.  Maximum size will be set to &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot;, the coreSize value, since it must be equal to or greater than the coreSize value&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到线程池队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are using SynchronousQueue if maxQueueSize &lt;= 0 (meaning a queue is not wanted).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * SynchronousQueue will do a handoff from calling thread to worker thread and not allow queuing which is what we want.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Queuing results in added latency and would only occur when the thread-pool is full at which point there are latency issues</span></span><br><span class="line"><span class="comment">     * and rejecting is the preferred solution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队</span></span><br><span class="line">    <span class="keyword">if</span> (maxQueueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去排队，如果排队的也满了，就会增加core-size到maximumSize，还不够就拒绝掉了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxQueueSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HystrixThreadPool-getScheduler"><a href="#HystrixThreadPool-getScheduler" class="headerlink" title="HystrixThreadPool.getScheduler"></a>HystrixThreadPool.getScheduler</h2><p>线程池初始化后，回到之前<a href="#executeCommandWithSpecifiedIsolation">executeCommandWithSpecifiedIsolation</a>的代码里，他的subscribeOn方法，在订阅Observable的时候，调用了HystrixThreadPool.getScheduler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line">.subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这就搞了个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">(Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了允许动态调整线程池大家，就修改配置</span></span><br><span class="line">    touchConfig();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), <span class="keyword">this</span>, shouldInterruptThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就到了内部类HystrixContextSchedulerWorker里，看他的schedule方法</p><h2 id="线程池执行，以及判断线程池是否满了"><a href="#线程池执行，以及判断线程池是否满了" class="headerlink" title="线程池执行，以及判断线程池是否满了"></a>线程池执行，以及判断线程池是否满了</h2><p>假设core-size=10，queueSizeRejectionThreshold=5</p><p>首先会将任务不断的给线程池，让线程池来处理，如果10个线程都满了，此时就会进入队列来排队。如果此时队列排队的请求是3个，那么3&lt;5，还可以继续发送请求，进行排队。当队列数量达到5个以后，也会抛出RejectedExecutionException异常。</p><ol><li>如果queueSize小于0，则表示没有队列</li><li>如果当前队列小于queueSizeRejectionThreshold，表示还有空间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否还有空间，没有就拒绝了</span></span><br><span class="line">        <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Rejected command because thread-pool queueSize is at rejection threshold.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action), delayTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// we don&#x27;t have a queue so we won&#x27;t look for space but instead</span></span><br><span class="line">        <span class="comment">// let the thread-pool reject or not</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</p><p>最后在<code>ThreadPoolWorker</code>中，找到了提交到线程的代码逻辑，Action0就是HystrixContexSchedulerAction。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscription.isUnsubscribed()) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is internal RxJava API but it is too useful.</span></span><br><span class="line">    ScheduledAction sa = <span class="keyword">new</span> ScheduledAction(action);</span><br><span class="line"></span><br><span class="line">    subscription.add(sa);</span><br><span class="line">    sa.addParent(subscription);</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();</span><br><span class="line">    FutureTask&lt;?&gt; f = (FutureTask&lt;?&gt;) executor.submit(sa);</span><br><span class="line">    sa.add(<span class="keyword">new</span> FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，Hystrix基于线程池的基本执行逻辑一句分析完成，画个图总结一下</p><p><img src="/img/spring-cloud/Hystrix%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="Hystrix执行原理图"></p><h1 id="超时监测"><a href="#超时监测" class="headerlink" title="超时监测"></a>超时监测</h1><p>Hystrix超时计算的代码在HystrixObservableTimeoutOperator里，里面就有一个用于计算超时的监听器，如果在命令超时了，命令的状态还是NOT_EXECUTED，就将状态设置成TIMED_OUT，并抛出一个HystrixTimeoutException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TimerListener listener = <span class="keyword">new</span> TimerListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath</span></span><br><span class="line">        <span class="comment">// otherwise it means we lost a race and the run() execution completed or did not start</span></span><br><span class="line">        <span class="keyword">if</span> (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) &#123;</span><br><span class="line">            <span class="comment">// report timeout failure</span></span><br><span class="line">            originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shut down the original request</span></span><br><span class="line">            s.unsubscribe();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> HystrixContextRunnable timeoutRunnable = <span class="keyword">new</span> HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    child.onError(<span class="keyword">new</span> HystrixTimeoutException());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            timeoutRunnable.run();</span><br><span class="line">            <span class="comment">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntervalTimeInMilliseconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalCommand.properties.executionTimeoutInMilliseconds().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将这个监听器放到了HystrixTimer里，在这里判断超时的时候回调</span></span><br><span class="line"><span class="keyword">final</span> Reference&lt;TimerListener&gt; tl = HystrixTimer.getInstance().addTimerListener(listener);</span><br><span class="line"><span class="comment">// 放回到Command中</span></span><br><span class="line">originalCommand.timeoutTimer.set(tl);</span><br></pre></td></tr></table></figure><p>创建线程，并按照时间执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addTimerListener</span><span class="params">(<span class="keyword">final</span> TimerListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化了HystrixTimer线程池，大小是4</span></span><br><span class="line">    startThreadIfNeeded();</span><br><span class="line">    <span class="comment">// add the listener</span></span><br><span class="line"></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.tick();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed while ticking TimerListener&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 利用前面初始化的线程池，每隔1秒钟执行一次r（也就是TimerListener)，这个时间就是Command设置的超时是时间</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TimerReference(listener, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令执行完成以后，HystrixCommand的isCommandTimedOut的状态就会变成COMPLETED，所以在定时调度的时候不会进入判断条件。同时在任务处理完成也会清理掉定时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotTimedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED</span></span><br><span class="line">    <span class="keyword">return</span> originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||</span><br><span class="line">            originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommandEnd</span><span class="params">(<span class="keyword">boolean</span> commandExecutionStarted)</span> </span>&#123;</span><br><span class="line">    Reference&lt;TimerListener&gt; tl = timeoutTimer.get();</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tl.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/Hystrix%E8%B6%85%E6%97%B6%E5%8E%9F%E7%90%86.jpg" alt="Hystrix超时原理"></p><p>然后超时的降级，下面的文章再看。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>超时、命令执行过程中，线程满了，都会抛出异常，那Hystrix在这种情况下都会执行降级逻辑，我们去找一下处理这些异常，然后执行降级逻辑的代码在哪里。其实就在<a href="#executeCommandAndObserve">executeCommandAndObserve</a>方法中的<code>handleFallback</code></p><p>在这里就发现，所有的异常都是handleFallback处理的，其实就是拒绝、超时、失败，都会执行降级逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        circuitBreaker.markNonSuccess();</span><br><span class="line">        Exception e = getExceptionFromThrowable(t);</span><br><span class="line">        executionResult = executionResult.setExecutionException(e);</span><br><span class="line">        <span class="comment">// 拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">          <span class="comment">// 超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">          <span class="comment">// 失败</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>这些就是fallback的处理，最终会调用getFallbackOrThrowException，然后执行用户定义的fallback方法</p><p>handleSemaphoreRejectionViaFallback<br>handleShortCircuitViaFallback<br>handleThreadPoolRejectionViaFallback<br>handleTimeoutViaFallback<br>handleFailureViaFallback</p><h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p>在多次异常降级后，熔断器就会打开了，接着就分析一下熔断器是如何打开的</p><p>先去看初始化的代码，在HystrixCommand构造方法中，会初始化熔断器</p><ol><li>一个Command Key就对应了一个熔断器</li><li>在初始化HystrixCircuitBreakerImpl的时候，会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</li><li>在最近的一个时间窗口以内（10s），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</li><li>反之，如果totalRequests（总请求数量）&gt;= circuitBreakerRequestVolumeThreshold（默认是20），就会进入下一步的尝试</li><li>如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</li><li>反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">initCircuitBreaker</span><span class="params">(<span class="keyword">boolean</span> enabled, HystrixCircuitBreaker fromConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandGroupKey groupKey, HystrixCommandKey commandKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// get the default implementation of HystrixCircuitBreaker</span></span><br><span class="line">            <span class="comment">// 拿的是HystrixCircuitBreakerImpl</span></span><br><span class="line">            <span class="keyword">return</span> HystrixCircuitBreaker.Factory.getInstance(commandKey, groupKey, properties, metrics);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fromConstructor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NoOpCircuitBreaker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCircuitBreakerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, <span class="keyword">final</span> HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//On a timer, this will set the circuit between OPEN/CLOSED as command executions occur</span></span><br><span class="line">    <span class="comment">// 会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</span></span><br><span class="line">    Subscription s = subscribeToStream();</span><br><span class="line">    activeSubscription.set(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Subscription <span class="title">subscribeToStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This stream will recalculate the OPEN/CLOSED status on every onNext from the health stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> metrics.getHealthCountsStream()</span><br><span class="line">            .observe()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Subscriber&lt;HealthCounts&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最近10秒钟的统计信息</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(HealthCounts hc)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 在最近的一个时间窗口以内（10秒），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</span></span><br><span class="line">                    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">                    <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                        <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></span><br><span class="line">                        <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                        <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                        <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                        <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 进入下一步的尝试</span></span><br><span class="line">                        <span class="comment">// 如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</span></span><br><span class="line">                        <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                            <span class="comment">//we are not past the minimum error threshold for the stat window,</span></span><br><span class="line">                            <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                            <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                            <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                            <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> </span><br><span class="line">                            <span class="comment">// 反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</span></span><br><span class="line">                            <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></span><br><span class="line">                            <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</span><br><span class="line">                                circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="熔断器打开后，请求直接降级"><a href="#熔断器打开后，请求直接降级" class="headerlink" title="熔断器打开后，请求直接降级"></a>熔断器打开后，请求直接降级</h2><p>就是在在<a href="#applyHystrixSemantics">applyHystrixSemantics</a>这里的代码，就会先判断人熔断器的状态，如果熔断器打开了，就直接走降级逻辑了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -1 就是可以执行请求，断路器没有打开</span></span><br><span class="line">    <span class="keyword">if</span> (circuitOpened.get() == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAfterSleepWindow()) &#123;</span><br><span class="line">            <span class="comment">// 状态搞为半打开，让一个请求执行试一下</span></span><br><span class="line">            <span class="comment">// 如果失败了，那么还是OPEN，handleFallback -&gt; circuitBreaker.markNonSuccess();同时会更新熔断的时间戳</span></span><br><span class="line">            <span class="comment">// 如果请求成功，markEmits/markOnCompleted,circuitBreaker.markSuccess(),关闭熔断器。会变成CLOSED</span></span><br><span class="line">            <span class="keyword">if</span> (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) &#123;</span><br><span class="line">                <span class="comment">//only the first request after sleep window should execute</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过了一个circuitBreakerSleepWindowInMilliseconds时间以后，这个时间默认是5秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAfterSleepWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> circuitOpenTime = circuitOpened.get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> sleepWindowTime = properties.circuitBreakerSleepWindowInMilliseconds().get();</span><br><span class="line">    <span class="keyword">return</span> currentTime &gt; circuitOpenTime + sleepWindowTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to close the circuit - it resets the stream to start it over from 0</span></span><br><span class="line">        metrics.resetStream();</span><br><span class="line">        Subscription previousSubscription = activeSubscription.get();</span><br><span class="line">        <span class="keyword">if</span> (previousSubscription != <span class="keyword">null</span>) &#123;</span><br><span class="line">            previousSubscription.unsubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        Subscription newSubscription = subscribeToStream();</span><br><span class="line">        activeSubscription.set(newSubscription);</span><br><span class="line">        circuitOpened.set(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markNonSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.OPEN)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to re-open the circuit - it resets the start time for the sleep window</span></span><br><span class="line">        circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/Hystrix%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86-9119853.jpg" alt="Hystrix熔断器的中断原理"></p><h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><p><a href="#toObservable">toObservable</a> 方法里包含了请求缓存的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* try from cache first */</span></span><br><span class="line"><span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">    HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HystrixCommand-execute源码细节&quot;&gt;&lt;a href=&quot;#HystrixCommand-execute源码细节&quot; class=&quot;headerlink&quot; title=&quot;HystrixCommand.execute源码细节&quot;&gt;&lt;/a&gt;HystrixCommand.execute源码细节&lt;/h1&gt;&lt;p&gt;HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// HystrixCommand.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; R &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue().get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; Exceptions.sneakyThrow(decomposeException(e));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件的各种MaxTotalConnections详解</title>
    <link href="http://www.saily.top/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.saily.top/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-29T14:05:39.000Z</published>
    <updated>2020-04-29T10:19:17.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在zuul网关中，有关于配置连接数量的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">max-per-route-connections:</span> <span class="number">20</span> <span class="comment">#默认值</span></span><br><span class="line">    <span class="attr">max-total-connections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><p>这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。</p><p>这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">MaxConnectionsPerHost:</span> <span class="number">50</span> <span class="comment">#默认值</span></span><br><span class="line">  <span class="attr">MaxTotalConnections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>还有Feign的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 默认值 </span></span><br><span class="line">      <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 默认值</span></span><br></pre></td></tr></table></figure><p>那么问题来了，在服务中既有Feign，又有Ribbon，那如果都配置了，是用哪一个配置？仔细的分析了一下，情况还比较复杂。</p><h1 id="zuul-host-max-per-route-connections"><a href="#zuul-host-max-per-route-connections" class="headerlink" title="zuul.host.max-per-route-connections"></a>zuul.host.max-per-route-connections</h1><p>刚才说这个配置和基于RIbbon调用服务没有什么关系，放个证据看一下，SimpleHostRoutingFilter是用于静态路由的具体请求处理类，这里面的初始化代码就是读取这个参数，并进行连接池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHostRoutingFilter.java</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!customHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.connectionManager = connectionManagerFactory.newConnectionManager(</span><br><span class="line">            !<span class="keyword">this</span>.sslHostnameValidationEnabled,</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxTotalConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxPerRouteConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getTimeToLive(), <span class="keyword">this</span>.hostProperties.getTimeUnit(),</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">this</span>.httpClient = newClient();</span><br><span class="line">      <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager.closeExpiredConnections();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="number">30000</span>, <span class="number">5000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="服务里的Ribbon"><a href="#服务里的Ribbon" class="headerlink" title="服务里的Ribbon"></a>服务里的Ribbon</h2><p>先说在服务里只有Ribbon，并没有引入Feign的情况下，用RestTemplate发送请求，底层是通过SimpleBufferingClientHttpRequest发起实际http请求，用的是JDK原生的http。</p><p>所以在什么都不配置的情况下，上面的<code>ribbon.MaxConnectionsPerHost</code>配置是没有用的，而且我从这个源码看下来，像那些重试参数什么的，应该都没有用。他仅仅只是给RestTemplate赋予了负载均衡的功能，其他什么都没有控制。</p><p>在<code>RibbonClientConfiguration</code>类中，还额外Import了几个关于HttpClient的类，但是在默认情况下，都没什么用。</p><p>所以其实在服务里边，什么<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>，配置了以后，他只会去注册这些bean，不会被用到。自己搞的那个RestTemplate，用的就是spring默认的JDK 原生http组件。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于RestTemplate的方式使用Ribbon，在yaml里的大多数配置都不会生效，也没什么用。</p><h2 id="网关里的Ribbon"><a href="#网关里的Ribbon" class="headerlink" title="网关里的Ribbon"></a>网关里的Ribbon</h2><p>在网关里面，大有不同，我们先看ZuulProxyAutoConfiguration配置类，他引入了几个跟http组件有关的配置类，在这里<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>就能直接起作用了，他决定了加载哪一个具体的配置。在没有okhttpclient的情况下，默认就是使用apache的httpcomponents。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZuulProxyAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      HttpClientConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonCommandFactoryConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnRibbonHttpClient</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;ZuulFallbackProvider&gt; zuulFallbackProviders = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> RibbonCommandFactory&lt;?&gt; ribbonCommandFactory(</span><br><span class="line">      SpringClientFactory clientFactory, ZuulProperties zuulProperties) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommandFactory(clientFactory, zuulProperties, zuulFallbackProviders);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClientRibbonCommandFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">  ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line">  <span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">  <span class="comment">//  最终还是从ribbon管理的上下文中获取到一个RibbonLoadBalancingHttpClient。注意，SpringClientFactory里的bean基本都来自于RibbonClientConfiguration，看过Ribbon的源码就知道</span></span><br><span class="line">  <span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">      serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">  client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">      clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，Ribbon本身也会对<code>RibbonClientConfiguration</code>配置类也进行初始化，一样的，他也引入了几个Http组件，和上面不同的是，zuul的几个配置类，主要是为了封装Hystrix的逻辑，实际上最终还是调用的<code>RibbonLoadBalancingHttpClient</code>执行请求。所以我们接下来去看<code>RibbonClientConfiguration</code>的配置，以及<code>RibbonLoadBalancingHttpClient</code>是如何被注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各种http组件支持，默认是加载最后一个</span></span><br><span class="line"><span class="meta">@Import(&#123;HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpClientRibbonConfiguration.java</span></span><br><span class="line"><span class="comment">// 在zuul中，httpcomponents已经被自动引入了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.apache.http.client.HttpClient&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;ribbon.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个配置被RibbonClientConfiguration一起被加载，可通过@RibbonClient注解的configuration属性覆盖</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">httpClientConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 终于在这里找到了读取MaxTotalConnections等配置的代码</span></span><br><span class="line">     Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">     Integer maxConnectionsPerHost = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxConnectionsPerHost,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_CONNECTIONS_PER_HOST);</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里声明了一个基于Apache的httpClient的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">(ApacheHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpClientConnectionManager connectionManager, IClientConfig config)</span> </span>&#123;</span><br><span class="line">    Boolean followRedirects = config.getPropertyAsBoolean(</span><br><span class="line">        CommonClientConfigKey.FollowRedirects,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_FOLLOW_REDIRECTS);</span><br><span class="line">    Integer connectTimeout = config.getPropertyAsInteger(</span><br><span class="line">        CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    RequestConfig defaultRequestConfig = RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(connectTimeout)</span><br><span class="line">        .setRedirectsEnabled(followRedirects).build();</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClientFactory.createBuilder().</span><br><span class="line">        setDefaultRequestConfig(defaultRequestConfig).</span><br><span class="line">        setConnectionManager(connectionManager).build();</span><br><span class="line">    <span class="keyword">return</span> httpClient;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 划重点。。。终于在这里发现了RibbonLoadBalancingHttpClient的声明，并且MaxTotalConnections等属性在上面的代码已经被注册了。</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(value = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonLoadBalancingHttpClient <span class="title">ribbonLoadBalancingHttpClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IClientConfig config, ServerIntrospector serverIntrospector,</span></span></span><br><span class="line"><span class="function"><span class="params">ILoadBalancer loadBalancer, RetryHandler retryHandler, CloseableHttpClient httpClient)</span> </span>&#123;</span><br><span class="line">RibbonLoadBalancingHttpClient client = <span class="keyword">new</span> RibbonLoadBalancingHttpClient(httpClient, config, serverIntrospector);</span><br><span class="line">client.setLoadBalancer(loadBalancer);</span><br><span class="line">client.setRetryHandler(retryHandler);</span><br><span class="line">Monitors.registerObject(<span class="string">&quot;Client_&quot;</span> + <span class="keyword">this</span>.name, client);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在网关打断点测试了一下，请求确实是通过RibbonLoadBalancingHttpClient执行的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于网关使用Ribbon，会读取<code>ribbon.MaxTotalConnections</code>和<code>ribbon.MaxConnectionsPerHost</code>等配置，并给予HTTPComponents组件进行访问。</p><h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>那么Fiegn的配置在什么时候生效？情况又有变化了，Feign同样有一个配置类<code>FeignRibbonClientAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>在默认没有额外配置的情况下，是读取的<code>DefaultFeignLoadBalancedConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="comment">// Client.Default就基于JDK的http组件完成了http的请求，底层没有连接池</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>),</span><br><span class="line">            cachingFactory, clientFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign在默认情况下使用的是JDK原生的<code>URLConnection</code>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的<code>persistence connection</code> 。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在默认情况下，也就是不开启<code>feign.okhttp.enable</code>和<code>feign.httpclient.enable</code>的时候，feign的<code>feign.max-connections</code>配置，也是没有什么用的。</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>在开启<code>feign.httpclient.enable</code>以后，HttpClientFeignLoadBalancedConfiguration会被加载。这里得加个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign-httpclient&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和Ribbon一样，Feign也定义了自己的HttpClient等组件，在定义过程中，读取了配置并利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">connectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        FeignHttpClientProperties httpClientProperties)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在这里读取了feign相关的MaxConnectionsPerRoute和MaxConnections配置</span></span><br><span class="line">     <span class="keyword">final</span> HttpClientConnectionManager connectionManager = connectionManagerFactory</span><br><span class="line">           .newConnectionManager(httpClientProperties.isDisableSslValidation(), httpClientProperties.getMaxConnections(),</span><br><span class="line">                 httpClientProperties.getMaxConnectionsPerRoute(),</span><br><span class="line">                 httpClientProperties.getTimeToLive(),</span><br><span class="line">                 httpClientProperties.getTimeToLiveUnit(), registryBuilder);</span><br><span class="line">     <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           connectionManager.closeExpiredConnections();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="number">30000</span>, httpClientProperties.getConnectionTimerRepeat());</span><br><span class="line">     <span class="keyword">return</span> connectionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(Client.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                SpringClientFactory clientFactory, HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    ApacheHttpClient delegate = <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200429174359246.png" alt="image-20200429174359246"></p><p>经过打了断点测试和验证， 确实在这里加载到了连接池的配置。请求也是通过ApacheHttpClient发送的。</p><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>在引入了feign-httpclient的包以后，feign才会启用<code>feign.max-connections</code>等连接池的配置。那么Ribbon之前的配置呢，在使用Feign的时候，Ribbon的那些Http相关的Bean就没有用了，不会被用到。</p><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>和上面一样，不过OkHttp只会读取MaxTotalConnections属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(ConnectionPool.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionPool <span class="title">httpClientConnectionPool</span><span class="params">(IClientConfig config, OkHttpClientConnectionPoolFactory connectionPoolFactory)</span> </span>&#123;</span><br><span class="line">   Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">         CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">         DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">   Object timeToLiveObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTime);</span><br><span class="line">   Long timeToLive = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME;</span><br><span class="line">   Object ttlUnitObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits);</span><br><span class="line">   TimeUnit ttlUnit = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;</span><br><span class="line">   <span class="keyword">if</span> (timeToLiveObj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">      timeToLive = (Long) timeToLiveObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ttlUnitObj <span class="keyword">instanceof</span> TimeUnit) &#123;</span><br><span class="line">      ttlUnit = (TimeUnit) ttlUnitObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于这个值应该怎么设置，大家根据自己的项目情况来设置，其实就是访问其他服务的Http连接池数量，不要设置的过于夸张了，有些人可能会跟Tomcat的maxconnections搞混了，甚至配个几千上万的，虽然名字一样，但是含义却不同。SpringBoot给我们设置的默认值，也是有参考意义的，在实际项目中，大家可以根据压测情况进行调整。</p><h1 id="Tomcat-maxConnections"><a href="#Tomcat-maxConnections" class="headerlink" title="Tomcat:maxConnections"></a>Tomcat:maxConnections</h1><p>关于Tomcat这个参数的详细解释，可以看这个博客：<a href="https://blog.csdn.net/zzzgd_666/article/details/88740198%E3%80%82">https://blog.csdn.net/zzzgd_666/article/details/88740198。</a></p><p>大概说一下，Tomcat有Nio、Bio、APR三种运行模式，maxConnections是Tomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为-1，则连接数不受限制。</p><p>默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</p><p>在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。</p><p>maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，maxConnections值应该远大于maxThreads。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在zuul网关中，有关于配置连接数量的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;zuul:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;host:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;max-per-route-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;max-total-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。&lt;/p&gt;
&lt;p&gt;这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ribbon:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;MaxConnectionsPerHost:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;MaxTotalConnections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Feign和Hystrix的结合使用</title>
    <link href="http://www.saily.top/2020/04/19/springcloud/hystrix05/"/>
    <id>http://www.saily.top/2020/04/19/springcloud/hystrix05/</id>
    <published>2020-04-19T10:03:59.000Z</published>
    <updated>2020-05-10T09:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign和Hystrix结合使用"><a href="#Feign和Hystrix结合使用" class="headerlink" title="Feign和Hystrix结合使用"></a>Feign和Hystrix结合使用</h1><p>在@FeignClient中增加fallback配置，指定降级方法的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user&quot;,url = &quot;$&#123;user.url&#125;&quot;,fallback = UserFeignFallback.class</span></span><br><span class="line"><span class="meta">        /*fallbackFactory = UserFeignFactory.class*/)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>降级方法的编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFeignFallback</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByID</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;fallback 回调用户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Feign和Hystrix整合的配置"><a href="#Feign和Hystrix整合的配置" class="headerlink" title="Feign和Hystrix整合的配置"></a>Feign和Hystrix整合的配置</h2><p>超时时间设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><p>如果要特定某个服务的配置，就不写default，这个user是FeignClient的服务名，对应一个HystrixGroup，具体的key就是方法名。</p><p>那么如果想针对服务的某一个方法配置怎么办？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="string">ServiceA#sayHello(Long,String):</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><p>hystrix.threadpool.default.coreSize：线程池大小，默认10</p><p>hystrix.threadpool.default.maximumSize：线程池最大大小，默认10</p><p>hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize：是否允许动态调整线程数量，默认false，只有设置为true了，上面的maximumSize才有效</p><p>hystrix.threadpool.default.keepAliveTimeMinutes ：默认是1，超出coreSize的线程，空闲1分钟后释放掉</p><p>hystrix.threadpool.default.maxQueueSize 默认－1，不能动态修改</p><p>hystrix.threadpool.default.queueSizeRejectionThreshold 可以动态修改，默认是5，先进入请求队列，然后再由线程池执行</p><h3 id="如何计算线程池数量？"><a href="#如何计算线程池数量？" class="headerlink" title="如何计算线程池数量？"></a>如何计算线程池数量？</h3><h4 id="高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间"><a href="#高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间" class="headerlink" title="高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间"></a>高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间</h4><p>比如说处理一个请求，要50ms，那么TP99，也就是99%的请求里处理一个请求耗时最长是50ms。</p><p>我们给一点缓冲空间10ms，那就是处理请求接口耗时60ms。</p><p> 所以一秒钟一个线程可以处理：1000 / 60 = 16，一个线程一秒钟可以处理16个请求。</p><p> 假设高峰期，每秒最多1200个请求，一个线程每秒可以处理16个请求，需要多少个线程才能处理每秒1200个请求呢？1200 / 16 = 75，最多需要75个线程，每个线程每秒处理16个请求，75个线程每秒才可以处理1200个请求。</p><p>最多需要多少个线程数量，就是这样子算出来</p><h4 id="如果是服务B-gt-服务A的话，服务B线程数量怎么设置"><a href="#如果是服务B-gt-服务A的话，服务B线程数量怎么设置" class="headerlink" title="如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置"></a>如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置</h4><p>服务B调用服务A的线程池需要多少个线程呢？</p><p>高峰期，服务B最多要调用服务A每秒钟1200次，服务A处理一个请求是60ms，服务B每次调用服务A的时候，用一个线程发起一次请求，那么这个服务B的这个线程，要60ms才能返回。</p><p>服务B而言，一个线程对服务A发起一次请求需要60ms，一个线程每秒钟可以请求服务A达到16次，但是现在服务B每秒钟需要请求服务A达到1200次，那么服务B就需要75个线程，在高峰期并发请求服务A，才可以完成每秒1200次的调用。</p><p>服务B，部署多台机器，每台机器调用服务A的线程池有10个线程，比如说搞个10个线程，一共部署10台机器，那么服务B调用服务A的线程数量，一共有100个线程，轻轻松松可以支撑高峰期调用服务A的1200次的场景</p><p>每个线程调用服务A一次，耗时60ms，每个线程每秒可以调用服务A一共是16次，100个线程，每秒最多可以调用服务A是1600次，高峰的时候只要支持调用服务A的1200次就可以了，所以这个机器部署就绰绰有余了</p><h2 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h2><p>hystrix.command.default.execution.isolation.strategy：隔离策略，默认Thread，可以选择Semaphore信号量 </p><p>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：超时时间，默认1000ms</p><p>hystrix.command.default.execution.timeout.enabled：是否启用超时，默认ture</p><p>hystrix.command.default.execution.isolation.thread.interruptOnTimeout：超时的时候是否中断执行，默认true  </p><p>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests：信号量隔离策略下，允许的最大并发请求数量，默认10</p><h2 id="降级配置"><a href="#降级配置" class="headerlink" title="降级配置"></a>降级配置</h2><p>hystrix.command.default.fallback.enabled 默认true</p><h2 id="熔断配置"><a href="#熔断配置" class="headerlink" title="熔断配置"></a>熔断配置</h2><p>hystrix.command.default.circuitBreaker.enabled：是否启用熔断器默认true</p><p>hystrix.command.default.circuitBreaker.requestVolumeThreshold：10秒钟内，请求数量达到多少才能去尝试触发熔断，默认20</p><p>hystrix.command.default.circuitBreaker.errorThresholdPercentage：10秒钟内，请求数量达到20，同时异常比例达到50%，就会触发熔断，默认50</p><p>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：触发熔断之后，5s内直接拒绝请求，走降级逻辑，5s后尝试half-open放过少量流量试着恢复，默认5000</p><p>hystrix.command.default.circuitBreaker.forceOpen：强制打开熔断器</p><p>hystrix.command.default.circuitBreaker.forceClosed：强制关闭熔断器</p><h2 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h2><p>hystrix.threadpool.default.metrics.rollingStats.timeInMillisecond：线程池统计指标的时间，默认10000，就是10s</p><p>hystrix.threadpool.default.metrics.rollingStats.numBuckets：将rolling window划分为n个buckets，默认10</p><p>hystrix.command.default.metrics.rollingStats.timeInMilliseconds：command的统计时间，熔断器是否打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</p><p>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</p><p>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</p><p>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</p><p>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</p><p>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</p><p>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</p><h2 id="高阶特性配置"><a href="#高阶特性配置" class="headerlink" title="高阶特性配置"></a>高阶特性配置</h2><p>hystrix.command.default.requestCache.enabled 默true </p><p>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true </p><p>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</p><p>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</p><p>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</p><h1 id="Feign和Hystrix结合的原理"><a href="#Feign和Hystrix结合的原理" class="headerlink" title="Feign和Hystrix结合的原理"></a>Feign和Hystrix结合的原理</h1><p>Feign在和Hystrix整合的时候，feign动态代理里面有一些Hystrix相关的代码，请求走feign动态代理的时候，就会基于Hystrix Command发送请求，实现服务间调用的隔离、限流、超时、降级、熔断、统计等。</p><p><img src="/img/spring-cloud/Feign%E5%92%8CHystrix%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Feign和Hystrix的核心原理"></p><h2 id="Feign中基于Hystrix的动态代理"><a href="#Feign中基于Hystrix的动态代理" class="headerlink" title="Feign中基于Hystrix的动态代理"></a>Feign中基于Hystrix的动态代理</h2><p>在Feign的动态代理代码中，HystrixTargeter默认情况下，在没有开启Hystrix的时候，会使用自带的Feign.Builder。在启用Hystrix走，就使用HystrixFeign.Builder。</p><p><strong>HystrixFeign.Builder是在这里创建的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">   <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixTargeter中，用Hystrix构造动态代理的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 没有开启Hystrix的话，走这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在有Hystrix的条件下，就开始往这下面走。</span></span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   <span class="comment">// 用于读取yaml文件中的Hystrix相关的配置，在执行命令的时候会用到</span></span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 有降级的话，就用降级包装下</span></span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个fallback的实例，从和服务相关联的Spring上下文里获取ServiceAClient的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HystrixFeign.Builder builder, Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">   T fallbackInstance = getFromContext(<span class="string">&quot;fallback&quot;</span>, feignClientName, context, fallback, target.type());</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工厂创建一个实例，并校验是否是ServiceAClient接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                              HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">   FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;)</span><br><span class="line">      getFromContext(<span class="string">&quot;fallbackFactory&quot;</span>, feignClientName, context, fallbackFactoryClass, FallbackFactory.class);</span><br><span class="line">   <span class="comment">/* We take a sample fallback from the fallback factory to check if it returns a fallback</span></span><br><span class="line"><span class="comment">   that is compatible with the annotated feign interface. */</span></span><br><span class="line">   <span class="comment">// 创建一个对象出来看看，检测一下创建出来的对象是否符合要求</span></span><br><span class="line">   Object exampleFallback = fallbackFactory.create(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">   Assert.notNull(exampleFallback,</span><br><span class="line">      String.format(</span><br><span class="line">      <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory may not produce null!&quot;</span>,</span><br><span class="line">         feignClientName));</span><br><span class="line">   <span class="keyword">if</span> (!target.type().isAssignableFrom(exampleFallback.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         String.format(</span><br><span class="line">            <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory produces instances of &#x27;%s&#x27;, but should produce instances of &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">            feignClientName, exampleFallback.getClass(), target.type()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在确认fallbackFactory创建出来的对象没有问题后，调用HystrixFeign的target方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target, T fallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build(fallback != <span class="keyword">null</span> ? <span class="keyword">new</span> FallbackFactory.Default&lt;T&gt;(fallback) : <span class="keyword">null</span>)</span><br><span class="line">      .newInstance(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要注意build方法，里面就包含了两局关键的代码，他重新设置了invocationHandlerFactory和contract</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="function">Feign <span class="title">build</span><span class="params">(<span class="keyword">final</span> FallbackFactory&lt;?&gt; nullableFallbackFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.invocationHandlerFactory(<span class="keyword">new</span> InvocationHandlerFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 关键代码 HystrixInvocationHandler，包含了基于HystrixCommand的封装，实际还是调用dispatch</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixInvocationHandler(target, dispatch, setterFactory, nullableFallbackFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 关键代码HystrixDelegatingContract，用于解析Hystrix相关的注解</span></span><br><span class="line">  <span class="keyword">super</span>.contract(<span class="keyword">new</span> HystrixDelegatingContract(contract));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/%E5%90%AF%E7%94%A8Hystrix%E4%B9%8B%E5%90%8Efeign%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="启用Hystrix之后feign生成动态代理的过程"></p><p>再往后的代码就和Hystrix没有关系了，就在feign的动态代理那一套东西，下面继续看HystrixInvocationHandler封装的细节。</p><h2 id="Feign中HystrixCommand的执行细节"><a href="#Feign中HystrixCommand的执行细节" class="headerlink" title="Feign中HystrixCommand的执行细节"></a>Feign中HystrixCommand的执行细节</h2><p>HystrixInvocationHandler，作为一个动态代理的接口，看下它的invoke方法，他构造了一个HystrixCommand，利用Hystrix包装了请求的执行，在HystrixCommand的run方法里，就包含了执行调用的代码（SynchronousMethodHandler）。如果执行请求的时候报错的话，就会调用getFallbac方法，就会执行之前配置的降级方法，执行降级的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixInvocationHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// early exit if the invoked method is from java.lang.Object</span></span><br><span class="line">  <span class="comment">// code is the same as ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造一个HystrixCommand匿名内部类,每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的配置，例如超时时间等</span></span><br><span class="line">  HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setterMethodMap.get(method)) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用SynchronousMethodHandler,也就是发起Http请求的代码</span></span><br><span class="line">        <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果降级方法不存在的话，父类会直接报错UnsupportedOperationException。</span></span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFallback();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建fallback</span></span><br><span class="line">        Object fallback = fallbackFactory.create(getExecutionException());</span><br><span class="line">        <span class="comment">// 调用之前定义的fallback方法</span></span><br><span class="line">        Object result = fallbackMethodMap.get(method).invoke(fallback, args);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((HystrixCommand) result).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable</span></span><br><span class="line">          <span class="keyword">return</span> ((Observable) result).toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">          <span class="keyword">return</span> ((Single) result).toObservable().toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">          ((Completable) result).await();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// shouldn&#x27;t happen as method is public due to being an interface</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// Exceptions on fallback are tossed by Hystrix</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</span></span><br><span class="line">  <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toSingle();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toCompletable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hystrixCommand.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixInvocationHandler构造的时候，构造了一个setterMethodMap，每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的key和groupkey的配置，例如超时时间等，线程池配置等，Setter被创建的时候，用的就是@FeignClient的name作为groupKey，也就是ServiceA，commandKey用于是类名+方法名（ServiceA#sayHello(Long,String)），这个groupKey就对应了一个线程池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetterFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">create</span><span class="params">(Target&lt;?&gt; target, Method method)</span> </span>&#123;</span><br><span class="line">  String groupKey = target.name();</span><br><span class="line">  String commandKey = Feign.configKey(target.type(), method);</span><br><span class="line">  <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))</span><br><span class="line">      .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>基于Method对象对应的setterMethodMap，构造一个HystrixCommand匿名内部类</li><li>内部类实现了run方法和getFallback方法</li><li>run方法直接调用调用SynchronousMethodHandler发起http请求</li><li>如果run方法执行异常，getFallback方法调用之前在FeignClient中定义的降级方法</li><li>检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</li></ol><p>到这里已经看到调用了HystrixCommand的execute方法，所以接下来的内容，将会进入到Hystrix的源码中，下一篇文章细说。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign和Hystrix结合使用&quot;&gt;&lt;a href=&quot;#Feign和Hystrix结合使用&quot; class=&quot;headerlink&quot; title=&quot;Feign和Hystrix结合使用&quot;&gt;&lt;/a&gt;Feign和Hystrix结合使用&lt;/h1&gt;&lt;p&gt;在@FeignClient中增加fallback配置，指定降级方法的执行&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FeignClient(name = &amp;quot;user&amp;quot;,url = &amp;quot;$&amp;#123;user.url&amp;#125;&amp;quot;,fallback = UserFeignFallback.class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        /*fallbackFactory = UserFeignFactory.class*/)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UserFeign&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@PostMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping(&amp;quot;/&amp;#123;id&amp;#125;&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;User &lt;span class=&quot;title&quot;&gt;getUserByID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@PathVariable(&amp;quot;id&amp;quot;)&lt;/span&gt; String id)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;title&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Feign04-Feign超时和重试分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign04/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign04/</id>
    <published>2020-04-18T14:05:39.000Z</published>
    <updated>2020-06-02T14:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign超时和重试"><a href="#Feign超时和重试" class="headerlink" title="Feign超时和重试"></a>Feign超时和重试</h1><p><strong>超时</strong></p><p>在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。</p><p><strong>重试</strong></p><p>服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。</p><a id="more"></a><h2 id="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"><a href="#在SpringCloud的Feign和Ribbon整合的时候，如何配置？" class="headerlink" title="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"></a>在SpringCloud的Feign和Ribbon整合的时候，如何配置？</h2><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>feign的超时时间优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="超时和重试源码"><a href="#超时和重试源码" class="headerlink" title="超时和重试源码"></a>超时和重试源码</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果feign没有配置超时时间，则读取ribbon的配置，否则读取feign的超时配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IClientConfig <span class="title">getClientConfig</span><span class="params">(Request.Options options, String clientName)</span> </span>&#123;</span><br><span class="line">   IClientConfig requestConfig;</span><br><span class="line">   <span class="keyword">if</span> (options == DEFAULT_OPTIONS) &#123;</span><br><span class="line">      requestConfig = <span class="keyword">this</span>.clientFactory.getClientConfig(clientName);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestConfig = <span class="keyword">new</span> FeignOptionsClientConfig(options);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> requestConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignLoadBalancer.execute()，发送实际的http请求的时候，就会传入设置的超时参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(</span><br><span class="line">         configOverride.get(CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">               <span class="keyword">this</span>.connectTimeout),</span><br><span class="line">         (configOverride.get(CommonClientConfigKey.ReadTimeout,</span><br><span class="line">               <span class="keyword">this</span>.readTimeout)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(<span class="keyword">this</span>.connectTimeout, <span class="keyword">this</span>.readTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><h4 id="Feign的重试"><a href="#Feign的重试" class="headerlink" title="Feign的重试"></a>Feign的重试</h4><p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p><p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。</p><p>SynchronousMethodHandler.invoke()方法里面，如果抛了异常的话，也会默认根据Retryer进行重试。</p><p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试，这个默认是NEVER_RETRY</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon的重试"><a href="#Ribbon的重试" class="headerlink" title="Ribbon的重试"></a>Ribbon的重试</h4><p>因为SpringCloud的Feign重试默认是NEVER_RETRY，所以主要是靠Ribbon的重试机制。</p><p>FeignLoadBalancer.getRequestSpecificRetryHandler()方法中，会读取配置的几个参数：OkToRetryOnAllOperations、MaxAutoRetries、MaxAutoRetriesNextServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.clientConfig.get(CommonClientConfigKey.OkToRetryOnAllOperations,</span><br><span class="line">         <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().method().equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LoadBalancerCommand.submit()方法中，读取RetryHandler中配置的参数，会根据请求的情况，是否报错，是否报异常，进行重试的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br></pre></td></tr></table></figure><p>LoadBalancerCommand包含了大量的重试逻辑，这里是判断是否对同一台机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>) </span><br><span class="line">  o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure><p>重试都会进入retryPolicy方法，判断是否需要进行重试，然后利用rxjava的retry方法进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Func2&lt;Integer, Throwable, Boolean&gt; <span class="title">retryPolicy</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxRetrys, <span class="keyword">final</span> <span class="keyword">boolean</span> same)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer tryCount, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AbortExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCount &gt; maxRetrys) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e.getCause() != <span class="keyword">null</span> &amp;&amp; e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                e = e.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> retryHandler.isRetriableException(e, same);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其他机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>) </span><br><span class="line">    o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure><blockquote><p>上面的逻辑是服务宕机的时候的重试逻辑，在超时的时候重试逻辑却是在RetryableFeignLoadBalancer里</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign超时和重试&quot;&gt;&lt;a href=&quot;#Feign超时和重试&quot; class=&quot;headerlink&quot; title=&quot;Feign超时和重试&quot;&gt;&lt;/a&gt;Feign超时和重试&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign03-Feign请求处理机制分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign03/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign03/</id>
    <published>2020-04-18T08:05:39.000Z</published>
    <updated>2020-04-18T14:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口方法与MethodHandler映射map的生成机制"><a href="#接口方法与MethodHandler映射map的生成机制" class="headerlink" title="接口方法与MethodHandler映射map的生成机制"></a>接口方法与MethodHandler映射map的生成机制</h1><p>在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br></pre></td></tr></table></figure><p>这里面就完成了SpringMVCContract对方法的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这就用contract完成了方法上的SpringMVC注解的转换</span></span><br><span class="line">  <span class="comment">// ServiceAClient的每一个方法都会被解析成MethodMetadata</span></span><br><span class="line">  <span class="comment">// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 遍历方法元数据</span></span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里就创建了SynchronousMethodHandler，key就是方法名</span></span><br><span class="line">    <span class="comment">// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="画个图"><a href="#画个图" class="headerlink" title="画个图"></a>画个图</h2><p><img src="/img/spring-cloud/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E4%B8%8EMethodHandler%E6%98%A0%E5%B0%84map%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6.jpg" alt="接口方法与MethodHandler映射map的生成机制"></p><h1 id="Feign请求处理大体流程"><a href="#Feign请求处理大体流程" class="headerlink" title="Feign请求处理大体流程"></a>Feign请求处理大体流程</h1><p><img src="/img/spring-cloud/Feign%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="Feign基于动态代理处理请求的机制"></p><h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><h2 id="动态代理拦截Client所有的方法调用"><a href="#动态代理拦截Client所有的方法调用" class="headerlink" title="动态代理拦截Client所有的方法调用"></a>动态代理拦截Client所有的方法调用</h2><p>在动态代理生成以后，动态代理所有的调用都会被FeignInvocationHandler拦截，所以我们分析实际的请求流程，需要去查看invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 排除掉equals等方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object</span><br><span class="line">          otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个dispatch，就是Map&lt;Method, MethodHandler&gt; dispatch;</span></span><br><span class="line">  <span class="comment">// 那么拿到的对象就是SynchronousMethodHandler，然后将参数传过去了</span></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将方法上的请求参数封装到RequestTemplate里"><a href="#将方法上的请求参数封装到RequestTemplate里" class="headerlink" title="将方法上的请求参数封装到RequestTemplate里"></a>将方法上的请求参数封装到RequestTemplate里</h2><p>Map&lt;Method, MethodHandler&gt; dispatch;维护了方法对象和SynchronousMethodHandler的映射，所以流程到这里，直接跟到SynchronousMethodHandler利的invoke方法去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 又是关键代码，用于替换PathVariable、@RequestParam以及RequestBody</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发起调用</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拿到的参数拼到url上，例如 /user/{id}拼接成， /user/1?name=xxx&amp;age=19</p><h2 id="执行所有的RequestInterceptor"><a href="#执行所有的RequestInterceptor" class="headerlink" title="执行所有的RequestInterceptor"></a>执行所有的RequestInterceptor</h2><p>然后开始调用executeAndDecode方法，执行http调用的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line">  <span class="comment">// 并创建可用于发送请求的Request对象</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</li><li>基于RequestTemplate创建一个Request对象，用于发送请求</li><li>将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s。基于LoadBalancerFeignClient进行了请求的处理和发送，同时获取了Response。</li></ol><h2 id="获得负载均衡器选择服务发起请求"><a href="#获得负载均衡器选择服务发起请求" class="headerlink" title="获得负载均衡器选择服务发起请求"></a>获得负载均衡器选择服务发起请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerFeignClient.execute</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      <span class="comment">// 获取请求的服务名称，也就是ServiceA</span></span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      <span class="comment">// 从请求URL中剔除了服务名称，</span></span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 基于去除了服务名称的地址创建了一个RibbonRequest</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"><span class="comment">// 这是ribbon的配置</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">            requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取请求的服务名称，也就是ServiceA</li><li>从请求URL中剔除了服务名称</li><li>基于去除了服务名称的地址创建了一个RibbonRequest</li><li>读取某个服务ribbon的配置IClientConfig</li><li>创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</li></ol><h2 id="Feign是如何与Ribbon进行整合的"><a href="#Feign是如何与Ribbon进行整合的" class="headerlink" title="Feign是如何与Ribbon进行整合的"></a>Feign是如何与Ribbon进行整合的</h2><p>上面已经创建了FeignLoadBalancer，他内部封装了Ribbon的ILoadBalancer，所以要重点分析下他究竟是如何与Ribbon进行整合的，用的是Ribbon的哪一个ILoadBalancer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CachingSpringLoadBalancerFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(clientName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   <span class="comment">// 从SpringClientFactory获取，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer</span></span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">   FeignLoadBalancer client = enableRetry ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">      loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从SpringClientFactory获取ILoadBalancer等组件，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer，这里也就自然的与Eureka完成了整合。</p><h2 id="FeignLoadBalancer如何负载均衡选择Server"><a href="#FeignLoadBalancer如何负载均衡选择Server" class="headerlink" title="FeignLoadBalancer如何负载均衡选择Server"></a>FeignLoadBalancer如何负载均衡选择Server</h2><p>进入到executeWithLoadBalancer方法中构造了一个LoadBalancerCommand，然后下面的submit方法，有一个匿名内部类ServerOperation的的实现传进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractLoadBalancerAwareClient.executeWithLoadBalancer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这提交了一个匿名内部类进去，那么ServerOperation.call方法就一定会在submit方法里被调用</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure><p>提交了一个匿名内部类作为参数，那么ServerOperation.call方法就一定会在submit方法里被调用，跟到submit方法里去看下，因为是第一次进入，所以server肯定是null，selectServer()方法，看名字明显就是调用负载均衡选择服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ribbon的重试参数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    <span class="comment">// selectServer 负载均衡选择实例</span></span><br><span class="line">    Observable&lt;T&gt; o = </span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">      ......省略部分代码</span><br><span class="line">      <span class="comment">// 选择出服务实例后，对operation进行回调，进行url的替换，然后发起真正的http请求</span></span><br><span class="line">      <span class="keyword">return</span> operation.call(server)...</span><br><span class="line">      ......胜率部分代码</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 选择一个服务实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Server&gt; <span class="title">selectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Server&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取host信息，也就是服务名，然后调用负载均衡器chooseServer方法选择一个服务实例</span></span><br><span class="line">                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造了一个LoadBalancerCommand</li><li>构造了一个ServerOperation，包含了发起http调用的逻辑，作为参数传入LoadBalancerCommand.submit方法，后面会进行回调</li><li>在submit方法中，会调用selectServer方法，选择服务实例</li><li>selectServer方法调用loadBalancerContext.getServerFromLoadBalancer，最终调用负载均衡器<a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">chooseServer</a>方法选择一个服务实例，</li><li>拿到服务实例后，将Server对象传入ServerOperation的call方法进行回调</li><li>ServerOperation用server的信息替换host里的服务名，拿到真正的请求地址</li><li>再调用子类也就是FeignLoadBalancer.execute方法执行http请求</li><li>默认的connectTimeout和readTimeout都是1000毫秒</li><li>响应结果封装为RibbonResponse</li></ol><h2 id="收到响应后将json串转换成对象"><a href="#收到响应后将json串转换成对象" class="headerlink" title="收到响应后将json串转换成对象"></a>收到响应后将json串转换成对象</h2><p>回到最初的SynchronousMethodHandler方法里，在executeAndDecode方法中，<code>response = client.execute(request, options);</code>在拿到RibbonResponse以后，开始进行对响应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前面已经执行完这里的代码了，拿到了RibbonResponse</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">      response.toBuilder().request(request).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键代码在这里</span></span><br><span class="line">        <span class="keyword">return</span> decode(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">return</span> decode(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到响应以后，执行decode方法，这个decoder默认是ResponseEntityDecoder，将json字符串转换成java对象，也就是方法的返回类型，metadata.returnType()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">decode</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DecodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画个图总结"><a href="#画个图总结" class="headerlink" title="画个图总结"></a>画个图总结</h2><p><img src="/img/spring-cloud/Feign%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-7217603.jpg" alt="Feign请求处理机制"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;a href=&quot;#接口方法与MethodHandler映射map的生成机制&quot; class=&quot;headerlink&quot; title=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;/a&gt;接口方法与MethodHandler映射map的生成机制&lt;/h1&gt;&lt;p&gt;在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;String, MethodHandler&amp;gt; nameToHandler = targetToHandlersByName.apply(target);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里面就完成了SpringMVCContract对方法的解析&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ReflectiveFeign.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, MethodHandler&amp;gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Target key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 这就用contract完成了方法上的SpringMVC注解的转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ServiceAClient的每一个方法都会被解析成MethodMetadata&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;MethodMetadata&amp;gt; metadata = contract.parseAndValidatateMetadata(key.type());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Map&amp;lt;String, MethodHandler&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String, MethodHandler&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 遍历方法元数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (MethodMetadata md : metadata) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BuildTemplateByResolvingArgs buildTemplate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!md.formParams().isEmpty() &amp;amp;&amp;amp; md.template().bodyTemplate() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildFormEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (md.bodyIndex() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildTemplateByResolvingArgs(md);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在这里就创建了SynchronousMethodHandler，key就是方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.put(md.configKey(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign02-动态代理创建FeignClient的实例</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign02/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign02/</id>
    <published>2020-04-18T05:05:39.000Z</published>
    <updated>2020-04-18T09:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理创建FeignClient的实例"><a href="#动态代理创建FeignClient的实例" class="headerlink" title="动态代理创建FeignClient的实例"></a>动态代理创建FeignClient的实例</h1><p>在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 每个服务对应一个Spring容器，里面就包含了所有的FeignClientSpecification，在FeignAutoConfiguration中定义好了</span></span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   <span class="comment">// Feign对象构建器，Feign包含了动态代理生成对象的代码，详细分析在下一节</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面先看下Feign.Builder是如何构造的</p><h2 id="Feign-Builder构造过程以及Feign在SpringCloud中的默认组件"><a href="#Feign-Builder构造过程以及Feign在SpringCloud中的默认组件" class="headerlink" title="Feign.Builder构造过程以及Feign在SpringCloud中的默认组件"></a>Feign.Builder构造过程以及Feign在SpringCloud中的默认组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 这里的所有组件默认bean，定义都是在FeignClientsConfiguration里</span></span><br><span class="line"><span class="comment">// 除非用@FeignClients的defaultConfiguration覆盖</span></span><br><span class="line"><span class="comment">// 或者用@FeignClient的configuration覆盖</span></span><br><span class="line"><span class="comment">// 优先级 代码可以在NamedContextFactory.createContext查看</span></span><br><span class="line"><span class="comment">// 1、@FeignClient的configuration</span></span><br><span class="line"><span class="comment">// 2、@FeignClients的defaultConfiguration</span></span><br><span class="line"><span class="comment">// 3、SpringCloud的FeignClientsConfiguration</span></span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 去ServiceA对应的Spring容器里获取自己的FeignLoggerFactory，默认是DefaultFeignLoggerFactory</span></span><br><span class="line">   FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);</span><br><span class="line">   <span class="comment">// type就是feignClient的class</span></span><br><span class="line">   <span class="comment">// Slf4jLogger</span></span><br><span class="line">   Logger logger = loggerFactory.create(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder</span></span><br><span class="line">   <span class="comment">// 否则是Feign.Builder，那么默认就是Feign.Builder</span></span><br><span class="line">   <span class="comment">// @formatter:off</span></span><br><span class="line">   Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">         <span class="comment">// required values</span></span><br><span class="line">         .logger(logger)</span><br><span class="line">         <span class="comment">// 默认是SpringEncoder</span></span><br><span class="line">         .encoder(get(context, Encoder.class))</span><br><span class="line">       <span class="comment">// 默认是ResponseEntityDecoder</span></span><br><span class="line">         .decoder(get(context, Decoder.class))</span><br><span class="line">         <span class="comment">// 默认是SpringMvcContract</span></span><br><span class="line">         .contract(get(context, Contract.class));</span><br><span class="line">   <span class="comment">// @formatter:on</span></span><br><span class="line">   <span class="comment">// 读取application.yml设置一些参数，feign.client开头的，超时、日志级别等</span></span><br><span class="line">   configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>从ServiceA对应的Spring容器读取FeignLoggerFactory，默认是DefaultFeignLoggerFactory</li><li>DefaultFeignLoggerFactory创建并设置Logger，是Slf4jLogger</li><li>从ServiceA对应的Spring容器读取并设置Feign.Builder，如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder，默认是Feign.Builder</li><li>从ServiceA对应的Spring容器读取并设置Encoder，默认是SpringEncoder</li><li>从ServiceA对应的Spring容器读取并设置Decoder，默认是ResponseEntityDecoder</li><li>从ServiceA对应的Spring容器读取并设置Contract，默认是SpringMvcContract</li><li>读取并设置application.yml属性</li></ol><h2 id="超时、日志级别、拦截器等属性设置"><a href="#超时、日志级别、拦截器等属性设置" class="headerlink" title="超时、日志级别、拦截器等属性设置"></a>超时、日志级别、拦截器等属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 用@FeignClient指定的configuration进行配置，和读取application.yml</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureFeign</span><span class="params">(FeignContext context, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">  FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.class);</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个默认是true</span></span><br><span class="line">    <span class="keyword">if</span> (properties.isDefaultToProperties()) &#123;</span><br><span class="line">      <span class="comment">// 读取configuration</span></span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line"> <span class="comment">// 全局配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      <span class="comment">// 特定服务配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    configureUsingConfiguration(context, builder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureUsingProperties</span><span class="params">(FeignClientProperties.FeignClientConfiguration config, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getLoggerLevel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.logLevel(config.getLoggerLevel());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getConnectTimeout() != <span class="keyword">null</span> &amp;&amp; config.getReadTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.options(<span class="keyword">new</span> Request.Options(config.getConnectTimeout(), config.getReadTimeout()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRetryer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Retryer retryer = getOrInstantiate(config.getRetryer());</span><br><span class="line">      builder.retryer(retryer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getErrorDecoder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ErrorDecoder errorDecoder = getOrInstantiate(config.getErrorDecoder());</span><br><span class="line">      builder.errorDecoder(errorDecoder);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRequestInterceptors() != <span class="keyword">null</span> &amp;&amp; !config.getRequestInterceptors().isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// this will add request interceptor to builder, not replace existing</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;RequestInterceptor&gt; bean : config.getRequestInterceptors()) &#123;</span><br><span class="line">         RequestInterceptor interceptor = getOrInstantiate(bean);</span><br><span class="line">         builder.requestInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getDecode404() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getDecode404()) &#123;</span><br><span class="line">         builder.decode404();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置读取过程详解：</p><ol><li><p>读取@FeignClient中指定的MyConfiguration配置，比如Logger.Level，Retryer，ErrorDecoder，Request.Options，RequestInterceptors。</p></li><li><p>读取application.yml中feign.client开头的配置，application.yml的优先级更高。</p></li><li><p>读取application.yml中feign.client.serviceA开头的配置，这个优先级最高</p></li></ol><h2 id="动态代理创建ServiceAClient的实例"><a href="#动态代理创建ServiceAClient的实例" class="headerlink" title="动态代理创建ServiceAClient的实例"></a>动态代理创建ServiceAClient的实例</h2><p>根据配置构造好了Feign.Builder后，就要开始创建Feign.Client的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查@FeignClient是否配置了url地址</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">// 拼了一个http://ServiceA出来</span></span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="comment">// Target 一般就是和动态代理有关的类，即被代理的对象</span></span><br><span class="line">      <span class="comment">// HardCodedTarget包含了 type:接口类class(ServiceAClient)，name(ServiceA)和url(http://ServiceA)。</span></span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>如果@FeignClient没有配置url属性，就将服务名拼接成<a href="http://servicea)这样的地址/">http://ServiceA）这样的地址</a></li><li>构造了一个HardCodedTarget，包含了type:接口类class(ServiceAClient)，name(ServiceA)和url(<a href="http://servicea),和feign.builder、feigncontext一起传入loadbalance./">http://ServiceA)，和Feign.Builder、FeignContext一起传入loadBalance。</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 从上下文中获得一个LoadBalancerFeignClient，这里，就和ribbon结合起来了</span></span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      builder.client(client);</span><br><span class="line">      <span class="comment">// 那么targeter就是动态代理的组件</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>从上下文获取了一个Client，通过IDEA强大的源码查看能力，找到一个实现类LoadBalancerFeignClient，取决于不同的实现，可能会由<code>DefaultFeignLoadBalancedConfiguration</code> 或者<code>HttpClientFeignLoadBalancedConfiguration</code>或者<code>OkHttpFeignLoadBalancedConfiguration</code>定义的，通过FeignRibbonClientAutoConfiguration的@Import注解导入。默认是Default开头的。LoadBalancerFeignClient就是基于Ribbon，可负载均衡的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>从Spring容器中获取到targeter动态代理的组件，Targeter的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 这个条件明显是成立的，所以代码拿到的肯定是HystrixTargeter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在HystrixTargeter中，如果没有开启feign.hystrix.enabled配置，那么就进入默认的Feign.Builder.target方法，不过在生产环境中，一般都会开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认情况下是Feign.Builder，所以会进入这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   feign.target(target)方法里，将Feign.Builder中所有的的东西集成在一起，构造一个ReflectiveFeign，调用newInstance方法，传入target生成动态代理</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">    <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                         logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">    <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                            errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>调用newInstance方法，传入target，生成ServiceAClient的动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 关键代码，接口中的每个方法的名称，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  <span class="comment">// 接口中的每个方法对应的Method对象，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  <span class="comment">// 到时候每一个handler，都会去触发真正的调用</span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 反射遍历ServiceAClient的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 基于工厂创建的InvocationHandler，JDK动态代理的组件, 这里是ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">// 基于JDK的动态代理创建了一个动态代理对象，这个proxy对象，就实现了ServiceAClient接口</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建完成后，对象被放入Sping容器中，可以被其他类注入使用。</p></li></ol><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/feign%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.jpg" alt="feign动态代理的构造过程"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;a href=&quot;#动态代理创建FeignClient的实例&quot; class=&quot;headerlink&quot; title=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;/a&gt;动态代理创建FeignClient的实例&lt;/h1&gt;&lt;p&gt;在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign01-流程大体分析和源码分析入口</title>
    <link href="http://www.saily.top/2020/04/12/springcloud/feign01/"/>
    <id>http://www.saily.top/2020/04/12/springcloud/feign01/</id>
    <published>2020-04-12T11:05:39.000Z</published>
    <updated>2020-04-18T08:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign的组件简介"><a href="#Feign的组件简介" class="headerlink" title="Feign的组件简介"></a>Feign的组件简介</h1><p>Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件</p><ol><li>编码器和解码器：Encoder和Decoder。<br>Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。<br>Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。</li><li>Logger：用于打印接口请求相关的调用日志</li><li>Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 </li><li>Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。</li><li>FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。</li></ol><a id="more"></a><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a><strong>默认配置</strong></h2><p>Spring Cloud对feign的默认组件</p><ul><li>Encoder:SpringEncoder</li><li>Decoder:ResponseEntityDecoder</li><li>Logger:Sl4jLogger</li><li>Contract:SpringMvcContract，解析Spring web mvc的注解</li><li>Feign.Builder:HystrixFeign.Builder，和Hystrix整合使用</li><li>FeignClient:LoadBalancerFeignClient，底层还是和Ribbon整合</li></ul><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a><strong>自定义配置</strong></h2><p>可以通过自定义配置覆盖一些默认的组件，也可以定义拦截器配置，可实现对feign的请求进行拦截，可用于在发起请求之前动态添加请求头，或者打印日志等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;serviceA&quot;,configuration=MyConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyRequestInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><h3 id="feign配置"><a href="#feign配置" class="headerlink" title="feign配置"></a>feign配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 某个服务的配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">ServiceA:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br></pre></td></tr></table></figure><h3 id="启用feign的压缩"><a href="#启用feign的压缩" class="headerlink" title="启用feign的压缩"></a>启用feign的压缩</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">compression:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">            <span class="attr">min-request-size:</span> <span class="number">2048</span></span><br><span class="line">        <span class="attr">response:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="启用请求日志"><a href="#启用请求日志" class="headerlink" title="启用请求日志"></a>启用请求日志</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.zhss.service.ServiceAClient:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><h2 id="大体流程画图"><a href="#大体流程画图" class="headerlink" title="大体流程画图"></a>大体流程画图</h2><p>大体分析一下Feign是如何完成请求的，包含动态代理，路径和参数的拼装，与Ribbon的整合等。</p><p><img src="/img/spring-cloud/Feign%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="Feign的核心工作流程"></p><h1 id="Feign源码入口"><a href="#Feign源码入口" class="headerlink" title="Feign源码入口"></a>Feign源码入口</h1><p>在分析feign源码之前，应该从哪里入手？那么我们在接入feign的时候，有2个很重要的注解，分别是@EnableFeignClients开启feign，和每个接口上的@FeignClient。</p><p>分别看一下注解源码上的javadoc。</p><h2 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h2><p>用@FeignClient注解标记的接口，会被创建为一个Rest Client，可以被其他组件注入使用。</p><p>如果Ribbon启用的话，就会采用负载均衡的方式发送http请求。负载均衡器可以用@RibbonClient来配置，RibbonClient的和名字要和FeignClient的名字一样。就是@FeignClient(“serviceA”)可以通过下面的配置来指定对应服务Ribbon的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient(name = &quot;serviceA&quot;, configuration = ServiceAConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                         serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><p>扫描那些标记了@FeignClient的接口，指定要扫描哪些包下面的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientsRegistrar是非常重要的一个类，SpringBoot大多数的EnableXXX注解都是通过@Import来完成功能开启的，所以我们猜测，SpringBoot项目启动后，在识别到EnableFeignClients注解后，FeignClientsRegistrar肯定是扫描了标记@FeignClient的接口，完成了@FeignClient的注册。这部分代码和RibbonClientConfigurationRegistrar的相似的，都是先加载了一个default开头的默认配置，然后将每个服务对应的client的配置再加载一些，包装了FeignClientSpecification类放在spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerDefaultConfiguration"><a href="#registerDefaultConfiguration" class="headerlink" title="registerDefaultConfiguration"></a>registerDefaultConfiguration</h3><p>注册默认配置和注册FeignClient，这儿和Ribbon的代码差不多。</p><p>1、Application启动类的全的限定名</p><p>2、获取@EnableFeignClients注解里配置的defaultConfiguration属性</p><p>3、利用以上2个属性，构建一个FeignClientSpecification，注册到了Spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 拿到EnableFeignClients注解所有配置的属性</span></span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 属性里是否包含defaultConfiguration配置</span></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="comment">// 组装成default.com.demo.DemoApplication这样的name</span></span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册feign Client配置</span></span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Object configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是Spring用来构建Bean实例用的构建器，这里搞一个FeignClientSpecification的实例</span></span><br><span class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">    .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">  builder.addConstructorArgValue(name);</span><br><span class="line">  builder.addConstructorArgValue(configuration);</span><br><span class="line">  <span class="comment">// 这儿就是default.com.demo.DemoApplication.org.springframework.cloud.netflix.feign.FeignClientSpecification作为bean的name,FeignClientSpecification的实例作为对象，注册到了Spring的上下文中。</span></span><br><span class="line">  registry.registerBeanDefinition(</span><br><span class="line">    name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">    builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerFeignClients"><a href="#registerFeignClients" class="headerlink" title="registerFeignClients"></a>registerFeignClients</h3><p>这个方法会扫描配置的包，然后将标注了@FeignClient注解的接口，进行配置的注册。</p><ol><li>获得组件扫描器ClassPathScanningCandidateComponentProvider，这是个内部类。</li><li>如果没有配置clients属性，设置扫描的组件为标记了@FeignClient注解类或者接口。读取@EnableFeignClients的basePackages属性</li><li>如果没有配置basePackages属性，就会根据注解所在的类设置为扫描的包，例如DemoApplication所在的包</li><li>如果配置了clients属性，则不会开启扫描，直接使用配置的clients。一般不会配置</li><li>遍历basePackages，扫描所有注解了@FeignClient的类或者接口。判断的逻辑在内部匿名类ClassPathScanningCandidateComponentProvider.isCandidateComponent方法里</li><li>得到标记了@FeignClient的接口</li><li>根据@FeignClient的配置注册serviceId对应的个性化配置</li><li>根据配置的属性，构建器模式构建基于FeignClientFactoryBean的BeanDefinition并注册到BeanDefinitionRegistry中。此时FeignClient类的实例并没有生成，只是构建了一个FeignClientFactoryBean的BeanDefinition，并将其注册到了BeanDefinitionRegistry（也就是Spring上下文）里。大胆猜一下，应该是在后面才会用动态代理去创建FeignClient接口的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 扫描用的组件</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">   </span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient.class);</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">   <span class="comment">// 如果没有配置clients属性</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 扫描标记了@FeignClient注解的接口</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 扫描EnableFeignClients里配置的basePackages</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则遍历配置的clients，加载相应配置。</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 如果EnableFeignClients没有配置basePackages，则扫描DemoApplication所在的包</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// 找到标记了@FeignClient的注解</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line">            <span class="comment">// 拿到@FeignClient注解配置的属性</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient.class.getCanonicalName());</span><br><span class="line"><span class="comment">// 拿到配置的serviceId</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 根据配置的configuration，注册服务名个性化的配置</span></span><br><span class="line">            <span class="comment">// ServiceA.org.springframework.cloud.netflix.feign.FeignClientSpecification</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"><span class="comment">// 注册FeignClient</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 构建器模式构建基于FeignClientFactoryBean的BeanDefinition</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">   validate(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// ServiceA</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// ServiceAFeignClient</span></span><br><span class="line">   String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">   <span class="comment">// 构建器构造完成</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">&quot;primary&quot;</span>); <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画图总结流程"><a href="#画图总结流程" class="headerlink" title="画图总结流程"></a>画图总结流程</h3><p><img src="/img/spring-cloud/%E6%89%AB%E6%8F%8F@FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="扫描@FeignClient注解的机制"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign的组件简介&quot;&gt;&lt;a href=&quot;#Feign的组件简介&quot; class=&quot;headerlink&quot; title=&quot;Feign的组件简介&quot;&gt;&lt;/a&gt;Feign的组件简介&lt;/h1&gt;&lt;p&gt;Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码器和解码器：Encoder和Decoder。&lt;br&gt;Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。&lt;br&gt;Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。&lt;/li&gt;
&lt;li&gt;Logger：用于打印接口请求相关的调用日志&lt;/li&gt;
&lt;li&gt;Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 &lt;/li&gt;
&lt;li&gt;Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。&lt;/li&gt;
&lt;li&gt;FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>分析Ribbon源码，Ribbon在底层如何拉取服务列表、进行负载均衡选择并发起Http请求</title>
    <link href="http://www.saily.top/2020/03/31/springcloud/ribbon01/"/>
    <id>http://www.saily.top/2020/03/31/springcloud/ribbon01/</id>
    <published>2020-03-31T15:05:39.000Z</published>
    <updated>2020-05-14T08:34:24.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><strong>服务注册</strong>，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。</p><p><strong>服务发现</strong>就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。</p><p><strong>负载均衡</strong>就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。</p><a id="more"></a><h1 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h1><p>Spring Cloud Ribbon组件，也是基于Netflix Ribbon做的封装。</p><p>Ribbon包含几个核心组件：</p><ul><li><p>IRule:负载均衡规则组件，轮询，随机，权重等。</p></li><li><p>IPing: 用于检测服务是否存活，剔除宕机的服务。</p></li><li><p>ServerList: 针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及eureka的DomainExtractingServerList。</p></li><li><p>ILoadBalancer:负载均衡器，选择服务用，包含了IRule、IPing和ServerList。</p></li><li><p>LoadBalancerClient: 这是SpringCloud二次封装的一层组件，基于以上组件进行服务列表更新，过滤，选择并发起http调用。</p></li></ul><p>大体流程如下图所示：</p><p><img src="/img/spring-cloud/image-20200331230023575.png" alt="image-20200331230023575"></p><ol><li>自动装配LoadBalancerAutoConfiguration</li><li>在自动配置类中，会为RestTemplate添加拦截器LoadBalancerInterceptor</li><li>调用请求后，拦截器中获取host，并在LoadBalancerClient中对host信息进行转换，得到真正的服务器地址。</li><li>LoadBalancerClient中从Eureka client得到服务实例列表，然后通过包含了负载均衡规则IRule，选出要发起调用的server。</li><li>交给负责Http通讯的组件LoadBalancerRequest执行真正的http请求。</li></ol><h2 id="RestTemplate如何拥有负载均衡的能力"><a href="#RestTemplate如何拥有负载均衡的能力" class="headerlink" title="RestTemplate如何拥有负载均衡的能力"></a>RestTemplate如何拥有负载均衡的能力</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced的源码： 标记RestTemplate被配置为使用LoadBalancerClient。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient</span><br></pre></td></tr></table></figure><p>定位在这个注解所在的jar包，可以发现有如下的类：</p><p><img src="/img/spring-cloud/image-20200402225210595.png" alt="image-20200402225210595"></p><p>根据SpringBoot的命名习惯，自动装配的类一般都是XXXAutoConfiguration，所以我们应该重点关注LoadBalancerAutoConfiguration这个类，进去看看，我省略掉部分代码，找到我们最应该关注的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto configuration for Ribbon (client side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will Tran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gang Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RestTemplate.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  .....省略部分代码</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplateCustomizer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">restTemplate.getInterceptors());</span><br><span class="line">list.add(loadBalancerInterceptor);</span><br><span class="line">restTemplate.setInterceptors(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  ....省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里给系统里的RestTemplate添加了拦截器，LoadBalancerInterceptor。在声明了LoadBalancerInterceptor后，用RestTemplateCustomizer定制化了拦截器<code>restTemplate.setInterceptors(list);</code>。</p><p>去LoadBalancerInterceptor看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line"><span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// for backwards compatibility</span></span><br><span class="line"><span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 原来是在这个方法里替换了host，将host通过loadBalancer转换成了实际要访问的ip:port</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    <span class="comment">// 这里是serviceA</span></span><br><span class="line">String serviceName = originalUri.getHost();</span><br><span class="line">Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);</span><br><span class="line">    <span class="comment">// 通过拦截器处理后，将serviceA转换为ip:port，在拦截器里去执行了真正的http请求</span></span><br><span class="line">    <span class="comment">// cmd + option + B 可以在IDEA直接定位到实现类RibbonLoadBalancerClient的源码</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个源码打开一看，我们一下就明朗了，原来SpringCloud是这样通过拦截器实现了restTeplate.getForObject(“<a href="http://servicea/hello&quot;">http://serviceA/hello&quot;</a>) 到restTeplate.getForObject(“<a href="http://192.168.21.100:8080/hello&quot;)%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">http://192.168.21.100:8080/hello&quot;)的转换。</a></p><p>在RibbonLoadBalancerClient的类上按option(alt) + F7，可以迅速的找到在哪里声明创建的这个类的实例，如下图所示，也就是在RibbonAutoConfiguration类里。</p><p><img src="/img/spring-cloud/image-20200404224238571.png" alt="image-20200404224238571"></p><p>接着看一下RibbonLoadBalancerClient的execute方法具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonLoadBalancerClient，execute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找服务对应的负载均衡器，因为每个服务ribbon配置可能不一样</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// getServer方法里，会调用loadBalancer.chooseServer方法。</span></span><br><span class="line">  <span class="comment">// 这个server就已经包含了具体的ip和port</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">                                                                           serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行真正的http请求</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....省略部分代码</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// chooseServer方法会去执行真正的IRule实现逻辑，利用负载均衡规则筛选出适合的服务实例</span></span><br><span class="line">  <span class="keyword">return</span> loadBalancer.chooseServer(<span class="string">&quot;default&quot;</span>); <span class="comment">// <span class="doctag">TODO:</span> better handling of key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡器ILoadBalancer"><a href="#负载均衡器ILoadBalancer" class="headerlink" title="负载均衡器ILoadBalancer"></a>负载均衡器ILoadBalancer</h2><p>那么看到上面有个ILoadBalancer，ILoadBalancer维护了一份服务列表，并提供了过滤服务和用负载均衡选择server等功能。这个ILoadBalancer在SpringCloud中默认是用的什么实现呢，这里的实例是用SpringClientFactory.getLoadBalancer方法获取的，<strong>这个SpringClientFactory是SpringCloud对Ribbon的一层封装，为每一个服务都创建了一个Spring ApplicationContext，每一个服务都有自己的client，load balancer 和 client configuration实例。</strong>这个<code>SpringClientFactory</code>非常重要，它是为每一个服务指定不同配置的基础例如不同的服务采用不同的负载均衡规则，就是通过这个机制实现的。</p><p>在SpringClientFactory.getLoadBalancer方法里，调用了<code>getInstance(name, ILoadBalancer.class);</code>跟到代码里去看是如何获取实例的，最后跟到父类里，发现是用map维护了服务和上下文的对应关系，serviceA -&gt; AnnotationConfigApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个ILoadBalancer的实例究竟是在哪里创建的呢？还是老办法，option + F7，去找一个叫XXXConfiguration的类，于是在RibbonClientConfiguration的类里，发现了Bean的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ILoadBalancer定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                     serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是使用<strong>ZoneAwareLoadBalancer</strong>，父类是：DynamicServerListLoadBalancer，再往上的父类是BaseLoadBalancer。</p><blockquote><p>这里多说一句，其实RibbonClientConfiguration的加载，是在NamedContextFactory.createContext里加载的，而且优先级是最低的，具体可以看本文最后一节引用文章，现在不必细究，等把整体流程了解的差不多以后，再去看这种细节问题。</p></blockquote><h2 id="Ribbon如何获取到服务列表"><a href="#Ribbon如何获取到服务列表" class="headerlink" title="Ribbon如何获取到服务列表"></a>Ribbon如何获取到服务列表</h2><p>在ZoneAwareLoadBalancer中，并没有找到和服务列表相关的代码，去父类的构造方法看下，调用了restOfInit方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer，restOfInit方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> primeConnection = <span class="keyword">this</span>.isEnablePrimingConnections();</span><br><span class="line">  <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">// 初始化并加载服务列表，会调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  enableAndInitLearnNewServersFeature();</span><br><span class="line">  <span class="comment">// 调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  updateListOfServers();</span><br><span class="line">  <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="keyword">this</span>.getPrimeConnections() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getPrimeConnections()</span><br><span class="line">      .primeConnections(getReachableServers());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">  LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来serverListImpl，也就是ServerList就是获取服务列表的关键。那么这个ServerList是在构造方法里传入的，所以回到ZoneAwareLoadBalancer的Bean定义的地方，可以看到他是通过依赖注入获取到的。</p><p>通过IDEA看一下接口有哪些实现类：</p><p><img src="/img/spring-cloud/image-20200408233824757.png" alt="image-20200408233824757"></p><p>可以看到，针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及在spring cloud eureka包下面的DomainExtractingServerList。</p><p>由此可以断定，SpringCloud在和Ribbon和Eureka整合的时候，一定使用了DomainExtractingServerList这个类。更进一步的，找到了DomainExtractingServerList创建的地方，发现他又是包装了一层DiscoveryEnabledNIWSServerList，这个DiscoveryEnabledNIWSServerList是com.netflix.niws.loadbalancer;包下面的，在ribbon-eureka.jar里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ServerList的定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config,</span><br><span class="line">                                      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">    config, eurekaClientProvider);</span><br><span class="line">  DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">    discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line">  <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下面截图是DiscoveryEnabledNIWSServerList的getInitialListOfServers和getUpdatedListOfServers方法，在这里看到了前面熟悉的eurekaClient，通过eurekaClient获取到了实例列表，并且转成了List<DiscoveryEnabledServer>返回，我们在用IDEA分析源码的时候，真的是非常的方便，可以通过查看类或者方法的引用，来找到创建或者使用的代码。也可以很方便的通过继承关系查看，就找到可能的具体的实现。</p><p><img src="/img/spring-cloud/image-20200409210354113.png" alt="image-20200409210354113"></p><p>最后，将拿到的服务列表存入了成员变量allServerList中。</p><p><img src="/img/spring-cloud/image-20200409215159851.png" alt="image-20200409215159851"></p><p>已经找到了更新服务列表的地方，那么他是什么时候去更新的呢，实际上在restOfInit方法调用的enableAndInitLearnNewServersFeature方法里，就调用了一个更新器：serverListUpdater，他会定时去更新，在构造方法里，构造了PollingServerListUpdater的实例，他是在启动1秒后，每隔30秒就会执行一次，去从eureka client里将服务列表定时同步到LoadBalancer的allServerList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableAndInitLearnNewServersFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGGER.info(<span class="string">&quot;Using serverListUpdater &#123;&#125;&quot;</span>, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">  <span class="comment">// 这里的updateAction，就是调用updateListOfServers()方法。</span></span><br><span class="line">  serverListUpdater.start(updateAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法如何选择一个server"><a href="#负载均衡算法如何选择一个server" class="headerlink" title="负载均衡算法如何选择一个server"></a>负载均衡算法如何选择一个server</h2><p>前面有提到，在获取到负载均衡器（ILoadBalancer）后，就会调用chooseServer方法去选择一个server，看了眼他的逻辑，对每个机房都搞了个LoadBalancer，最后还是调用的BaseLoadBalancer.chooseServer方法，也就是父类的chooseServer方法，咱们在这里，就找到了rule.choose(key)的调用，所以接下来，我们就重点关注一下rule是哪里来的，他的默认实现又是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseLoadBalancer.chooseServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    counter = createCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  counter.increment();</span><br><span class="line">  <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;&quot;</span>, name, key, e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ZoneAwareLoadBalancer的定义类里，也就是RibbonClientConfiguration里，也声明了IRule的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration.ribbonRule</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">  rule.initWithNiwsConfig(config);</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在ZoneAvoidanceRule里，并没有找到choose方法，看一眼他的层级结构，choose方法在父类PredicateBasedRule里。</p><p><img src="/img/spring-cloud/image-20200409221508995.png" alt="image-20200409221508995"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PredicateBasedRule.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来过滤服务列表的核心逻辑，可利用自己的实现进行个性化的实例过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">  <span class="comment">// 过滤然后轮询选择服务列表</span></span><br><span class="line">  Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">  <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> server.get();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPredicate().chooseRoundRobinAfterFiltering，先过滤后再用轮询算法选择一个Server。这个具体算法可以在incrementAndGetModulo里找到，算出一个索引值，然后去List里取一个server。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractServerPredicate.java </span></span><br><span class="line"><span class="comment">// 先过滤后，再用轮询算法一次取下一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先过滤服务列表</span></span><br><span class="line">  List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">  <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.absent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轮训算法计算索引值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = nextIndex.get();</span><br><span class="line">    <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">    <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200409224739519.png" alt="image-20200409224739519"></p><p>在这里说一句题外话，其实在工作中，这个地方我们可以大做文章，比如编写自己的Rule，实现自己的负责均衡算法。也可以利用getEligibleServers的过滤服务实例机制，去实现自己Predicate，从而实现一些灰度发布等操作。关于SpringCloud的灰度发布，可参考开源框架Nepxion Discovery：<strong><a href="https://github.com/Nepxion/Discovery">https://github.com/Nepxion/Discovery</a></strong></p><h2 id="拿到server后如何发起真正的请求"><a href="#拿到server后如何发起真正的请求" class="headerlink" title="拿到server后如何发起真正的请求"></a>拿到server后如何发起真正的请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #RibbonLoadBalancerClient.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Server server = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">      server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">         .getLoadBalancerContext(serviceId);</span><br><span class="line">   RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      T returnVal = request.apply(serviceInstance);</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure><p>在选择到服务实例以后，RibbonLoadBalancerClient.execute()就要发起真正的调用了。用了一个回调，将被请求的服务器信息当作参数穿进去，完成了http的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T returnVal = request.apply(serviceInstance);</span><br></pre></td></tr></table></figure><p>所以回到LoadBalancerInterceptor类里，request是一个匿名内部类，在里面对request和服务实例进行了包装，将具体执行交给了ClientHttpRequestExecution。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerInterceptor.java</span></span><br><span class="line">requestFactory.createRequest(request, body, execution)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadBalancerRequestFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                               <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequest&lt;ClientHttpResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">apply</span><span class="params">(<span class="keyword">final</span> ServiceInstance instance)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, loadBalancer);</span><br><span class="line">      <span class="keyword">if</span> (transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : transformers) &#123;</span><br><span class="line">          serviceRequest = transformer.transformRequest(serviceRequest, instance);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> execution.execute(serviceRequest, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了ClientHttpRequestExecution里面，其实已经到了spring-web的类里了，spring-web从ServiceRequestWrapper获取到真正的请求URL地址，发起了http请求。所以spring-web的源码，这里就不再去看了，但是需要关注ServiceRequestWrapper，ServiceRequestWrapper完成了对真实请求地址的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奥秘所在类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance instance;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceRequestWrapper</span><span class="params">(HttpRequest request, ServiceInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params"> LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.instance = instance;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写了HttpRequest的getURI方法，利用LoadBalancerClient获取到了真正的请求地址。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">URI uri = <span class="keyword">this</span>.loadBalancer.reconstructURI(</span><br><span class="line"><span class="keyword">this</span>.instance, getRequest().getURI());</span><br><span class="line"><span class="keyword">return</span> uri;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonLoadBalancerClient.java</span></span><br><span class="line"><span class="comment">// 利用服务实例的host和端口以及path信息，拼接出真正的请求地址</span></span><br><span class="line"><span class="comment">// http://serviceA/sayHello -&gt; http://192.168.10.1:8080/sayHello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(instance, <span class="string">&quot;instance can not be null&quot;</span>);</span><br><span class="line">  String serviceId = instance.getServiceId();</span><br><span class="line">  RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">    .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">  URI uri;</span><br><span class="line">  Server server;</span><br><span class="line">  <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">    RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">    server = ribbonServer.getServer();</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(),</span><br><span class="line">                        instance.getPort());</span><br><span class="line">    IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">    ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                           serverIntrospector, server);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图总结下：</p><p><img src="/img/spring-cloud/image-20200410001159973.png" alt="image-20200410001159973"></p><h2 id="Ribbon-IPing检查服务是否存活"><a href="#Ribbon-IPing检查服务是否存活" class="headerlink" title="Ribbon IPing检查服务是否存活"></a>Ribbon IPing检查服务是否存活</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;Ping&quot; Discovery Client</span></span><br><span class="line"><span class="comment"> * i.e. we dont do a real &quot;ping&quot;. We just assume that the server is up if Discovery Client says so</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIWSDiscoveryPing</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerPing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (server!=<span class="keyword">null</span> &amp;&amp; server <span class="keyword">instanceof</span> DiscoveryEnabledServer)&#123;</span><br><span class="line">            DiscoveryEnabledServer dServer = (DiscoveryEnabledServer)server;            </span><br><span class="line">            InstanceInfo instanceInfo = dServer.getInstanceInfo();</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo!=<span class="keyword">null</span>)&#123;                </span><br><span class="line">                InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line">                <span class="keyword">if</span> (status!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> isAlive;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ribbon和eureka整合的时候，并不会真正的去检查服务是否存活，而是利用Discovery Client本来就会有定时更新服务列表的机制。</p><p>在BaseLoadBalancer类里，可以找到IPing的调用之处，他启动了一个定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">&quot;NFLoadBalancer-PingTimer-&quot;</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是每隔30秒，就执行一次PingTask，task里用了一个读写锁完成了ping之后的服务实例列表计算，最后更新upServerList。</p><h2 id="其他几种自带的负载均衡规则"><a href="#其他几种自带的负载均衡规则" class="headerlink" title="其他几种自带的负载均衡规则"></a>其他几种自带的负载均衡规则</h2><p>BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。</p><p>AvailabilityFilteringRule：过滤掉那些一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态。</p><p>ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server。</p><p>RandomRule：随机选择一个Server。</p><p>RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server。</p><p>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server。</p><p>ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule。</p><p>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低。</p><h2 id="服务宕机后Ribbon多久能感知到"><a href="#服务宕机后Ribbon多久能感知到" class="headerlink" title="服务宕机后Ribbon多久能感知到"></a>服务宕机后Ribbon多久能感知到</h2><p>在和eureka结合使用的情况下，因为eureka server是靠心跳来摘除服务实例，那么他是需要duration * 2 =180秒，eureka client 从server同步(recentlyChangedQueue)默认是需要30秒，Ribbon从Eureka Client同步也是30秒，所以最多可能需要240秒，也就是4分钟才能知道一个服务已经宕机了，他是有可能访问到宕机的服务，不过SpringCloud是借用了Hystrix降级和熔断的机制来解决这个问题，一定次数错误后会屏蔽某个实例。</p><p><img src="/img/spring-cloud/%E9%BB%98%E8%AE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="默认的负载均衡算法可能存在的问题"></p><h2 id="SpringCloud和Ribbon的全局配置和特定配置"><a href="#SpringCloud和Ribbon的全局配置和特定配置" class="headerlink" title="SpringCloud和Ribbon的全局配置和特定配置"></a>SpringCloud和Ribbon的全局配置和特定配置</h2><p>这有篇文章写的比较清晰，说明了SpringCloud在读取Ribbon配置的时候是通过懒加载去读取配置的，也就是第一次发起调用的时候，才会通过NamedContextFactory.createContext去初始化@RibbonClients和@RibbonClient指定的配置。 但是@RibbonClients和@RibbonClient的配置被放入NamedContextFactory的configurations字段中，是在RibbonClientConfigurationRegistrar这个类里，结合源码看看文章，就很清楚了。</p><p><a href="https://www.cnblogs.com/trust-freedom/p/11216280.html">https://www.cnblogs.com/trust-freedom/p/11216280.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务发现&lt;/strong&gt;就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="ribnon" scheme="http://www.saily.top/tags/ribnon/"/>
    
  </entry>
  
</feed>
