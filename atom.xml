<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的博客</title>
  <icon>https://www.gravatar.com/avatar/5e6c22ad69915102664d6eb06cca090f</icon>
  <subtitle>扬帆起航</subtitle>
  <link href="http://www.saily.top/atom.xml" rel="self"/>
  
  <link href="http://www.saily.top/"/>
  <updated>2020-10-20T05:52:03.585Z</updated>
  <id>http://www.saily.top/</id>
  
  <author>
    <name>帆</name>
    <email>hyyangfan@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK集合源码</title>
    <link href="http://www.saily.top/2020/10/13/jdk/jdk01/"/>
    <id>http://www.saily.top/2020/10/13/jdk/jdk01/</id>
    <published>2020-10-13T06:00:37.000Z</published>
    <updated>2020-10-20T05:52:03.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK集合源码"><a href="#JDK集合源码" class="headerlink" title="JDK集合源码"></a>JDK集合源码</h1><p>准备写一些文章，把集合、并发、网络相关的JDK工具的使用和源码都在这里记录一下。首先从简单的集合源码开始。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>基于数组的集合，默认的构造函数，给了一个空数组，Object[]， {}，默认的初始化大小为10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般在构造ArrayList，建议指定一个大小，避免频繁扩容带来的开销。</p></blockquote><p>每次往ArrayList中插入数据的时候，都会判断当前数组的元素是否塞满了，如果塞满的话，此时就会扩容这个数组，然后将老数组中的元素拷贝到新数组中去，确保说数组一定是可以承受足够多的元素的。</p><a id="more"></a><h4 id="add-方法的源码"><a href="#add-方法的源码" class="headerlink" title="add()方法的源码"></a>add()方法的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经满了，会扩容大约1.5倍</span></span><br><span class="line">    <span class="comment">// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span><br><span class="line">    <span class="comment">// 然后利用Arrays.copyOf，将老数据复制到新数组中</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// 大约是1.5倍</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  <span class="comment">// 将老数据的数据复制到新的数组里</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-方法的源码"><a href="#set-方法的源码" class="headerlink" title="set()方法的源码"></a>set()方法的源码</h4><p>set源码比较简单，就是检查索引是否超出边界，然后做一个值的替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-index-element-方法的源码"><a href="#add-index-element-方法的源码" class="headerlink" title="add(index, element)方法的源码"></a>add(index, element)方法的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查索引是否越界</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  <span class="comment">// 检查容量是否够了</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">// 关键代码，将某个索引后的数据往数组后面复制，也就是相当于数据往后移动一位</span></span><br><span class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                   size - index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法的源码"><a href="#get-方法的源码" class="headerlink" title="get()方法的源码"></a>get()方法的源码</h4><p>这个简单，就是直接根据索引返回数组里的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-方法的源码"><a href="#remove-方法的源码" class="headerlink" title="remove()方法的源码"></a>remove()方法的源码</h4><p>删除某一个元素，就是从某一个元素开始往前移动一位，然后将最后一位重置为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 往前移动</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>remove()<br>add(index, element)</p><p>这个两个方法，都会导致数组的拷贝，大量元素的挪动，性能都不是太高，基于数组来做这种随机位置的插入和删除，其实性能真的不是太高</p><p>add()、add(index, element)，这两个方法，都可能会导致数组需要扩容，数组长度是固定的，默认初始大小是10个元素，如果不停的往数组里塞入数据，可能会导致瞬间数组不停的扩容，影响系统的性能</p><p>set()、get()，定位到随机的位置，替换那个元素，或者是获取那个元素，这个其实还是比较靠谱的，基于数组来实现随机位置的定位，性能是很高的</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList，是一个双向链表。</p><p>![image-20201013184959422](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013184959422.png)</p><p>add()，默认就是在队列的尾部插入一个元素，在那个双向链表的尾部插入一个元素<br>add(index, element)，是在队列的中间插入一个元素<br>addFirst()，在队列的头部插入一个元素<br>addLast()，跟add()方法是一样的，也是在尾部插入一个元素</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>在往中间插入数据的时候，会根据传入的索引，找到对应的节点，然后设置到节点的before变量中，那么在查找这个节点的过程中，实际上是一个遍历的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果索引在列表的前半部分，则从前往后开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则从后往前遍历查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过一些指针的变换操作，来完成插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert succ != null;</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">  succ.prev = newNode;</span><br><span class="line">  <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20201013185212959](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185212959.png)</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>**getFirst() == peek()**：获取头部的元素，直接返回first指针指向的那个Node里面的数据，他们都是返回头部的元素。getFirst()如果是对空list调用，会抛异常；peek()对空list调用，会返回null</p><p>**getLast()**：获取尾部的元素</p><p>get(int index)，需要用到node(index)方法来定位元素，也就是先判断索引在前半部分还是在后半部分，然后遍历来获得元素，性能较低。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>removeLast()</strong><br><strong>removeFirst() == poll()</strong><br><strong>remove(int index)</strong></p><p>删除，也是通过一些指针的替换，将节点脱离出来，item设置为null，然后等待被回收掉。</p><p>![image-20201013185444906](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185444906.png)</p><h3 id="Vector和Stack"><a href="#Vector和Stack" class="headerlink" title="Vector和Stack"></a>Vector和Stack</h3><p>Stack是基于数组的栈结构，而Vector是基于数组的有序集合，Stack是继承于Vector。</p><p>栈：先进后出</p><p>Stack的push方法，几乎和ArrayList的add一样，顺序设置数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[elementCount++] = obj;</span><br></pre></td></tr></table></figure><p>但是，ArrayList每次扩容是1.5倍，<code>capacity + (capacity &gt;&gt; 1) = 1.5</code>，Vector每次扩容默认是2倍。</p><p>pop()方法，从栈顶弹出一个元素，就是返回最后一个元素，然后删除最后一个元数据，这里会涉及到利用System.arraycopy拷贝数组元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>一个最常见的场景，就是在迭代这个集合的时候，对集合进行remove操作，就一定会遇到这个错误。</p><p>这个是集合迭代器的fail-fast机制，每一种集合的数据结构，都有一个modCount的字段，新增和删除元素的时候，会对这个字段进行modCount++操作。</p><p>然后在初始化迭代器的时候，会记录初始化的会记录modCount的值到expectedModCount中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 初始化的时候记录modCount的值</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure><p>然后在后面迭代的的回收，会判断值是否发生改变，如果改变了，就直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK集合源码&quot;&gt;&lt;a href=&quot;#JDK集合源码&quot; class=&quot;headerlink&quot; title=&quot;JDK集合源码&quot;&gt;&lt;/a&gt;JDK集合源码&lt;/h1&gt;&lt;p&gt;准备写一些文章，把集合、并发、网络相关的JDK工具的使用和源码都在这里记录一下。首先从简单的集合源码开始。&lt;/p&gt;
&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;p&gt;基于数组的集合，默认的构造函数，给了一个空数组，Object[]， {}，默认的初始化大小为10。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Constructs an empty list with an initial capacity of ten.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;一般在构造ArrayList，建议指定一个大小，避免频繁扩容带来的开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次往ArrayList中插入数据的时候，都会判断当前数组的元素是否塞满了，如果塞满的话，此时就会扩容这个数组，然后将老数组中的元素拷贝到新数组中去，确保说数组一定是可以承受足够多的元素的。&lt;/p&gt;</summary>
    
    
    
    <category term="JDK源码" scheme="http://www.saily.top/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="JDK源码" scheme="http://www.saily.top/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK集合源码-Map</title>
    <link href="http://www.saily.top/2020/10/13/jdk/jdk02/"/>
    <id>http://www.saily.top/2020/10/13/jdk/jdk02/</id>
    <published>2020-10-13T06:00:37.000Z</published>
    <updated>2020-10-20T05:42:42.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map源码"><a href="#Map源码" class="headerlink" title="Map源码"></a>Map源码</h1><p>Map是集合里一个非常重要的数据结构，面试也是会经常问到源码的。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>简单描述一下HashMap的原理，它的结构就是数组+链表+红黑树。</p><p>put的时候，对key进行hash，找到对应的数组位置放在里面，然后hash冲突了就组成链表往后追加。查询的时候也是一样，对key进行hash，然后用equals去比较链表上key的值。</p><p>JDK1.8优化了hashmap的数据结构，如果链表过长，达到8以后，就会转变成红黑树。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这个数组的初始化长度，是16，和ArrayList不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组变量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 初始数组大小，默认是16</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后他有个，负载因子是0.75，意思就是默认情况下，如果数组占用达到了<code>16 * 0.75 = 12</code>，就会开始执行扩容操作了。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 这个就是负载因子值了，默认就是上边这个0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// next指针，就形成了链表</span></span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>看这个put方法的源码，就是有一个hash(key)的方法，用来做key做hash计算，然后定位数组索引用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h4><p>这个hash(key)，并不是简单对hashCode取模得到的一个值，它这里是一个非常高性能的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，key.hashCode()，直接获取到了key的hash值，然后和 h &gt;&gt;&gt; 16做了一个异或的运算。</p><p>h &gt;&gt;&gt; 16，就是二进制右移16位，举例，下面是一个hash值的2进制</p><p><code>1111 1111 1111 1111 1111 1010 0111 1100</code></p><p>右移16位后，高位补0，他就变成了</p><p><code>0000 0000 0000 0000 1111 1111 1111 1111</code></p><p>然后再做异或操作，也就是<code>h ^ (h &gt;&gt;&gt; 16)</code></p><blockquote><p>异或：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p></blockquote><p>所以异或之后的结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1010 0111 1100</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line">1111 1111 1111 1111 0000 0101 1000 0011</span><br></pre></td></tr></table></figure><p>发现没有，这么做，就实现了int值的，高16位和低16位异或运算，为什么要这么做呢，是跟后面的代码有关系。</p><p>在定位数组索引的时候，也用到了一个位运算，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p>n就是数组的长度，这个值一般情况下，是比较小的，比如n=16的二进制</p><p><code>0000 0000 0000 0000 0000 0000 0001 0000</code></p><p>这个值如果去和原始的hash值做位运算，肯定始终都是只会在低16位做运算，高16位，就用不上了。所以提前用hash()方法将高16位和低16位做了位运算后，就能保证在定位数组索引的时候，无论这个n值的大小，也能让hash的高低16位都参与到运算中。</p><p>为什么要这样做呢？因为这样做可以<strong>降低hash冲突的概率</strong>，如果说老是用低16位去做运算定位数组索引的话，就会导致一定的hash冲突。</p><p>继续看put的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 刚开始，数组都是空的，这里就分配一个默认的大小，也就是16</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// (n - 1) &amp; hash 通过位运算，来实现了一个取模的效果，而且每次扩容，都是2的n次方，只要保证数组的大小是2的n次方，就能保证(n - 1) &amp; hash和 hash % 数组.length取模是一样的效果</span></span><br><span class="line"><span class="comment">// 比直接取模，效率高很多</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>这个取模的优化，是hashmap非常重要的优化点</p><h4 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h4><p>接着看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 这个 (n - 1) &amp; hash 很重要</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 满足这个条件，说明是相同的key，覆盖旧的值就好</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 处理红黑树的情况</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的总长度达到了8，那么链表就要转变成红黑树了</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相同的key，替换新的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>这个红黑树的具体算法，非常复杂，有什么翻转，变色什么的，就当成黑盒来看吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环的方式，先转成双向链表，然后转成成一棵树</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前面的源码看，如果put的时候发现一家是一个红黑树了，那么就是直接往红黑树上挂节点了。</p><p><code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code></p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>HashMap基于数组的数据结构，那么必然会有扩容的问题，它的原理就是，达到负载因子的的数量后，就进行2倍扩容，然后rehash，每一个key-value对，都会基于key的hash值重新寻址找到新数组的新的位置。</p><p>比如他之前的长度是16，新的数组长度是32</p><p>之前那些key的hash可能之前对16取模的位置是5，那么对32取模后，他的位置就变成了11，位置发生了变化。</p><p>这是1.7之前的原理，1.8以后，他就不是直接取模了，用的是与运算的位操作来实现高性能的取模操作，但是这个就要求数组的长度必须是2的n次方。</p><p>举一个扩容的例子。</p><p>还记得寻址的算法么：<code>tab[i = (n - 1) &amp; hash]</code></p><p>此时，n=16</p><p>第一个key</p><p>n - 1    0000 0000 0000 0000 0000 0000 0000 1111</p><p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p><p>&amp;结果  0000 0000 0000 0000 0000 0000 0000 0101  = 5（index = 5的位置）</p><p>第二个key</p><p>n - 1 0000 0000 0000 0000 0000 0000 0000 1111</p><p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p>他们就是在同一个位置，然后数组扩容，变成了32</p><p>此时，n=32</p><p>第一个key</p><p>n-1 0000 0000 0000 0000 0000 0000 0001 1111</p><p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p><p> 第二个key</p><p>n-1      0000 0000 0000 0000 0000 0000 0001 1111</p><p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p><p>&amp;结果 0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 21的位置）</p><p>第一个位置没有变，但是第二个就变成了21。</p><p>所以规律是什么？</p><ol><li>首先，数组的长度肯定是2的倍数，16-&gt;32-&gt;64-&gt;128</li><li>扩容之后，key要么在之前的index位置，要么就变成了之前的index（5） + oldCap（16） = 21的位置</li></ol><p>贴下扩容的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 这就是数组2倍扩容了</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// e.next是null，说明就是一个单节点，直接重新计算一下hash放过去就好了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，就基于红黑树的算法讲每一个节点都重新hash寻址，找到各自的新数组位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 这里就是链表了</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 还是在之前的位置</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 如果是链表，它在新数组的位置就是之前的index+oldCap </span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>HashMap看完了，LinkedHashMap也就简单了，它就是多了一个功能，它会记录你插入的顺序，如果你去遍历LinkedHashMap，是按照你插入的顺序来遍历的。</p><p>如果面试官问，LinkedHashMap和TreeMap，都可以维持key顺序，那区别是什么？LinkedHashMap是基于链表实现的，它的顺序是key的插入顺序，TreeMap的基于红黑树实现的，它的顺序是基于key的某个排序算法来排序的。</p><p>LinkedHashMap和HashMap的原理，大致是一样的，区别就是在插入、更新、删除的时候，他会记录一下key的顺序。他的put方法，其实也还是调用的HashMap的put方法，但是在执行结束之后，有一个<code>afterNodeInsertion(evict);</code>方法，这个方法在HashMap的实现中是空实现。但是在LinkedHashMap中，他就覆盖了这个方法，其实一共有3个方法在不同的地方会被回调到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>他用了一个链表的结构，来存储了key插入的顺序，这个数据结构就是，直接继承了HashMap的Node，然后增加了before和after参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后每次都会调用linkNodeLast方法， 将这个节点挂在链表的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么覆盖，会不会改变他的顺序呢，默认是不会的，</p><p>LInkedHashMap有一个字段，accessOrder，可在构造方法的时候传入，如果为true，则访问后也会刷新位置，否则只是插入才会记录位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>为true，get和put方法，都会导致这个key对应的Entry移动到链表的尾部去，删除元素的时候，也会从链表里删除。</p><p>迭代的时候，就会从链表的头部，也就是head节点开始按顺序迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>![image-20201020131704780](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201020131704780.png)</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是用红黑树做的数据结构，用红黑树维护了key的顺序，可以按照指定顺序进行迭代。</p><p>它有自己的Entry结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，TreeMap是按照自然排序，也就是字典序来对key进行排序的。如果想定制排序规则的话，可以在构造方法中参数排序比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashSet、LinkedHashSet、TreeSet"><a href="#HashSet、LinkedHashSet、TreeSet" class="headerlink" title="HashSet、LinkedHashSet、TreeSet"></a>HashSet、LinkedHashSet、TreeSet</h2><p>Set的源码，没什么好说的，他其实就是继承自HashMap，然后只用了key的结构，value都是空值。</p><p>比如HashSet，LinkedHashSet，TreeSet都是。</p><p>HashSet，就是无序的，LinkedHashSet就是插入顺序，TreeSet就是可排序的，都是不可重复的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Map源码&quot;&gt;&lt;a href=&quot;#Map源码&quot; class=&quot;headerlink&quot; title=&quot;Map源码&quot;&gt;&lt;/a&gt;Map源码&lt;/h1&gt;&lt;p&gt;Map是集合里一个非常重要的数据结构，面试也是会经常问到源码的。&lt;/p&gt;
&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;p&gt;简单描述一下HashMap的原理，它的结构就是数组+链表+红黑树。&lt;/p&gt;
&lt;p&gt;put的时候，对key进行hash，找到对应的数组位置放在里面，然后hash冲突了就组成链表往后追加。查询的时候也是一样，对key进行hash，然后用equals去比较链表上key的值。&lt;/p&gt;
&lt;p&gt;JDK1.8优化了hashmap的数据结构，如果链表过长，达到8以后，就会转变成红黑树。&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;这个数组的初始化长度，是16，和ArrayList不一样。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// aka 16	&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始数组大小，默认是16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JDK源码" scheme="http://www.saily.top/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
    <category term="JDK源码" scheme="http://www.saily.top/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</title>
    <link href="http://www.saily.top/2020/06/04/springcloud/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B9%B6%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.saily.top/2020/06/04/springcloud/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B9%B6%E8%A7%A3%E5%86%B3/</id>
    <published>2020-06-04T13:55:39.000Z</published>
    <updated>2020-06-04T14:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次线上故障排查并解决-Spring-Cloud健康检查的坑"><a href="#记一次线上故障排查并解决-Spring-Cloud健康检查的坑" class="headerlink" title="记一次线上故障排查并解决(Spring Cloud健康检查的坑)"></a>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</h1><p>今天下班在回家路上的时候，同事反馈他们的生产环境项目不停的在输出错误日志，一时半会没有找到原因，让我帮忙看看。我到家后登录VPN，打开了kibana查看日志，确实一直在报错，错误日志如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: 断开的管道    </span><br><span class="line">at sun.nio.ch.FileDispatcherImpl.write0(Native Method)    </span><br><span class="line">at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:<span class="number">47</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:<span class="number">93</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.write(IOUtil.java:<span class="number">65</span>)    </span><br><span class="line">at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:<span class="number">471</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:<span class="number">134</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:<span class="number">101</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:<span class="number">157</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:<span class="number">1276</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:<span class="number">670</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:<span class="number">607</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:<span class="number">597</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:<span class="number">646</span>)    </span><br><span class="line">at org.apache.coyote.http11.filters.ChunkedOutputFilter.flush(ChunkedOutputFilter.java:<span class="number">169</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:<span class="number">252</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:<span class="number">1564</span>)    </span><br><span class="line">at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:<span class="number">352</span>)    </span><br><span class="line">at org.apache.coyote.Response.action(Response.java:<span class="number">173</span>)    </span><br><span class="line">at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:<span class="number">317</span>)    </span><br><span class="line">... <span class="number">92</span> more </span><br></pre></td></tr></table></figure><p>搜索<code>ERROR</code>级别日志，看到的全是这个日志，而且有两个项目都在输出这个错误日志，询问同事后确定了几个问题：</p><ol><li>项目近期没有升级</li><li>这两个项目当前都没有人访问，也就是没有接口流量</li><li>这个日志似乎是有周期性的输出，1分钟~3分钟不等</li></ol><p>记录一下我自己的排查思路，首先项目没有流量，也没有人访问，<strong>但是这个错明显是有接口请求，并且是因为客户端主动断开链接导致的，这一点可以确定</strong>。那么再结合周期性的错误日志输出，我首先想到的是不是采集监控的端点，或者是健康检查的端点出问题了，于是我登录堡垒机，测试了一下问题项目的采集监控数据的接口，没有问题，健康检查端点也没有问题，都是可以访问的。</p><p>我们的项目是SpringCloud的，所以健康检查端点是：<code>/actuator/health</code>，但是我多刷新了几次，发现有的时候很慢，有的时候很快，慢的时候能达到十几二十秒，健康检查的结果才出来。因为我们的项目是接入了prometheus的，紧接着我又去看了下监控，没有发现问题（监控排除了健康检查端点的访问情况，因为如果是SLB的话每秒会检查10+次），于是我将Grafana中的条件做了调整，得到了健康检查端点的耗时情况。</p><p><img src="/img/spring-cloud/image-20200604221611065.png" alt="image-20200604221611065"></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>可以看得出来，健康检查端点的耗时确实很长，基本可以确定，上面异常产生的原因是因为consul在对服务进行心跳检查的时候，<strong>超时了</strong>。所以consul的agent主动断开了<code>/actuator/health</code>的请求，所以得到了 <code>java.io.IOException: Broken pipe</code>的错误。</p><p><img src="/img/spring-cloud/image-20200604222132779.png" alt="image-20200604222132779"></p><p>这一点从监控数据原文里也得到了确认，是健康检查的端点在输出异常日志。</p><h2 id="为什么健康检查端点会超时"><a href="#为什么健康检查端点会超时" class="headerlink" title="为什么健康检查端点会超时"></a>为什么健康检查端点会超时</h2><p>现在知道了原因，但是这只是表面现象，为什么健康检查会超时？这不太正常，之前都是好好的，为什么突然开始就一直超时了，于是我开始观察健康检查里都有些什么内容，发现有一个可能会比较耗时的东西。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mail&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;xxx.com:-1&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我对比了这两个出问题的项目，他们都有邮件的健康检查，我问了下同事，是不是只有这两个项目会用到发邮件的功能，而其他项目没有，同事确认说是的。</p><p>基本可以确认，就是因为邮件的健康检查导致的，可能因为网络或是什么原因，导致邮件服务器的健康检查比较慢，从而导致健康检查的端点也非常耗时。</p><p>所以联系了运维的同事，加上了以下配置，关闭了邮件的健康检查。因为邮件并不是核心的功能，所以先关闭掉，验证一下是否能解决问题。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.health.mail.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>在加入配置关闭邮件服务器的健康检查以后，重启服务，观察了5分钟日志，发现一切恢复如初，没有产生新的异常日志，健康检查的端点，也变得非常快了。</p><p><img src="/img/spring-cloud/image-20200604223511793.png" alt="image-20200604223511793"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本次故障是因为邮件服务器的健康检查很慢，导致consul对服务进行心跳检查的时候超时，主动断开连接，然后定期的输出了 <code>java.io.IOException: Broken pipe</code>的异常日志。</p><p>关于SpringCloud提供的健康检查机制，其实大多数情况下，好多功能的检查都可以关闭，按需打开，举个例子，如果Redis挂掉了，这里整个服务的健康检查就会是<strong>DOWN</strong>了，会直接导致其他服务无法调用，但是实际上在业务中如果Redis挂掉的话，我们是会去做降级从数据库查询的，仍然可以为其他服务提供调用。</p><p>所以我们在项目里，完全可以把这些第三方中间件的健康检查默认给关闭掉。按需打开必要的健康检查选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">health:</span></span><br><span class="line">    <span class="attr">defaults:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 按需打开db或者redis等中间件健康检查</span></span><br><span class="line">    <span class="attr">db:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记一次线上故障排查并解决-Spring-Cloud健康检查的坑&quot;&gt;&lt;a href=&quot;#记一次线上故障排查并解决-Spring-Cloud健康检查的坑&quot; class=&quot;headerlink&quot; title=&quot;记一次线上故障排查并解决(Spring Cloud健康检查的坑)&quot;&gt;&lt;/a&gt;记一次线上故障排查并解决(Spring Cloud健康检查的坑)&lt;/h1&gt;&lt;p&gt;今天下班在回家路上的时候，同事反馈他们的生产环境项目不停的在输出错误日志，一时半会没有找到原因，让我帮忙看看。我到家后登录VPN，打开了kibana查看日志，确实一直在报错，错误日志如下：&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Netflix生产实践</title>
    <link href="http://www.saily.top/2020/05/17/springcloud/SpringCloud%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.saily.top/2020/05/17/springcloud/SpringCloud%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-05-17T12:57:58.000Z</published>
    <updated>2020-05-27T14:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务注册生产实践"><a href="#服务注册生产实践" class="headerlink" title="服务注册生产实践"></a>服务注册生产实践</h1><h2 id="服务注册的时效性（毫秒级）"><a href="#服务注册的时效性（毫秒级）" class="headerlink" title="服务注册的时效性（毫秒级）"></a>服务注册的时效性（毫秒级）</h2><p>服务在启动后，会向eureka server发起注册，应该是在1秒以内的。</p><p>会通过SpringCloud额外封装的<code>EurekaAutoServiceRegistration#start()</code>发起注册，这个类的实例被EurekaClientAutoConfiguration定义。</p><h2 id="服务发现的时效性（毫秒级和分钟级）"><a href="#服务发现的时效性（毫秒级和分钟级）" class="headerlink" title="服务发现的时效性（毫秒级和分钟级）"></a>服务发现的时效性（毫秒级和分钟级）</h2><p>一个服务启动后，发现其他所有的服务需要多长时间？如果其他服务新增了机器，那么又需要多长时间才能发现。</p><ol><li>服务启动后，会主动拉取全量注册表，可以发现已经注册的服务列表（毫秒级）</li><li>服务每隔30秒会拉取增量注册表（先走ALL_APPS_DELTA缓存，读不到查queue）</li><li>eureka server 二级缓存，定时任务30秒从readWriterCacheMap同步到readOnlyCacheMap</li><li>一个服务启动注册后，要30秒才会被其他服务发现（1分钟以内）</li></ol><a id="more"></a><p>eureka的服务发现是分钟级，可通过修改配置减少这个时间：</p><p>eureka client端(EurekaClientConfigBean)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.client.registryFetchIntervalSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><p>eureka server端(EurekaServerConfigBean)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.server.responseCacheUpdateIntervalMs</span>=<span class="string">30 * 1000</span></span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7%E5%88%86%E6%9E%90.png" alt="服务发现的时效性分析"></p><h2 id="服务心跳的时效性（30秒）"><a href="#服务心跳的时效性（30秒）" class="headerlink" title="服务心跳的时效性（30秒）"></a>服务心跳的时效性（30秒）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务心跳流程分析</a></p><p>服务启动以后，会定时发送心跳给eureka server，默认是30秒一次(EurekaInstanceConfigBean)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.instance.leaseRenewalIntervalInSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><h2 id="服务故障感知的时效性（5分）"><a href="#服务故障感知的时效性（5分）" class="headerlink" title="服务故障感知的时效性（5分）"></a>服务故障感知的时效性（5分）</h2><p><a href="%5Bhttp://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%5D(http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)">服务故障流程分析</a></p><p>在eureka server中，每隔60秒会执行一次evict task（加上JVM gc等原因的补偿时间），判断当前所有的服务实例是否有的实例出现了故障（一直没有发送心跳）。</p><p>这个任务的逻辑是，默认90s没有收到过心跳就认为已经过期，但是这里有bug，实际上是90s * 2 = 180s才会认为已经故障了，那么算到这里，eureka server可能要4分钟才能感知到一个服务宕机后认为是下线了。 （而且每次只会摘除最多15%数量的故障实例）,</p><p><strong>客户端</strong>：服务摘除后，会清空readWriteCacheMap的缓存，算eureka server的读写缓存30秒，然后每隔30秒会同步到readOnlyCacheMap里。所以宕机后要被客户端感知到，极端情况下可能要5分钟。</p><h2 id="服务下线感知的时效性（1分钟）"><a href="#服务下线感知的时效性（1分钟）" class="headerlink" title="服务下线感知的时效性（1分钟）"></a>服务下线感知的时效性（1分钟）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务下线流程分析</a></p><p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。逻辑也是从内存的map里删除，然后放入recentlyChangedQueue队列里，最后让缓存失效。</p><p>无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能<strong>60秒</strong>才能感知到服务的下线。</p><h2 id="eureka-server自我保护机制（不要用）"><a href="#eureka-server自我保护机制（不要用）" class="headerlink" title="eureka server自我保护机制（不要用）"></a>eureka server自我保护机制（不要用）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">服务自我保护机制</a></p><p>eureka的自我保护机制，充斥着大量的hash code硬编码，写死你的心跳间隔时间是30秒，1分钟2次，通过统计服务的心跳次数来判断自己是不是网络故障了。这个根本就是很严重的bug，无法在生产环境使用。</p><p>直接在配置中关闭</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.server.enableSelfPreservation</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><h2 id="eureka-server集群的负载均衡（按配置顺序）"><a href="#eureka-server集群的负载均衡（按配置顺序）" class="headerlink" title="eureka server集群的负载均衡（按配置顺序）"></a>eureka server集群的负载均衡（按配置顺序）</h2><p>服务在注册的时候，如果在yml里配置了多个eureka server，会按顺序用第一个eureka server的机器发起注册，只有在第一个机器挂掉的情况下，在重试一定次数失败以后，才会尝试用第二台机器。</p><p>那如果第一台又恢复了呢，其实还是会一直用第二台，除非第二台死掉了，才会重试别的机器。</p><p>这些重试的逻辑的源码，都在<code>RetryableEurekaHttpClient</code>类里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</span><br><span class="line">    List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</span><br><span class="line">        EurekaHttpClient currentHttpClient = delegate.get();</span><br><span class="line">        EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></span><br><span class="line">            <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateHosts = getHostCandidates();</span><br><span class="line">                <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;There is no known eureka server; cluster server list is empty&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></span><br><span class="line">            <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Cannot execute request on any known server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建候选的 EurekaHttpClient</span></span><br><span class="line">            currentEndpoint = candidateHosts.get(endpointIdx++);</span><br><span class="line">            currentHttpClient = clientFactory.newClient(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</span><br><span class="line">            <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></span><br><span class="line">            <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</span><br><span class="line">                delegate.set(currentHttpClient);</span><br><span class="line">                <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Request execution succeeded on retry #&#123;&#125;&quot;</span>, retry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failure with status code &#123;&#125;; retrying on another server if available&quot;</span>, response.getStatusCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failed with message: &#123;&#125;&quot;</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></span><br><span class="line">        <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></span><br><span class="line">        delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></span><br><span class="line">        <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quarantineSet.add(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Retry limit reached; giving up on completing the request&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eureka-server集群同步的时效性（1秒内）"><a href="#eureka-server集群同步的时效性（1秒内）" class="headerlink" title="eureka server集群同步的时效性（1秒内）"></a>eureka server集群同步的时效性（1秒内）</h2><p><a href="http://www.saily.top/2020/03/28/springcloud/eureka05/#%E6%B3%A8%E5%86%8C%E3%80%81%E4%B8%8B%E7%BA%BF%E3%80%81%E6%95%85%E9%9A%9C%E9%9B%86%E7%BE%A4%E9%97%B4%E5%90%8C%E6%AD%A5">集群间同步</a></p><p>在eureka server收到注册请求的时候，就会将注册数据同步到其他节点，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，并且这里包含了一个注册逻辑的批处理。</p><p><img src="http://www.saily.top/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p><p>可以看到，因为有一个批处理的机制，每500毫秒以内的请求会统一打包处理，所以集群间的数据同步，是一秒以内完成同步。</p><h1 id="服务调用生产实践"><a href="#服务调用生产实践" class="headerlink" title="服务调用生产实践"></a>服务调用生产实践</h1><h2 id="Ribbon-Eureka服务发现与故障的时效性"><a href="#Ribbon-Eureka服务发现与故障的时效性" class="headerlink" title="Ribbon+Eureka服务发现与故障的时效性"></a>Ribbon+Eureka服务发现与故障的时效性</h2><h3 id="服务正常上线-修改，最大可能会有60s滞后"><a href="#服务正常上线-修改，最大可能会有60s滞后" class="headerlink" title="服务正常上线/修改，最大可能会有60s滞后"></a>服务正常上线/修改，最大可能会有60s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br></pre></td></tr></table></figure><p>前面已经分析了Eureka本身的时效性，刚启动发现其他服务是毫秒级，发现新注册的服务是分钟级。那么在结合Ribbon使用后，他有一个PollingServerListUpdater，这个是每30秒从eureka client同步一次到Ribbon的缓存中，所以一个新注册的服务要被Ribbon感知到，极端情况下需要90秒。</p><h3 id="服务异常下线：最大可能会有300s滞后"><a href="#服务异常下线：最大可能会有300s滞后" class="headerlink" title="服务异常下线：最大可能会有300s滞后"></a>服务异常下线：最大可能会有300s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 定时清理任务每eureka.server.evictionIntervalTimerInMs(默认60)执行一次清理任务</span><br><span class="line">- 每次清理任务会把90秒(3个心跳周期，eureka.instance.leaseExpirationDurationInSeconds)没收到心跳的踢除，但是根据官方的说法 ，因为代码实现的bug，这个时间其实是两倍，即180秒，也就是说如果一个客户端因为网络问题或者主机问题异常下线，可能会在180秒后才剔除</span><br><span class="line">- 读取端，因为readOnlyCacheMap以及客户端缓存的存在，可能会在30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br><span class="line">- 所以极端情况最终可能会是60+180+90&#x3D;330</span><br></pre></td></tr></table></figure><p>那如果某一个服务宕机了，Eureka Client感知到的时间是5分钟，再加上Ribbon的PollingServerListUpdater的30秒，Ribbon在极端情况下是需要5.5分钟才能感知到。</p><h2 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h2><p>Ribbon默认是用ZoneAwareLoadBalancer，默认算法就是轮询</p><p><a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">负载均衡算法如何选择一个server</a></p><h2 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h2><p><a href="http://www.saily.top/2020/04/18/springcloud/feign04/">Feign超时和重试分析</a></p><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>feign的超时时间优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="Ribbon预加载"><a href="#Ribbon预加载" class="headerlink" title="Ribbon预加载"></a>Ribbon预加载</h2><p>网关的项目第一次访问的时候总是会超时，是因为在第一次访问的时候，Ribbon会去调用eureka-client里的服务列表，所以这里会消耗一些时间，而zuul默认超时时间又是1秒，所以加上下面的参数，让Ribbon提前加载好。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure><h2 id="Zuul-Ribbon-eureka感知服务上线和故障的时效性"><a href="#Zuul-Ribbon-eureka感知服务上线和故障的时效性" class="headerlink" title="Zuul+Ribbon+eureka感知服务上线和故障的时效性"></a>Zuul+Ribbon+eureka感知服务上线和故障的时效性</h2><p>这块儿和<a href="#Ribbon+Eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7">Ribbon+Eureka服务发现与故障的时效性</a>是一样的</p><h2 id="Zuul降级和异常"><a href="#Zuul降级和异常" class="headerlink" title="Zuul降级和异常"></a>Zuul降级和异常</h2><p>Error Filter错误处理和<a href="http://www.saily.top/2020/05/10/springcloud/zuul01/#hystrix%E9%85%8D%E7%BD%AE">降级</a></p><h2 id="Zuul超时"><a href="#Zuul超时" class="headerlink" title="Zuul超时"></a>Zuul超时</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Hystrix的超时时间应该大于Ribbon的超时时间，加上Ribbon的重试机制，基于上面的参数计算，(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)。</p><p>Hystrix的超时时间应该是设置为8秒。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;服务注册生产实践&quot;&gt;&lt;a href=&quot;#服务注册生产实践&quot; class=&quot;headerlink&quot; title=&quot;服务注册生产实践&quot;&gt;&lt;/a&gt;服务注册生产实践&lt;/h1&gt;&lt;h2 id=&quot;服务注册的时效性（毫秒级）&quot;&gt;&lt;a href=&quot;#服务注册的时效性（毫秒级）&quot; class=&quot;headerlink&quot; title=&quot;服务注册的时效性（毫秒级）&quot;&gt;&lt;/a&gt;服务注册的时效性（毫秒级）&lt;/h2&gt;&lt;p&gt;服务在启动后，会向eureka server发起注册，应该是在1秒以内的。&lt;/p&gt;
&lt;p&gt;会通过SpringCloud额外封装的&lt;code&gt;EurekaAutoServiceRegistration#start()&lt;/code&gt;发起注册，这个类的实例被EurekaClientAutoConfiguration定义。&lt;/p&gt;
&lt;h2 id=&quot;服务发现的时效性（毫秒级和分钟级）&quot;&gt;&lt;a href=&quot;#服务发现的时效性（毫秒级和分钟级）&quot; class=&quot;headerlink&quot; title=&quot;服务发现的时效性（毫秒级和分钟级）&quot;&gt;&lt;/a&gt;服务发现的时效性（毫秒级和分钟级）&lt;/h2&gt;&lt;p&gt;一个服务启动后，发现其他所有的服务需要多长时间？如果其他服务新增了机器，那么又需要多长时间才能发现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务启动后，会主动拉取全量注册表，可以发现已经注册的服务列表（毫秒级）&lt;/li&gt;
&lt;li&gt;服务每隔30秒会拉取增量注册表（先走ALL_APPS_DELTA缓存，读不到查queue）&lt;/li&gt;
&lt;li&gt;eureka server 二级缓存，定时任务30秒从readWriterCacheMap同步到readOnlyCacheMap&lt;/li&gt;
&lt;li&gt;一个服务启动注册后，要30秒才会被其他服务发现（1分钟以内）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Zuul02-核心流程和源码分析</title>
    <link href="http://www.saily.top/2020/05/11/springcloud/zuul02/"/>
    <id>http://www.saily.top/2020/05/11/springcloud/zuul02/</id>
    <published>2020-05-11T14:12:59.000Z</published>
    <updated>2020-05-13T15:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>在看Zuul的原理之前，要先熟透Ribbon和Hystrix的原理，因为Zuul就是基于这2个组件来做的。</p><p>画个图概括下:</p><p><img src="/img/spring-cloud/Zuul%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B.jpg" alt="Zuul的核心流程"></p><a id="more"></a><h1 id="EnableZuulProxy"><a href="#EnableZuulProxy" class="headerlink" title="@EnableZuulProxy"></a>@EnableZuulProxy</h1><p>会自动开启一个ZuulProxyAutoConfiguration的自动装配，里面定义了很多的Bean，包括RouteLocator、过滤器等和的一些组件。他的父类<code>ZuulServerAutoConfiguration</code>，也包含了很多配置的定义，其中就包括了ZuulServlet，这个是zuul核心请求的入口，拦截所有的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">zuulServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean servlet = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> ZuulServlet(),</span><br><span class="line">         <span class="keyword">this</span>.zuulProperties.getServletPattern());</span><br><span class="line">   <span class="comment">// The whole point of exposing this servlet is to provide a route that doesn&#x27;t</span></span><br><span class="line">   <span class="comment">// buffer requests.</span></span><br><span class="line">   servlet.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ZuulServlet"><a href="#ZuulServlet" class="headerlink" title="ZuulServlet"></a>ZuulServlet</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化RequestContext</span></span><br><span class="line">        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span></span><br><span class="line">        <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先调用pre 过滤器</span></span><br><span class="line">            preRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="comment">// 报错了，先是error过滤器</span></span><br><span class="line">            error(e);</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是 route 过滤器</span></span><br><span class="line">            route();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNHANDLED_EXCEPTION_&quot;</span> + e.getClass().getName()));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理掉ThreadLocal</span></span><br><span class="line">        RequestContext.getCurrentContext().unset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init方法，对RequestContext进行了初始化，他是用ThreadLocal实现的，用装饰器模式包装了Request和Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这个是用ThreadLocal实现的</span></span><br><span class="line">    RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    <span class="comment">// 这个默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (bufferRequests) &#123;</span><br><span class="line">        ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.setRequest(servletRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZuulServlet的代码就能看出来，过滤器的执行逻辑是先执行pre，然后是route，如果这2个filter报错了，就会先执行error，然后是post，但是如果在post阶段报错，就直接执行error。</p><p>然后还有一个类是<code>ZuulServletFilter</code>，这个类和<code>ZuulServlet</code>的代码几乎是一样的，只不过zuul提供了filter和servlet两种方式提供服务，默认情况下是<code>ZuulServlet</code>。</p><p>下面开始看Zuul自带的过滤器</p><h1 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h1><ul><li>-3：ServletDetectionFilter</li><li>-2：Servlet30WrapperFilter</li><li>-1：FromBodyWrapperFilter</li><li>1：DebugFilter</li><li>5：PreDecorationFilter</li></ul><p>所有的filter都是通过FilterProcessor.runFilters()方法来执行的，参数作为过滤器的类型来执行对应阶段的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runFilters(<span class="string">&quot;pre&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">        Debug.addRoutingDebug(<span class="string">&quot;Invoking &#123;&quot;</span> + sType + <span class="string">&quot;&#125; type filters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 根据指定的过滤器类型，比如pre，找到所有的pre类型的过滤器，并且是按照优先级排序的</span></span><br><span class="line">    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">            Object result = processZuulFilter(zuulFilter);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                bResult |= ((Boolean) result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServletDetectionFilter"><a href="#ServletDetectionFilter" class="headerlink" title="ServletDetectionFilter"></a>ServletDetectionFilter</h2><p>设置isDispatcherServletRequest=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 就判断了下，然后设置了一个标识</span></span><br><span class="line">   <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequestWrapper) </span><br><span class="line">         &amp;&amp; isDispatcherServletRequest(request)) &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet30WrapperFilter"><a href="#Servlet30WrapperFilter" class="headerlink" title="Servlet30WrapperFilter"></a>Servlet30WrapperFilter</h2><p>用Servlet30RequestWrapper包裹了下request，说Zuul 1.2.2里有个bug，HttpServletRequestWrapper没有返回原生的request，所以包裹了以后，getRequest()方法返回原生的request。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 不成立</span></span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      request = (HttpServletRequest) ReflectionUtils.getField(<span class="keyword">this</span>.requestField,</span><br><span class="line">            request);</span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用Servlet30RequestWrapper包装下</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (RequestUtils.isDispatcherServletRequest()) &#123;</span><br><span class="line">      <span class="comment">// If it&#x27;s going through the dispatcher we need to buffer the body</span></span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FormBodyWrapperFilter"><a href="#FormBodyWrapperFilter" class="headerlink" title="FormBodyWrapperFilter"></a>FormBodyWrapperFilter</h2><p>只有在请求content-type为APPLICATION_FORM_URLENCODED或者MULTIPART_FORM_DATA的时候，才会执行这个filter，他一样也是会将用request用FormBodyRequestWrapper包裹一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   FormBodyRequestWrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      HttpServletRequest wrapped = (HttpServletRequest) ReflectionUtils</span><br><span class="line">            .getField(<span class="keyword">this</span>.requestField, request);</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(wrapped);</span><br><span class="line">      ReflectionUtils.setField(<span class="keyword">this</span>.requestField, request, wrapper);</span><br><span class="line">      <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletRequestWrapper) &#123;</span><br><span class="line">         ReflectionUtils.setField(<span class="keyword">this</span>.servletRequestField, request, wrapper);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(request);</span><br><span class="line">      ctx.setRequest(wrapper);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ctx.getZuulRequestHeaders().put(<span class="string">&quot;content-type&quot;</span>, wrapper.getContentType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DebugFilter"><a href="#DebugFilter" class="headerlink" title="DebugFilter"></a>DebugFilter</h2><p>在http参数传一个?debug=true才会执行这个，然后就设置了2个属性，后续打日志的时候会用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HttpServletRequest request = RequestContext.getCurrentContext().getRequest();</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(request.getParameter(DEBUG_PARAMETER.get()))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ROUTING_DEBUG.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   ctx.setDebugRouting(<span class="keyword">true</span>);</span><br><span class="line">   ctx.setDebugRequest(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PreDecorationFilter"><a href="#PreDecorationFilter" class="headerlink" title="PreDecorationFilter"></a>PreDecorationFilter</h2><p>这个过滤器逻辑稍显复杂，也是核心的一个逻辑，承担了解析路由的工作</p><ol><li>解析请求url，拿到了请求的地址</li><li>根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置，这个routeLocator是SimpleRouteLocator，在这里可以做一定的定制化，将route给做到mysql里去。</li><li>将Route规则设置到RequestContext中，加了一些请求头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="comment">// 拿到了请求的url path</span></span><br><span class="line">   <span class="keyword">final</span> String requestURI = <span class="keyword">this</span>.urlPathHelper.getPathWithinApplication(ctx.getRequest());</span><br><span class="line">   <span class="comment">// 根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置</span></span><br><span class="line">   Route route = <span class="keyword">this</span>.routeLocator.getMatchingRoute(requestURI);</span><br><span class="line">   <span class="keyword">if</span> (route != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String location = route.getLocation();</span><br><span class="line">      <span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// route相关规则放进ctx</span></span><br><span class="line">         ctx.put(REQUEST_URI_KEY, route.getPath());</span><br><span class="line">         ctx.put(PROXY_KEY, route.getId());</span><br><span class="line">         <span class="keyword">if</span> (!route.isCustomSensitiveHeaders()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper</span><br><span class="line">                  .addIgnoredHeaders(<span class="keyword">this</span>.properties.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper.addIgnoredHeaders(route.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (route.getRetryable() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.put(RETRYABLE_KEY, route.getRetryable());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (location.startsWith(HTTP_SCHEME+<span class="string">&quot;:&quot;</span>) || location.startsWith(HTTPS_SCHEME+<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">            ctx.setRouteHost(getUrl(location));</span><br><span class="line">            <span class="comment">// 添加了一些header</span></span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(FORWARD_LOCATION_PREFIX)) &#123;</span><br><span class="line">            ctx.set(FORWARD_TO_KEY,</span><br><span class="line">                  StringUtils.cleanPath(location.substring(FORWARD_LOCATION_PREFIX.length()) + route.getPath()));</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// set serviceId for use in filters.route.RibbonRequest</span></span><br><span class="line">            ctx.set(SERVICE_ID_KEY, location);</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_ID_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddProxyHeaders()) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            addProxyHeaders(ctx, route);</span><br><span class="line">            String xforwardedfor = ctx.getRequest().getHeader(X_FORWARDED_FOR_HEADER);</span><br><span class="line">            String remoteAddr = ctx.getRequest().getRemoteAddr();</span><br><span class="line">            <span class="keyword">if</span> (xforwardedfor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               xforwardedfor = remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!xforwardedfor.contains(remoteAddr)) &#123; <span class="comment">// Prevent duplicates</span></span><br><span class="line">               xforwardedfor += <span class="string">&quot;, &quot;</span> + remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.addZuulRequestHeader(X_FORWARDED_FOR_HEADER, xforwardedfor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddHostHeader()) &#123;</span><br><span class="line">            ctx.addZuulRequestHeader(HttpHeaders.HOST, toHostHeader(ctx.getRequest()));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;No route found for uri: &quot;</span> + requestURI);</span><br><span class="line"></span><br><span class="line">      String fallBackUri = requestURI;</span><br><span class="line">      String fallbackPrefix = <span class="keyword">this</span>.dispatcherServletPath; <span class="comment">// default fallback</span></span><br><span class="line">                                             <span class="comment">// servlet is</span></span><br><span class="line">                                             <span class="comment">// DispatcherServlet</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (RequestUtils.isZuulServletRequest()) &#123;</span><br><span class="line">         <span class="comment">// remove the Zuul servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;zuulServletPath=&quot;</span> + <span class="keyword">this</span>.properties.getServletPath());</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.properties.getServletPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced Zuul servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// remove the DispatcherServlet servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;dispatcherServletPath=&quot;</span> + <span class="keyword">this</span>.dispatcherServletPath);</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.dispatcherServletPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced DispatcherServlet servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fallBackUri.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         fallBackUri = <span class="string">&quot;/&quot;</span> + fallBackUri;</span><br><span class="line">      &#125;</span><br><span class="line">      String forwardURI = fallbackPrefix + fallBackUri;</span><br><span class="line">      forwardURI = forwardURI.replaceAll(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">      ctx.set(FORWARD_TO_KEY, forwardURI);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleRouteLocator"><a href="#SimpleRouteLocator" class="headerlink" title="SimpleRouteLocator"></a>SimpleRouteLocator</h3><p>这个就是用来读取和保存路由规则的辅助了，用Map维护了一个<code>private AtomicReference&lt;Map&lt;String, ZuulRoute&gt;&gt; routes = new AtomicReference&lt;&gt;();</code>，主要需要关注它的locateRoutes方法，可以继承这个类，然后重写locateRoutes方法，改为从数据库读取路由配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, ZuulRoute&gt; <span class="title">locateRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LinkedHashMap&lt;String, ZuulRoute&gt; routesMap = <span class="keyword">new</span> LinkedHashMap&lt;String, ZuulRoute&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ZuulRoute route : <span class="keyword">this</span>.properties.getRoutes().values()) &#123;</span><br><span class="line">      routesMap.put(route.getPath(), route);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> routesMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="route过滤器"><a href="#route过滤器" class="headerlink" title="route过滤器"></a>route过滤器</h1><ul><li>10：RibbonRoutingFilter</li><li>100：SimpleHostRoutingFilter</li><li>500：SendForwardFilter</li></ul><h2 id="RibbonRoutingFilter"><a href="#RibbonRoutingFilter" class="headerlink" title="RibbonRoutingFilter"></a>RibbonRoutingFilter</h2><p>如果这个请求是转发给服务的，就会用这个Filter通过Ribbon和Hystrix去执行对应的http请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理Ribbon相关内容</span></span><br><span class="line">      RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">      <span class="comment">// 处理Hystrix，并发送请求</span></span><br><span class="line">      ClientHttpResponse response = forward(commandContext);</span><br><span class="line">      setResponse(response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RibbonCommandContext"><a href="#RibbonCommandContext" class="headerlink" title="RibbonCommandContext"></a>RibbonCommandContext</h3><p>对RequestContext里的数据做了解析，封装成了RibbonCommandContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RibbonCommandContext&#123;serviceId&#x3D;&#39;ServiceB&#39;, method&#x3D;&#39;GET&#39;, uri&#x3D;&#39;&#x2F;ServiceB&#x2F;user&#x2F;sayHello&#x2F;1&#39;, retryable&#x3D;false, headers&#x3D;&#123;accept&#x3D;[application&#x2F;json], cache-control&#x3D;[no-cache], user-agent&#x3D;[Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36], content-type&#x3D;[application&#x2F;json], accept-language&#x3D;[zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8], x-forwarded-host&#x3D;[localhost:9000], x-forwarded-proto&#x3D;[http], x-forwarded-prefix&#x3D;[&#x2F;demo], x-forwarded-port&#x3D;[9000], x-forwarded-for&#x3D;[0:0:0:0:0:0:0:1], Accept-Encoding&#x3D;[gzip]&#125;, params&#x3D;&#123;name&#x3D;[张三], age&#x3D;[20]&#125;, requestEntity&#x3D;com.netflix.zuul.http.ServletInputStreamWrapper@22453c1d, requestCustomizers&#x3D;[], contentLength&#x3D;-1, loadBalancerKey&#x3D;null&#125;</span><br></pre></td></tr></table></figure><h3 id="forward-commandContext"><a href="#forward-commandContext" class="headerlink" title="forward(commandContext);"></a>forward(commandContext);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">         context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">         context.getRequestEntity());</span><br><span class="line">   <span class="comment">// 这个代码没有什么新鲜的逻辑，看过Ribbon代码的话就知道，这里面就是封装了一个基于Ribbon和Hystrix的Command</span></span><br><span class="line">   RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ClientHttpResponse response = command.execute();</span><br><span class="line">      <span class="keyword">this</span>.helper.appendDebug(info, response.getRawStatusCode(), response.getHeaders());</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ribbonCommandFactory.create</code>最终创建的类是HttpClientRibbonCommand，这个类其实就是一个HystrixCommand，他实现了自己的run方法，在run方法里，就包含了执行请求的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRibbonCommand#run()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"></span><br><span class="line">   RQ request = createRequest();</span><br><span class="line">   RS response;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">boolean</span> retryableClient = <span class="keyword">this</span>.client <span class="keyword">instanceof</span> AbstractLoadBalancingClient</span><br><span class="line">         &amp;&amp; ((AbstractLoadBalancingClient)<span class="keyword">this</span>.client).isClientRetryable((ContextAwareRequest)request);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (retryableClient) &#123;</span><br><span class="line">      response = <span class="keyword">this</span>.client.execute(request, config);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用负载均衡客户端发起请求,这里面都是ribbon相关的代码了</span></span><br><span class="line">      response = <span class="keyword">this</span>.client.executeWithLoadBalancer(request, config);</span><br><span class="line">   &#125;</span><br><span class="line">   context.set(<span class="string">&quot;ribbonResponse&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Explicitly close the HttpResponse if the Hystrix command timed out to</span></span><br><span class="line">   <span class="comment">// release the underlying HTTP connection held by the response.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.isResponseTimedOut()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">         response.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RibbonHttpResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleHostRoutingFilter"><a href="#SimpleHostRoutingFilter" class="headerlink" title="SimpleHostRoutingFilter"></a>SimpleHostRoutingFilter</h2><p>如果请求是直接配host转发静态路由的，会走这个filter用apache http发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = context.getRequest();</span><br><span class="line">   MultiValueMap&lt;String, String&gt; headers = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestHeaders(request);</span><br><span class="line">   MultiValueMap&lt;String, String&gt; params = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestQueryParams(request);</span><br><span class="line">   String verb = getVerb(request);</span><br><span class="line">   InputStream requestEntity = getRequestBody(request);</span><br><span class="line">   <span class="keyword">if</span> (getContentLength(request) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      context.setChunkedRequestBody();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String uri = <span class="keyword">this</span>.helper.buildZuulRequestURI(request);</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 利用Apache HttpComponent发送请求</span></span><br><span class="line">      CloseableHttpResponse response = forward(<span class="keyword">this</span>.httpClient, verb, uri, request,</span><br><span class="line">            headers, params, requestEntity);</span><br><span class="line">      setResponse(response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SendForwardFilter"><a href="#SendForwardFilter" class="headerlink" title="SendForwardFilter"></a>SendForwardFilter</h2><p>转发到自己本地的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      String path = (String) ctx.get(FORWARD_TO_KEY);</span><br><span class="line">      RequestDispatcher dispatcher = ctx.getRequest().getRequestDispatcher(path);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_FORWARD_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            dispatcher.forward(ctx.getRequest(), ctx.getResponse());</span><br><span class="line">            ctx.getResponse().flushBuffer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h1><ul><li>900：LocationRewriteFilter</li><li>1000：SendResponseFilter </li></ul><h2 id="LocationRewriteFilter"><a href="#LocationRewriteFilter" class="headerlink" title="LocationRewriteFilter"></a>LocationRewriteFilter</h2><p>默认不执行，看响应结果是否需要重定向，如果是的话才会执行。</p><h2 id="SendResponseFilter"><a href="#SendResponseFilter" class="headerlink" title="SendResponseFilter"></a>SendResponseFilter</h2><p>这个就是添加了一些请求头，然后将响应写入Response，</p><ol><li>优先写入RequestContext.getCurrentContext().getResponseBody()的内容</li><li>然后才是context.getResponseDataStream()，也就是应用返回的内容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      addResponseHeaders();</span><br><span class="line">      writeResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeResponse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"><span class="comment">// there is no body to send</span></span><br><span class="line"><span class="keyword">if</span> (context.getResponseBody() == <span class="keyword">null</span></span><br><span class="line">&amp;&amp; context.getResponseDataStream() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HttpServletResponse servletResponse = context.getResponse();</span><br><span class="line"><span class="keyword">if</span> (servletResponse.getCharacterEncoding() == <span class="keyword">null</span>) &#123; <span class="comment">// only set if not set</span></span><br><span class="line">servletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">OutputStream outStream = servletResponse.getOutputStream();</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 优先写入RequestContext.getCurrentContext().getResponseBody()的内容</span></span><br><span class="line"><span class="keyword">if</span> (RequestContext.getCurrentContext().getResponseBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">String body = RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">writeResponse(</span><br><span class="line"><span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">outStream);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> isGzipRequested = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">final</span> String requestEncoding = context.getRequest()</span><br><span class="line">.getHeader(ZuulHeaders.ACCEPT_ENCODING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestEncoding != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; HTTPRequestUtils.getInstance().isGzipped(requestEncoding)) &#123;</span><br><span class="line">isGzipRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 然后才是context.getResponseDataStream()，也就是应用返回的内容</span></span><br><span class="line">is = context.getResponseDataStream();</span><br><span class="line">InputStream inputStream = is;</span><br><span class="line">      <span class="comment">// ....省略部分代码</span></span><br></pre></td></tr></table></figure><h1 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h1><ul><li>0：SendErrorFilter</li></ul><h2 id="SendErrorFilter"><a href="#SendErrorFilter" class="headerlink" title="SendErrorFilter"></a>SendErrorFilter</h2><p>直接转发到<code>/error</code>路径，这个就是BasicErrorController的路径，所以要想定制异常消息，继承这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      ZuulException exception = findZuulException(ctx.getThrowable());</span><br><span class="line">      HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>, exception.nStatusCode);</span><br><span class="line"></span><br><span class="line">      log.warn(<span class="string">&quot;Error during filtering&quot;</span>, exception);</span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, exception);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(exception.errorCause)) &#123;</span><br><span class="line">         request.setAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>, exception.errorCause);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 直接转发到/error路径，这个就是BasicErrorController，所以要想定制异常消息，继承这个类</span></span><br><span class="line">      RequestDispatcher dispatcher = request.getRequestDispatcher(</span><br><span class="line">            <span class="keyword">this</span>.errorPath);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_ERROR_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            ctx.setResponseStatusCode(exception.nStatusCode);</span><br><span class="line">            dispatcher.forward(request, ctx.getResponse());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h1><p>![Zuul源码分析 (/img/spring-cloud/Zuul源码分析 (1).jpg)](/../../../Downloads/Zuul源码分析 (1).jpg)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;核心流程&quot;&gt;&lt;a href=&quot;#核心流程&quot; class=&quot;headerlink&quot; title=&quot;核心流程&quot;&gt;&lt;/a&gt;核心流程&lt;/h1&gt;&lt;p&gt;在看Zuul的原理之前，要先熟透Ribbon和Hystrix的原理，因为Zuul就是基于这2个组件来做的。&lt;/p&gt;
&lt;p&gt;画个图概括下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/Zuul%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B.jpg&quot; alt=&quot;Zuul的核心流程&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="zuul" scheme="http://www.saily.top/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>Zuul01-网关介绍和基本使用</title>
    <link href="http://www.saily.top/2020/05/10/springcloud/zuul01/"/>
    <id>http://www.saily.top/2020/05/10/springcloud/zuul01/</id>
    <published>2020-05-10T03:23:59.000Z</published>
    <updated>2020-05-11T15:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么微服务需要网关"><a href="#为什么微服务需要网关" class="headerlink" title="为什么微服务需要网关"></a>为什么微服务需要网关</h1><p>在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中聚合数据，而且服务的划分位置结构可能会有所改变。网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。</p><a id="more"></a><p>当然这只是网关众多功能中的一部分，它还可以做负载均衡，统一鉴权，协议转换，监控监测等一系列功能。</p><ol><li>统一安全认证</li><li>统一限流</li><li>统一降级</li><li>统一异常处理</li><li>统一请求统计</li><li>统一超时</li></ol><p><img src="/img/spring-cloud/sgxpes8edv.png" alt="sgxpes8edv"></p><h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>用一张图过一下zuul的核心原理，Zuul是一个责任链模式</p><p><img src="/img/spring-cloud/Zuul%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Zuul核心原理"></p><p>过滤器前面的数字，表示执行的时候的顺序</p><h2 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h2><ul><li><p>-3：ServletDetectionFilter</p></li><li><p>-2：Servlet30WrapperFilter</p></li><li><p>-1：FromBodyWrapperFilter</p></li><li><p>1：DebugFilter</p></li><li><p>5：PreDecorationFilter</p></li></ul><h2 id="routing过滤器"><a href="#routing过滤器" class="headerlink" title="routing过滤器"></a>routing过滤器</h2><ul><li><p>10：RibbonRoutingFilter</p></li><li><p>100：SimpleHostRoutingFilter</p></li><li><p>500：SendForwardFilter</p></li></ul><h2 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h2><ul><li>1000：SendResponseFilter </li></ul><h2 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h2><ul><li>0：SendErrorFilter</li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="路由规则配置"><a href="#路由规则配置" class="headerlink" title="路由规则配置"></a>路由规则配置</h2><h3 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h3><p>SimpleHostRoutingFilter 往指定的地址路由</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SimpleHostRoutingFilter 往指定的地址跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/ServiceB/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">http://localhost:9090/ServiceB</span></span><br><span class="line"><span class="comment"># 这是配置连接到目标主机的最大http连接数，是用来配置http连接池的，默认是200</span></span><br><span class="line"><span class="meta">zuul.host.maxTotalConnections</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 就是每个主机的初始连接数，默认是20</span></span><br><span class="line"><span class="meta">zuul.host.maxPerRouteConnections</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure><h3 id="跳转路由"><a href="#跳转路由" class="headerlink" title="跳转路由"></a>跳转路由</h3><p>SendForwardFilter 往自己的接口跳转</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SendForwardFilter 往自己的接口跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">forward: /gateway/sayHello</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon路由"><a href="#Ribbon路由" class="headerlink" title="Ribbon路由"></a>Ribbon路由</h3><p>RibbonRoutingFilter 基于Ribbon的服务路由</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RibbonRoutingFilter</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.serviceId</span>=<span class="string">ServiceB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h3><p>请求：test/**的路径，转发给zuul-test-service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRouteRuleConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">patternServiceRouteMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(<span class="string">&quot;(zuul)-(?&lt;test&gt;.+)-(service)&quot;</span>, <span class="string">&quot;$&#123;test&#125;/**&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="忽略路由"><a href="#忽略路由" class="headerlink" title="忽略路由"></a>忽略路由</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.ignoredPatterns</span>=<span class="string">/ServiceB/test</span></span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="请求头配置"><a href="#请求头配置" class="headerlink" title="请求头配置"></a>请求头配置</h3><p>默认情况下，zuul有些敏感的请求头不会转发给下游的服务，比如：Cookie、Set-Cookie、Authorization，也可以自己配置敏感请求头</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.sensitiveHeaders</span>=<span class="string">accept-language, cookie</span></span><br><span class="line"><span class="meta">zuul.routes.demo.sensitiveHeaders</span>=<span class="string">cookie</span></span><br></pre></td></tr></table></figure><h3 id="路由映射信息"><a href="#路由映射信息" class="headerlink" title="路由映射信息"></a>路由映射信息</h3><p>在Zuul项目中，引入actuator依赖，然后在配置文件中，将<code>management.security.enabled</code>设置为false，就可以访问<code>/actuator/routes</code>地址，然后可以看到路由的映射信息</p><h3 id="hystrix配置"><a href="#hystrix配置" class="headerlink" title="hystrix配置"></a>hystrix配置</h3><p>与Ribbon整合的时候，会使用Hystrix，可以在网关写统一的降级实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBFallbackProvider</span> <span class="keyword">implements</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 服务名，一般都设置全局的降级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;fallback&quot;</span>.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(MediaType.TEXT_PLAIN);</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ZuulFallbackProvider <span class="title">fallbackProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceBFallbackProvider();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ribbon客户端预加载"><a href="#ribbon客户端预加载" class="headerlink" title="ribbon客户端预加载"></a>ribbon客户端预加载</h3><p>默认情况下，第一次请求zuul才会初始化ribbon客户端，所以可以配置预加载</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.ribbon.eager-load.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><p>Zuul用的是ribbon+Hystrix，所以设置超时得考虑这2个组件的配置，而且hystrix的超时要考虑ribbon的重试次数和单次超时时间。</p><p>hystrix的超时时间计算公式如下：</p><p>(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ribbon.ReadTimeout</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">ribbon.ConnectTimeout</span>=<span class="string">500</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetries</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetriesNextServer</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><p>如果不配置ribbon的超时时间，默认的hystrix超时时间是4000ms</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否要执行过滤器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">publici Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行过滤器&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在哪个阶段执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FilterConstants.ROUTE_TYPE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是过滤器的优先级</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyFilter <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="groovy动态加载过滤器"><a href="#groovy动态加载过滤器" class="headerlink" title="groovy动态加载过滤器"></a>groovy动态加载过滤器</h3><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.groovy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加代码配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zuulInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterLoader.getInstance().setCompiler(<span class="keyword">new</span> GroovyCompiler());</span><br><span class="line">    String scriptRoot = System.getProperty(<span class="string">&quot;zuul.filter.root&quot;</span>, <span class="string">&quot;groovy/filters&quot;</span>);</span><br><span class="line">    String refreshInterval = System.getProperty(<span class="string">&quot;zuul.filter.refreshInterval&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(scriptRoot.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        scriptRoot = scriptRoot + File.separator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FilterFileManager.setFilenameFilter(<span class="keyword">new</span> GroovyFileFilter());</span><br><span class="line">        FilterFileManager.init(Integer.parseInt(refreshInterval), scriptRoot + <span class="string">&quot;pre&quot;</span>, scriptRoot + <span class="string">&quot;route&quot;</span>, scriptRoot + <span class="string">&quot;post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.filter.root</span>=<span class="string">groovy/filters</span></span><br><span class="line"><span class="meta">zuul.filter.refreshInterval</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure><p>然后将groovy编写的过滤器，放在<code>groovy/filters</code>文件夹下，几秒后就会生效。</p><h3 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.SendForwardFilter.route.disable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="EnableZuulServer"><a href="#EnableZuulServer" class="headerlink" title="@EnableZuulServer"></a>@EnableZuulServer</h3><p>会自动禁用掉PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter等过滤器</p><h3 id="error过滤器-1"><a href="#error过滤器-1" class="headerlink" title="error过滤器"></a>error过滤器</h3><p>在自定义的过滤器有异常可以抛一个ZuulException，然后写一个MyErrorController，继承BasicErrorController，统一处理异常。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么微服务需要网关&quot;&gt;&lt;a href=&quot;#为什么微服务需要网关&quot; class=&quot;headerlink&quot; title=&quot;为什么微服务需要网关&quot;&gt;&lt;/a&gt;为什么微服务需要网关&lt;/h1&gt;&lt;p&gt;在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中聚合数据，而且服务的划分位置结构可能会有所改变。网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="zuul" scheme="http://www.saily.top/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>HystrixCommand执行源码分析</title>
    <link href="http://www.saily.top/2020/05/09/springcloud/hystrix06/"/>
    <id>http://www.saily.top/2020/05/09/springcloud/hystrix06/</id>
    <published>2020-05-09T13:03:59.000Z</published>
    <updated>2020-05-10T14:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HystrixCommand-execute源码细节"><a href="#HystrixCommand-execute源码细节" class="headerlink" title="HystrixCommand.execute源码细节"></a>HystrixCommand.execute源码细节</h1><p>HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Future returned by Observable.toBlocking().toFuture() does not implement the</span></span><br><span class="line"><span class="comment"> * interruption of the execution thread when the &quot;mayInterrupt&quot; flag of Future.cancel(boolean) is set to true;</span></span><br><span class="line"><span class="comment"> * thus, to comply with the contract of Future, we must wrap around it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</span><br></pre></td></tr></table></figure><p>toObservable().toBlocking().toFuture();这行代码已经把command扔到线程池里去执行了，并且拿到了一个Future对象，没有办法在异常情况下终止Future对象对应的线程的执行，所以要对Future做一个包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>然后接下来就是对delegate做了包装，实现了一下cancel等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.get();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure><p>f.isDone()，通过future判断对应的那个线程是否完成了command的执行，然后调用f.get()会阻塞住，获取到Thread执行command返回的结果。</p><p>那我们就发现，在调用queue()方法后，就会通过线程池去执行command，然后在queue()方法中，会等待线程执行结束，如果线程执行结束了，就会返回future；即使执行失败了，也会根据情况，返回future，要不就是抛异常。</p><p>下面，我们接着分析<code>toObservable().toBlocking().toFuture();</code>核心逻辑，它实现了Hystrix几乎所有的核心逻辑，包括请求缓存、熔断、队列+线程池、线程异步执行、超时检测、异常处理、异常统计、熔断开关等。</p><h2 id="toObservable"><a href="#toObservable" class="headerlink" title="toObservable()"></a>toObservable()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Used <span class="keyword">for</span> asynchronous execution of command with a callback by subscribing to the &#123;<span class="meta">@link</span> Observable&#125;.</span><br></pre></td></tr></table></figure><p>获取到Observable后，Command还没有立即开始执行，只是将Command封装到了Observable对象。如果订阅了Observable对象，提供了回调接口，才会触发执行，并根据Command执行结果回调提供的接口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An eager &#123;@link Observable&#125; can be obtained from &#123;@link #observe()&#125;.</span><br></pre></td></tr></table></figure><p>如果希望获取到Observable对象就立即执行内部的Command的话，就不要调用toObservable()方法，可以去调用observe()方法</p><p>声明了一堆匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态是OBSERVABLE_CHAIN_CREATED</span></span><br><span class="line">        <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成false，并且用户的代码没有被执行过（HystrixCommand.run）</span></span><br><span class="line">            handleCommandEnd(<span class="keyword">false</span>); <span class="comment">//user code never ran</span></span><br><span class="line">          <span class="comment">// 如果状态是USER_CODE_EXECUTED</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成true，并且用户的代码已经运行过了（HystrixCommand.run）</span></span><br><span class="line">          handleCommandEnd(<span class="keyword">true</span>); <span class="comment">//user code did run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unsubscribeCommandCleanup</p><p>applyHystrixSemantics</p><p>wrapWithAllOnNextHooks</p><p>fireOnCompletedHook</p><p>然后基于上面的这些回调，去创建了Observable对象，因为创建Observable对象后，并不会被立马执行，所以在调用toBlocking()方法之后，才会触发执行call方法，再依次去执行上面的5个回调方法。因为Observable是rxjava的代码，所以toBlocking()的源码这里就不再跟进去看了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="comment">// 调用toBlocking方法后就会触发执行这里的代码了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个Command命令只能被执行一次，所以Command对象每次都是new</span></span><br><span class="line">        <span class="comment">// 刚开始状态是NOT_STARTED</span></span><br><span class="line">         <span class="comment">/* this is a stateful object so can only be used once */</span></span><br><span class="line">        <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</span><br><span class="line">            IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This instance can only be executed once. Please instantiate a new instance.&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO make a new error type for this</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">&quot; command executed multiple times - this is not permitted.&quot;</span>, ex, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 命令开始的时间戳</span></span><br><span class="line">        commandStartTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日志</span></span><br><span class="line">        <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</span><br><span class="line">            <span class="comment">// log this command execution regardless of what happened</span></span><br><span class="line">            <span class="comment">// 请求日志</span></span><br><span class="line">            <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentRequestLog.addExecutedCommand(_cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</span><br><span class="line">        <span class="keyword">final</span> String cacheKey = getCacheKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存RequestCache</span></span><br><span class="line">        <span class="comment">/* try from cache first */</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用回调创建了Observable对象</span></span><br><span class="line">        Observable&lt;R&gt; hystrixObservable =</span><br><span class="line">                Observable.defer(applyHystrixSemantics)</span><br><span class="line">                        .map(wrapWithAllOnNextHooks);</span><br><span class="line"></span><br><span class="line">        Observable&lt;R&gt; afterCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Request cache</span></span><br><span class="line">        <span class="comment">// put in cache</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// wrap it for caching</span></span><br><span class="line">            HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// another thread beat us so we&#x27;ll use the cached value instead</span></span><br><span class="line">                toCache.unsubscribe();</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we just created an ObservableCommand so we cast and return it</span></span><br><span class="line">                afterCache = toCache.toObservable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            afterCache = hystrixObservable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> afterCache</span><br><span class="line">                .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></span><br><span class="line">                .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></span><br><span class="line">                .doOnCompleted(fireOnCompletedHook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>刚开始命令的状态是NOT_STARTED，设置为OBSERVABLE_CHAIN_CREATED</li><li>记录请求日志（默认启用，但是不处理）</li><li>从缓存读取（默认没有启用缓存）</li><li>得到Observable对象，将5个回调设置到对应doOnCompleted、doOnUnsubscribe等的方法里</li></ol><p>那实际上真正执行Command的代码，是在applyHystrixSemantics的回调里</p><h2 id="applyHystrixSemantics"><a href="#applyHystrixSemantics" class="headerlink" title="applyHystrixSemantics"></a>applyHystrixSemantics</h2><ol><li>applyHystrixSemantics.call()调用applyHystrixSemantics方法 </li><li>判断断路器是否打开</li><li>拿到一个信号量</li><li>执行executeCommandAndObserve</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mark that we&#x27;re starting execution on the ExecutionHook</span></span><br><span class="line">    <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></span><br><span class="line">    <span class="comment">// 这个类是ExecutionHookDeprecationWrapper，是内部类</span></span><br><span class="line">    executionHook.onStart(_cmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断路器是否打开，打开的话直接走降级逻辑</span></span><br><span class="line">    <span class="comment">/* determine if we&#x27;re allowed to execute */</span></span><br><span class="line">    <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</span><br><span class="line">        <span class="comment">// 这里会拿到信号量，如果不是使用SEMAPHORE的话，这里拿到的是一个什么都不干的TryableSemaphoreNoOp.DEFAULT</span></span><br><span class="line">        <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    executionSemaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* used to track userThreadExecutionTime */</span></span><br><span class="line">                executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br><span class="line">                <span class="comment">// 核心逻辑在executeCommandAndObserve里</span></span><br><span class="line">                <span class="keyword">return</span> executeCommandAndObserve(_cmd)</span><br><span class="line">                        .doOnError(markExceptionThrown)</span><br><span class="line">                        .doOnTerminate(singleSemaphoreRelease)</span><br><span class="line">                        .doOnUnsubscribe(singleSemaphoreRelease);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleShortCircuitViaFallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the TryableSemaphore this HystrixCommand should use for execution if not running in a separate thread.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> TryableSemaphore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果不是信号量的话，返回TryableSemaphoreNoOp.DEFAULT，啥也不干</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用SEMAPHORE</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// we didn&#x27;t find one cache so setup</span></span><br><span class="line">                executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</span><br><span class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></span><br><span class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> _s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return NoOp implementation since we&#x27;re not using SEMAPHORE isolation</span></span><br><span class="line">        <span class="comment">// 不用SEMAPHORE</span></span><br><span class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executeCommandAndObserve"><a href="#executeCommandAndObserve" class="headerlink" title="executeCommandAndObserve"></a>executeCommandAndObserve</h2><p>executeCommandAndObserve代码，又是一堆回调，先把回调记录下来</p><ol><li>markEmits</li><li>markOnCompleted</li><li>handleFallback</li><li>setRequestContext</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This decorates &quot;Hystrix&quot; functionality around the run() Observable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> R</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandAndObserve</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;R&gt; markEmits = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</span><br><span class="line">                executionResult = executionResult.addEvent(HystrixEventType.EMIT);</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action0 markOnCompleted = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            circuitBreaker.markNonSuccess();</span><br><span class="line">            Exception e = getExceptionFromThrowable(t);</span><br><span class="line">            executionResult = executionResult.setExecutionException(e);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                    eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</span><br><span class="line">            setRequestContextIfNeeded(currentRequestContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Observable&lt;R&gt; execution;</span><br><span class="line">    <span class="comment">// 是否开启超时，用线程池隔离去执行</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionTimeoutEnabled().get()) &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd)</span><br><span class="line">                .lift(<span class="keyword">new</span> HystrixObservableTimeoutOperator&lt;R&gt;(_cmd));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execution.doOnNext(markEmits)</span><br><span class="line">            .doOnCompleted(markOnCompleted)</span><br><span class="line">            .onErrorResumeNext(handleFallback)</span><br><span class="line">            .doOnEach(setRequestContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="executeCommandWithSpecifiedIsolation"><a href="#executeCommandWithSpecifiedIsolation" class="headerlink" title="executeCommandWithSpecifiedIsolation"></a>executeCommandWithSpecifiedIsolation</h2><p>继续往executeCommandWithSpecifiedIsolation方法里跟，到这里，就发现了他会判断你如果隔离策略是Thread，执行线程池相关逻辑，如果是信号量，执行信号量相关逻辑。</p><p>我们在这个代码里，去找一下跟线程池有关的代码到底在哪里，肯定是有一个队列+线程池。</p><ol><li>默认是线程隔离</li><li>命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是就报错</li><li>记录监控数据，命令开始</li><li>判断是否已经超时了（在执行run方法之前，就已经超时）</li><li>调用startCurrentThreadExecutingCommand方法，将要执行的一个命令，压入一个栈中</li><li>调用getUserExecutionObservable方法，在这个方法里，最终会去执行run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandWithSpecifiedIsolation</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认就是线程隔离的</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;</span><br><span class="line">        <span class="comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span></span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="comment">// 命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是花就报错</span></span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 监控</span></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;</span><br><span class="line">                    <span class="comment">// the command timed out in the wrapping thread so we will return immediately</span></span><br><span class="line">                    <span class="comment">// and not increment any of the counters below or other such logic</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;timed out before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断线程的状态，从NOT_USING_THREAD，切换到STARTED</span></span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;</span><br><span class="line">                    <span class="comment">//we have not been unsubscribed, so should proceed</span></span><br><span class="line">                    HystrixCounters.incrementGlobalConcurrentThreads();</span><br><span class="line">                    threadPool.markThreadExecution();</span><br><span class="line">                    <span class="comment">// store the command that is being run</span></span><br><span class="line">                    <span class="comment">// 将要执行的一个命令，压入一个栈中</span></span><br><span class="line">                    endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                    executionResult = executionResult.setExecutedInThread();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这几行代码也没干啥</span></span><br><span class="line">                        executionHook.onThreadStart(_cmd);</span><br><span class="line">                        executionHook.onRunStart(_cmd);</span><br><span class="line">                        executionHook.onExecutionStart(_cmd);</span><br><span class="line">                        <span class="comment">// run方法最终执行的地方</span></span><br><span class="line">                        <span class="keyword">return</span> getUserExecutionObservable(_cmd);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//command has already been unsubscribed, so return immediately</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;unsubscribed before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnTerminate(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and received terminal, then no need to clean up (I don&#x27;t think this is possible)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was unsubscribed, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and was cancelled, then no need to clean up</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was terminal, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</span><br><span class="line">                <span class="comment">// semaphore isolated</span></span><br><span class="line">                <span class="comment">// store the command that is being run</span></span><br><span class="line">                endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executionHook.onRunStart(_cmd);</span><br><span class="line">                    executionHook.onExecutionStart(_cmd);</span><br><span class="line">                    <span class="keyword">return</span> getUserExecutionObservable(_cmd);  <span class="comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn&#x27;t throw</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//If the above hooks throw, then use that as the result of the run method</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getUserExecutionObservable"><a href="#getUserExecutionObservable" class="headerlink" title="getUserExecutionObservable"></a>getUserExecutionObservable</h2><p>看到这里后，run方法就已经执行了，但是回过头想一下，这个Hystrix是基于队列和线程池去执行的，那怎么没看见跟线程池有关的代码呢在哪呢，前面一个又一个的Observable，互相触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getUserExecutionObservable</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    Observable&lt;R&gt; userObservable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这行代码里的Func0.call()会执行HystrixCommand的run方法</span></span><br><span class="line">        userObservable = getExecutionObservable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// the run() method is a user provided implementation so can throw instead of using Observable.onError</span></span><br><span class="line">        <span class="comment">// so we catch it here and turn it into Observable.error</span></span><br><span class="line">        userObservable = Observable.error(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userObservable</span><br><span class="line">            .lift(<span class="keyword">new</span> ExecutionHookApplication(_cmd))</span><br><span class="line">            .lift(<span class="keyword">new</span> DeprecatedOnRunHookApplication(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里就是执行HystrixCommand的run方法了</span></span><br><span class="line">                <span class="keyword">return</span> Observable.just(run());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span></span><br><span class="line">            executionThread.set(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那从代码执行的层面没有找到，我们去找一下，threadPool这个变量，是在什么时候被使用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</span><br></pre></td></tr></table></figure><h1 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h1><p>在AbstractCommand的构造方法中，就有一行初始化线程池的代码initThreadPool，这就会根据threadPoolKey去创建对应的线程池，线程池的相关参数来自于HystrixThreadPoolProperties.Setter，维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池。</p><p>可配置的属性：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hystrix.threadpool.ServiceA.allowMaximumSizeToDivergeFromCoreSize</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.keepAliveTimeMinutes</span> = <span class="string">1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maximumSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.coreSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maxQueueSize</span> = <span class="string">-1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.queueSizeRejectionThreshold</span> = <span class="string">5</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.numBuckets</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.timeInMilliseconds</span> = <span class="string">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixThreadPool <span class="title">initThreadPool</span><span class="params">(HystrixThreadPool fromConstructor, HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get the default implementation of HystrixThreadPool</span></span><br><span class="line">        <span class="keyword">return</span> HystrixThreadPool.Factory.getInstance(threadPoolKey, threadPoolPropertiesDefaults);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromConstructor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="comment">// 维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池</span></span><br><span class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> HystrixThreadPool <span class="title">getInstance</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work</span></span><br><span class="line">    String key = threadPoolKey.name();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should find it for all but the first time</span></span><br><span class="line">    HystrixThreadPool previouslyCached = threadPools.get(key);</span><br><span class="line">    <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> previouslyCached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we get here this is the first time so we need to initialize</span></span><br><span class="line">    <span class="keyword">synchronized</span> (HystrixThreadPool.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!threadPools.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 创建线程池</span></span><br><span class="line">            threadPools.put(key, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadPools.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolDefault</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);</span><br><span class="line">    HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">this</span>.queueSize = properties.maxQueueSize().get();</span><br><span class="line"><span class="comment">// 用这个线程池</span></span><br><span class="line">    <span class="keyword">this</span>.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,</span><br><span class="line">            concurrencyStrategy.getThreadPool(threadPoolKey, properties),</span><br><span class="line">            properties);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.metrics.getThreadPool();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">this</span>.threadPool.getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* strategy: HystrixMetricsPublisherThreadPool */</span></span><br><span class="line">    HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, <span class="keyword">this</span>.metrics, <span class="keyword">this</span>.properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池初始化的参数，线程池大小的设置"><a href="#线程池初始化的参数，线程池大小的设置" class="headerlink" title="线程池初始化的参数，线程池大小的设置"></a>线程池初始化的参数，线程池大小的设置</h2><p>仔细看一下线程池构造的代码：</p><ol><li>构建了一个 ThreadFactory，这个就是为了给线程起名字，Hystrix开头的名字</li><li>hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队，如果满了就reject了。否则就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去queue排队，如果queue也满了，就会增加core-size到maximumSize，还不够就reject掉了。</li><li>默认配置：线程池：10，不可动态增加线程（hystrix.threadpool.ServiceA.maximumSize无效），queue：SynchronousQueue，不支持排队。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(<span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadFactory这个就是为了给线程起名字，Hystrix开头的名字</span></span><br><span class="line">    <span class="keyword">final</span> ThreadFactory threadFactory = getThreadFactory(threadPoolKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dynamicCoreSize = threadPoolProperties.coreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxQueueSize = threadPoolProperties.maxQueueSize().get();</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = getBlockingQueue(maxQueueSize);</span><br><span class="line">  <span class="comment">// 默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (allowMaximumSizeToDivergeFromCoreSize) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dynamicMaximumSize = threadPoolProperties.maximumSize().get();</span><br><span class="line">        <span class="keyword">if</span> (dynamicCoreSize &gt; dynamicMaximumSize) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Hystrix ThreadPool configuration at startup for : &quot;</span> + threadPoolKey.name() + <span class="string">&quot; is trying to set coreSize = &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot; and maximumSize = &quot;</span> + dynamicMaximumSize + <span class="string">&quot;.  Maximum size will be set to &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot;, the coreSize value, since it must be equal to or greater than the coreSize value&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到线程池队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are using SynchronousQueue if maxQueueSize &lt;= 0 (meaning a queue is not wanted).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * SynchronousQueue will do a handoff from calling thread to worker thread and not allow queuing which is what we want.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Queuing results in added latency and would only occur when the thread-pool is full at which point there are latency issues</span></span><br><span class="line"><span class="comment">     * and rejecting is the preferred solution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队</span></span><br><span class="line">    <span class="keyword">if</span> (maxQueueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去排队，如果排队的也满了，就会增加core-size到maximumSize，还不够就拒绝掉了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxQueueSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HystrixThreadPool-getScheduler"><a href="#HystrixThreadPool-getScheduler" class="headerlink" title="HystrixThreadPool.getScheduler"></a>HystrixThreadPool.getScheduler</h2><p>线程池初始化后，回到之前<a href="#executeCommandWithSpecifiedIsolation">executeCommandWithSpecifiedIsolation</a>的代码里，他的subscribeOn方法，在订阅Observable的时候，调用了HystrixThreadPool.getScheduler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line">.subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这就搞了个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">(Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了允许动态调整线程池大家，就修改配置</span></span><br><span class="line">    touchConfig();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), <span class="keyword">this</span>, shouldInterruptThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就到了内部类HystrixContextSchedulerWorker里，看他的schedule方法</p><h2 id="线程池执行，以及判断线程池是否满了"><a href="#线程池执行，以及判断线程池是否满了" class="headerlink" title="线程池执行，以及判断线程池是否满了"></a>线程池执行，以及判断线程池是否满了</h2><p>假设core-size=10，queueSizeRejectionThreshold=5</p><p>首先会将任务不断的给线程池，让线程池来处理，如果10个线程都满了，此时就会进入队列来排队。如果此时队列排队的请求是3个，那么3&lt;5，还可以继续发送请求，进行排队。当队列数量达到5个以后，也会抛出RejectedExecutionException异常。</p><ol><li>如果queueSize小于0，则表示没有队列</li><li>如果当前队列小于queueSizeRejectionThreshold，表示还有空间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否还有空间，没有就拒绝了</span></span><br><span class="line">        <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Rejected command because thread-pool queueSize is at rejection threshold.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action), delayTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// we don&#x27;t have a queue so we won&#x27;t look for space but instead</span></span><br><span class="line">        <span class="comment">// let the thread-pool reject or not</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</p><p>最后在<code>ThreadPoolWorker</code>中，找到了提交到线程的代码逻辑，Action0就是HystrixContexSchedulerAction。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscription.isUnsubscribed()) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is internal RxJava API but it is too useful.</span></span><br><span class="line">    ScheduledAction sa = <span class="keyword">new</span> ScheduledAction(action);</span><br><span class="line"></span><br><span class="line">    subscription.add(sa);</span><br><span class="line">    sa.addParent(subscription);</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();</span><br><span class="line">    FutureTask&lt;?&gt; f = (FutureTask&lt;?&gt;) executor.submit(sa);</span><br><span class="line">    sa.add(<span class="keyword">new</span> FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，Hystrix基于线程池的基本执行逻辑一句分析完成，画个图总结一下</p><p><img src="/img/spring-cloud/Hystrix%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="Hystrix执行原理图"></p><h1 id="超时监测"><a href="#超时监测" class="headerlink" title="超时监测"></a>超时监测</h1><p>Hystrix超时计算的代码在HystrixObservableTimeoutOperator里，里面就有一个用于计算超时的监听器，如果在命令超时了，命令的状态还是NOT_EXECUTED，就将状态设置成TIMED_OUT，并抛出一个HystrixTimeoutException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TimerListener listener = <span class="keyword">new</span> TimerListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath</span></span><br><span class="line">        <span class="comment">// otherwise it means we lost a race and the run() execution completed or did not start</span></span><br><span class="line">        <span class="keyword">if</span> (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) &#123;</span><br><span class="line">            <span class="comment">// report timeout failure</span></span><br><span class="line">            originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shut down the original request</span></span><br><span class="line">            s.unsubscribe();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> HystrixContextRunnable timeoutRunnable = <span class="keyword">new</span> HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    child.onError(<span class="keyword">new</span> HystrixTimeoutException());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            timeoutRunnable.run();</span><br><span class="line">            <span class="comment">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntervalTimeInMilliseconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalCommand.properties.executionTimeoutInMilliseconds().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将这个监听器放到了HystrixTimer里，在这里判断超时的时候回调</span></span><br><span class="line"><span class="keyword">final</span> Reference&lt;TimerListener&gt; tl = HystrixTimer.getInstance().addTimerListener(listener);</span><br><span class="line"><span class="comment">// 放回到Command中</span></span><br><span class="line">originalCommand.timeoutTimer.set(tl);</span><br></pre></td></tr></table></figure><p>创建线程，并按照时间执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addTimerListener</span><span class="params">(<span class="keyword">final</span> TimerListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化了HystrixTimer线程池，大小是4</span></span><br><span class="line">    startThreadIfNeeded();</span><br><span class="line">    <span class="comment">// add the listener</span></span><br><span class="line"></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.tick();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed while ticking TimerListener&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 利用前面初始化的线程池，每隔1秒钟执行一次r（也就是TimerListener)，这个时间就是Command设置的超时是时间</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TimerReference(listener, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令执行完成以后，HystrixCommand的isCommandTimedOut的状态就会变成COMPLETED，所以在定时调度的时候不会进入判断条件。同时在任务处理完成也会清理掉定时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotTimedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED</span></span><br><span class="line">    <span class="keyword">return</span> originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||</span><br><span class="line">            originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommandEnd</span><span class="params">(<span class="keyword">boolean</span> commandExecutionStarted)</span> </span>&#123;</span><br><span class="line">    Reference&lt;TimerListener&gt; tl = timeoutTimer.get();</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tl.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/Hystrix%E8%B6%85%E6%97%B6%E5%8E%9F%E7%90%86.jpg" alt="Hystrix超时原理"></p><p>然后超时的降级，下面的文章再看。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>超时、命令执行过程中，线程满了，都会抛出异常，那Hystrix在这种情况下都会执行降级逻辑，我们去找一下处理这些异常，然后执行降级逻辑的代码在哪里。其实就在<a href="#executeCommandAndObserve">executeCommandAndObserve</a>方法中的<code>handleFallback</code></p><p>在这里就发现，所有的异常都是handleFallback处理的，其实就是拒绝、超时、失败，都会执行降级逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        circuitBreaker.markNonSuccess();</span><br><span class="line">        Exception e = getExceptionFromThrowable(t);</span><br><span class="line">        executionResult = executionResult.setExecutionException(e);</span><br><span class="line">        <span class="comment">// 拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">          <span class="comment">// 超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">          <span class="comment">// 失败</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>这些就是fallback的处理，最终会调用getFallbackOrThrowException，然后执行用户定义的fallback方法</p><p>handleSemaphoreRejectionViaFallback<br>handleShortCircuitViaFallback<br>handleThreadPoolRejectionViaFallback<br>handleTimeoutViaFallback<br>handleFailureViaFallback</p><h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p>在多次异常降级后，熔断器就会打开了，接着就分析一下熔断器是如何打开的</p><p>先去看初始化的代码，在HystrixCommand构造方法中，会初始化熔断器</p><ol><li>一个Command Key就对应了一个熔断器</li><li>在初始化HystrixCircuitBreakerImpl的时候，会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</li><li>在最近的一个时间窗口以内（10s），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</li><li>反之，如果totalRequests（总请求数量）&gt;= circuitBreakerRequestVolumeThreshold（默认是20），就会进入下一步的尝试</li><li>如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</li><li>反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">initCircuitBreaker</span><span class="params">(<span class="keyword">boolean</span> enabled, HystrixCircuitBreaker fromConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandGroupKey groupKey, HystrixCommandKey commandKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// get the default implementation of HystrixCircuitBreaker</span></span><br><span class="line">            <span class="comment">// 拿的是HystrixCircuitBreakerImpl</span></span><br><span class="line">            <span class="keyword">return</span> HystrixCircuitBreaker.Factory.getInstance(commandKey, groupKey, properties, metrics);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fromConstructor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NoOpCircuitBreaker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCircuitBreakerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, <span class="keyword">final</span> HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//On a timer, this will set the circuit between OPEN/CLOSED as command executions occur</span></span><br><span class="line">    <span class="comment">// 会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</span></span><br><span class="line">    Subscription s = subscribeToStream();</span><br><span class="line">    activeSubscription.set(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Subscription <span class="title">subscribeToStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This stream will recalculate the OPEN/CLOSED status on every onNext from the health stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> metrics.getHealthCountsStream()</span><br><span class="line">            .observe()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Subscriber&lt;HealthCounts&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最近10秒钟的统计信息</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(HealthCounts hc)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 在最近的一个时间窗口以内（10秒），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</span></span><br><span class="line">                    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">                    <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                        <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></span><br><span class="line">                        <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                        <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                        <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                        <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 进入下一步的尝试</span></span><br><span class="line">                        <span class="comment">// 如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</span></span><br><span class="line">                        <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                            <span class="comment">//we are not past the minimum error threshold for the stat window,</span></span><br><span class="line">                            <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                            <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                            <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                            <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> </span><br><span class="line">                            <span class="comment">// 反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</span></span><br><span class="line">                            <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></span><br><span class="line">                            <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</span><br><span class="line">                                circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="熔断器打开后，请求直接降级"><a href="#熔断器打开后，请求直接降级" class="headerlink" title="熔断器打开后，请求直接降级"></a>熔断器打开后，请求直接降级</h2><p>就是在在<a href="#applyHystrixSemantics">applyHystrixSemantics</a>这里的代码，就会先判断人熔断器的状态，如果熔断器打开了，就直接走降级逻辑了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -1 就是可以执行请求，断路器没有打开</span></span><br><span class="line">    <span class="keyword">if</span> (circuitOpened.get() == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAfterSleepWindow()) &#123;</span><br><span class="line">            <span class="comment">// 状态搞为半打开，让一个请求执行试一下</span></span><br><span class="line">            <span class="comment">// 如果失败了，那么还是OPEN，handleFallback -&gt; circuitBreaker.markNonSuccess();同时会更新熔断的时间戳</span></span><br><span class="line">            <span class="comment">// 如果请求成功，markEmits/markOnCompleted,circuitBreaker.markSuccess(),关闭熔断器。会变成CLOSED</span></span><br><span class="line">            <span class="keyword">if</span> (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) &#123;</span><br><span class="line">                <span class="comment">//only the first request after sleep window should execute</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过了一个circuitBreakerSleepWindowInMilliseconds时间以后，这个时间默认是5秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAfterSleepWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> circuitOpenTime = circuitOpened.get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> sleepWindowTime = properties.circuitBreakerSleepWindowInMilliseconds().get();</span><br><span class="line">    <span class="keyword">return</span> currentTime &gt; circuitOpenTime + sleepWindowTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to close the circuit - it resets the stream to start it over from 0</span></span><br><span class="line">        metrics.resetStream();</span><br><span class="line">        Subscription previousSubscription = activeSubscription.get();</span><br><span class="line">        <span class="keyword">if</span> (previousSubscription != <span class="keyword">null</span>) &#123;</span><br><span class="line">            previousSubscription.unsubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        Subscription newSubscription = subscribeToStream();</span><br><span class="line">        activeSubscription.set(newSubscription);</span><br><span class="line">        circuitOpened.set(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markNonSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.OPEN)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to re-open the circuit - it resets the start time for the sleep window</span></span><br><span class="line">        circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/Hystrix%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86-9119853.jpg" alt="Hystrix熔断器的中断原理"></p><h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><p><a href="#toObservable">toObservable</a> 方法里包含了请求缓存的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* try from cache first */</span></span><br><span class="line"><span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">    HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HystrixCommand-execute源码细节&quot;&gt;&lt;a href=&quot;#HystrixCommand-execute源码细节&quot; class=&quot;headerlink&quot; title=&quot;HystrixCommand.execute源码细节&quot;&gt;&lt;/a&gt;HystrixCommand.execute源码细节&lt;/h1&gt;&lt;p&gt;HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// HystrixCommand.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; R &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue().get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; Exceptions.sneakyThrow(decomposeException(e));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件的各种MaxTotalConnections详解</title>
    <link href="http://www.saily.top/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.saily.top/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-29T14:05:39.000Z</published>
    <updated>2020-04-29T10:19:17.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在zuul网关中，有关于配置连接数量的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">max-per-route-connections:</span> <span class="number">20</span> <span class="comment">#默认值</span></span><br><span class="line">    <span class="attr">max-total-connections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><p>这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。</p><p>这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">MaxConnectionsPerHost:</span> <span class="number">50</span> <span class="comment">#默认值</span></span><br><span class="line">  <span class="attr">MaxTotalConnections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>还有Feign的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 默认值 </span></span><br><span class="line">      <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 默认值</span></span><br></pre></td></tr></table></figure><p>那么问题来了，在服务中既有Feign，又有Ribbon，那如果都配置了，是用哪一个配置？仔细的分析了一下，情况还比较复杂。</p><h1 id="zuul-host-max-per-route-connections"><a href="#zuul-host-max-per-route-connections" class="headerlink" title="zuul.host.max-per-route-connections"></a>zuul.host.max-per-route-connections</h1><p>刚才说这个配置和基于RIbbon调用服务没有什么关系，放个证据看一下，SimpleHostRoutingFilter是用于静态路由的具体请求处理类，这里面的初始化代码就是读取这个参数，并进行连接池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHostRoutingFilter.java</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!customHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.connectionManager = connectionManagerFactory.newConnectionManager(</span><br><span class="line">            !<span class="keyword">this</span>.sslHostnameValidationEnabled,</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxTotalConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxPerRouteConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getTimeToLive(), <span class="keyword">this</span>.hostProperties.getTimeUnit(),</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">this</span>.httpClient = newClient();</span><br><span class="line">      <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager.closeExpiredConnections();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="number">30000</span>, <span class="number">5000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="服务里的Ribbon"><a href="#服务里的Ribbon" class="headerlink" title="服务里的Ribbon"></a>服务里的Ribbon</h2><p>先说在服务里只有Ribbon，并没有引入Feign的情况下，用RestTemplate发送请求，底层是通过SimpleBufferingClientHttpRequest发起实际http请求，用的是JDK原生的http。</p><p>所以在什么都不配置的情况下，上面的<code>ribbon.MaxConnectionsPerHost</code>配置是没有用的，而且我从这个源码看下来，像那些重试参数什么的，应该都没有用。他仅仅只是给RestTemplate赋予了负载均衡的功能，其他什么都没有控制。</p><p>在<code>RibbonClientConfiguration</code>类中，还额外Import了几个关于HttpClient的类，但是在默认情况下，都没什么用。</p><p>所以其实在服务里边，什么<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>，配置了以后，他只会去注册这些bean，不会被用到。自己搞的那个RestTemplate，用的就是spring默认的JDK 原生http组件。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于RestTemplate的方式使用Ribbon，在yaml里的大多数配置都不会生效，也没什么用。</p><h2 id="网关里的Ribbon"><a href="#网关里的Ribbon" class="headerlink" title="网关里的Ribbon"></a>网关里的Ribbon</h2><p>在网关里面，大有不同，我们先看ZuulProxyAutoConfiguration配置类，他引入了几个跟http组件有关的配置类，在这里<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>就能直接起作用了，他决定了加载哪一个具体的配置。在没有okhttpclient的情况下，默认就是使用apache的httpcomponents。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZuulProxyAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      HttpClientConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonCommandFactoryConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnRibbonHttpClient</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;ZuulFallbackProvider&gt; zuulFallbackProviders = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> RibbonCommandFactory&lt;?&gt; ribbonCommandFactory(</span><br><span class="line">      SpringClientFactory clientFactory, ZuulProperties zuulProperties) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommandFactory(clientFactory, zuulProperties, zuulFallbackProviders);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClientRibbonCommandFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">  ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line">  <span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">  <span class="comment">//  最终还是从ribbon管理的上下文中获取到一个RibbonLoadBalancingHttpClient。注意，SpringClientFactory里的bean基本都来自于RibbonClientConfiguration，看过Ribbon的源码就知道</span></span><br><span class="line">  <span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">      serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">  client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">      clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，Ribbon本身也会对<code>RibbonClientConfiguration</code>配置类也进行初始化，一样的，他也引入了几个Http组件，和上面不同的是，zuul的几个配置类，主要是为了封装Hystrix的逻辑，实际上最终还是调用的<code>RibbonLoadBalancingHttpClient</code>执行请求。所以我们接下来去看<code>RibbonClientConfiguration</code>的配置，以及<code>RibbonLoadBalancingHttpClient</code>是如何被注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各种http组件支持，默认是加载最后一个</span></span><br><span class="line"><span class="meta">@Import(&#123;HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpClientRibbonConfiguration.java</span></span><br><span class="line"><span class="comment">// 在zuul中，httpcomponents已经被自动引入了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.apache.http.client.HttpClient&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;ribbon.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个配置被RibbonClientConfiguration一起被加载，可通过@RibbonClient注解的configuration属性覆盖</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">httpClientConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 终于在这里找到了读取MaxTotalConnections等配置的代码</span></span><br><span class="line">     Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">     Integer maxConnectionsPerHost = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxConnectionsPerHost,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_CONNECTIONS_PER_HOST);</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里声明了一个基于Apache的httpClient的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">(ApacheHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpClientConnectionManager connectionManager, IClientConfig config)</span> </span>&#123;</span><br><span class="line">    Boolean followRedirects = config.getPropertyAsBoolean(</span><br><span class="line">        CommonClientConfigKey.FollowRedirects,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_FOLLOW_REDIRECTS);</span><br><span class="line">    Integer connectTimeout = config.getPropertyAsInteger(</span><br><span class="line">        CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    RequestConfig defaultRequestConfig = RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(connectTimeout)</span><br><span class="line">        .setRedirectsEnabled(followRedirects).build();</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClientFactory.createBuilder().</span><br><span class="line">        setDefaultRequestConfig(defaultRequestConfig).</span><br><span class="line">        setConnectionManager(connectionManager).build();</span><br><span class="line">    <span class="keyword">return</span> httpClient;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 划重点。。。终于在这里发现了RibbonLoadBalancingHttpClient的声明，并且MaxTotalConnections等属性在上面的代码已经被注册了。</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(value = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonLoadBalancingHttpClient <span class="title">ribbonLoadBalancingHttpClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IClientConfig config, ServerIntrospector serverIntrospector,</span></span></span><br><span class="line"><span class="function"><span class="params">ILoadBalancer loadBalancer, RetryHandler retryHandler, CloseableHttpClient httpClient)</span> </span>&#123;</span><br><span class="line">RibbonLoadBalancingHttpClient client = <span class="keyword">new</span> RibbonLoadBalancingHttpClient(httpClient, config, serverIntrospector);</span><br><span class="line">client.setLoadBalancer(loadBalancer);</span><br><span class="line">client.setRetryHandler(retryHandler);</span><br><span class="line">Monitors.registerObject(<span class="string">&quot;Client_&quot;</span> + <span class="keyword">this</span>.name, client);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在网关打断点测试了一下，请求确实是通过RibbonLoadBalancingHttpClient执行的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于网关使用Ribbon，会读取<code>ribbon.MaxTotalConnections</code>和<code>ribbon.MaxConnectionsPerHost</code>等配置，并给予HTTPComponents组件进行访问。</p><h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>那么Fiegn的配置在什么时候生效？情况又有变化了，Feign同样有一个配置类<code>FeignRibbonClientAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>在默认没有额外配置的情况下，是读取的<code>DefaultFeignLoadBalancedConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="comment">// Client.Default就基于JDK的http组件完成了http的请求，底层没有连接池</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>),</span><br><span class="line">            cachingFactory, clientFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign在默认情况下使用的是JDK原生的<code>URLConnection</code>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的<code>persistence connection</code> 。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在默认情况下，也就是不开启<code>feign.okhttp.enable</code>和<code>feign.httpclient.enable</code>的时候，feign的<code>feign.max-connections</code>配置，也是没有什么用的。</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>在开启<code>feign.httpclient.enable</code>以后，HttpClientFeignLoadBalancedConfiguration会被加载。这里得加个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign-httpclient&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和Ribbon一样，Feign也定义了自己的HttpClient等组件，在定义过程中，读取了配置并利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">connectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        FeignHttpClientProperties httpClientProperties)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在这里读取了feign相关的MaxConnectionsPerRoute和MaxConnections配置</span></span><br><span class="line">     <span class="keyword">final</span> HttpClientConnectionManager connectionManager = connectionManagerFactory</span><br><span class="line">           .newConnectionManager(httpClientProperties.isDisableSslValidation(), httpClientProperties.getMaxConnections(),</span><br><span class="line">                 httpClientProperties.getMaxConnectionsPerRoute(),</span><br><span class="line">                 httpClientProperties.getTimeToLive(),</span><br><span class="line">                 httpClientProperties.getTimeToLiveUnit(), registryBuilder);</span><br><span class="line">     <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           connectionManager.closeExpiredConnections();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="number">30000</span>, httpClientProperties.getConnectionTimerRepeat());</span><br><span class="line">     <span class="keyword">return</span> connectionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(Client.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                SpringClientFactory clientFactory, HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    ApacheHttpClient delegate = <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200429174359246.png" alt="image-20200429174359246"></p><p>经过打了断点测试和验证， 确实在这里加载到了连接池的配置。请求也是通过ApacheHttpClient发送的。</p><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>在引入了feign-httpclient的包以后，feign才会启用<code>feign.max-connections</code>等连接池的配置。那么Ribbon之前的配置呢，在使用Feign的时候，Ribbon的那些Http相关的Bean就没有用了，不会被用到。</p><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>和上面一样，不过OkHttp只会读取MaxTotalConnections属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(ConnectionPool.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionPool <span class="title">httpClientConnectionPool</span><span class="params">(IClientConfig config, OkHttpClientConnectionPoolFactory connectionPoolFactory)</span> </span>&#123;</span><br><span class="line">   Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">         CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">         DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">   Object timeToLiveObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTime);</span><br><span class="line">   Long timeToLive = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME;</span><br><span class="line">   Object ttlUnitObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits);</span><br><span class="line">   TimeUnit ttlUnit = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;</span><br><span class="line">   <span class="keyword">if</span> (timeToLiveObj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">      timeToLive = (Long) timeToLiveObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ttlUnitObj <span class="keyword">instanceof</span> TimeUnit) &#123;</span><br><span class="line">      ttlUnit = (TimeUnit) ttlUnitObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于这个值应该怎么设置，大家根据自己的项目情况来设置，其实就是访问其他服务的Http连接池数量，不要设置的过于夸张了，有些人可能会跟Tomcat的maxconnections搞混了，甚至配个几千上万的，虽然名字一样，但是含义却不同。SpringBoot给我们设置的默认值，也是有参考意义的，在实际项目中，大家可以根据压测情况进行调整。</p><h1 id="Tomcat-maxConnections"><a href="#Tomcat-maxConnections" class="headerlink" title="Tomcat:maxConnections"></a>Tomcat:maxConnections</h1><p>关于Tomcat这个参数的详细解释，可以看这个博客：<a href="https://blog.csdn.net/zzzgd_666/article/details/88740198%E3%80%82">https://blog.csdn.net/zzzgd_666/article/details/88740198。</a></p><p>大概说一下，Tomcat有Nio、Bio、APR三种运行模式，maxConnections是Tomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为-1，则连接数不受限制。</p><p>默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</p><p>在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。</p><p>maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，maxConnections值应该远大于maxThreads。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在zuul网关中，有关于配置连接数量的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;zuul:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;host:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;max-per-route-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;max-total-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。&lt;/p&gt;
&lt;p&gt;这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ribbon:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;MaxConnectionsPerHost:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;MaxTotalConnections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Feign和Hystrix的结合使用</title>
    <link href="http://www.saily.top/2020/04/19/springcloud/hystrix05/"/>
    <id>http://www.saily.top/2020/04/19/springcloud/hystrix05/</id>
    <published>2020-04-19T10:03:59.000Z</published>
    <updated>2020-05-10T09:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign和Hystrix结合使用"><a href="#Feign和Hystrix结合使用" class="headerlink" title="Feign和Hystrix结合使用"></a>Feign和Hystrix结合使用</h1><p>在@FeignClient中增加fallback配置，指定降级方法的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user&quot;,url = &quot;$&#123;user.url&#125;&quot;,fallback = UserFeignFallback.class</span></span><br><span class="line"><span class="meta">        /*fallbackFactory = UserFeignFactory.class*/)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>降级方法的编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFeignFallback</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByID</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;fallback 回调用户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Feign和Hystrix整合的配置"><a href="#Feign和Hystrix整合的配置" class="headerlink" title="Feign和Hystrix整合的配置"></a>Feign和Hystrix整合的配置</h2><p>超时时间设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><p>如果要特定某个服务的配置，就不写default，这个user是FeignClient的服务名，对应一个HystrixGroup，具体的key就是方法名。</p><p>那么如果想针对服务的某一个方法配置怎么办？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="string">ServiceA#sayHello(Long,String):</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><p>hystrix.threadpool.default.coreSize：线程池大小，默认10</p><p>hystrix.threadpool.default.maximumSize：线程池最大大小，默认10</p><p>hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize：是否允许动态调整线程数量，默认false，只有设置为true了，上面的maximumSize才有效</p><p>hystrix.threadpool.default.keepAliveTimeMinutes ：默认是1，超出coreSize的线程，空闲1分钟后释放掉</p><p>hystrix.threadpool.default.maxQueueSize 默认－1，不能动态修改</p><p>hystrix.threadpool.default.queueSizeRejectionThreshold 可以动态修改，默认是5，先进入请求队列，然后再由线程池执行</p><h3 id="如何计算线程池数量？"><a href="#如何计算线程池数量？" class="headerlink" title="如何计算线程池数量？"></a>如何计算线程池数量？</h3><h4 id="高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间"><a href="#高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间" class="headerlink" title="高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间"></a>高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间</h4><p>比如说处理一个请求，要50ms，那么TP99，也就是99%的请求里处理一个请求耗时最长是50ms。</p><p>我们给一点缓冲空间10ms，那就是处理请求接口耗时60ms。</p><p> 所以一秒钟一个线程可以处理：1000 / 60 = 16，一个线程一秒钟可以处理16个请求。</p><p> 假设高峰期，每秒最多1200个请求，一个线程每秒可以处理16个请求，需要多少个线程才能处理每秒1200个请求呢？1200 / 16 = 75，最多需要75个线程，每个线程每秒处理16个请求，75个线程每秒才可以处理1200个请求。</p><p>最多需要多少个线程数量，就是这样子算出来</p><h4 id="如果是服务B-gt-服务A的话，服务B线程数量怎么设置"><a href="#如果是服务B-gt-服务A的话，服务B线程数量怎么设置" class="headerlink" title="如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置"></a>如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置</h4><p>服务B调用服务A的线程池需要多少个线程呢？</p><p>高峰期，服务B最多要调用服务A每秒钟1200次，服务A处理一个请求是60ms，服务B每次调用服务A的时候，用一个线程发起一次请求，那么这个服务B的这个线程，要60ms才能返回。</p><p>服务B而言，一个线程对服务A发起一次请求需要60ms，一个线程每秒钟可以请求服务A达到16次，但是现在服务B每秒钟需要请求服务A达到1200次，那么服务B就需要75个线程，在高峰期并发请求服务A，才可以完成每秒1200次的调用。</p><p>服务B，部署多台机器，每台机器调用服务A的线程池有10个线程，比如说搞个10个线程，一共部署10台机器，那么服务B调用服务A的线程数量，一共有100个线程，轻轻松松可以支撑高峰期调用服务A的1200次的场景</p><p>每个线程调用服务A一次，耗时60ms，每个线程每秒可以调用服务A一共是16次，100个线程，每秒最多可以调用服务A是1600次，高峰的时候只要支持调用服务A的1200次就可以了，所以这个机器部署就绰绰有余了</p><h2 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h2><p>hystrix.command.default.execution.isolation.strategy：隔离策略，默认Thread，可以选择Semaphore信号量 </p><p>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：超时时间，默认1000ms</p><p>hystrix.command.default.execution.timeout.enabled：是否启用超时，默认ture</p><p>hystrix.command.default.execution.isolation.thread.interruptOnTimeout：超时的时候是否中断执行，默认true  </p><p>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests：信号量隔离策略下，允许的最大并发请求数量，默认10</p><h2 id="降级配置"><a href="#降级配置" class="headerlink" title="降级配置"></a>降级配置</h2><p>hystrix.command.default.fallback.enabled 默认true</p><h2 id="熔断配置"><a href="#熔断配置" class="headerlink" title="熔断配置"></a>熔断配置</h2><p>hystrix.command.default.circuitBreaker.enabled：是否启用熔断器默认true</p><p>hystrix.command.default.circuitBreaker.requestVolumeThreshold：10秒钟内，请求数量达到多少才能去尝试触发熔断，默认20</p><p>hystrix.command.default.circuitBreaker.errorThresholdPercentage：10秒钟内，请求数量达到20，同时异常比例达到50%，就会触发熔断，默认50</p><p>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：触发熔断之后，5s内直接拒绝请求，走降级逻辑，5s后尝试half-open放过少量流量试着恢复，默认5000</p><p>hystrix.command.default.circuitBreaker.forceOpen：强制打开熔断器</p><p>hystrix.command.default.circuitBreaker.forceClosed：强制关闭熔断器</p><h2 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h2><p>hystrix.threadpool.default.metrics.rollingStats.timeInMillisecond：线程池统计指标的时间，默认10000，就是10s</p><p>hystrix.threadpool.default.metrics.rollingStats.numBuckets：将rolling window划分为n个buckets，默认10</p><p>hystrix.command.default.metrics.rollingStats.timeInMilliseconds：command的统计时间，熔断器是否打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</p><p>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</p><p>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</p><p>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</p><p>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</p><p>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</p><p>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</p><h2 id="高阶特性配置"><a href="#高阶特性配置" class="headerlink" title="高阶特性配置"></a>高阶特性配置</h2><p>hystrix.command.default.requestCache.enabled 默true </p><p>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true </p><p>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</p><p>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</p><p>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</p><h1 id="Feign和Hystrix结合的原理"><a href="#Feign和Hystrix结合的原理" class="headerlink" title="Feign和Hystrix结合的原理"></a>Feign和Hystrix结合的原理</h1><p>Feign在和Hystrix整合的时候，feign动态代理里面有一些Hystrix相关的代码，请求走feign动态代理的时候，就会基于Hystrix Command发送请求，实现服务间调用的隔离、限流、超时、降级、熔断、统计等。</p><p><img src="/img/spring-cloud/Feign%E5%92%8CHystrix%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Feign和Hystrix的核心原理"></p><h2 id="Feign中基于Hystrix的动态代理"><a href="#Feign中基于Hystrix的动态代理" class="headerlink" title="Feign中基于Hystrix的动态代理"></a>Feign中基于Hystrix的动态代理</h2><p>在Feign的动态代理代码中，HystrixTargeter默认情况下，在没有开启Hystrix的时候，会使用自带的Feign.Builder。在启用Hystrix走，就使用HystrixFeign.Builder。</p><p><strong>HystrixFeign.Builder是在这里创建的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">   <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixTargeter中，用Hystrix构造动态代理的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 没有开启Hystrix的话，走这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在有Hystrix的条件下，就开始往这下面走。</span></span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   <span class="comment">// 用于读取yaml文件中的Hystrix相关的配置，在执行命令的时候会用到</span></span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 有降级的话，就用降级包装下</span></span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个fallback的实例，从和服务相关联的Spring上下文里获取ServiceAClient的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HystrixFeign.Builder builder, Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">   T fallbackInstance = getFromContext(<span class="string">&quot;fallback&quot;</span>, feignClientName, context, fallback, target.type());</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工厂创建一个实例，并校验是否是ServiceAClient接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                              HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">   FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;)</span><br><span class="line">      getFromContext(<span class="string">&quot;fallbackFactory&quot;</span>, feignClientName, context, fallbackFactoryClass, FallbackFactory.class);</span><br><span class="line">   <span class="comment">/* We take a sample fallback from the fallback factory to check if it returns a fallback</span></span><br><span class="line"><span class="comment">   that is compatible with the annotated feign interface. */</span></span><br><span class="line">   <span class="comment">// 创建一个对象出来看看，检测一下创建出来的对象是否符合要求</span></span><br><span class="line">   Object exampleFallback = fallbackFactory.create(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">   Assert.notNull(exampleFallback,</span><br><span class="line">      String.format(</span><br><span class="line">      <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory may not produce null!&quot;</span>,</span><br><span class="line">         feignClientName));</span><br><span class="line">   <span class="keyword">if</span> (!target.type().isAssignableFrom(exampleFallback.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         String.format(</span><br><span class="line">            <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory produces instances of &#x27;%s&#x27;, but should produce instances of &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">            feignClientName, exampleFallback.getClass(), target.type()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在确认fallbackFactory创建出来的对象没有问题后，调用HystrixFeign的target方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target, T fallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build(fallback != <span class="keyword">null</span> ? <span class="keyword">new</span> FallbackFactory.Default&lt;T&gt;(fallback) : <span class="keyword">null</span>)</span><br><span class="line">      .newInstance(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要注意build方法，里面就包含了两局关键的代码，他重新设置了invocationHandlerFactory和contract</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="function">Feign <span class="title">build</span><span class="params">(<span class="keyword">final</span> FallbackFactory&lt;?&gt; nullableFallbackFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.invocationHandlerFactory(<span class="keyword">new</span> InvocationHandlerFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 关键代码 HystrixInvocationHandler，包含了基于HystrixCommand的封装，实际还是调用dispatch</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixInvocationHandler(target, dispatch, setterFactory, nullableFallbackFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 关键代码HystrixDelegatingContract，用于解析Hystrix相关的注解</span></span><br><span class="line">  <span class="keyword">super</span>.contract(<span class="keyword">new</span> HystrixDelegatingContract(contract));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/%E5%90%AF%E7%94%A8Hystrix%E4%B9%8B%E5%90%8Efeign%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="启用Hystrix之后feign生成动态代理的过程"></p><p>再往后的代码就和Hystrix没有关系了，就在feign的动态代理那一套东西，下面继续看HystrixInvocationHandler封装的细节。</p><h2 id="Feign中HystrixCommand的执行细节"><a href="#Feign中HystrixCommand的执行细节" class="headerlink" title="Feign中HystrixCommand的执行细节"></a>Feign中HystrixCommand的执行细节</h2><p>HystrixInvocationHandler，作为一个动态代理的接口，看下它的invoke方法，他构造了一个HystrixCommand，利用Hystrix包装了请求的执行，在HystrixCommand的run方法里，就包含了执行调用的代码（SynchronousMethodHandler）。如果执行请求的时候报错的话，就会调用getFallbac方法，就会执行之前配置的降级方法，执行降级的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixInvocationHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// early exit if the invoked method is from java.lang.Object</span></span><br><span class="line">  <span class="comment">// code is the same as ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造一个HystrixCommand匿名内部类,每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的配置，例如超时时间等</span></span><br><span class="line">  HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setterMethodMap.get(method)) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用SynchronousMethodHandler,也就是发起Http请求的代码</span></span><br><span class="line">        <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果降级方法不存在的话，父类会直接报错UnsupportedOperationException。</span></span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFallback();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建fallback</span></span><br><span class="line">        Object fallback = fallbackFactory.create(getExecutionException());</span><br><span class="line">        <span class="comment">// 调用之前定义的fallback方法</span></span><br><span class="line">        Object result = fallbackMethodMap.get(method).invoke(fallback, args);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((HystrixCommand) result).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable</span></span><br><span class="line">          <span class="keyword">return</span> ((Observable) result).toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">          <span class="keyword">return</span> ((Single) result).toObservable().toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">          ((Completable) result).await();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// shouldn&#x27;t happen as method is public due to being an interface</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// Exceptions on fallback are tossed by Hystrix</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</span></span><br><span class="line">  <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toSingle();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toCompletable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hystrixCommand.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixInvocationHandler构造的时候，构造了一个setterMethodMap，每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的key和groupkey的配置，例如超时时间等，线程池配置等，Setter被创建的时候，用的就是@FeignClient的name作为groupKey，也就是ServiceA，commandKey用于是类名+方法名（ServiceA#sayHello(Long,String)），这个groupKey就对应了一个线程池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetterFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">create</span><span class="params">(Target&lt;?&gt; target, Method method)</span> </span>&#123;</span><br><span class="line">  String groupKey = target.name();</span><br><span class="line">  String commandKey = Feign.configKey(target.type(), method);</span><br><span class="line">  <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))</span><br><span class="line">      .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>基于Method对象对应的setterMethodMap，构造一个HystrixCommand匿名内部类</li><li>内部类实现了run方法和getFallback方法</li><li>run方法直接调用调用SynchronousMethodHandler发起http请求</li><li>如果run方法执行异常，getFallback方法调用之前在FeignClient中定义的降级方法</li><li>检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</li></ol><p>到这里已经看到调用了HystrixCommand的execute方法，所以接下来的内容，将会进入到Hystrix的源码中，下一篇文章细说。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign和Hystrix结合使用&quot;&gt;&lt;a href=&quot;#Feign和Hystrix结合使用&quot; class=&quot;headerlink&quot; title=&quot;Feign和Hystrix结合使用&quot;&gt;&lt;/a&gt;Feign和Hystrix结合使用&lt;/h1&gt;&lt;p&gt;在@FeignClient中增加fallback配置，指定降级方法的执行&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FeignClient(name = &amp;quot;user&amp;quot;,url = &amp;quot;$&amp;#123;user.url&amp;#125;&amp;quot;,fallback = UserFeignFallback.class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        /*fallbackFactory = UserFeignFactory.class*/)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UserFeign&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@PostMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping(&amp;quot;/&amp;#123;id&amp;#125;&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;User &lt;span class=&quot;title&quot;&gt;getUserByID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@PathVariable(&amp;quot;id&amp;quot;)&lt;/span&gt; String id)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;title&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Feign04-Feign超时和重试分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign04/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign04/</id>
    <published>2020-04-18T14:05:39.000Z</published>
    <updated>2020-06-02T14:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign超时和重试"><a href="#Feign超时和重试" class="headerlink" title="Feign超时和重试"></a>Feign超时和重试</h1><p><strong>超时</strong></p><p>在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。</p><p><strong>重试</strong></p><p>服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。</p><a id="more"></a><h2 id="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"><a href="#在SpringCloud的Feign和Ribbon整合的时候，如何配置？" class="headerlink" title="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"></a>在SpringCloud的Feign和Ribbon整合的时候，如何配置？</h2><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>feign的超时时间优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="超时和重试源码"><a href="#超时和重试源码" class="headerlink" title="超时和重试源码"></a>超时和重试源码</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果feign没有配置超时时间，则读取ribbon的配置，否则读取feign的超时配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IClientConfig <span class="title">getClientConfig</span><span class="params">(Request.Options options, String clientName)</span> </span>&#123;</span><br><span class="line">   IClientConfig requestConfig;</span><br><span class="line">   <span class="keyword">if</span> (options == DEFAULT_OPTIONS) &#123;</span><br><span class="line">      requestConfig = <span class="keyword">this</span>.clientFactory.getClientConfig(clientName);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestConfig = <span class="keyword">new</span> FeignOptionsClientConfig(options);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> requestConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignLoadBalancer.execute()，发送实际的http请求的时候，就会传入设置的超时参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(</span><br><span class="line">         configOverride.get(CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">               <span class="keyword">this</span>.connectTimeout),</span><br><span class="line">         (configOverride.get(CommonClientConfigKey.ReadTimeout,</span><br><span class="line">               <span class="keyword">this</span>.readTimeout)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(<span class="keyword">this</span>.connectTimeout, <span class="keyword">this</span>.readTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><h4 id="Feign的重试"><a href="#Feign的重试" class="headerlink" title="Feign的重试"></a>Feign的重试</h4><p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p><p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。</p><p>SynchronousMethodHandler.invoke()方法里面，如果抛了异常的话，也会默认根据Retryer进行重试。</p><p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试，这个默认是NEVER_RETRY</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon的重试"><a href="#Ribbon的重试" class="headerlink" title="Ribbon的重试"></a>Ribbon的重试</h4><p>因为SpringCloud的Feign重试默认是NEVER_RETRY，所以主要是靠Ribbon的重试机制。</p><p>FeignLoadBalancer.getRequestSpecificRetryHandler()方法中，会读取配置的几个参数：OkToRetryOnAllOperations、MaxAutoRetries、MaxAutoRetriesNextServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.clientConfig.get(CommonClientConfigKey.OkToRetryOnAllOperations,</span><br><span class="line">         <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().method().equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LoadBalancerCommand.submit()方法中，读取RetryHandler中配置的参数，会根据请求的情况，是否报错，是否报异常，进行重试的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br></pre></td></tr></table></figure><p>LoadBalancerCommand包含了大量的重试逻辑，这里是判断是否对同一台机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>) </span><br><span class="line">  o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure><p>重试都会进入retryPolicy方法，判断是否需要进行重试，然后利用rxjava的retry方法进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Func2&lt;Integer, Throwable, Boolean&gt; <span class="title">retryPolicy</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxRetrys, <span class="keyword">final</span> <span class="keyword">boolean</span> same)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer tryCount, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AbortExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCount &gt; maxRetrys) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e.getCause() != <span class="keyword">null</span> &amp;&amp; e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                e = e.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> retryHandler.isRetriableException(e, same);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其他机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>) </span><br><span class="line">    o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure><blockquote><p>上面的逻辑是服务宕机的时候的重试逻辑，在超时的时候重试逻辑却是在RetryableFeignLoadBalancer里</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign超时和重试&quot;&gt;&lt;a href=&quot;#Feign超时和重试&quot; class=&quot;headerlink&quot; title=&quot;Feign超时和重试&quot;&gt;&lt;/a&gt;Feign超时和重试&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign03-Feign请求处理机制分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign03/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign03/</id>
    <published>2020-04-18T08:05:39.000Z</published>
    <updated>2020-04-18T14:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口方法与MethodHandler映射map的生成机制"><a href="#接口方法与MethodHandler映射map的生成机制" class="headerlink" title="接口方法与MethodHandler映射map的生成机制"></a>接口方法与MethodHandler映射map的生成机制</h1><p>在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br></pre></td></tr></table></figure><p>这里面就完成了SpringMVCContract对方法的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这就用contract完成了方法上的SpringMVC注解的转换</span></span><br><span class="line">  <span class="comment">// ServiceAClient的每一个方法都会被解析成MethodMetadata</span></span><br><span class="line">  <span class="comment">// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 遍历方法元数据</span></span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里就创建了SynchronousMethodHandler，key就是方法名</span></span><br><span class="line">    <span class="comment">// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="画个图"><a href="#画个图" class="headerlink" title="画个图"></a>画个图</h2><p><img src="/img/spring-cloud/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E4%B8%8EMethodHandler%E6%98%A0%E5%B0%84map%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6.jpg" alt="接口方法与MethodHandler映射map的生成机制"></p><h1 id="Feign请求处理大体流程"><a href="#Feign请求处理大体流程" class="headerlink" title="Feign请求处理大体流程"></a>Feign请求处理大体流程</h1><p><img src="/img/spring-cloud/Feign%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="Feign基于动态代理处理请求的机制"></p><h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><h2 id="动态代理拦截Client所有的方法调用"><a href="#动态代理拦截Client所有的方法调用" class="headerlink" title="动态代理拦截Client所有的方法调用"></a>动态代理拦截Client所有的方法调用</h2><p>在动态代理生成以后，动态代理所有的调用都会被FeignInvocationHandler拦截，所以我们分析实际的请求流程，需要去查看invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 排除掉equals等方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object</span><br><span class="line">          otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个dispatch，就是Map&lt;Method, MethodHandler&gt; dispatch;</span></span><br><span class="line">  <span class="comment">// 那么拿到的对象就是SynchronousMethodHandler，然后将参数传过去了</span></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将方法上的请求参数封装到RequestTemplate里"><a href="#将方法上的请求参数封装到RequestTemplate里" class="headerlink" title="将方法上的请求参数封装到RequestTemplate里"></a>将方法上的请求参数封装到RequestTemplate里</h2><p>Map&lt;Method, MethodHandler&gt; dispatch;维护了方法对象和SynchronousMethodHandler的映射，所以流程到这里，直接跟到SynchronousMethodHandler利的invoke方法去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 又是关键代码，用于替换PathVariable、@RequestParam以及RequestBody</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发起调用</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拿到的参数拼到url上，例如 /user/{id}拼接成， /user/1?name=xxx&amp;age=19</p><h2 id="执行所有的RequestInterceptor"><a href="#执行所有的RequestInterceptor" class="headerlink" title="执行所有的RequestInterceptor"></a>执行所有的RequestInterceptor</h2><p>然后开始调用executeAndDecode方法，执行http调用的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line">  <span class="comment">// 并创建可用于发送请求的Request对象</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</li><li>基于RequestTemplate创建一个Request对象，用于发送请求</li><li>将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s。基于LoadBalancerFeignClient进行了请求的处理和发送，同时获取了Response。</li></ol><h2 id="获得负载均衡器选择服务发起请求"><a href="#获得负载均衡器选择服务发起请求" class="headerlink" title="获得负载均衡器选择服务发起请求"></a>获得负载均衡器选择服务发起请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerFeignClient.execute</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      <span class="comment">// 获取请求的服务名称，也就是ServiceA</span></span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      <span class="comment">// 从请求URL中剔除了服务名称，</span></span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 基于去除了服务名称的地址创建了一个RibbonRequest</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"><span class="comment">// 这是ribbon的配置</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">            requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取请求的服务名称，也就是ServiceA</li><li>从请求URL中剔除了服务名称</li><li>基于去除了服务名称的地址创建了一个RibbonRequest</li><li>读取某个服务ribbon的配置IClientConfig</li><li>创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</li></ol><h2 id="Feign是如何与Ribbon进行整合的"><a href="#Feign是如何与Ribbon进行整合的" class="headerlink" title="Feign是如何与Ribbon进行整合的"></a>Feign是如何与Ribbon进行整合的</h2><p>上面已经创建了FeignLoadBalancer，他内部封装了Ribbon的ILoadBalancer，所以要重点分析下他究竟是如何与Ribbon进行整合的，用的是Ribbon的哪一个ILoadBalancer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CachingSpringLoadBalancerFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(clientName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   <span class="comment">// 从SpringClientFactory获取，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer</span></span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">   FeignLoadBalancer client = enableRetry ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">      loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从SpringClientFactory获取ILoadBalancer等组件，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer，这里也就自然的与Eureka完成了整合。</p><h2 id="FeignLoadBalancer如何负载均衡选择Server"><a href="#FeignLoadBalancer如何负载均衡选择Server" class="headerlink" title="FeignLoadBalancer如何负载均衡选择Server"></a>FeignLoadBalancer如何负载均衡选择Server</h2><p>进入到executeWithLoadBalancer方法中构造了一个LoadBalancerCommand，然后下面的submit方法，有一个匿名内部类ServerOperation的的实现传进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractLoadBalancerAwareClient.executeWithLoadBalancer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这提交了一个匿名内部类进去，那么ServerOperation.call方法就一定会在submit方法里被调用</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure><p>提交了一个匿名内部类作为参数，那么ServerOperation.call方法就一定会在submit方法里被调用，跟到submit方法里去看下，因为是第一次进入，所以server肯定是null，selectServer()方法，看名字明显就是调用负载均衡选择服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ribbon的重试参数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    <span class="comment">// selectServer 负载均衡选择实例</span></span><br><span class="line">    Observable&lt;T&gt; o = </span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">      ......省略部分代码</span><br><span class="line">      <span class="comment">// 选择出服务实例后，对operation进行回调，进行url的替换，然后发起真正的http请求</span></span><br><span class="line">      <span class="keyword">return</span> operation.call(server)...</span><br><span class="line">      ......胜率部分代码</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 选择一个服务实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Server&gt; <span class="title">selectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Server&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取host信息，也就是服务名，然后调用负载均衡器chooseServer方法选择一个服务实例</span></span><br><span class="line">                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造了一个LoadBalancerCommand</li><li>构造了一个ServerOperation，包含了发起http调用的逻辑，作为参数传入LoadBalancerCommand.submit方法，后面会进行回调</li><li>在submit方法中，会调用selectServer方法，选择服务实例</li><li>selectServer方法调用loadBalancerContext.getServerFromLoadBalancer，最终调用负载均衡器<a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">chooseServer</a>方法选择一个服务实例，</li><li>拿到服务实例后，将Server对象传入ServerOperation的call方法进行回调</li><li>ServerOperation用server的信息替换host里的服务名，拿到真正的请求地址</li><li>再调用子类也就是FeignLoadBalancer.execute方法执行http请求</li><li>默认的connectTimeout和readTimeout都是1000毫秒</li><li>响应结果封装为RibbonResponse</li></ol><h2 id="收到响应后将json串转换成对象"><a href="#收到响应后将json串转换成对象" class="headerlink" title="收到响应后将json串转换成对象"></a>收到响应后将json串转换成对象</h2><p>回到最初的SynchronousMethodHandler方法里，在executeAndDecode方法中，<code>response = client.execute(request, options);</code>在拿到RibbonResponse以后，开始进行对响应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前面已经执行完这里的代码了，拿到了RibbonResponse</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">      response.toBuilder().request(request).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键代码在这里</span></span><br><span class="line">        <span class="keyword">return</span> decode(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">return</span> decode(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到响应以后，执行decode方法，这个decoder默认是ResponseEntityDecoder，将json字符串转换成java对象，也就是方法的返回类型，metadata.returnType()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">decode</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DecodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画个图总结"><a href="#画个图总结" class="headerlink" title="画个图总结"></a>画个图总结</h2><p><img src="/img/spring-cloud/Feign%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-7217603.jpg" alt="Feign请求处理机制"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;a href=&quot;#接口方法与MethodHandler映射map的生成机制&quot; class=&quot;headerlink&quot; title=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;/a&gt;接口方法与MethodHandler映射map的生成机制&lt;/h1&gt;&lt;p&gt;在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;String, MethodHandler&amp;gt; nameToHandler = targetToHandlersByName.apply(target);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里面就完成了SpringMVCContract对方法的解析&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ReflectiveFeign.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, MethodHandler&amp;gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Target key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 这就用contract完成了方法上的SpringMVC注解的转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ServiceAClient的每一个方法都会被解析成MethodMetadata&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;MethodMetadata&amp;gt; metadata = contract.parseAndValidatateMetadata(key.type());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Map&amp;lt;String, MethodHandler&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String, MethodHandler&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 遍历方法元数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (MethodMetadata md : metadata) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BuildTemplateByResolvingArgs buildTemplate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!md.formParams().isEmpty() &amp;amp;&amp;amp; md.template().bodyTemplate() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildFormEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (md.bodyIndex() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildTemplateByResolvingArgs(md);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在这里就创建了SynchronousMethodHandler，key就是方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.put(md.configKey(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign02-动态代理创建FeignClient的实例</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign02/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign02/</id>
    <published>2020-04-18T05:05:39.000Z</published>
    <updated>2020-04-18T09:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理创建FeignClient的实例"><a href="#动态代理创建FeignClient的实例" class="headerlink" title="动态代理创建FeignClient的实例"></a>动态代理创建FeignClient的实例</h1><p>在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 每个服务对应一个Spring容器，里面就包含了所有的FeignClientSpecification，在FeignAutoConfiguration中定义好了</span></span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   <span class="comment">// Feign对象构建器，Feign包含了动态代理生成对象的代码，详细分析在下一节</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面先看下Feign.Builder是如何构造的</p><h2 id="Feign-Builder构造过程以及Feign在SpringCloud中的默认组件"><a href="#Feign-Builder构造过程以及Feign在SpringCloud中的默认组件" class="headerlink" title="Feign.Builder构造过程以及Feign在SpringCloud中的默认组件"></a>Feign.Builder构造过程以及Feign在SpringCloud中的默认组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 这里的所有组件默认bean，定义都是在FeignClientsConfiguration里</span></span><br><span class="line"><span class="comment">// 除非用@FeignClients的defaultConfiguration覆盖</span></span><br><span class="line"><span class="comment">// 或者用@FeignClient的configuration覆盖</span></span><br><span class="line"><span class="comment">// 优先级 代码可以在NamedContextFactory.createContext查看</span></span><br><span class="line"><span class="comment">// 1、@FeignClient的configuration</span></span><br><span class="line"><span class="comment">// 2、@FeignClients的defaultConfiguration</span></span><br><span class="line"><span class="comment">// 3、SpringCloud的FeignClientsConfiguration</span></span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 去ServiceA对应的Spring容器里获取自己的FeignLoggerFactory，默认是DefaultFeignLoggerFactory</span></span><br><span class="line">   FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);</span><br><span class="line">   <span class="comment">// type就是feignClient的class</span></span><br><span class="line">   <span class="comment">// Slf4jLogger</span></span><br><span class="line">   Logger logger = loggerFactory.create(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder</span></span><br><span class="line">   <span class="comment">// 否则是Feign.Builder，那么默认就是Feign.Builder</span></span><br><span class="line">   <span class="comment">// @formatter:off</span></span><br><span class="line">   Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">         <span class="comment">// required values</span></span><br><span class="line">         .logger(logger)</span><br><span class="line">         <span class="comment">// 默认是SpringEncoder</span></span><br><span class="line">         .encoder(get(context, Encoder.class))</span><br><span class="line">       <span class="comment">// 默认是ResponseEntityDecoder</span></span><br><span class="line">         .decoder(get(context, Decoder.class))</span><br><span class="line">         <span class="comment">// 默认是SpringMvcContract</span></span><br><span class="line">         .contract(get(context, Contract.class));</span><br><span class="line">   <span class="comment">// @formatter:on</span></span><br><span class="line">   <span class="comment">// 读取application.yml设置一些参数，feign.client开头的，超时、日志级别等</span></span><br><span class="line">   configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>从ServiceA对应的Spring容器读取FeignLoggerFactory，默认是DefaultFeignLoggerFactory</li><li>DefaultFeignLoggerFactory创建并设置Logger，是Slf4jLogger</li><li>从ServiceA对应的Spring容器读取并设置Feign.Builder，如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder，默认是Feign.Builder</li><li>从ServiceA对应的Spring容器读取并设置Encoder，默认是SpringEncoder</li><li>从ServiceA对应的Spring容器读取并设置Decoder，默认是ResponseEntityDecoder</li><li>从ServiceA对应的Spring容器读取并设置Contract，默认是SpringMvcContract</li><li>读取并设置application.yml属性</li></ol><h2 id="超时、日志级别、拦截器等属性设置"><a href="#超时、日志级别、拦截器等属性设置" class="headerlink" title="超时、日志级别、拦截器等属性设置"></a>超时、日志级别、拦截器等属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 用@FeignClient指定的configuration进行配置，和读取application.yml</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureFeign</span><span class="params">(FeignContext context, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">  FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.class);</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个默认是true</span></span><br><span class="line">    <span class="keyword">if</span> (properties.isDefaultToProperties()) &#123;</span><br><span class="line">      <span class="comment">// 读取configuration</span></span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line"> <span class="comment">// 全局配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      <span class="comment">// 特定服务配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    configureUsingConfiguration(context, builder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureUsingProperties</span><span class="params">(FeignClientProperties.FeignClientConfiguration config, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getLoggerLevel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.logLevel(config.getLoggerLevel());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getConnectTimeout() != <span class="keyword">null</span> &amp;&amp; config.getReadTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.options(<span class="keyword">new</span> Request.Options(config.getConnectTimeout(), config.getReadTimeout()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRetryer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Retryer retryer = getOrInstantiate(config.getRetryer());</span><br><span class="line">      builder.retryer(retryer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getErrorDecoder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ErrorDecoder errorDecoder = getOrInstantiate(config.getErrorDecoder());</span><br><span class="line">      builder.errorDecoder(errorDecoder);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRequestInterceptors() != <span class="keyword">null</span> &amp;&amp; !config.getRequestInterceptors().isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// this will add request interceptor to builder, not replace existing</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;RequestInterceptor&gt; bean : config.getRequestInterceptors()) &#123;</span><br><span class="line">         RequestInterceptor interceptor = getOrInstantiate(bean);</span><br><span class="line">         builder.requestInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getDecode404() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getDecode404()) &#123;</span><br><span class="line">         builder.decode404();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置读取过程详解：</p><ol><li><p>读取@FeignClient中指定的MyConfiguration配置，比如Logger.Level，Retryer，ErrorDecoder，Request.Options，RequestInterceptors。</p></li><li><p>读取application.yml中feign.client开头的配置，application.yml的优先级更高。</p></li><li><p>读取application.yml中feign.client.serviceA开头的配置，这个优先级最高</p></li></ol><h2 id="动态代理创建ServiceAClient的实例"><a href="#动态代理创建ServiceAClient的实例" class="headerlink" title="动态代理创建ServiceAClient的实例"></a>动态代理创建ServiceAClient的实例</h2><p>根据配置构造好了Feign.Builder后，就要开始创建Feign.Client的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查@FeignClient是否配置了url地址</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">// 拼了一个http://ServiceA出来</span></span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="comment">// Target 一般就是和动态代理有关的类，即被代理的对象</span></span><br><span class="line">      <span class="comment">// HardCodedTarget包含了 type:接口类class(ServiceAClient)，name(ServiceA)和url(http://ServiceA)。</span></span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>如果@FeignClient没有配置url属性，就将服务名拼接成<a href="http://servicea)这样的地址/">http://ServiceA）这样的地址</a></li><li>构造了一个HardCodedTarget，包含了type:接口类class(ServiceAClient)，name(ServiceA)和url(<a href="http://servicea),和feign.builder、feigncontext一起传入loadbalance./">http://ServiceA)，和Feign.Builder、FeignContext一起传入loadBalance。</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 从上下文中获得一个LoadBalancerFeignClient，这里，就和ribbon结合起来了</span></span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      builder.client(client);</span><br><span class="line">      <span class="comment">// 那么targeter就是动态代理的组件</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>从上下文获取了一个Client，通过IDEA强大的源码查看能力，找到一个实现类LoadBalancerFeignClient，取决于不同的实现，可能会由<code>DefaultFeignLoadBalancedConfiguration</code> 或者<code>HttpClientFeignLoadBalancedConfiguration</code>或者<code>OkHttpFeignLoadBalancedConfiguration</code>定义的，通过FeignRibbonClientAutoConfiguration的@Import注解导入。默认是Default开头的。LoadBalancerFeignClient就是基于Ribbon，可负载均衡的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>从Spring容器中获取到targeter动态代理的组件，Targeter的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 这个条件明显是成立的，所以代码拿到的肯定是HystrixTargeter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在HystrixTargeter中，如果没有开启feign.hystrix.enabled配置，那么就进入默认的Feign.Builder.target方法，不过在生产环境中，一般都会开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认情况下是Feign.Builder，所以会进入这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   feign.target(target)方法里，将Feign.Builder中所有的的东西集成在一起，构造一个ReflectiveFeign，调用newInstance方法，传入target生成动态代理</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">    <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                         logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">    <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                            errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>调用newInstance方法，传入target，生成ServiceAClient的动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 关键代码，接口中的每个方法的名称，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  <span class="comment">// 接口中的每个方法对应的Method对象，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  <span class="comment">// 到时候每一个handler，都会去触发真正的调用</span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 反射遍历ServiceAClient的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 基于工厂创建的InvocationHandler，JDK动态代理的组件, 这里是ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">// 基于JDK的动态代理创建了一个动态代理对象，这个proxy对象，就实现了ServiceAClient接口</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建完成后，对象被放入Sping容器中，可以被其他类注入使用。</p></li></ol><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/feign%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.jpg" alt="feign动态代理的构造过程"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;a href=&quot;#动态代理创建FeignClient的实例&quot; class=&quot;headerlink&quot; title=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;/a&gt;动态代理创建FeignClient的实例&lt;/h1&gt;&lt;p&gt;在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign01-流程大体分析和源码分析入口</title>
    <link href="http://www.saily.top/2020/04/12/springcloud/feign01/"/>
    <id>http://www.saily.top/2020/04/12/springcloud/feign01/</id>
    <published>2020-04-12T11:05:39.000Z</published>
    <updated>2020-04-18T08:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign的组件简介"><a href="#Feign的组件简介" class="headerlink" title="Feign的组件简介"></a>Feign的组件简介</h1><p>Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件</p><ol><li>编码器和解码器：Encoder和Decoder。<br>Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。<br>Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。</li><li>Logger：用于打印接口请求相关的调用日志</li><li>Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 </li><li>Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。</li><li>FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。</li></ol><a id="more"></a><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a><strong>默认配置</strong></h2><p>Spring Cloud对feign的默认组件</p><ul><li>Encoder:SpringEncoder</li><li>Decoder:ResponseEntityDecoder</li><li>Logger:Sl4jLogger</li><li>Contract:SpringMvcContract，解析Spring web mvc的注解</li><li>Feign.Builder:HystrixFeign.Builder，和Hystrix整合使用</li><li>FeignClient:LoadBalancerFeignClient，底层还是和Ribbon整合</li></ul><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a><strong>自定义配置</strong></h2><p>可以通过自定义配置覆盖一些默认的组件，也可以定义拦截器配置，可实现对feign的请求进行拦截，可用于在发起请求之前动态添加请求头，或者打印日志等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;serviceA&quot;,configuration=MyConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyRequestInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><h3 id="feign配置"><a href="#feign配置" class="headerlink" title="feign配置"></a>feign配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 某个服务的配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">ServiceA:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br></pre></td></tr></table></figure><h3 id="启用feign的压缩"><a href="#启用feign的压缩" class="headerlink" title="启用feign的压缩"></a>启用feign的压缩</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">compression:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">            <span class="attr">min-request-size:</span> <span class="number">2048</span></span><br><span class="line">        <span class="attr">response:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="启用请求日志"><a href="#启用请求日志" class="headerlink" title="启用请求日志"></a>启用请求日志</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.zhss.service.ServiceAClient:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><h2 id="大体流程画图"><a href="#大体流程画图" class="headerlink" title="大体流程画图"></a>大体流程画图</h2><p>大体分析一下Feign是如何完成请求的，包含动态代理，路径和参数的拼装，与Ribbon的整合等。</p><p><img src="/img/spring-cloud/Feign%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="Feign的核心工作流程"></p><h1 id="Feign源码入口"><a href="#Feign源码入口" class="headerlink" title="Feign源码入口"></a>Feign源码入口</h1><p>在分析feign源码之前，应该从哪里入手？那么我们在接入feign的时候，有2个很重要的注解，分别是@EnableFeignClients开启feign，和每个接口上的@FeignClient。</p><p>分别看一下注解源码上的javadoc。</p><h2 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h2><p>用@FeignClient注解标记的接口，会被创建为一个Rest Client，可以被其他组件注入使用。</p><p>如果Ribbon启用的话，就会采用负载均衡的方式发送http请求。负载均衡器可以用@RibbonClient来配置，RibbonClient的和名字要和FeignClient的名字一样。就是@FeignClient(“serviceA”)可以通过下面的配置来指定对应服务Ribbon的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient(name = &quot;serviceA&quot;, configuration = ServiceAConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                         serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><p>扫描那些标记了@FeignClient的接口，指定要扫描哪些包下面的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientsRegistrar是非常重要的一个类，SpringBoot大多数的EnableXXX注解都是通过@Import来完成功能开启的，所以我们猜测，SpringBoot项目启动后，在识别到EnableFeignClients注解后，FeignClientsRegistrar肯定是扫描了标记@FeignClient的接口，完成了@FeignClient的注册。这部分代码和RibbonClientConfigurationRegistrar的相似的，都是先加载了一个default开头的默认配置，然后将每个服务对应的client的配置再加载一些，包装了FeignClientSpecification类放在spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerDefaultConfiguration"><a href="#registerDefaultConfiguration" class="headerlink" title="registerDefaultConfiguration"></a>registerDefaultConfiguration</h3><p>注册默认配置和注册FeignClient，这儿和Ribbon的代码差不多。</p><p>1、Application启动类的全的限定名</p><p>2、获取@EnableFeignClients注解里配置的defaultConfiguration属性</p><p>3、利用以上2个属性，构建一个FeignClientSpecification，注册到了Spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 拿到EnableFeignClients注解所有配置的属性</span></span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 属性里是否包含defaultConfiguration配置</span></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="comment">// 组装成default.com.demo.DemoApplication这样的name</span></span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册feign Client配置</span></span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Object configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是Spring用来构建Bean实例用的构建器，这里搞一个FeignClientSpecification的实例</span></span><br><span class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">    .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">  builder.addConstructorArgValue(name);</span><br><span class="line">  builder.addConstructorArgValue(configuration);</span><br><span class="line">  <span class="comment">// 这儿就是default.com.demo.DemoApplication.org.springframework.cloud.netflix.feign.FeignClientSpecification作为bean的name,FeignClientSpecification的实例作为对象，注册到了Spring的上下文中。</span></span><br><span class="line">  registry.registerBeanDefinition(</span><br><span class="line">    name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">    builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerFeignClients"><a href="#registerFeignClients" class="headerlink" title="registerFeignClients"></a>registerFeignClients</h3><p>这个方法会扫描配置的包，然后将标注了@FeignClient注解的接口，进行配置的注册。</p><ol><li>获得组件扫描器ClassPathScanningCandidateComponentProvider，这是个内部类。</li><li>如果没有配置clients属性，设置扫描的组件为标记了@FeignClient注解类或者接口。读取@EnableFeignClients的basePackages属性</li><li>如果没有配置basePackages属性，就会根据注解所在的类设置为扫描的包，例如DemoApplication所在的包</li><li>如果配置了clients属性，则不会开启扫描，直接使用配置的clients。一般不会配置</li><li>遍历basePackages，扫描所有注解了@FeignClient的类或者接口。判断的逻辑在内部匿名类ClassPathScanningCandidateComponentProvider.isCandidateComponent方法里</li><li>得到标记了@FeignClient的接口</li><li>根据@FeignClient的配置注册serviceId对应的个性化配置</li><li>根据配置的属性，构建器模式构建基于FeignClientFactoryBean的BeanDefinition并注册到BeanDefinitionRegistry中。此时FeignClient类的实例并没有生成，只是构建了一个FeignClientFactoryBean的BeanDefinition，并将其注册到了BeanDefinitionRegistry（也就是Spring上下文）里。大胆猜一下，应该是在后面才会用动态代理去创建FeignClient接口的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 扫描用的组件</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">   </span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient.class);</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">   <span class="comment">// 如果没有配置clients属性</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 扫描标记了@FeignClient注解的接口</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 扫描EnableFeignClients里配置的basePackages</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则遍历配置的clients，加载相应配置。</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 如果EnableFeignClients没有配置basePackages，则扫描DemoApplication所在的包</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// 找到标记了@FeignClient的注解</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line">            <span class="comment">// 拿到@FeignClient注解配置的属性</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient.class.getCanonicalName());</span><br><span class="line"><span class="comment">// 拿到配置的serviceId</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 根据配置的configuration，注册服务名个性化的配置</span></span><br><span class="line">            <span class="comment">// ServiceA.org.springframework.cloud.netflix.feign.FeignClientSpecification</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line"><span class="comment">// 注册FeignClient</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 构建器模式构建基于FeignClientFactoryBean的BeanDefinition</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">   validate(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// ServiceA</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// ServiceAFeignClient</span></span><br><span class="line">   String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">   <span class="comment">// 构建器构造完成</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">&quot;primary&quot;</span>); <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画图总结流程"><a href="#画图总结流程" class="headerlink" title="画图总结流程"></a>画图总结流程</h3><p><img src="/img/spring-cloud/%E6%89%AB%E6%8F%8F@FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="扫描@FeignClient注解的机制"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign的组件简介&quot;&gt;&lt;a href=&quot;#Feign的组件简介&quot; class=&quot;headerlink&quot; title=&quot;Feign的组件简介&quot;&gt;&lt;/a&gt;Feign的组件简介&lt;/h1&gt;&lt;p&gt;Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码器和解码器：Encoder和Decoder。&lt;br&gt;Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。&lt;br&gt;Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。&lt;/li&gt;
&lt;li&gt;Logger：用于打印接口请求相关的调用日志&lt;/li&gt;
&lt;li&gt;Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 &lt;/li&gt;
&lt;li&gt;Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。&lt;/li&gt;
&lt;li&gt;FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>分析Ribbon源码，Ribbon在底层如何拉取服务列表、进行负载均衡选择并发起Http请求</title>
    <link href="http://www.saily.top/2020/03/31/springcloud/ribbon01/"/>
    <id>http://www.saily.top/2020/03/31/springcloud/ribbon01/</id>
    <published>2020-03-31T15:05:39.000Z</published>
    <updated>2020-05-14T08:34:24.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><strong>服务注册</strong>，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。</p><p><strong>服务发现</strong>就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。</p><p><strong>负载均衡</strong>就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。</p><a id="more"></a><h1 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h1><p>Spring Cloud Ribbon组件，也是基于Netflix Ribbon做的封装。</p><p>Ribbon包含几个核心组件：</p><ul><li><p>IRule:负载均衡规则组件，轮询，随机，权重等。</p></li><li><p>IPing: 用于检测服务是否存活，剔除宕机的服务。</p></li><li><p>ServerList: 针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及eureka的DomainExtractingServerList。</p></li><li><p>ILoadBalancer:负载均衡器，选择服务用，包含了IRule、IPing和ServerList。</p></li><li><p>LoadBalancerClient: 这是SpringCloud二次封装的一层组件，基于以上组件进行服务列表更新，过滤，选择并发起http调用。</p></li></ul><p>大体流程如下图所示：</p><p><img src="/img/spring-cloud/image-20200331230023575.png" alt="image-20200331230023575"></p><ol><li>自动装配LoadBalancerAutoConfiguration</li><li>在自动配置类中，会为RestTemplate添加拦截器LoadBalancerInterceptor</li><li>调用请求后，拦截器中获取host，并在LoadBalancerClient中对host信息进行转换，得到真正的服务器地址。</li><li>LoadBalancerClient中从Eureka client得到服务实例列表，然后通过包含了负载均衡规则IRule，选出要发起调用的server。</li><li>交给负责Http通讯的组件LoadBalancerRequest执行真正的http请求。</li></ol><h2 id="RestTemplate如何拥有负载均衡的能力"><a href="#RestTemplate如何拥有负载均衡的能力" class="headerlink" title="RestTemplate如何拥有负载均衡的能力"></a>RestTemplate如何拥有负载均衡的能力</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced的源码： 标记RestTemplate被配置为使用LoadBalancerClient。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient</span><br></pre></td></tr></table></figure><p>定位在这个注解所在的jar包，可以发现有如下的类：</p><p><img src="/img/spring-cloud/image-20200402225210595.png" alt="image-20200402225210595"></p><p>根据SpringBoot的命名习惯，自动装配的类一般都是XXXAutoConfiguration，所以我们应该重点关注LoadBalancerAutoConfiguration这个类，进去看看，我省略掉部分代码，找到我们最应该关注的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto configuration for Ribbon (client side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will Tran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gang Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RestTemplate.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  .....省略部分代码</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplateCustomizer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">restTemplate.getInterceptors());</span><br><span class="line">list.add(loadBalancerInterceptor);</span><br><span class="line">restTemplate.setInterceptors(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  ....省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里给系统里的RestTemplate添加了拦截器，LoadBalancerInterceptor。在声明了LoadBalancerInterceptor后，用RestTemplateCustomizer定制化了拦截器<code>restTemplate.setInterceptors(list);</code>。</p><p>去LoadBalancerInterceptor看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line"><span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// for backwards compatibility</span></span><br><span class="line"><span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 原来是在这个方法里替换了host，将host通过loadBalancer转换成了实际要访问的ip:port</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    <span class="comment">// 这里是serviceA</span></span><br><span class="line">String serviceName = originalUri.getHost();</span><br><span class="line">Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);</span><br><span class="line">    <span class="comment">// 通过拦截器处理后，将serviceA转换为ip:port，在拦截器里去执行了真正的http请求</span></span><br><span class="line">    <span class="comment">// cmd + option + B 可以在IDEA直接定位到实现类RibbonLoadBalancerClient的源码</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个源码打开一看，我们一下就明朗了，原来SpringCloud是这样通过拦截器实现了restTeplate.getForObject(“<a href="http://servicea/hello&quot;">http://serviceA/hello&quot;</a>) 到restTeplate.getForObject(“<a href="http://192.168.21.100:8080/hello&quot;)%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">http://192.168.21.100:8080/hello&quot;)的转换。</a></p><p>在RibbonLoadBalancerClient的类上按option(alt) + F7，可以迅速的找到在哪里声明创建的这个类的实例，如下图所示，也就是在RibbonAutoConfiguration类里。</p><p><img src="/img/spring-cloud/image-20200404224238571.png" alt="image-20200404224238571"></p><p>接着看一下RibbonLoadBalancerClient的execute方法具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonLoadBalancerClient，execute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找服务对应的负载均衡器，因为每个服务ribbon配置可能不一样</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// getServer方法里，会调用loadBalancer.chooseServer方法。</span></span><br><span class="line">  <span class="comment">// 这个server就已经包含了具体的ip和port</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">                                                                           serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行真正的http请求</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....省略部分代码</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// chooseServer方法会去执行真正的IRule实现逻辑，利用负载均衡规则筛选出适合的服务实例</span></span><br><span class="line">  <span class="keyword">return</span> loadBalancer.chooseServer(<span class="string">&quot;default&quot;</span>); <span class="comment">// <span class="doctag">TODO:</span> better handling of key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡器ILoadBalancer"><a href="#负载均衡器ILoadBalancer" class="headerlink" title="负载均衡器ILoadBalancer"></a>负载均衡器ILoadBalancer</h2><p>那么看到上面有个ILoadBalancer，ILoadBalancer维护了一份服务列表，并提供了过滤服务和用负载均衡选择server等功能。这个ILoadBalancer在SpringCloud中默认是用的什么实现呢，这里的实例是用SpringClientFactory.getLoadBalancer方法获取的，<strong>这个SpringClientFactory是SpringCloud对Ribbon的一层封装，为每一个服务都创建了一个Spring ApplicationContext，每一个服务都有自己的client，load balancer 和 client configuration实例。</strong>这个<code>SpringClientFactory</code>非常重要，它是为每一个服务指定不同配置的基础例如不同的服务采用不同的负载均衡规则，就是通过这个机制实现的。</p><p>在SpringClientFactory.getLoadBalancer方法里，调用了<code>getInstance(name, ILoadBalancer.class);</code>跟到代码里去看是如何获取实例的，最后跟到父类里，发现是用map维护了服务和上下文的对应关系，serviceA -&gt; AnnotationConfigApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个ILoadBalancer的实例究竟是在哪里创建的呢？还是老办法，option + F7，去找一个叫XXXConfiguration的类，于是在RibbonClientConfiguration的类里，发现了Bean的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ILoadBalancer定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                     serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是使用<strong>ZoneAwareLoadBalancer</strong>，父类是：DynamicServerListLoadBalancer，再往上的父类是BaseLoadBalancer。</p><blockquote><p>这里多说一句，其实RibbonClientConfiguration的加载，是在NamedContextFactory.createContext里加载的，而且优先级是最低的，具体可以看本文最后一节引用文章，现在不必细究，等把整体流程了解的差不多以后，再去看这种细节问题。</p></blockquote><h2 id="Ribbon如何获取到服务列表"><a href="#Ribbon如何获取到服务列表" class="headerlink" title="Ribbon如何获取到服务列表"></a>Ribbon如何获取到服务列表</h2><p>在ZoneAwareLoadBalancer中，并没有找到和服务列表相关的代码，去父类的构造方法看下，调用了restOfInit方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer，restOfInit方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> primeConnection = <span class="keyword">this</span>.isEnablePrimingConnections();</span><br><span class="line">  <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">// 初始化并加载服务列表，会调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  enableAndInitLearnNewServersFeature();</span><br><span class="line">  <span class="comment">// 调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  updateListOfServers();</span><br><span class="line">  <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="keyword">this</span>.getPrimeConnections() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getPrimeConnections()</span><br><span class="line">      .primeConnections(getReachableServers());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">  LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来serverListImpl，也就是ServerList就是获取服务列表的关键。那么这个ServerList是在构造方法里传入的，所以回到ZoneAwareLoadBalancer的Bean定义的地方，可以看到他是通过依赖注入获取到的。</p><p>通过IDEA看一下接口有哪些实现类：</p><p><img src="/img/spring-cloud/image-20200408233824757.png" alt="image-20200408233824757"></p><p>可以看到，针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及在spring cloud eureka包下面的DomainExtractingServerList。</p><p>由此可以断定，SpringCloud在和Ribbon和Eureka整合的时候，一定使用了DomainExtractingServerList这个类。更进一步的，找到了DomainExtractingServerList创建的地方，发现他又是包装了一层DiscoveryEnabledNIWSServerList，这个DiscoveryEnabledNIWSServerList是com.netflix.niws.loadbalancer;包下面的，在ribbon-eureka.jar里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ServerList的定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config,</span><br><span class="line">                                      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">    config, eurekaClientProvider);</span><br><span class="line">  DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">    discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line">  <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下面截图是DiscoveryEnabledNIWSServerList的getInitialListOfServers和getUpdatedListOfServers方法，在这里看到了前面熟悉的eurekaClient，通过eurekaClient获取到了实例列表，并且转成了List<DiscoveryEnabledServer>返回，我们在用IDEA分析源码的时候，真的是非常的方便，可以通过查看类或者方法的引用，来找到创建或者使用的代码。也可以很方便的通过继承关系查看，就找到可能的具体的实现。</p><p><img src="/img/spring-cloud/image-20200409210354113.png" alt="image-20200409210354113"></p><p>最后，将拿到的服务列表存入了成员变量allServerList中。</p><p><img src="/img/spring-cloud/image-20200409215159851.png" alt="image-20200409215159851"></p><p>已经找到了更新服务列表的地方，那么他是什么时候去更新的呢，实际上在restOfInit方法调用的enableAndInitLearnNewServersFeature方法里，就调用了一个更新器：serverListUpdater，他会定时去更新，在构造方法里，构造了PollingServerListUpdater的实例，他是在启动1秒后，每隔30秒就会执行一次，去从eureka client里将服务列表定时同步到LoadBalancer的allServerList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableAndInitLearnNewServersFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGGER.info(<span class="string">&quot;Using serverListUpdater &#123;&#125;&quot;</span>, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">  <span class="comment">// 这里的updateAction，就是调用updateListOfServers()方法。</span></span><br><span class="line">  serverListUpdater.start(updateAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法如何选择一个server"><a href="#负载均衡算法如何选择一个server" class="headerlink" title="负载均衡算法如何选择一个server"></a>负载均衡算法如何选择一个server</h2><p>前面有提到，在获取到负载均衡器（ILoadBalancer）后，就会调用chooseServer方法去选择一个server，看了眼他的逻辑，对每个机房都搞了个LoadBalancer，最后还是调用的BaseLoadBalancer.chooseServer方法，也就是父类的chooseServer方法，咱们在这里，就找到了rule.choose(key)的调用，所以接下来，我们就重点关注一下rule是哪里来的，他的默认实现又是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseLoadBalancer.chooseServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    counter = createCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  counter.increment();</span><br><span class="line">  <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;&quot;</span>, name, key, e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ZoneAwareLoadBalancer的定义类里，也就是RibbonClientConfiguration里，也声明了IRule的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration.ribbonRule</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">  rule.initWithNiwsConfig(config);</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在ZoneAvoidanceRule里，并没有找到choose方法，看一眼他的层级结构，choose方法在父类PredicateBasedRule里。</p><p><img src="/img/spring-cloud/image-20200409221508995.png" alt="image-20200409221508995"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PredicateBasedRule.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来过滤服务列表的核心逻辑，可利用自己的实现进行个性化的实例过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">  <span class="comment">// 过滤然后轮询选择服务列表</span></span><br><span class="line">  Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">  <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> server.get();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPredicate().chooseRoundRobinAfterFiltering，先过滤后再用轮询算法选择一个Server。这个具体算法可以在incrementAndGetModulo里找到，算出一个索引值，然后去List里取一个server。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractServerPredicate.java </span></span><br><span class="line"><span class="comment">// 先过滤后，再用轮询算法一次取下一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先过滤服务列表</span></span><br><span class="line">  List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">  <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.absent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轮训算法计算索引值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = nextIndex.get();</span><br><span class="line">    <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">    <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200409224739519.png" alt="image-20200409224739519"></p><p>在这里说一句题外话，其实在工作中，这个地方我们可以大做文章，比如编写自己的Rule，实现自己的负责均衡算法。也可以利用getEligibleServers的过滤服务实例机制，去实现自己Predicate，从而实现一些灰度发布等操作。关于SpringCloud的灰度发布，可参考开源框架Nepxion Discovery：<strong><a href="https://github.com/Nepxion/Discovery">https://github.com/Nepxion/Discovery</a></strong></p><h2 id="拿到server后如何发起真正的请求"><a href="#拿到server后如何发起真正的请求" class="headerlink" title="拿到server后如何发起真正的请求"></a>拿到server后如何发起真正的请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #RibbonLoadBalancerClient.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Server server = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">      server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">         .getLoadBalancerContext(serviceId);</span><br><span class="line">   RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      T returnVal = request.apply(serviceInstance);</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure><p>在选择到服务实例以后，RibbonLoadBalancerClient.execute()就要发起真正的调用了。用了一个回调，将被请求的服务器信息当作参数穿进去，完成了http的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T returnVal = request.apply(serviceInstance);</span><br></pre></td></tr></table></figure><p>所以回到LoadBalancerInterceptor类里，request是一个匿名内部类，在里面对request和服务实例进行了包装，将具体执行交给了ClientHttpRequestExecution。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerInterceptor.java</span></span><br><span class="line">requestFactory.createRequest(request, body, execution)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadBalancerRequestFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                               <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequest&lt;ClientHttpResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">apply</span><span class="params">(<span class="keyword">final</span> ServiceInstance instance)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, loadBalancer);</span><br><span class="line">      <span class="keyword">if</span> (transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : transformers) &#123;</span><br><span class="line">          serviceRequest = transformer.transformRequest(serviceRequest, instance);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> execution.execute(serviceRequest, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了ClientHttpRequestExecution里面，其实已经到了spring-web的类里了，spring-web从ServiceRequestWrapper获取到真正的请求URL地址，发起了http请求。所以spring-web的源码，这里就不再去看了，但是需要关注ServiceRequestWrapper，ServiceRequestWrapper完成了对真实请求地址的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奥秘所在类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance instance;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceRequestWrapper</span><span class="params">(HttpRequest request, ServiceInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params"> LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.instance = instance;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写了HttpRequest的getURI方法，利用LoadBalancerClient获取到了真正的请求地址。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">URI uri = <span class="keyword">this</span>.loadBalancer.reconstructURI(</span><br><span class="line"><span class="keyword">this</span>.instance, getRequest().getURI());</span><br><span class="line"><span class="keyword">return</span> uri;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonLoadBalancerClient.java</span></span><br><span class="line"><span class="comment">// 利用服务实例的host和端口以及path信息，拼接出真正的请求地址</span></span><br><span class="line"><span class="comment">// http://serviceA/sayHello -&gt; http://192.168.10.1:8080/sayHello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(instance, <span class="string">&quot;instance can not be null&quot;</span>);</span><br><span class="line">  String serviceId = instance.getServiceId();</span><br><span class="line">  RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">    .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">  URI uri;</span><br><span class="line">  Server server;</span><br><span class="line">  <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">    RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">    server = ribbonServer.getServer();</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(),</span><br><span class="line">                        instance.getPort());</span><br><span class="line">    IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">    ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                           serverIntrospector, server);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图总结下：</p><p><img src="/img/spring-cloud/image-20200410001159973.png" alt="image-20200410001159973"></p><h2 id="Ribbon-IPing检查服务是否存活"><a href="#Ribbon-IPing检查服务是否存活" class="headerlink" title="Ribbon IPing检查服务是否存活"></a>Ribbon IPing检查服务是否存活</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;Ping&quot; Discovery Client</span></span><br><span class="line"><span class="comment"> * i.e. we dont do a real &quot;ping&quot;. We just assume that the server is up if Discovery Client says so</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIWSDiscoveryPing</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerPing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (server!=<span class="keyword">null</span> &amp;&amp; server <span class="keyword">instanceof</span> DiscoveryEnabledServer)&#123;</span><br><span class="line">            DiscoveryEnabledServer dServer = (DiscoveryEnabledServer)server;            </span><br><span class="line">            InstanceInfo instanceInfo = dServer.getInstanceInfo();</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo!=<span class="keyword">null</span>)&#123;                </span><br><span class="line">                InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line">                <span class="keyword">if</span> (status!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> isAlive;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ribbon和eureka整合的时候，并不会真正的去检查服务是否存活，而是利用Discovery Client本来就会有定时更新服务列表的机制。</p><p>在BaseLoadBalancer类里，可以找到IPing的调用之处，他启动了一个定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">&quot;NFLoadBalancer-PingTimer-&quot;</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是每隔30秒，就执行一次PingTask，task里用了一个读写锁完成了ping之后的服务实例列表计算，最后更新upServerList。</p><h2 id="其他几种自带的负载均衡规则"><a href="#其他几种自带的负载均衡规则" class="headerlink" title="其他几种自带的负载均衡规则"></a>其他几种自带的负载均衡规则</h2><p>BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。</p><p>AvailabilityFilteringRule：过滤掉那些一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态。</p><p>ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server。</p><p>RandomRule：随机选择一个Server。</p><p>RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server。</p><p>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server。</p><p>ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule。</p><p>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低。</p><h2 id="服务宕机后Ribbon多久能感知到"><a href="#服务宕机后Ribbon多久能感知到" class="headerlink" title="服务宕机后Ribbon多久能感知到"></a>服务宕机后Ribbon多久能感知到</h2><p>在和eureka结合使用的情况下，因为eureka server是靠心跳来摘除服务实例，那么他是需要duration * 2 =180秒，eureka client 从server同步(recentlyChangedQueue)默认是需要30秒，Ribbon从Eureka Client同步也是30秒，所以最多可能需要240秒，也就是4分钟才能知道一个服务已经宕机了，他是有可能访问到宕机的服务，不过SpringCloud是借用了Hystrix降级和熔断的机制来解决这个问题，一定次数错误后会屏蔽某个实例。</p><p><img src="/img/spring-cloud/%E9%BB%98%E8%AE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="默认的负载均衡算法可能存在的问题"></p><h2 id="SpringCloud和Ribbon的全局配置和特定配置"><a href="#SpringCloud和Ribbon的全局配置和特定配置" class="headerlink" title="SpringCloud和Ribbon的全局配置和特定配置"></a>SpringCloud和Ribbon的全局配置和特定配置</h2><p>这有篇文章写的比较清晰，说明了SpringCloud在读取Ribbon配置的时候是通过懒加载去读取配置的，也就是第一次发起调用的时候，才会通过NamedContextFactory.createContext去初始化@RibbonClients和@RibbonClient指定的配置。 但是@RibbonClients和@RibbonClient的配置被放入NamedContextFactory的configurations字段中，是在RibbonClientConfigurationRegistrar这个类里，结合源码看看文章，就很清楚了。</p><p><a href="https://www.cnblogs.com/trust-freedom/p/11216280.html">https://www.cnblogs.com/trust-freedom/p/11216280.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务发现&lt;/strong&gt;就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="ribnon" scheme="http://www.saily.top/tags/ribnon/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码05-服务集群初始化和同步原理分析</title>
    <link href="http://www.saily.top/2020/03/28/springcloud/eureka05/"/>
    <id>http://www.saily.top/2020/03/28/springcloud/eureka05/</id>
    <published>2020-03-28T03:05:39.000Z</published>
    <updated>2020-04-12T06:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-server集群相关源码分析"><a href="#eureka-server集群相关源码分析" class="headerlink" title="eureka server集群相关源码分析"></a>eureka server集群相关源码分析</h1><p>前面的文章分别介绍了服务启动、注册、下线、故障和自我保护机制等原理，这里就开始介绍集群相关的东西。</p><p><img src="/img/spring-cloud/image-20200329222305903.png" alt="image-20200329222305903"></p><a id="more"></a><h2 id="集群信息初始化"><a href="#集群信息初始化" class="headerlink" title="集群信息初始化"></a>集群信息初始化</h2><p>eureka server集群高可用，是需要相互注册的，然后会相互同步服务实例列表。前面分析eureka server启动流程的时候，在EurekaBootstrap的初始化代码里有一段和集群相关的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五步，处理peer节点相关的事情</span></span><br><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">  registry,</span><br><span class="line">  eurekaServerConfig,</span><br><span class="line">  eurekaClient.getEurekaClientConfig(),</span><br><span class="line">  serverCodecs,</span><br><span class="line">  applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个PeerEurekaNodes的start方法，在DefaultEurekaServerContext的初始化代码中被调用。它会解析配置文件中配置的其他eureka server的地址，基于URL地址构造一个一个的PeerEurekaNode，然后将其他节点的信息保存到本地。默认是每隔10分钟，会定时基于这个配置刷新集群配置信息。</p><h2 id="集群数据同步"><a href="#集群数据同步" class="headerlink" title="集群数据同步"></a>集群数据同步</h2><p>在初始化集群的节点信息后，还需要同步其他节点的注册表到本地。也就是EurekaBootstrap初始化代码里的registry.syncUp();，因为自己本来也是一个eureka client，<a href="http://www.saily.top/2020/03/21/springcloud/eureka03/#eureka-client%E5%85%A8%E9%87%8F%E6%8A%93%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8">所以在启动初始化的时候，就已经从任意一个其他的eureka server节点拉取到注册表在本地</a>，在这里只需要将缓存的实例信息取出来，然后在挨个本地注册一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果第一次没有在本地的eureka client 中获取任何注册表</span></span><br><span class="line">      <span class="comment">// 那么就等待30秒，看DiscoveryClient.fetchRegistry是否已经执行完成。</span></span><br><span class="line">      Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Interrupted during registry transfer..&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是读取的eureka client在本地初始化的时候拉取的全量注册表缓存。</span></span><br><span class="line">  Applications apps = eurekaClient.getApplications();</span><br></pre></td></tr></table></figure><p>那么在源码里我们可以看到，这里有一个重试的机制，里面还包含了sleep的代码，其实就是因为eureka client在本地的缓存可能还没有生成成功，就先执行了这里的代码，所以会等到30秒后再重试，看是否缓存已经有了数据。</p><p>这里也包含了上一节中提到的统计服务实例数量，后续会用来计算预期收到的心跳次数。</p><h2 id="注册、下线、故障集群间同步"><a href="#注册、下线、故障集群间同步" class="headerlink" title="注册、下线、故障集群间同步"></a>注册、下线、故障集群间同步</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>还记得eureka server处理注册请求的代码，在ApplicationResource.addInstance方法中，调用PeerAwareInstanceRegistryImpl.register方法进行注册，那么replicateToPeers方法，就会将注册数据同步到其他节点，此时这里的<code>isReplication</code>参数是false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">  <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">  <span class="comment">// 将注册信息同步到其他集群节点</span></span><br><span class="line">  replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到这个方法里面看一下，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，但是这里和client调用是有区别的，他底层的调用发起类是JerseyReplicationClient，在发起http请求的时候，一定会带上请求头：<code>webResource.header(PeerEurekaNode.HEADER_REPLICATION, &quot;true&quot;);</code>，那么其他节点在收到请求的时候，上面的<code>isReplication</code>就是肯定是true了。当<code>isReplication</code>是true的时候，不会像其他节点进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> Cancel:</span><br><span class="line">    node.cancel(appName, id);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Heartbeat:</span><br><span class="line">    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Register:</span><br><span class="line">    node.register(info);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> StatusUpdate:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.statusUpdate(appName, id, newStatus, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DeleteStatusOverride:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.deleteStatusOverride(appName, id, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册逻辑的批处理"><a href="#注册逻辑的批处理" class="headerlink" title="注册逻辑的批处理"></a>注册逻辑的批处理</h2><p>跟到node.register(info);里去看，这块代码有点复杂，他用了一个三层队列做了一个批处理请求。</p><ol><li>集群同步的机制：client可以找任意一个几点发送请求，然后这个server会将请求同步到其他所有的节点上去，但是其他的server仅仅只会在本地执行，不会再往其他节点同步。</li><li>数据同步的异步批处理机制：有三个队列，第一个队列纯写入（acceptorQueue），第二个队列用来根据时间和大小来拆分队列（processingOrder），第三个队列用来放批处理任务(batchWorkQueue)—&gt;任务批处理机制。</li></ol><p>流程如下图所示。</p><p><img src="/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在看完Eureka集群的源码以后，关于Eureka的核心概念涉及到的源码已经分析完成。在SpringCloud中，其实只是做了一层简单的封装，比如把配置文件从读取properties文件改成了从application.yml里，然后利用SpringBoot的自动装配去做了一些自动配置，并没有什么新鲜的东西。下面一张图总结下eureka 核心流程和原理</p><p><img src="/img/spring-cloud/image-20200330224323248.png" alt="image-20200330224323248"></p><ol><li>eureka server启动：注册中心</li><li>eureka client启动：服务实例</li><li>服务注册：map数据结构</li><li>eureka server集群：注册表的同步，三层队列任务批处理机制</li><li>全量拉取注册表：多级缓存机制，</li><li>增量拉取注册表：一致性hash比对机制，recentChangedQueue</li><li>心跳机制：服务续约，renew，刷新时间</li><li>服务下线：cancel</li><li>服务故障：expiration，eviction</li><li>自我保护机制：自动识别eureka server出现网络故障了，上一分钟心跳次数少于期望的心跳次数。</li><li>控制台：jsp页面。</li></ol><p><img src="/img/spring-cloud/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="未命名文件"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka-server集群相关源码分析&quot;&gt;&lt;a href=&quot;#eureka-server集群相关源码分析&quot; class=&quot;headerlink&quot; title=&quot;eureka server集群相关源码分析&quot;&gt;&lt;/a&gt;eureka server集群相关源码分析&lt;/h1&gt;&lt;p&gt;前面的文章分别介绍了服务启动、注册、下线、故障和自我保护机制等原理，这里就开始介绍集群相关的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/image-20200329222305903.png&quot; alt=&quot;image-20200329222305903&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码04-服务心跳、下线、故障和服务自我保护机制流程分析</title>
    <link href="http://www.saily.top/2020/03/22/springcloud/eureka04/"/>
    <id>http://www.saily.top/2020/03/22/springcloud/eureka04/</id>
    <published>2020-03-22T10:05:39.000Z</published>
    <updated>2020-05-19T14:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务心跳流程分析"><a href="#服务心跳流程分析" class="headerlink" title="服务心跳流程分析"></a>服务心跳流程分析</h1><p>eureka client每隔一定的时间，会给eureka server发送心跳，保持心跳，让eureka server认为自己还活着。</p><p>心跳在代码里，叫做续约。</p><ol><li><p>还是在DiscoveryClient初始化的时候，有一个心跳的定时任务，由<code>HeartbeatThread</code>执行。</p></li><li><p>默认值是每隔30秒去发送一个心跳。DEFAULT_LEASE_RENEWAL_INTERVAL</p></li><li><p>接下来是用jersy去给eureka server发送心跳的http请求。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>请求的地址是：<code>PUT apps/&#123;appName&#125;/&#123;id&#125;</code></p></li><li><p>我们根据这个接口去找下是什么类处理的请求，这个又是让我好一顿找：在ApplicationsResource里有个<code>@Path(&quot;&#123;appId&#125;&quot;)</code>，这里已经组成了路径<code>apps/&#123;appId&#125;</code>，然后在ApplicationsResource里边又有一个``@Path(“{id}”)<code>方法，到这里就是</code>apps/{appId}/{id}`，是不是刚好符合客户端的请求路径，但是还是没有定位到PUT方法在哪里，继续看InstanceResource里的renewLease方法，配合参数看下，终于才找到了server端处理心跳逻辑的代码。<em>不得不说这个隐藏的真是比较深，你看那个getInstanceInfo方法，你很难想到这个get方法只是一个路径的节点，具体的处理还得继续往里跟。应该是也因为我不熟悉jersy这个框架，不知道怎么快速定位一个mvc路径的执行代码。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationsResource</span></span><br><span class="line"><span class="meta">@Path(&quot;&#123;appId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@PathParam(&quot;version&quot;)</span> String version,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@PathParam(&quot;appId&quot;)</span> String appId)</span> </span>&#123;</span><br><span class="line">    CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ApplicationResource</span></span><br><span class="line"><span class="meta">@Path(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InstanceResource <span class="title">getInstanceInfo</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceResource(<span class="keyword">this</span>, id, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstanceResource</span></span><br><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;overriddenstatus&quot;)</span> String overriddenStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;status&quot;)</span> String status,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;lastDirtyTimestamp&quot;)</span> String lastDirtyTimestamp)</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>通过注册表的renew方法，完成服务续约的逻辑。registry.renew，实际还是进入AbstractInstanceRegistry.renew这个方法里。</p></li><li><p>用appName获取服务注册表那个map，做了一些检查。最后执行续约的逻辑（leaseToRenew.renew();）其实就是更新了一下lastUpdateTimestamp的时间，加上了duration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line"><span class="comment">// 一些代码</span></span><br><span class="line">leaseToRenew.renew();</span><br></pre></td></tr></table></figure></li></ol><h1 id="服务下线流程分析"><a href="#服务下线流程分析" class="headerlink" title="服务下线流程分析"></a>服务下线流程分析</h1><p>下面看一下DiscoveryClient的shutdown方法的逻辑。</p><ol><li><p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。关注里边的unregister();方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</span><br></pre></td></tr></table></figure><p>对应的路径是，<code>DELETE apps/&#123;appName&#125;/&#123;id&#125;</code>，和上面一样，是在InstanceResource类里的cancelLease方法。</p></li><li><p>最后跟着源码里走，执行的的逻辑是AbstractInstanceRegistry.internalCancel方法。</p></li><li><p>取到注册表的map，直接调用remove从map里给移除了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">....</span><br><span class="line">gMap.remove(id);</span><br></pre></td></tr></table></figure></li><li><p>然后调用了leaseToCancel.cancel();，设置了evictionTimestamp时间。</p></li><li><p>在recentlyChangedQueue里新增了一条服务实例变更记录，保留3分钟。（用于在客户端进行增量更新的时候进行合并）</p></li><li><p>调用invalidateCache，让缓存失效，从readWriteCacheMap里全部清理掉。会有定时任务每隔30秒让readOnlyCacheMap和readWriteCacheMap进行同步。这部分逻辑在上一篇文章有分析到。</p></li><li><p><strong>下次所有的eureka client来拉取增量注册表的时候，就会返回recentlyChangedQueue里的数据，然后在本地进行合并，比对hash值，再决定是否重新拉取全量注册表的逻辑。</strong></p></li></ol><p><img src="/img/spring-cloud/image-20200322230318802.png" alt="image-20200322230318802"></p><p>这里再一次体现了，无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能60秒才能感知到服务的下线。</p><h1 id="服务故障流程分析"><a href="#服务故障流程分析" class="headerlink" title="服务故障流程分析"></a>服务故障流程分析</h1><p>如果客户端在故障后，没有通知eureka server服务下线。那么就需要用到eureka server自己的故障感应机制，以及服务实例摘除的机制。</p><p>eureka server是靠心跳来感知服务是否存活，如果在一定时间内没有收到心跳，那么就认为服务已经宕机了，此时会修改服务状态，并进行摘除。</p><p>可以判定，肯定是有一个定时任务，在定时的判断。就是EurekaBootStrap初始化方法里的这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line">AbstractInstanceRegistry.postInit()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    renewsLastMin.start();</span><br><span class="line">    <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        evictionTaskRef.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">    evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔60秒，会执行一次任务，判断服务实例的租约是否已经过期了，虽然定时任务是60秒一次，这里有个getCompensationTimeMs();方法，计算上次心跳，到这次任务执行的时间差到底是多少，从而保证准确的计算过期时间，因为可能jvm gc原因或者时钟原因，并没有刚好60秒执行这次的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前时间</span></span><br><span class="line">  <span class="keyword">long</span> currNanos = getCurrentTimeNano();</span><br><span class="line">  <span class="comment">// 上次任务的时间</span></span><br><span class="line">  <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</span><br><span class="line">  <span class="keyword">if</span> (lastNanos == <span class="number">0l</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0l</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 间隔时间是和配置的时间间隔，getEvictionIntervalTimerInMs默认是60秒</span></span><br><span class="line">  <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</span><br><span class="line">  <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</span><br><span class="line">  <span class="keyword">return</span> compensationTime &lt;= <span class="number">0l</span> ? <span class="number">0l</span> : compensationTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line"><span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line"><span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">  Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">  <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">      Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        expiredLeases.add(lease);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否过期</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if the lease of a given &#123;<span class="doctag">@link</span> com.netflix.appinfo.InstanceInfo&#125; has expired or not.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that due to renew() doing the &#x27;wrong&quot; thing and setting lastUpdateTimestamp to +duration more than</span></span><br><span class="line"><span class="comment">     * what it should be, the expiry will actually be 2 * duration. This is a minor bug and should only affect</span></span><br><span class="line"><span class="comment">     * instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will</span></span><br><span class="line"><span class="comment">     * not be fixed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalLeaseMs any additional lease time to add to the lease evaluation in ms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lastUpdateTimestamp上次心跳时间+90秒+比预期的任务时间晚了多少秒。</span></span><br><span class="line">  <span class="comment">// 看似这里的逻辑是，在不计算预期任务执行的时间情况下，90s没有收到过心跳就认为已经过期</span></span><br><span class="line">  <span class="comment">// 但是看上面的注释，其实这里是有一个bug，因为在心跳的时候，时间就已经+了duration，比如上次心跳的时间 22:47:44，那么lastUpdateTimestamp就是22:49:14</span></span><br><span class="line">  <span class="comment">// 所以在这里判断的时候，真正判断的过期时间是22:50:44，相比上次心跳，已经是过去了180s的时间。</span></span><br><span class="line">  <span class="comment">// 并且这个bug不打算修复</span></span><br><span class="line">  <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，要3分钟没有收到心跳，才会剔除一个服务的实例。</p><p>接着后面就是拆除服务实例的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性不能摘除太多的实例，因为有可能是eureka server节点自己的网络故障原因，导致没有心跳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line"><span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line"><span class="comment">// 所以想下面计算了一个比例，比如当前注册表的大小是20，getRenewalPercentThreshold的默认值是0.85，</span></span><br><span class="line"><span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line"><span class="comment">// 这里是17</span></span><br><span class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line"><span class="comment">// 所以限制最多只能是3个</span></span><br><span class="line"><span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设expiredLeases过期了6个，和3个里选个最小值，这里是3，随机再从6个里选3个摘除，最后调用internalCancel（服务下线的方法）</span></span><br><span class="line"><span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line"><span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)&quot;</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">    <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">    <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br></pre></td></tr></table></figure><p>最后调用internalCancel（服务下线的方法）。所以说一个服务如果没有心跳了，可能需要定时任务60秒+心跳时间90秒+过期判断90s，也许要4分钟以上，才能感知一个服务下线了，再加上客户端同步的间隔时间，时间就会更长。</p><h1 id="服务自我保护机制"><a href="#服务自我保护机制" class="headerlink" title="服务自我保护机制"></a>服务自我保护机制</h1><p>下面看一下eureka server自我保护机制。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>如果有20个服务实例，在1分钟以内，只有8个服务保持了心跳，那么eureka server会将剩余的12个没有心跳的服务实例全部摘除吗？其实不是的，有可能是由于eureka server自己的机器所在的网络故障了，导致那些服务心跳发送不过来，导致eureka server一直没有更新心跳的时间。</p><p>进入自我保护机制以后，就不会摘除任何实例了。</p><p>还是看上面一节的evict方法，第一行就有一个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否允许主动删除实例，和自我保护机制有关</span></span><br><span class="line"><span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;DS: lease expiration is currently disabled.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码命名其实也是非常奇怪的，你光看名字，永远也想不到isLeaseExpirationEnabled方法里会包含自我保护机制的触发代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果关闭自我保护机制，随时可以清理实例</span></span><br><span class="line">  <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">    <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 会触发自我保护机制</span></span><br><span class="line">  <span class="comment">// numberOfRenewsPerMinThreshold 期望所有服务实例1分钟要有发送多少次心跳过来</span></span><br><span class="line">  <span class="comment">// getNumOfRenewsInLastMin() 上1分钟所有服务实例一共发送多少次心跳</span></span><br><span class="line">  <span class="comment">// 如果上一分钟的心跳次数（假设是102次） &gt; 我所期望的心跳次数，那么返回true，就可以清理服务实例</span></span><br><span class="line">  <span class="comment">// 如果上次心跳次数（假设20次） &lt; 我期望的100次，此时返回false，表示不清理服务实例。</span></span><br><span class="line">  <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="isLeaseExpirationEnabled方法判断自我保护机制开启"><a href="#isLeaseExpirationEnabled方法判断自我保护机制开启" class="headerlink" title="isLeaseExpirationEnabled方法判断自我保护机制开启"></a>isLeaseExpirationEnabled方法判断自我保护机制开启</h3><p>在evict服务故障的定时任务中，有个isLeaseExpirationEnabled方法会判断<strong>上一分钟的心跳次数</strong>是否小于<strong>期望的一分钟内心跳次数</strong>，如果小于，那么不会清理服务实例。</p><h3 id="如何计算期望的一分钟心跳次数"><a href="#如何计算期望的一分钟心跳次数" class="headerlink" title="如何计算期望的一分钟心跳次数"></a>如何计算期望的一分钟心跳次数</h3><p><strong>numberOfRenewsPerMinThreshold的值是如何设定的？</strong></p><ol><li><p>EurekaBootStrap是启动初始化的类，有一行registry.openForTraffic（开启故障检查）的代码，完成了numberOfRenewsPerMinThreshold的初始化。<br>首先调用sync方法，从相邻的eureka server节点拷贝注册表（调用服务实例列表后注册到本地），拿到服务实例的数量。服务实例数量 * 2 * getRenewalPercentThreshold(0.85)。得到numberOfRenewsPerMinThreshold。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></span><br><span class="line"><span class="comment">// 如果心跳时间间隔修改了怎么办？这里不应该硬编码，应该用心跳间隔时间作来计算。</span></span><br><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// count * 2 * 0.85</span></span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">  (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure><blockquote><p>实际上这里的*2的操作，是很迷的一种写法，首先他这个地方硬编码了。然后他想表达的意思是，如果有10个实例，那么就在1分钟以内，要收到20次心跳，因为30秒一次心跳嘛。可是如果用户自己修改了心跳的间隔2时间，那这个地方不就BUG了吗？</p></blockquote></li><li><p>在注册、下线、故障的时候，肯定也会更新值，这里有个小技巧，我们要查找一个变量在哪些地方赋值过。可以在IDEA里按快捷 <code>ALT+F7</code>，在看源码的时候非常有用，如截图所示，在前边有红色一根笔的小图标，可以看得出来是写操作，绿色一本书是读操作。<br><img src="/img/spring-cloud/image-20200329171857177.png" alt="image-20200329171857177"><br>AbstractInstanceRegistry.register方法中，这里再一次做了硬编码，新注册一个实例后，每分钟期望的心跳次数就会 <code>+ 2</code>。一样的，下线就是<code>-2</code>。<strong>那么故障的时候有更新这个值吗？我反正是没有找到，直接调用internalCancel方法不会去更新这个值，所以这应该是一个BUG！！！因为如果都是因为故障下线的，这个期望的心跳值并没有更新，实际的心跳次数又变少。那么每次在清除实例的时候，可能导致快速的开启了自我保护机制，而不再去清理任何的实例了。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">(<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure></li><li><p>定时更新，根据<code>ALT+F7</code>的方式，PeerAwareInstanceRegistryImpl初始化的时候，启了定时调度任务，默认是15分钟执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      updateRenewalThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span><br><span class="line">                 serverConfig.getRenewalThresholdUpdateIntervalMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在updateRenewalThreshold任务中，从别的服务同步并合并注册表。然后计算出一个服务实例的数量。如果拉取到的服务实例数量，大于本地的期望的服务实例数量<em>0.85。**我觉得这里是不是写错了，numberOfRenewsPerMinThreshold本来就是count\</em>2*0.85，这里判断再*0.85？？？**接着再次计算了一下服务实例列表的count，count * 2 * 0.85。这个代码也是骚的很，刚计算了<code>expectedNumberOfRenewsPerMin=count * 2</code>，下面却不用这个变量，又写了一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">  <span class="comment">// Update threshold only if the threshold is greater than the</span></span><br><span class="line">  <span class="comment">// current expected threshold of if the self preservation is disabled.</span></span><br><span class="line">  <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</span><br><span class="line">      || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span><br><span class="line">    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实际的上一分钟心跳次数是如何计算的？"><a href="#实际的上一分钟心跳次数是如何计算的？" class="headerlink" title="实际的上一分钟心跳次数是如何计算的？"></a>实际的上一分钟心跳次数是如何计算的？</h3><p>回到前面判断是否开启自我保护的代码，实际的上一分钟心跳次数getNumOfRenewsInLastMin()，用到了MeasuredRate，我们可以用<code>ALT + F7</code>去找increment方法的调用处，直接定位到了renew(心跳)的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际的上一分钟心跳次数 + 1</span></span><br><span class="line">renewsLastMin.increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部实现细节----如何计算并保持上1分钟的数据？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每分钟一次，设置到lastBucket中，currentBucket设置为0</span></span><br><span class="line"><span class="comment">// lastBucket是用来读的，currentBucket是用来写的</span></span><br><span class="line"><span class="comment">// Zero out the current bucket.</span></span><br><span class="line">lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="自我保护机制的触发"><a href="#自我保护机制的触发" class="headerlink" title="自我保护机制的触发"></a>自我保护机制的触发</h3><p>如果上一分钟，实际的心跳次数少于了期望的心跳次数，那么就会开启自我保护机制，不允许摘除任何服务实例。此时认为自己的eureka server出现网络故障，大量的服务实例无法发送心跳过来。</p><p><img src="/img/spring-cloud/image-20200329182748663.png" alt="image-20200329182748663"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;服务心跳流程分析&quot;&gt;&lt;a href=&quot;#服务心跳流程分析&quot; class=&quot;headerlink&quot; title=&quot;服务心跳流程分析&quot;&gt;&lt;/a&gt;服务心跳流程分析&lt;/h1&gt;&lt;p&gt;eureka client每隔一定的时间，会给eureka server发送心跳，保持心跳，让eureka server认为自己还活着。&lt;/p&gt;
&lt;p&gt;心跳在代码里，叫做续约。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;还是在DiscoveryClient初始化的时候，有一个心跳的定时任务，由&lt;code&gt;HeartbeatThread&lt;/code&gt;执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认值是每隔30秒去发送一个心跳。DEFAULT_LEASE_RENEWAL_INTERVAL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来是用jersy去给eureka server发送心跳的http请求。</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码03-服务列表同步分析</title>
    <link href="http://www.saily.top/2020/03/21/springcloud/eureka03/"/>
    <id>http://www.saily.top/2020/03/21/springcloud/eureka03/</id>
    <published>2020-03-21T02:05:39.000Z</published>
    <updated>2020-04-17T04:14:33.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-client全量抓取注册表"><a href="#eureka-client全量抓取注册表" class="headerlink" title="eureka client全量抓取注册表"></a>eureka client全量抓取注册表</h1><p>eureka client第一次启动的时候，会从eureka server端抓取全量的注册表，在本地进行缓存。后续每隔30秒从eureka server端抓取增量的注册表信息，和本地缓存进行合并。</p><p>先找到第一次抓取全量注册表的源码，没记错的话应该是在创建DiscoveryClient的构造方法里。就是下面这几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">  fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个fetchRegistry方法，就是抓取注册表的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiscoveryClient.fetchRegistry()</span></span><br><span class="line"><span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line"><span class="comment">// applications</span></span><br><span class="line"><span class="comment">// 本地的Application缓存，在执行完成后续的全量注册表拉取后，也会将数据缓存到这个地方</span></span><br><span class="line">Applications applications = getApplications();</span><br><span class="line"><span class="keyword">if</span> 一大堆条件 &#123;</span><br><span class="line">  <span class="comment">// localRegionApps.set(this.filterAndShuffle(apps));</span></span><br><span class="line">  <span class="comment">// 用jeresy从server端获取全量注册表，然后缓存到本地（也就是上方的getApplications()）</span></span><br><span class="line">  getAndStoreFullRegistry();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 增量</span></span><br><span class="line">  getAndUpdateDelta(applications);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="eureka-server端处理抓取注册表的请求（多级缓存机制）"><a href="#eureka-server端处理抓取注册表的请求（多级缓存机制）" class="headerlink" title="eureka server端处理抓取注册表的请求（多级缓存机制）"></a>eureka server端处理抓取注册表的请求（多级缓存机制）</h1><p>根据客户端请求的接口（GET ip:port/v2/apps），去服务端找对应的处理方法。是在ApplicationsResource.getContainers方法。</p><p>eureka server端，有一套多级缓存的机制，这里的cacheKey，就是缓存用的Key，然后下面就是从缓存读取数据的逻辑，注意这里的key是ALL_APPS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">                       ResponseCacheImpl.ALL_APPS,</span><br><span class="line">                       keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">);</span><br><span class="line">Response response;</span><br><span class="line"><span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">  response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">    .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">    .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response = Response.ok(responseCache.get(cacheKey))</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eureka server的缓存，是基于ResponseCache这样的一个接口开发的。实现类是ResponseCacheImpl，看下它的get方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line">String get(final Key key, boolean useReadOnlyCache) &#123;</span><br><span class="line">    Value payload &#x3D; getValue(key, useReadOnlyCache);</span><br><span class="line">    if (payload &#x3D;&#x3D; null || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return payload.getPayload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的条件useReadOnlyCache，是通过配置读取的。再跟进去看看源码，getValue方法里，看到有了2个map，做了两级缓存，分别是readOnlyCacheMap和readWriteCacheMap，readWriteCacheMap是基于Guava Cache封装的一个缓存，程序先从只读缓存里去读，如果没有的话，会从读写缓存里去读，还是没有的话，才会从registry的map里读。实际上在ResponseCacheImpl的构造方法里，就包含了readWriteCacheMap数据初始化的逻辑。</p><blockquote><p>generatePayload方法中，从注册表中获取所有的Applications，通过ServerCodecs组件，将Applications对象序列化成一个json字符串，然后放入读写缓存（readWriteCacheMap）。接着，放入只读缓存中（readOnlyCacheMap）。</p></blockquote><p><img src="/img/spring-cloud/image-20200322172453943.png" alt="image-20200322172453943"></p><h2 id="多级缓存过期机制"><a href="#多级缓存过期机制" class="headerlink" title="多级缓存过期机制"></a>多级缓存过期机制</h2><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>有新的服务实例发生注册、下线、故障的时候，会刷新readWriteCacheMap。PeerAwareInstanceRegistryImpl的javadoc，说这个类会同步一些状态变化到其他节点，同时我们也看他也维护了注册表信息，并且注册的register方法也是在这里面，我们在register方法里，找到invalidateCache代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invalidate cache</span></span><br><span class="line">responseCache.invalidate(appName, vipAddress, secureVipAddress);</span><br></pre></td></tr></table></figure><p>这不就是调用responseCache的主动过期方法吗？之前注册的时候看不懂的逻辑，现在一切都明了。借助IDEA的快捷键，在invalidateCache方法上按<code>option + F7</code>，还能找到所有调用的方法，分别是：register、internalCancel、statusUpdate、deleteStatusOverride。</p><h3 id="定时过期"><a href="#定时过期" class="headerlink" title="定时过期"></a>定时过期</h3><p>被动过期在初始化缓存的时候就已经设置了过期属性，<code>.expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</code>，默认值是180秒。</p><h3 id="被动过期"><a href="#被动过期" class="headerlink" title="被动过期"></a>被动过期</h3><p>readOnlyCacheMap是在初始化的时候，设置了一个定时器，默认每隔30从readWriteCacheMap里对数据进行比对，如果数据不一致，就同步数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以说有服务注册、故障或者下线了，因为缓存的原因，其他客户端可能要30秒才能感知到。</p><h1 id="增量抓取注册表"><a href="#增量抓取注册表" class="headerlink" title="增量抓取注册表"></a>增量抓取注册表</h1><p>上面有说到，在eureka client初始化的时候，会全量的抓取一次注册表，然后在initScheduledTasks里启动了一个定时任务，每隔30秒会定时增量同步一次注册表的信息，具体的执行类叫做<code>CacheRefreshThread</code>。</p><ol><li>定时任务，30秒一次</li><li>因为本地有缓存的Applications，所以走增量抓取的逻辑</li><li>走eurekaHttpClient的getDelta接口，<code>GET apps/delta</code></li><li>ApplicationsResources.getContainerDifferential处理增量请求</li><li>一样是走多级缓存机制，key是ALL_APPS_DELTA。后面就是一样了，唯一的区别就是因为key不一样，所以在generatePayload方法里，执行的逻辑不一样，这里不再用registry.getApplications()获取全量数据，而是用registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));获取增量的注册表信息。</li><li>这儿有个recentlyChangedQueue，在状态变化的时候会往里边放数据，代表着最近有变化的服务实例，增量信息就是从这里边去抓取。在Registry初始化的时候有个定时任务，每隔30秒检查一次，这个队列里面的服务实例变更信息是否已经超过180秒了，如果超过会移除。所以这个队列里保留的其实是最近3分钟的服务实例变更数据。</li><li>eureka client每隔30秒，去抓取增量注册表的时候，会拿到最近3分钟内有变化的服务实例的注册表。</li><li>抓取到的注册表和本地缓存的注册表进行合并，完成服务实例的增删改。updateDelta(delta);</li><li>对合并后的注册表计算一个hash值，之前返回的delta带了一个eureka server全量注册表的hash值。对这2个值进行对比，如果不一致，此时会从eureka server抓取全量的注册表到本地。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/spring-cloud/image-20200322183205931.png" alt="image-20200322183205931"></p><h3 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h3><ol><li>如果要保存增量的最新数据变更，可以基于LinkedQueue将最新变更的数据放入这个queue中，然后用定时任务在队列超过一定时间的数据移除，保持这个队列中就是最近几分钟内变更的增量数据。</li><li>数据同步的hash值对：如果在分布式系统里，在不同的地方进行数据的同步，可以采用hash值的思想，从一个地方计算一个hash值，在另外一个地方也计算一个hash值，保证两个hash值是一样的，这样可以保证数据的准确性。 </li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka-client全量抓取注册表&quot;&gt;&lt;a href=&quot;#eureka-client全量抓取注册表&quot; class=&quot;headerlink&quot; title=&quot;eureka client全量抓取注册表&quot;&gt;&lt;/a&gt;eureka client全量抓取注册表&lt;/h1&gt;&lt;p&gt;eureka client第一次启动的时候，会从eureka server端抓取全量的注册表，在本地进行缓存。后续每隔30秒从eureka server端抓取增量的注册表信息，和本地缓存进行合并。&lt;/p&gt;
&lt;p&gt;先找到第一次抓取全量注册表的源码，没记错的话应该是在创建DiscoveryClient的构造方法里。就是下面这几行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clientConfig.shouldFetchRegistry() &amp;amp;&amp;amp; !fetchRegistry(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fetchRegistryFromBackup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码02-服务注册流程分析</title>
    <link href="http://www.saily.top/2020/03/18/springcloud/eureka02/"/>
    <id>http://www.saily.top/2020/03/18/springcloud/eureka02/</id>
    <published>2020-03-18T12:05:39.000Z</published>
    <updated>2020-04-12T06:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-client启动流程"><a href="#eureka-client启动流程" class="headerlink" title="eureka client启动流程"></a>eureka client启动流程</h1><p>上一篇文章，我们分析了eureka server的启动流程，这一篇来分析一下eureka client的启动流程。我们先要找到启动入口在哪里。在eureka-examples里，有一个ExampleEurekaClient的测试类。要执行这个类，首先需要复制一段代码，设置一些基础属性，这是从eureka-server的单元测试里复制过来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This will be read by server internal discovery client. We need to salience it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEurekaConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">  String myHostName = InetAddress.getLocalHost().getHostName();</span><br><span class="line">  String myServiceUrl = <span class="string">&quot;http://&quot;</span> + myHostName + <span class="string">&quot;:8080/v2/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.region&quot;</span>, <span class="string">&quot;default&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.name&quot;</span>, <span class="string">&quot;eureka&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.vipAddress&quot;</span>, <span class="string">&quot;eureka.mydomain.net&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.port&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.preferSameZone&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.shouldUseDns&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.shouldFetchRegistry&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.serviceUrl.defaultZone&quot;</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.serviceUrl.default.defaultZone&quot;</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.awsAccessId&quot;</span>, <span class="string">&quot;fake_aws_access_id&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.awsSecretKey&quot;</span>, <span class="string">&quot;fake_aws_secret_key&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.numberRegistrySyncRetries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在main方法的第一行调用一下上面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    injectEurekaConfiguration();</span><br><span class="line">    ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the client</span></span><br><span class="line">    ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">    EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the client</span></span><br><span class="line">    sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown the client</span></span><br><span class="line">    eurekaClient.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下上面这个方法，这段逻辑几乎和上一篇文章中介绍的eureka server启动流程中，初始化eureka client逻辑的是一样的。</p><ol><li>读取eureka-client.properties配置文件，形成服务实例配置，基于接口对外提供服务实例配置项的读取。（MyDataCenterInstanceConfig）</li><li>基于服务实例配置，构造服务实例（InstanceInfo）</li><li>基于eureka client配置和服务实例，构造服务实例管理器（ApplicationInfoManager）</li><li>读取eureka-client.properties配置文件，形成一个eureka client的配置，基于接口对外提供eureka client配置项读取（DefaultEurekaClientConfig）。</li><li>基于eureka client配置，和服务实例管理器构造了一个EurekaClient（DiscoveryClient），保存了一些配置，处理服务的注册和注册表的抓取，启动了几个线程池，启动了网络通信组件，启动了一些调度任务，注册了监控项。</li></ol><p>在DiscoveryClient的构造方法里，做了很多操作，具体可以看下图。</p><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p>![eureka client启动流程](/img/spring-cloud/eureka client启动流程.jpg)</p><h1 id="eureka-client服务注册逻辑"><a href="#eureka-client服务注册逻辑" class="headerlink" title="eureka client服务注册逻辑"></a>eureka client服务注册逻辑</h1><p>上面的逻辑咱们理完了后，发现不知道服务注册是哪一个步骤完成的，实际上注册的逻辑，是在初始化调度任务那里，和心跳任务一起初始化的<code>InstanceInfoReplicator</code>任务里。<strong>这儿其实感觉比较奇怪，注册服务和实例信息复制，在我们常见的分布式系统里应该是不同的概念，比如redis、mongodb、elastic search里都有副本的概念（Replica），但是在eureka这里，这里面实际上却是注册服务的逻辑。</strong></p><ol><li><code>InstanceInfoReplicator</code>的start方法里，将自己作为一个线程放到一个调度线程池中去了，默认</li></ol><p>是延迟40秒执行。</p><ol start="2"><li><p>那么执行线程的时候，是执行run()方法。</p></li><li><p>在run方法里，刷新了一下服务实例的信息discoveryClient.refreshInstanceInfo();，里面其实是调用ApplicationInfoManager的一些方法刷新了服务实例的配置，看看配置有没有改变，如果改变了，就刷新一下；用健康检查器检查状态，将状态设置到了ApplicationInfoManager中，更新服务实例状态。</p></li><li><p>然后调用discoveryClient.register();进行服务注册。</p></li><li><p>服务注册的时候，是基于EurekaClient的register()方法去注册的，调用的是底层的eurekaTransport的registrationClient，将InstanceInfo服务实例的信息，通过http请求，调用eureka server对外暴露的一个restful接口，将InstanceInfo发送过去。注意：EurekaTransport在构造的下一行代码的时候，调用了<strong>scheduleServerEndpointTask</strong>（一个令人迷惑的方法名），其实这个方法里就初始化了专门用于注册的registrationClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line"><span class="comment">// 其实是初始化eurekaTransport</span></span><br><span class="line">scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line">......</span><br><span class="line">httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br></pre></td></tr></table></figure></li><li><p>然后实际上底层执行发送请求的逻辑，实在是非常难找，代码嵌套过多，最后在EurekaHttpClient的子类里，寻找和http库有关的类，我们找到了AbstractJersey2EurekaHttpClient，在这里的<code>register</code>方法，发现了实际发送注册请求的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送请求，http://localhost:8080/v2/apps/ServiceA</span></span><br><span class="line"><span class="comment">// 发送的是post请求，服务实例的对象打成了一个json发送过去，包含了自己的主机，ip，端口号</span></span><br><span class="line"><span class="comment">// eureka server就知道这个ServiceA这个服务，有一个服务实例，比如是在172.16.21.33、dev-server、8080</span></span><br><span class="line">Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>eureka client在服务注册的这块代码，可以也是看到有用到工厂模式、装饰器模式，但是也有很多<strong>槽点</strong>：</p><ol><li>服务注册，不应该放在<code>InstanceInfoReplicator</code>中，语意不明朗。</li><li>负责发送请求的HttpClient，类体系过于<strong>复杂</strong>，导致看代码的人根本找不到对应的client，最后是根据顶层接口(EurekaHttpClient)和项目依赖实际是使用jersey框架来进行restful接口暴露和调用，才找到真正发送服务注册请求的地方(AbstractJersey2EurekaHttpClient)。</li></ol><h1 id="eureka-server收到注册请求的处理"><a href="#eureka-server收到注册请求的处理" class="headerlink" title="eureka server收到注册请求的处理"></a>eureka server收到注册请求的处理</h1><p>上面分析到了，eureka client向eureka server发起了http请求进行注册，下面就看一下在eureka server中，是如何接收并处理注册请求的。</p><p>因为eureka是基于jersey开发，所以我们去找/v2/apps/{appId}这样的post请求路径处理类，这个请求是在eureka-core模块中<code>ApplicationsResource</code>的<code>getApplicationResource</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;&#123;appId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@PathParam(&quot;version&quot;)</span> String version,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@PathParam(&quot;appId&quot;)</span> String appId)</span> </span>&#123;</span><br><span class="line">  CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到ApplicationResource里去找处理post的方法，就找到了接收注册请求的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="meta">@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication)</span> </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>接收的是InstanceInfo，代表了一个服务实例。</p><p>在单元测试里，有一个ApplicationResourceTest类，包含了许多功能的测试。接下来，在ApplicationResourceTest里，用断点的方式执行testGoodRegistration方法，对注册流程进行调试和源码分析。</p><p><img src="/img/spring-cloud/image-20200319222757757.png" alt="image-20200319222757757"></p><p>InstanceInfo主要包含2部分数据：</p><ol><li>主机名、ip地址、端口号、url地址</li><li>lease（租约）的信息：保持心跳的间隔时间，最近心跳的时间，服务注册的时间，服务启动的时间。</li></ol><p>register逻辑：</p><ol><li><p>检查了一些必要的参数</p></li><li><p>判断是否是在AWS数据中心，做额外的操作</p></li><li><p>调用registry.register(info, “true”.equals(isReplication));（PeerAwareInstanceRegistry）。向服务实例注册表里注册。</p></li><li><p>调用<a href="http://www.saily.top/2020/03/15/springcloud/eureka01/#%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E6%83%85">PeerAwareInstanceRegistry</a>父类的register方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    read.lock();</span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">    REGISTER.increment(isReplication);</span><br><span class="line">    <span class="comment">// 如果是第一次注册，这个map肯定是null</span></span><br><span class="line">    <span class="comment">// 对Map进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">      <span class="comment">// 一个服务会有多个实例，所以这样存</span></span><br><span class="line">      gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">      <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        gMap = gNewMap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次执行，这里肯定也是null</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">    ......省略部分代码</span><br><span class="line">    <span class="comment">// 如果是服务第一次注册，将服务实例信息放到map中</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">    <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">    gMap.put(registrant.getId(), lease);</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>这里的registry，他的数据结构里面就是保存的服务和实例信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;APP_A&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;00000&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;00001&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;00002&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;APP_B&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;10000&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line"> <span class="attr">&quot;20001&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;30002&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将服务实例的服务名和实例ID访问一个队列中（recentRegisteredQueue）</p></li><li><p>再后面也是更新一些状态。</p></li></ol><p><strong>所以服务注册，最终数据就是服务实例信息放在了一个内存的注册表中：<code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</code>。</strong></p><p>注册这里包含了一个读写锁的应用，ReentrantReadWriteLock，在这里注册的时候，上的是读锁，多个服务实例，可以同时注册。灵活运用读写锁，可以控制多线程的并发，有些操作是可以并发执行的，有些操作的互斥的。</p><h2 id="画图总结-1"><a href="#画图总结-1" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/image-20200319232127915.png" alt="image-20200319232127915"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka-client启动流程&quot;&gt;&lt;a href=&quot;#eureka-client启动流程&quot; class=&quot;headerlink&quot; title=&quot;eureka client启动流程&quot;&gt;&lt;/a&gt;eureka client启动流程&lt;/h1&gt;&lt;p&gt;上一篇文章，我们分析了eureka server的启动流程，这一篇来分析一下eureka client的启动流程。我们先要找到启动入口在哪里。在eureka-examples里，有一个ExampleEurekaClient的测试类。要执行这个类，首先需要复制一段代码，设置一些基础属性，这是从eureka-server的单元测试里复制过来的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * This will be read by server internal discovery client. We need to salience it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;injectEurekaConfiguration&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; UnknownHostException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String myHostName = InetAddress.getLocalHost().getHostName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String myServiceUrl = &lt;span class=&quot;string&quot;&gt;&amp;quot;http://&amp;quot;&lt;/span&gt; + myHostName + &lt;span class=&quot;string&quot;&gt;&amp;quot;:8080/v2/&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.region&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.name&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;eureka&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.vipAddress&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.mydomain.net&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.port&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;8080&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.preferSameZone&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.shouldUseDns&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.shouldFetchRegistry&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.serviceUrl.defaultZone&amp;quot;&lt;/span&gt;, myServiceUrl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.serviceUrl.default.defaultZone&amp;quot;&lt;/span&gt;, myServiceUrl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.awsAccessId&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;fake_aws_access_id&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.awsSecretKey&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;fake_aws_secret_key&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&amp;quot;eureka.numberRegistrySyncRetries&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码01-eureka启动流程</title>
    <link href="http://www.saily.top/2020/03/15/springcloud/eureka01/"/>
    <id>http://www.saily.top/2020/03/15/springcloud/eureka01/</id>
    <published>2020-03-15T09:05:39.000Z</published>
    <updated>2020-04-12T06:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何阅读一个开源框架的源码"><a href="#如何阅读一个开源框架的源码" class="headerlink" title="如何阅读一个开源框架的源码"></a>如何阅读一个开源框架的源码</h1><p>如果要阅读一个开源框架的源码，我们应该从什么地方入手。首先应该想到的是，从框架启动的入口入手，比如Eureka，肯定是从Eureka服务本身启动的入口开始。或者我们也可以从框架的单元测试开始看，因为单元测试都包含了框架的核心流程和功能。所以我们通过这2个入口，可以通过打断点执行的方式阅读代码的逻辑。下面我将开始学习Eureka的源码，我将基于<a href="https://github.com/Netflix/eureka.git">https://github.com/Netflix/eureka.git</a> 的v1.7.2分支进行阅读，因为我目前所用的SpringCloud引入的就是这个版本。</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>IDE选用idea2018版本进行阅读，为什么选2018版本，eureka的源码是基于gradle构建的，v1.7.2的分支是基于2.10的gradle版本，这个现在已经比较旧了，在JDK10以上的版本，无法运行，而dea2019已经开始用JDK11开始运行，具体情况可以看这篇文章，<a href="https://blog.csdn.net/jiajane/article/details/103014036">https://blog.csdn.net/jiajane/article/details/103014036</a>，是类似的问题。经过一番倒腾我最终也没有能在2019版本上加载依赖，所以我还是选择了2018版本开始源码的阅读，使用上没有区别。</p><p>先看下Eureka的核心流程，核心功能包括：</p><ul><li>服务注册</li><li>服务发现</li><li>client向server发送心跳</li><li>client向server获取服务注册表</li><li>服务实例摘除</li><li>自我保护机制</li><li>通信</li></ul><p>下面将从源码找到eureka的启动类，并作为入口进行源码分析。</p><h1 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h1><p>eureka-server依赖了eureka-client和eureka-core2个模块，server又当服务器，又当作客户端，因为在集群模式下，他们也会相互注册。注册中心相关核心的代码都在eureka-core模块里，也能看出来eureka是基于jersey（类似spring mvc)开发的接口，和客户端http请求，在服务之间相互通信。</p><p><img src="/img/spring-cloud/image-20200315153312195.png" alt="image-20200315153312195"  /><img src="/img/spring-cloud/image-20200315153257597.png" alt="image-20200315153257597"  /></p><p>然后eureka-resources里，其实就是一些css、js和jsp文件。</p><img src="/img/spring-cloud/image-20200315153346879.png" alt="image-20200315153346879"  /><p>那么eureka-server本质上其实就是一个web应用，并且在eureka-server里发现还有一个web.xml文件，所以我们应该重点分析下<code>web.xml</code>文件，里面包含了一些listener和filter，这些类应该都是我们要重点看一下的源码，先猜一下这几个类都是干什么的。</p><ul><li>com.netflix.eureka.EurekaBootStrap（初始化逻辑？）</li><li>com.netflix.eureka.StatusFilter（状态管理？）</li><li>com.netflix.eureka.ServerRequestAuthFilter（授权认证相关？）</li><li>com.netflix.eureka.RateLimitingFilter（限流控制？）</li><li>com.netflix.eureka.GzipEncodingEnforcingFilter（压缩和编码相关？）</li><li>com.sun.jersey.spi.container.servlet.ServletContainer（jersey框架初始化加载类，类似Spring MVC的DispatcherServlet）</li></ul><p>文件下面的filter-mapping里默认没有开启限流的过滤器，Gzip也只过滤<code>/v2/apps</code>路径下的请求。</p><h2 id="EurekaBootStrap（启动类，重要）"><a href="#EurekaBootStrap（启动类，重要）" class="headerlink" title="EurekaBootStrap（启动类，重要）"></a>EurekaBootStrap（启动类，重要）</h2><p>这个类在eureka-core里，监听器要关注<code>contextInitialized</code>方法，这里就是eureka-server启动，初始化的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initEurekaEnvironment();</span><br><span class="line">    initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">    ServletContext sc = event.getServletContext();</span><br><span class="line">    sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Cannot bootstrap eureka server :&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot bootstrap eureka server :&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initEurekaEnvironment"><a href="#initEurekaEnvironment" class="headerlink" title="initEurekaEnvironment"></a>initEurekaEnvironment</h3><ol><li>在initEurekaEnvironment中，ConfigurationManager.getConfigInstance()初始化ConcurrentCompositeConfiguration实例，基于<strong>双检锁单例模式</strong>的配置管理器，管理eureka的所有配置，。</li><li>初始化dataCenter，数据中心的配置，如果没有配置的话，就给个默认的（default）。</li><li>初始化eureka.environment，默认是test环境。</li></ol><h3 id="initEurekaServerContext"><a href="#initEurekaServerContext" class="headerlink" title="initEurekaServerContext"></a>initEurekaServerContext</h3><h4 id="加载eureka-server-properties文件中的配置"><a href="#加载eureka-server-properties文件中的配置" class="headerlink" title="加载eureka-server.properties文件中的配置"></a>加载eureka-server.properties文件中的配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String eurekaPropsFile &#x3D; EUREKA_PROPS_FILE.get();</span><br></pre></td></tr></table></figure><p>DefaultEurekaServerConfig的init方法中，加载了一个properties文件，文件名默认叫eureka-server.properties（<code>EUREKA_PROPS_FILE</code>变量），通过ConfigurationManager加载到内存中，然后EurekaServerConfig的方法，再用configInstance获取对应的值。EurekaServerConfig是个接口，有很多get方法，包含了eureka server需要的所有配置，都可以通过这个接口获取。通过接口，对properties文件里的配置项进行了封装，增加了代码的可读性，不像我们自己可能做的有些项目里，读取配置文件都是去调用get某个key。</p><p>在DefaultEurekaServerConfig的方法中，也能看到大量的硬编码配置项和默认值。</p><h4 id="初始化ApplicationInfoManager"><a href="#初始化ApplicationInfoManager" class="headerlink" title="初始化ApplicationInfoManager"></a>初始化ApplicationInfoManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">  ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">  : <span class="keyword">new</span> MyDataCenterInstanceConfig();</span><br><span class="line"></span><br><span class="line">applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</span><br><span class="line">  instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</span><br></pre></td></tr></table></figure><p>查看ApplicationInfoManager的javadoc说明，这个类用来初始化服务注册和被其他服务发现的一些配置，其中配置通过EurekaInstanceConfig设置，从MyDataCenterInstanceConfig的父类的构造方法可以看到，其实也是读取的eureka-client.properties文件加载的。和<code>DefaultEurekaServerConfig</code>一样<code>EurekaInstanceConfig</code>也是提供了一些方法，实际是从配置文件读取，同时也提供了默认值。</p><p><code>new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get()</code>方法返回了InstanceInfo。InstanceInfo是服务实例本身的信息，用<strong>构造器模式</strong><code>InstanceInfo.Builder.newBuilder()</code>构造了一个<code>InstanceInfo.Builder</code>实例，从instanceConfig里获取了大量配置，再加创建的几个类完成了构造。</p><p>最后，EurekaInstanceConfig和InstnaceInfo，构造了ApplicationInfoManager，作为服务实例的一个管理器。</p><h4 id="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"><a href="#初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）" class="headerlink" title="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"></a>初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br></pre></td></tr></table></figure><p>DefaultEurekaClientConfig一样也是面向接口的配置项读取方式，也同样是读取了eureka-client.properties配置，不过它只读取了eureka开头的配置项，在DefaultEurekaTransportConfig里可看到，包含了很多client相关的配置项。<strong>EurekaClientConfig</strong>配置，和前面构建好的<strong>ApplicationInfoManager</strong>（包含了服务的实例信息、配置，作为服务实例管理的一个组件）构建了eurekaClient的子类DiscoveryClient。</p><p>DiscoveryClient我们可以看一下构造方法，初始化了很多东西，重点处理：</p><ol><li>是否需要拉取注册信息，shouldRegisterWithEureka</li><li>是否要注册自己，shouldRegisterWithEureka</li><li>初始化调度线程池，scheduler</li><li>初始化心跳线程池，heartbeatExecutor</li><li>初始化缓存刷新的线程池，cacheRefreshExecutor</li><li>new EurekaTransport()，支持底层eureka client和eureka server通信的一些初始化。</li><li>如果要抓取注册表，则抓取注册表表，fetchRegistryFromBackup();</li><li>初始化调度任务，initScheduledTasks(); 定时抓取注册表、心跳。初始化服务实例副本传播器（instanceInfoReplicator），服务实例状态变更监听器（statusChangeListener）。</li></ol><h4 id="处理注册相关的事情"><a href="#处理注册相关的事情" class="headerlink" title="处理注册相关的事情"></a>处理注册相关的事情</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        eurekaClient</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过javadoc看下PeerAwareInstanceRegistryImpl是干什么用的：将所有操作复制到集群里对等的Eureka节点，以使它们保持同步。复制的主要操作是Registers,Renewals,Cancels,Expirations 和 Status Changes。</p><h4 id="处理peer节点相关的事情"><a href="#处理peer节点相关的事情" class="headerlink" title="处理peer节点相关的事情"></a>处理peer节点相关的事情</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">        registry,</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>初始化Eureka集群的信息，PeerEurekaNode包含了每个节点自己分享给其他节点的信息。</p><h4 id="完成eureka-server上下文（context）的构建以及初始化"><a href="#完成eureka-server上下文（context）的构建以及初始化" class="headerlink" title="完成eureka-server上下文（context）的构建以及初始化"></a>完成eureka-server上下文（context）的构建以及初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        serverCodecs,</span><br><span class="line">        registry,</span><br><span class="line">        peerEurekaNodes,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br><span class="line">EurekaServerContextHolder.initialize(serverContext);</span><br></pre></td></tr></table></figure><p>serverContext.initialize方法中调用了peerEurekaNodes.start();，定时当前的eureka server同步集群里其他eureka server的一些信息。</p><p>registry.init(peerEurekaNodes);</p><p>用从集群获取的到的信息，初始化本实例的注册表。其实就是和集群之间的信息同步，这个研究这块的时候再细看。</p><h4 id="从相邻的eureka节点拷贝注册信息"><a href="#从相邻的eureka节点拷贝注册信息" class="headerlink" title="从相邻的eureka节点拷贝注册信息"></a>从相邻的eureka节点拷贝注册信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</span><br></pre></td></tr></table></figure><p>看syncUp的javadoc，从一个节点拷贝注册信息，如果失败就换个节点。细节后面再看。</p><h4 id="处理监控统计项"><a href="#处理监控统计项" class="headerlink" title="处理监控统计项"></a>处理监控统计项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaMonitors.registerAllStats();</span><br></pre></td></tr></table></figure><p>注册一些监控和统计。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>启动流程，到这里就结束了，我们总结一下，源码里用了不少设计模式和优秀的实现机制，例如基于双检锁的单例模式、构建器模式，面向接口的配置读取等，这都是我们值得去学习的。</p><p>![eureka server启动流程图](/img/spring-cloud/eureka server启动流程图.jpg)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何阅读一个开源框架的源码&quot;&gt;&lt;a href=&quot;#如何阅读一个开源框架的源码&quot; class=&quot;headerlink&quot; title=&quot;如何阅读一个开源框架的源码&quot;&gt;&lt;/a&gt;如何阅读一个开源框架的源码&lt;/h1&gt;&lt;p&gt;如果要阅读一个开源框架的源码，我们应该从什么地方入手。首先应该想到的是，从框架启动的入口入手，比如Eureka，肯定是从Eureka服务本身启动的入口开始。或者我们也可以从框架的单元测试开始看，因为单元测试都包含了框架的核心流程和功能。所以我们通过这2个入口，可以通过打断点执行的方式阅读代码的逻辑。下面我将开始学习Eureka的源码，我将基于&lt;a href=&quot;https://github.com/Netflix/eureka.git&quot;&gt;https://github.com/Netflix/eureka.git&lt;/a&gt; 的v1.7.2分支进行阅读，因为我目前所用的SpringCloud引入的就是这个版本。&lt;/p&gt;</summary>
    
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
    <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
    <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-5-SpringBoot整合Spring MVC</title>
    <link href="http://www.saily.top/2020/01/30/springcloud/microservices-5/"/>
    <id>http://www.saily.top/2020/01/30/springcloud/microservices-5/</id>
    <published>2020-01-30T13:50:39.000Z</published>
    <updated>2020-03-15T14:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及到的源码：<a href="https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture">https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture</a></p><p>拖延中。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及到的源码：&lt;a href=&quot;https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture&quot;&gt;https://github.com/sail-y/spring-cloud-lectu</summary>
      
    
    
    
    <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
