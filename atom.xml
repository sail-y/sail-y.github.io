<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的博客</title>
  <icon>https://www.gravatar.com/avatar/5e6c22ad69915102664d6eb06cca090f</icon>
  <subtitle>扬帆起航</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.saily.top/"/>
  <updated>2020-05-09T16:08:49.636Z</updated>
  <id>http://www.saily.top/</id>
  
  <author>
    <name>帆</name>
    <email>hyyangfan@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HystrixCommand执行源码分析</title>
    <link href="http://www.saily.top/2020/05/09/springcloud/hystrix06/"/>
    <id>http://www.saily.top/2020/05/09/springcloud/hystrix06/</id>
    <published>2020-05-09T13:03:59.000Z</published>
    <updated>2020-05-09T16:08:49.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HystrixCommand-execute源码细节"><a href="#HystrixCommand-execute源码细节" class="headerlink" title="HystrixCommand.execute源码细节"></a>HystrixCommand.execute源码细节</h1><p>HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Future returned by Observable.toBlocking().toFuture() does not implement the</span></span><br><span class="line"><span class="comment"> * interruption of the execution thread when the "mayInterrupt" flag of Future.cancel(boolean) is set to true;</span></span><br><span class="line"><span class="comment"> * thus, to comply with the contract of Future, we must wrap around it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</span><br></pre></td></tr></table></figure><p>toObservable().toBlocking().toFuture();这行代码已经把command扔到线程池里去执行了，并且拿到了一个Future对象，没有办法在异常情况下终止Future对象对应的线程的执行，所以要对Future做一个包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>然后接下来就是对delegate做了包装，实现了一下cancel等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.get();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure><p>f.isDone()，通过future判断对应的那个线程是否完成了command的执行，然后调用f.get()会阻塞住，获取到Thread执行command返回的结果。</p><p>那我们就发现，在调用queue()方法后，就会通过线程池去执行command，然后在queue()方法中，会等待线程执行结束，如果线程执行结束了，就会返回future；即使执行失败了，也会根据情况，返回future，要不就是抛异常。</p><p>下面，我们接着分析<code>toObservable().toBlocking().toFuture();</code>核心逻辑，它实现了Hystrix几乎所有的核心逻辑，包括请求缓存、熔断、队列+线程池、线程异步执行、超时检测、异常处理、异常统计、熔断开关等。</p><h1 id="toObservable"><a href="#toObservable" class="headerlink" title="toObservable()"></a>toObservable()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Used <span class="keyword">for</span> asynchronous execution of command with a callback by subscribing to the &#123;<span class="meta">@link</span> Observable&#125;.</span><br></pre></td></tr></table></figure><p>获取到Observable后，Command还没有立即开始执行，只是将Command封装到了Observable对象。如果订阅了Observable对象，提供了回调接口，才会触发执行，并根据Command执行结果回调提供的接口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An eager &#123;@link Observable&#125; can be obtained from &#123;@link #observe()&#125;.</span><br></pre></td></tr></table></figure><p>如果希望获取到Observable对象就立即执行内部的Command的话，就不要调用toObservable()方法，可以去调用observe()方法</p><p>声明了一堆匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态是OBSERVABLE_CHAIN_CREATED</span></span><br><span class="line">        <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成false，并且用户的代码没有被执行过（HystrixCommand.run）</span></span><br><span class="line">            handleCommandEnd(<span class="keyword">false</span>); <span class="comment">//user code never ran</span></span><br><span class="line">          <span class="comment">// 如果状态是USER_CODE_EXECUTED</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成true，并且用户的代码已经运行过了（HystrixCommand.run）</span></span><br><span class="line">          handleCommandEnd(<span class="keyword">true</span>); <span class="comment">//user code did run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unsubscribeCommandCleanup</p><p>applyHystrixSemantics</p><p>wrapWithAllOnNextHooks</p><p>fireOnCompletedHook</p><p>然后基于上面的这些回调，去创建了Observable对象，因为创建Observable对象后，并不会被立马执行，所以在调用toBlocking()方法之后，才会触发执行call方法，再依次去执行上面的5个回调方法。因为Observable是rxjava的代码，所以toBlocking()的源码这里就不再跟进去看了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用toBlocking方法后就会触发执行这里的代码了</span></span><br><span class="line">        <span class="comment">// 一个Command命令只能被执行一次，所以Command对象每次都是new</span></span><br><span class="line">         <span class="comment">/* this is a stateful object so can only be used once */</span></span><br><span class="line">        <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</span><br><span class="line">            IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">"This instance can only be executed once. Please instantiate a new instance."</span>);</span><br><span class="line">            <span class="comment">//TODO make a new error type for this</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">" command executed multiple times - this is not permitted."</span>, ex, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        commandStartTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</span><br><span class="line">            <span class="comment">// log this command execution regardless of what happened</span></span><br><span class="line">            <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentRequestLog.addExecutedCommand(_cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</span><br><span class="line">        <span class="keyword">final</span> String cacheKey = getCacheKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* try from cache first */</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Observable&lt;R&gt; hystrixObservable =</span><br><span class="line">                Observable.defer(applyHystrixSemantics)</span><br><span class="line">                        .map(wrapWithAllOnNextHooks);</span><br><span class="line"></span><br><span class="line">        Observable&lt;R&gt; afterCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put in cache</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// wrap it for caching</span></span><br><span class="line">            HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// another thread beat us so we'll use the cached value instead</span></span><br><span class="line">                toCache.unsubscribe();</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we just created an ObservableCommand so we cast and return it</span></span><br><span class="line">                afterCache = toCache.toObservable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            afterCache = hystrixObservable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> afterCache</span><br><span class="line">                .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></span><br><span class="line">                .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></span><br><span class="line">                .doOnCompleted(fireOnCompletedHook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HystrixCommand-execute源码细节&quot;&gt;&lt;a href=&quot;#HystrixCommand-execute源码细节&quot; class=&quot;headerlink&quot; title=&quot;HystrixCommand.execute源码细节&quot;&gt;&lt;/a&gt;HystrixCommand.execute源码细节&lt;/h1&gt;&lt;p&gt;HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// HystrixCommand.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; R &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue().get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; Exceptions.sneakyThrow(decomposeException(e));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件的各种MaxTotalConnections详解</title>
    <link href="http://www.saily.top/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.saily.top/2020/04/29/springcloud/SpringCloud组件的各种MaxTotalConnections详解/</id>
    <published>2020-04-29T14:05:39.000Z</published>
    <updated>2020-04-29T10:19:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在zuul网关中，有关于配置连接数量的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  host:</span></span><br><span class="line"><span class="attr">    max-per-route-connections:</span> <span class="number">20</span> <span class="comment">#默认值</span></span><br><span class="line"><span class="attr">    max-total-connections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><p>这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。</p><p>这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  MaxConnectionsPerHost:</span> <span class="number">50</span> <span class="comment">#默认值</span></span><br><span class="line"><span class="attr">  MaxTotalConnections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>还有Feign的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  httpclient:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      max-connections:</span> <span class="number">200</span> <span class="comment"># 默认值 </span></span><br><span class="line"><span class="attr">      max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 默认值</span></span><br></pre></td></tr></table></figure><p>那么问题来了，在服务中既有Feign，又有Ribbon，那如果都配置了，是用哪一个配置？仔细的分析了一下，情况还比较复杂。</p><h1 id="zuul-host-max-per-route-connections"><a href="#zuul-host-max-per-route-connections" class="headerlink" title="zuul.host.max-per-route-connections"></a>zuul.host.max-per-route-connections</h1><p>刚才说这个配置和基于RIbbon调用服务没有什么关系，放个证据看一下，SimpleHostRoutingFilter是用于静态路由的具体请求处理类，这里面的初始化代码就是读取这个参数，并进行连接池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHostRoutingFilter.java</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!customHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.connectionManager = connectionManagerFactory.newConnectionManager(</span><br><span class="line">            !<span class="keyword">this</span>.sslHostnameValidationEnabled,</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxTotalConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxPerRouteConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getTimeToLive(), <span class="keyword">this</span>.hostProperties.getTimeUnit(),</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">this</span>.httpClient = newClient();</span><br><span class="line">      <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager.closeExpiredConnections();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="number">30000</span>, <span class="number">5000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="服务里的Ribbon"><a href="#服务里的Ribbon" class="headerlink" title="服务里的Ribbon"></a>服务里的Ribbon</h2><p>先说在服务里只有Ribbon，并没有引入Feign的情况下，用RestTemplate发送请求，底层是通过SimpleBufferingClientHttpRequest发起实际http请求，用的是JDK原生的http。</p><p>所以在什么都不配置的情况下，上面的<code>ribbon.MaxConnectionsPerHost</code>配置是没有用的，而且我从这个源码看下来，像那些重试参数什么的，应该都没有用。他仅仅只是给RestTemplate赋予了负载均衡的功能，其他什么都没有控制。</p><p>在<code>RibbonClientConfiguration</code>类中，还额外Import了几个关于HttpClient的类，但是在默认情况下，都没什么用。</p><p>所以其实在服务里边，什么<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>，配置了以后，他只会去注册这些bean，不会被用到。自己搞的那个RestTemplate，用的就是spring默认的JDK 原生http组件。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于RestTemplate的方式使用Ribbon，在yaml里的大多数配置都不会生效，也没什么用。</p><h2 id="网关里的Ribbon"><a href="#网关里的Ribbon" class="headerlink" title="网关里的Ribbon"></a>网关里的Ribbon</h2><p>在网关里面，大有不同，我们先看ZuulProxyAutoConfiguration配置类，他引入了几个跟http组件有关的配置类，在这里<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>就能直接起作用了，他决定了加载哪一个具体的配置。在没有okhttpclient的情况下，默认就是使用apache的httpcomponents。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZuulProxyAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span><br><span class="line">      RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span><br><span class="line">      RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span><br><span class="line">      HttpClientConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(ZuulProxyMarkerConfiguration.Marker.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonCommandFactoryConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnRibbonHttpClient</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> Set&lt;ZuulFallbackProvider&gt; zuulFallbackProviders = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> RibbonCommandFactory&lt;?&gt; ribbonCommandFactory(</span><br><span class="line">      SpringClientFactory clientFactory, ZuulProperties zuulProperties) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommandFactory(clientFactory, zuulProperties, zuulFallbackProviders);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClientRibbonCommandFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">  ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line">  <span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">  <span class="comment">//  最终还是从ribbon管理的上下文中获取到一个RibbonLoadBalancingHttpClient。注意，SpringClientFactory里的bean基本都来自于RibbonClientConfiguration，看过Ribbon的源码就知道</span></span><br><span class="line">  <span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">      serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">  client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">      clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，Ribbon本身也会对<code>RibbonClientConfiguration</code>配置类也进行初始化，一样的，他也引入了几个Http组件，和上面不同的是，zuul的几个配置类，主要是为了封装Hystrix的逻辑，实际上最终还是调用的<code>RibbonLoadBalancingHttpClient</code>执行请求。所以我们接下来去看<code>RibbonClientConfiguration</code>的配置，以及<code>RibbonLoadBalancingHttpClient</code>是如何被注册的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各种http组件支持，默认是加载最后一个</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpClientRibbonConfiguration.java</span></span><br><span class="line"><span class="comment">// 在zuul中，httpcomponents已经被自动引入了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.apache.http.client.HttpClient"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"ribbon.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个配置被RibbonClientConfiguration一起被加载，可通过@RibbonClient注解的configuration属性覆盖</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(HttpClientConnectionManager.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">httpClientConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 终于在这里找到了读取MaxTotalConnections等配置的代码</span></span><br><span class="line">     Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">     Integer maxConnectionsPerHost = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxConnectionsPerHost,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_CONNECTIONS_PER_HOST);</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里声明了一个基于Apache的httpClient的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(CloseableHttpClient.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">(ApacheHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpClientConnectionManager connectionManager, IClientConfig config)</span> </span>&#123;</span><br><span class="line">    Boolean followRedirects = config.getPropertyAsBoolean(</span><br><span class="line">        CommonClientConfigKey.FollowRedirects,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_FOLLOW_REDIRECTS);</span><br><span class="line">    Integer connectTimeout = config.getPropertyAsInteger(</span><br><span class="line">        CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    RequestConfig defaultRequestConfig = RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(connectTimeout)</span><br><span class="line">        .setRedirectsEnabled(followRedirects).build();</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClientFactory.createBuilder().</span><br><span class="line">        setDefaultRequestConfig(defaultRequestConfig).</span><br><span class="line">        setConnectionManager(connectionManager).build();</span><br><span class="line">    <span class="keyword">return</span> httpClient;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 划重点。。。终于在这里发现了RibbonLoadBalancingHttpClient的声明，并且MaxTotalConnections等属性在上面的代码已经被注册了。</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(AbstractLoadBalancerAwareClient.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(value = <span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonLoadBalancingHttpClient <span class="title">ribbonLoadBalancingHttpClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IClientConfig config, ServerIntrospector serverIntrospector,</span></span></span><br><span class="line"><span class="function"><span class="params">ILoadBalancer loadBalancer, RetryHandler retryHandler, CloseableHttpClient httpClient)</span> </span>&#123;</span><br><span class="line">RibbonLoadBalancingHttpClient client = <span class="keyword">new</span> RibbonLoadBalancingHttpClient(httpClient, config, serverIntrospector);</span><br><span class="line">client.setLoadBalancer(loadBalancer);</span><br><span class="line">client.setRetryHandler(retryHandler);</span><br><span class="line">Monitors.registerObject(<span class="string">"Client_"</span> + <span class="keyword">this</span>.name, client);</span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在网关打断点测试了一下，请求确实是通过RibbonLoadBalancingHttpClient执行的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于网关使用Ribbon，会读取<code>ribbon.MaxTotalConnections</code>和<code>ribbon.MaxConnectionsPerHost</code>等配置，并给予HTTPComponents组件进行访问。</p><h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>那么Fiegn的配置在什么时候生效？情况又有变化了，Feign同样有一个配置类<code>FeignRibbonClientAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span><br><span class="line">      OkHttpFeignLoadBalancedConfiguration.class,</span><br><span class="line">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>在默认没有额外配置的情况下，是读取的<code>DefaultFeignLoadBalancedConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="comment">// Client.Default就基于JDK的http组件完成了http的请求，底层没有连接池</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>),</span><br><span class="line">            cachingFactory, clientFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign在默认情况下使用的是JDK原生的<code>URLConnection</code>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的<code>persistence connection</code> 。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在默认情况下，也就是不开启<code>feign.okhttp.enable</code>和<code>feign.httpclient.enable</code>的时候，feign的<code>feign.max-connections</code>配置，也是没有什么用的。</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>在开启<code>feign.httpclient.enable</code>以后，HttpClientFeignLoadBalancedConfiguration会被加载。这里得加个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign-httpclient&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和Ribbon一样，Feign也定义了自己的HttpClient等组件，在定义过程中，读取了配置并利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ApacheHttpClient.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"feign.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(HttpClientConnectionManager.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">connectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        FeignHttpClientProperties httpClientProperties)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在这里读取了feign相关的MaxConnectionsPerRoute和MaxConnections配置</span></span><br><span class="line">     <span class="keyword">final</span> HttpClientConnectionManager connectionManager = connectionManagerFactory</span><br><span class="line">           .newConnectionManager(httpClientProperties.isDisableSslValidation(), httpClientProperties.getMaxConnections(),</span><br><span class="line">                 httpClientProperties.getMaxConnectionsPerRoute(),</span><br><span class="line">                 httpClientProperties.getTimeToLive(),</span><br><span class="line">                 httpClientProperties.getTimeToLiveUnit(), registryBuilder);</span><br><span class="line">     <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           connectionManager.closeExpiredConnections();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="number">30000</span>, httpClientProperties.getConnectionTimerRepeat());</span><br><span class="line">     <span class="keyword">return</span> connectionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(Client.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                SpringClientFactory clientFactory, HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    ApacheHttpClient delegate = <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200429174359246.png" alt="image-20200429174359246"></p><p>经过打了断点测试和验证， 确实在这里加载到了连接池的配置。请求也是通过ApacheHttpClient发送的。</p><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>在引入了feign-httpclient的包以后，feign才会启用<code>feign.max-connections</code>等连接池的配置。那么Ribbon之前的配置呢，在使用Feign的时候，Ribbon的那些Http相关的Bean就没有用了，不会被用到。</p><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>和上面一样，不过OkHttp只会读取MaxTotalConnections属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConnectionPool.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionPool <span class="title">httpClientConnectionPool</span><span class="params">(IClientConfig config, OkHttpClientConnectionPoolFactory connectionPoolFactory)</span> </span>&#123;</span><br><span class="line">   Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">         CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">         DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">   Object timeToLiveObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTime);</span><br><span class="line">   Long timeToLive = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME;</span><br><span class="line">   Object ttlUnitObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits);</span><br><span class="line">   TimeUnit ttlUnit = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;</span><br><span class="line">   <span class="keyword">if</span> (timeToLiveObj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">      timeToLive = (Long) timeToLiveObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ttlUnitObj <span class="keyword">instanceof</span> TimeUnit) &#123;</span><br><span class="line">      ttlUnit = (TimeUnit) ttlUnitObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于这个值应该怎么设置，大家根据自己的项目情况来设置，其实就是访问其他服务的Http连接池数量，不要设置的过于夸张了，有些人可能会跟Tomcat的maxconnections搞混了，甚至配个几千上万的，虽然名字一样，但是含义却不同。SpringBoot给我们设置的默认值，也是有参考意义的，在实际项目中，大家可以根据压测情况进行调整。</p><h1 id="Tomcat-maxConnections"><a href="#Tomcat-maxConnections" class="headerlink" title="Tomcat:maxConnections"></a>Tomcat:maxConnections</h1><p>关于Tomcat这个参数的详细解释，可以看这个博客：<a href="https://blog.csdn.net/zzzgd_666/article/details/88740198。" target="_blank" rel="noopener">https://blog.csdn.net/zzzgd_666/article/details/88740198。</a></p><p>大概说一下，Tomcat有Nio、Bio、APR三种运行模式，maxConnections是Tomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为-1，则连接数不受限制。</p><p>默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</p><p>在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。</p><p>maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，maxConnections值应该远大于maxThreads。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在zuul网关中，有关于配置连接数量的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;zuul:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  host:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    max-per-route-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    max-total-connections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。&lt;/p&gt;
&lt;p&gt;这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ribbon:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  MaxConnectionsPerHost:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  MaxTotalConnections:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#默认值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud和Hystrix的结合使用</title>
    <link href="http://www.saily.top/2020/04/19/springcloud/hystrix05/"/>
    <id>http://www.saily.top/2020/04/19/springcloud/hystrix05/</id>
    <published>2020-04-19T10:03:59.000Z</published>
    <updated>2020-05-09T15:04:26.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-Feign和Hystrix结合使用"><a href="#SpringCloud-Feign和Hystrix结合使用" class="headerlink" title="SpringCloud Feign和Hystrix结合使用"></a>SpringCloud Feign和Hystrix结合使用</h1><p>在@FeignClient中增加fallback配置，指定降级方法的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"user"</span>,url = <span class="string">"$&#123;user.url&#125;"</span>,fallback = UserFeignFallback.class</span><br><span class="line">        <span class="comment">/*fallbackFactory = UserFeignFactory.class*/</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>降级方法的编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFeignFallback</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByID</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">"100"</span>);</span><br><span class="line">        user.setName(<span class="string">"fallback 回调用户"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Feign和Hystrix整合的配置"><a href="#Feign和Hystrix整合的配置" class="headerlink" title="Feign和Hystrix整合的配置"></a>Feign和Hystrix整合的配置</h2><p>超时时间设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><p>如果要特定某个服务的配置，就不写default，这个user是FeignClient的服务名，对应一个HystrixGroup，具体的key就是方法名。</p><p>那么如果想针对服务的某一个方法配置怎么办？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line">    <span class="string">ServiceA#sayHello(Long,String):</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><p>hystrix.threadpool.default.coreSize：线程池大小，默认10</p><p>hystrix.threadpool.default.maximumSize：线程池最大大小，默认10</p><p>hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize：是否允许动态调整线程数量，默认false，只有设置为true了，上面的maximumSize才有效</p><p>hystrix.threadpool.default.keepAliveTimeMinutes ：默认是1，超出coreSize的线程，空闲1分钟后释放掉</p><p>hystrix.threadpool.default.maxQueueSize 默认－1，不能动态修改</p><p>hystrix.threadpool.default.queueSizeRejectionThreshold 可以动态修改，默认是5，先进入请求队列，然后再由线程池执行</p><h3 id="如何计算线程池？"><a href="#如何计算线程池？" class="headerlink" title="如何计算线程池？"></a>如何计算线程池？</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h2><p>hystrix.command.default.execution.isolation.strategy：隔离策略，默认Thread，可以选择Semaphore信号量 </p><p>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：超时时间，默认1000ms</p><p>hystrix.command.default.execution.timeout.enabled：是否启用超时，默认ture</p><p>hystrix.command.default.execution.isolation.thread.interruptOnTimeout：超时的时候是否中断执行，默认true  </p><p>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests：信号量隔离策略下，允许的最大并发请求数量，默认10</p><h2 id="降级配置"><a href="#降级配置" class="headerlink" title="降级配置"></a>降级配置</h2><p>hystrix.command.default.fallback.enabled 默认true</p><h2 id="熔断配置"><a href="#熔断配置" class="headerlink" title="熔断配置"></a>熔断配置</h2><p>hystrix.command.default.circuitBreaker.enabled：是否启用熔断器默认true</p><p>hystrix.command.default.circuitBreaker.requestVolumeThreshold：10秒钟内，请求数量达到多少才能去尝试触发熔断，默认20</p><p>hystrix.command.default.circuitBreaker.errorThresholdPercentage：10秒钟内，请求数量达到20，同时异常比例达到50%，就会触发熔断，默认50</p><p>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：触发熔断之后，5s内直接拒绝请求，走降级逻辑，5s后尝试half-open放过少量流量试着恢复，默认5000</p><p>hystrix.command.default.circuitBreaker.forceOpen：强制打开熔断器</p><p>hystrix.command.default.circuitBreaker.forceClosed：强制关闭熔断器</p><h2 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h2><p>hystrix.threadpool.default.metrics.rollingStats.timeInMillisecond：线程池统计指标的时间，默认10000，就是10s</p><p>hystrix.threadpool.default.metrics.rollingStats.numBuckets：将rolling window划分为n个buckets，默认10</p><p>hystrix.command.default.metrics.rollingStats.timeInMilliseconds：command的统计时间，熔断器是否打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</p><p>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</p><p>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</p><p>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</p><p>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</p><p>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</p><p>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</p><h2 id="高阶特性配置"><a href="#高阶特性配置" class="headerlink" title="高阶特性配置"></a>高阶特性配置</h2><p>hystrix.command.default.requestCache.enabled 默true </p><p>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true </p><p>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</p><p>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</p><p>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</p><h1 id="Feign和Hystrix结合的原理"><a href="#Feign和Hystrix结合的原理" class="headerlink" title="Feign和Hystrix结合的原理"></a>Feign和Hystrix结合的原理</h1><p>Feign在和Hystrix整合的时候，feign动态代理里面有一些Hystrix相关的代码，请求走feign动态代理的时候，就会基于Hystrix Command发送请求，实现服务间调用的隔离、限流、超时、降级、熔断、统计等。</p><p><img src="/img/spring-cloud/Feign和Hystrix的核心原理.jpg" alt="Feign和Hystrix的核心原理"></p><h2 id="Feign中基于Hystrix的动态代理"><a href="#Feign中基于Hystrix的动态代理" class="headerlink" title="Feign中基于Hystrix的动态代理"></a>Feign中基于Hystrix的动态代理</h2><p>在Feign的动态代理代码中，HystrixTargeter默认情况下，在没有开启Hystrix的时候，会使用自带的Feign.Builder。在启用Hystrix走，就使用HystrixFeign.Builder。</p><p><strong>HystrixFeign.Builder是在这里创建的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"feign.hystrix.enabled"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">   <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixTargeter中，用Hystrix构造动态代理的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 没有开启Hystrix的话，走这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在有Hystrix的条件下，就开始往这下面走。</span></span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   <span class="comment">// 用于读取yaml文件中的Hystrix相关的配置，在执行命令的时候会用到</span></span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 有降级的话，就用降级包装下</span></span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个fallback的实例，从和服务相关联的Spring上下文里获取ServiceAClient的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HystrixFeign.Builder builder, Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">   T fallbackInstance = getFromContext(<span class="string">"fallback"</span>, feignClientName, context, fallback, target.type());</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工厂创建一个实例，并校验是否是ServiceAClient接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                              HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">   FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;)</span><br><span class="line">      getFromContext(<span class="string">"fallbackFactory"</span>, feignClientName, context, fallbackFactoryClass, FallbackFactory.class);</span><br><span class="line">   <span class="comment">/* We take a sample fallback from the fallback factory to check if it returns a fallback</span></span><br><span class="line"><span class="comment">   that is compatible with the annotated feign interface. */</span></span><br><span class="line">   <span class="comment">// 创建一个对象出来看看，检测一下创建出来的对象是否符合要求</span></span><br><span class="line">   Object exampleFallback = fallbackFactory.create(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">   Assert.notNull(exampleFallback,</span><br><span class="line">      String.format(</span><br><span class="line">      <span class="string">"Incompatible fallbackFactory instance for feign client %s. Factory may not produce null!"</span>,</span><br><span class="line">         feignClientName));</span><br><span class="line">   <span class="keyword">if</span> (!target.type().isAssignableFrom(exampleFallback.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         String.format(</span><br><span class="line">            <span class="string">"Incompatible fallbackFactory instance for feign client %s. Factory produces instances of '%s', but should produce instances of '%s'"</span>,</span><br><span class="line">            feignClientName, exampleFallback.getClass(), target.type()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在确认fallbackFactory创建出来的对象没有问题后，调用HystrixFeign的target方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target, T fallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build(fallback != <span class="keyword">null</span> ? <span class="keyword">new</span> FallbackFactory.Default&lt;T&gt;(fallback) : <span class="keyword">null</span>)</span><br><span class="line">      .newInstance(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要注意build方法，里面就包含了两局关键的代码，他重新设置了invocationHandlerFactory和contract</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="function">Feign <span class="title">build</span><span class="params">(<span class="keyword">final</span> FallbackFactory&lt;?&gt; nullableFallbackFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.invocationHandlerFactory(<span class="keyword">new</span> InvocationHandlerFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 关键代码 HystrixInvocationHandler，包含了基于HystrixCommand的封装，实际还是调用dispatch</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixInvocationHandler(target, dispatch, setterFactory, nullableFallbackFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 关键代码HystrixDelegatingContract，用于解析Hystrix相关的注解</span></span><br><span class="line">  <span class="keyword">super</span>.contract(<span class="keyword">new</span> HystrixDelegatingContract(contract));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/启用Hystrix之后feign生成动态代理的过程.jpg" alt="启用Hystrix之后feign生成动态代理的过程"></p><p>再往后的代码就和Hystrix没有关系了，就在feign的动态代理那一套东西，下面继续看HystrixInvocationHandler封装的细节。</p><h2 id="Feign中HystrixCommand的执行细节"><a href="#Feign中HystrixCommand的执行细节" class="headerlink" title="Feign中HystrixCommand的执行细节"></a>Feign中HystrixCommand的执行细节</h2><p>HystrixInvocationHandler，作为一个动态代理的接口，看下它的invoke方法，他构造了一个HystrixCommand，利用Hystrix包装了请求的执行，在HystrixCommand的run方法里，就包含了执行调用的代码（SynchronousMethodHandler）。如果执行请求的时候报错的话，就会调用getFallbac方法，就会执行之前配置的降级方法，执行降级的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixInvocationHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// early exit if the invoked method is from java.lang.Object</span></span><br><span class="line">  <span class="comment">// code is the same as ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造一个HystrixCommand匿名内部类,每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的配置，例如超时时间等</span></span><br><span class="line">  HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setterMethodMap.get(method)) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用SynchronousMethodHandler,也就是发起Http请求的代码</span></span><br><span class="line">        <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果降级方法不存在的话，父类会直接报错UnsupportedOperationException。</span></span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFallback();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建fallback</span></span><br><span class="line">        Object fallback = fallbackFactory.create(getExecutionException());</span><br><span class="line">        <span class="comment">// 调用之前定义的fallback方法</span></span><br><span class="line">        Object result = fallbackMethodMap.get(method).invoke(fallback, args);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((HystrixCommand) result).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable</span></span><br><span class="line">          <span class="keyword">return</span> ((Observable) result).toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">          <span class="keyword">return</span> ((Single) result).toObservable().toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">          ((Completable) result).await();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// shouldn't happen as method is public due to being an interface</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// Exceptions on fallback are tossed by Hystrix</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</span></span><br><span class="line">  <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toSingle();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toCompletable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hystrixCommand.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HystrixInvocationHandler构造的时候，构造了一个setterMethodMap，每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的key和groupkey的配置，例如超时时间等，线程池配置等，Setter被创建的时候，用的就是@FeignClient的name作为groupKey，也就是ServiceA，commandKey用于是类名+方法名（ServiceA#sayHello(Long,String)），这个groupKey就对应了一个线程池的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetterFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">create</span><span class="params">(Target&lt;?&gt; target, Method method)</span> </span>&#123;</span><br><span class="line">  String groupKey = target.name();</span><br><span class="line">  String commandKey = Feign.configKey(target.type(), method);</span><br><span class="line">  <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))</span><br><span class="line">      .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>基于Method对象对应的setterMethodMap，构造一个HystrixCommand匿名内部类</li><li>内部类实现了run方法和getFallback方法</li><li>run方法直接调用调用SynchronousMethodHandler发起http请求</li><li>如果run方法执行异常，getFallback方法调用之前在FeignClient中定义的降级方法</li><li>检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</li></ol><p>到这里已经看到调用了HystrixCommand的execute方法，所以接下来的内容，将会进入到Hystrix的源码中，下一篇文章细说。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringCloud-Feign和Hystrix结合使用&quot;&gt;&lt;a href=&quot;#SpringCloud-Feign和Hystrix结合使用&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud Feign和Hystrix结合使用&quot;&gt;&lt;/a&gt;SpringCloud Feign和Hystrix结合使用&lt;/h1&gt;&lt;p&gt;在@FeignClient中增加fallback配置，指定降级方法的执行&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FeignClient&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;,url = &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;user.url&amp;#125;&quot;&lt;/span&gt;,fallback = UserFeignFallback.class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*fallbackFactory = UserFeignFactory.class*/&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UserFeign&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@PostMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/&amp;#123;id&amp;#125;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;User &lt;span class=&quot;title&quot;&gt;getUserByID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@PathVariable(&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; String id)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;title&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Feign04-Feign超时和重试分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign04/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign04/</id>
    <published>2020-04-18T14:05:39.000Z</published>
    <updated>2020-04-29T10:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign超时和重试"><a href="#Feign超时和重试" class="headerlink" title="Feign超时和重试"></a>Feign超时和重试</h1><p><strong>超时</strong></p><p>在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。</p><p><strong>重试</strong></p><p>服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。</p><a id="more"></a><h2 id="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"><a href="#在SpringCloud的Feign和Ribbon整合的时候，如何配置？" class="headerlink" title="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"></a>在SpringCloud的Feign和Ribbon整合的时候，如何配置？</h2><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/" target="_blank" rel="noopener">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>feign的超时时间优先级更高</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      feignName:</span></span><br><span class="line"><span class="attr">        connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="超时和重试源码"><a href="#超时和重试源码" class="headerlink" title="超时和重试源码"></a>超时和重试源码</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果feign没有配置超时时间，则读取ribbon的配置，否则读取feign的超时配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IClientConfig <span class="title">getClientConfig</span><span class="params">(Request.Options options, String clientName)</span> </span>&#123;</span><br><span class="line">   IClientConfig requestConfig;</span><br><span class="line">   <span class="keyword">if</span> (options == DEFAULT_OPTIONS) &#123;</span><br><span class="line">      requestConfig = <span class="keyword">this</span>.clientFactory.getClientConfig(clientName);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestConfig = <span class="keyword">new</span> FeignOptionsClientConfig(options);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> requestConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignLoadBalancer.execute()，发送实际的http请求的时候，就会传入设置的超时参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(</span><br><span class="line">         configOverride.get(CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">               <span class="keyword">this</span>.connectTimeout),</span><br><span class="line">         (configOverride.get(CommonClientConfigKey.ReadTimeout,</span><br><span class="line">               <span class="keyword">this</span>.readTimeout)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(<span class="keyword">this</span>.connectTimeout, <span class="keyword">this</span>.readTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><h4 id="Feign的重试"><a href="#Feign的重试" class="headerlink" title="Feign的重试"></a>Feign的重试</h4><p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p><p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。</p><p>SynchronousMethodHandler.invoke()方法里面，如果抛了异常的话，也会默认根据Retryer进行重试。</p><p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试，这个默认是NEVER_RETRY</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon的重试"><a href="#Ribbon的重试" class="headerlink" title="Ribbon的重试"></a>Ribbon的重试</h4><p>因为SpringCloud的Feign重试默认是NEVER_RETRY，所以主要是靠Ribbon的重试机制。</p><p>FeignLoadBalancer.getRequestSpecificRetryHandler()方法中，会读取配置的几个参数：OkToRetryOnAllOperations、MaxAutoRetries、MaxAutoRetriesNextServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.clientConfig.get(CommonClientConfigKey.OkToRetryOnAllOperations,</span><br><span class="line">         <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().method().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LoadBalancerCommand.submit()方法中，读取RetryHandler中配置的参数，会根据请求的情况，是否报错，是否报异常，进行重试的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br></pre></td></tr></table></figure><p>LoadBalancerCommand包含了大量的重试逻辑，这里是判断是否对同一台机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>) </span><br><span class="line">  o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure><p>重试都会进入retryPolicy方法，判断是否需要进行重试，然后利用rxjava的retry方法进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Func2&lt;Integer, Throwable, Boolean&gt; <span class="title">retryPolicy</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxRetrys, <span class="keyword">final</span> <span class="keyword">boolean</span> same)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer tryCount, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AbortExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCount &gt; maxRetrys) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e.getCause() != <span class="keyword">null</span> &amp;&amp; e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                e = e.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> retryHandler.isRetriableException(e, same);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其他机器进行重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>) </span><br><span class="line">    o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Feign超时和重试&quot;&gt;&lt;a href=&quot;#Feign超时和重试&quot; class=&quot;headerlink&quot; title=&quot;Feign超时和重试&quot;&gt;&lt;/a&gt;Feign超时和重试&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign03-Feign请求处理机制分析</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign03/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign03/</id>
    <published>2020-04-18T08:05:39.000Z</published>
    <updated>2020-04-18T14:55:38.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口方法与MethodHandler映射map的生成机制"><a href="#接口方法与MethodHandler映射map的生成机制" class="headerlink" title="接口方法与MethodHandler映射map的生成机制"></a>接口方法与MethodHandler映射map的生成机制</h1><p>在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br></pre></td></tr></table></figure><p>这里面就完成了SpringMVCContract对方法的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这就用contract完成了方法上的SpringMVC注解的转换</span></span><br><span class="line">  <span class="comment">// ServiceAClient的每一个方法都会被解析成MethodMetadata</span></span><br><span class="line">  <span class="comment">// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 遍历方法元数据</span></span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里就创建了SynchronousMethodHandler，key就是方法名</span></span><br><span class="line">    <span class="comment">// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="画个图"><a href="#画个图" class="headerlink" title="画个图"></a>画个图</h2><p><img src="/img/spring-cloud/接口方法与MethodHandler映射map的生成机制.jpg" alt="接口方法与MethodHandler映射map的生成机制"></p><h1 id="Feign请求处理大体流程"><a href="#Feign请求处理大体流程" class="headerlink" title="Feign请求处理大体流程"></a>Feign请求处理大体流程</h1><p><img src="/img/spring-cloud/Feign基于动态代理处理请求的机制.jpg" alt="Feign基于动态代理处理请求的机制"></p><h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><h2 id="动态代理拦截Client所有的方法调用"><a href="#动态代理拦截Client所有的方法调用" class="headerlink" title="动态代理拦截Client所有的方法调用"></a>动态代理拦截Client所有的方法调用</h2><p>在动态代理生成以后，动态代理所有的调用都会被FeignInvocationHandler拦截，所以我们分析实际的请求流程，需要去查看invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 排除掉equals等方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object</span><br><span class="line">          otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个dispatch，就是Map&lt;Method, MethodHandler&gt; dispatch;</span></span><br><span class="line">  <span class="comment">// 那么拿到的对象就是SynchronousMethodHandler，然后将参数传过去了</span></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将方法上的请求参数封装到RequestTemplate里"><a href="#将方法上的请求参数封装到RequestTemplate里" class="headerlink" title="将方法上的请求参数封装到RequestTemplate里"></a>将方法上的请求参数封装到RequestTemplate里</h2><p>Map&lt;Method, MethodHandler&gt; dispatch;维护了方法对象和SynchronousMethodHandler的映射，所以流程到这里，直接跟到SynchronousMethodHandler利的invoke方法去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 又是关键代码，用于替换PathVariable、@RequestParam以及RequestBody</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发起调用</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拿到的参数拼到url上，例如 /user/{id}拼接成， /user/1?name=xxx&amp;age=19</p><h2 id="执行所有的RequestInterceptor"><a href="#执行所有的RequestInterceptor" class="headerlink" title="执行所有的RequestInterceptor"></a>执行所有的RequestInterceptor</h2><p>然后开始调用executeAndDecode方法，执行http调用的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line">  <span class="comment">// 并创建可用于发送请求的Request对象</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</li><li>基于RequestTemplate创建一个Request对象，用于发送请求</li><li>将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s。基于LoadBalancerFeignClient进行了请求的处理和发送，同时获取了Response。</li></ol><h2 id="获得负载均衡器选择服务发起请求"><a href="#获得负载均衡器选择服务发起请求" class="headerlink" title="获得负载均衡器选择服务发起请求"></a>获得负载均衡器选择服务发起请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerFeignClient.execute</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      <span class="comment">// 获取请求的服务名称，也就是ServiceA</span></span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      <span class="comment">// 从请求URL中剔除了服务名称，</span></span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 基于去除了服务名称的地址创建了一个RibbonRequest</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line"><span class="comment">// 这是ribbon的配置</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">            requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取请求的服务名称，也就是ServiceA</li><li>从请求URL中剔除了服务名称</li><li>基于去除了服务名称的地址创建了一个RibbonRequest</li><li>读取某个服务ribbon的配置IClientConfig</li><li>创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</li></ol><h2 id="Feign是如何与Ribbon进行整合的"><a href="#Feign是如何与Ribbon进行整合的" class="headerlink" title="Feign是如何与Ribbon进行整合的"></a>Feign是如何与Ribbon进行整合的</h2><p>上面已经创建了FeignLoadBalancer，他内部封装了Ribbon的ILoadBalancer，所以要重点分析下他究竟是如何与Ribbon进行整合的，用的是Ribbon的哪一个ILoadBalancer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CachingSpringLoadBalancerFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(clientName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   <span class="comment">// 从SpringClientFactory获取，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer</span></span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">   FeignLoadBalancer client = enableRetry ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">      loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从SpringClientFactory获取ILoadBalancer等组件，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer，这里也就自然的与Eureka完成了整合。</p><h2 id="FeignLoadBalancer如何负载均衡选择Server"><a href="#FeignLoadBalancer如何负载均衡选择Server" class="headerlink" title="FeignLoadBalancer如何负载均衡选择Server"></a>FeignLoadBalancer如何负载均衡选择Server</h2><p>进入到executeWithLoadBalancer方法中构造了一个LoadBalancerCommand，然后下面的submit方法，有一个匿名内部类ServerOperation的的实现传进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractLoadBalancerAwareClient.executeWithLoadBalancer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这提交了一个匿名内部类进去，那么ServerOperation.call方法就一定会在submit方法里被调用</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure><p>提交了一个匿名内部类作为参数，那么ServerOperation.call方法就一定会在submit方法里被调用，跟到submit方法里去看下，因为是第一次进入，所以server肯定是null，selectServer()方法，看名字明显就是调用负载均衡选择服务实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ribbon的重试参数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    <span class="comment">// selectServer 负载均衡选择实例</span></span><br><span class="line">    Observable&lt;T&gt; o = </span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">      ......省略部分代码</span><br><span class="line">      <span class="comment">// 选择出服务实例后，对operation进行回调，进行url的替换，然后发起真正的http请求</span></span><br><span class="line">      <span class="keyword">return</span> operation.call(server)...</span><br><span class="line">      ......胜率部分代码</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 选择一个服务实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Server&gt; <span class="title">selectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Server&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取host信息，也就是服务名，然后调用负载均衡器chooseServer方法选择一个服务实例</span></span><br><span class="line">                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造了一个LoadBalancerCommand</li><li>构造了一个ServerOperation，包含了发起http调用的逻辑，作为参数传入LoadBalancerCommand.submit方法，后面会进行回调</li><li>在submit方法中，会调用selectServer方法，选择服务实例</li><li>selectServer方法调用loadBalancerContext.getServerFromLoadBalancer，最终调用负载均衡器<a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">chooseServer</a>方法选择一个服务实例，</li><li>拿到服务实例后，将Server对象传入ServerOperation的call方法进行回调</li><li>ServerOperation用server的信息替换host里的服务名，拿到真正的请求地址</li><li>再调用子类也就是FeignLoadBalancer.execute方法执行http请求</li><li>默认的connectTimeout和readTimeout都是1000毫秒</li><li>响应结果封装为RibbonResponse</li></ol><h2 id="收到响应后将json串转换成对象"><a href="#收到响应后将json串转换成对象" class="headerlink" title="收到响应后将json串转换成对象"></a>收到响应后将json串转换成对象</h2><p>回到最初的SynchronousMethodHandler方法里，在executeAndDecode方法中，<code>response = client.execute(request, options);</code>在拿到RibbonResponse以后，开始进行对响应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前面已经执行完这里的代码了，拿到了RibbonResponse</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">      response.toBuilder().request(request).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键代码在这里</span></span><br><span class="line">        <span class="keyword">return</span> decode(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">return</span> decode(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到响应以后，执行decode方法，这个decoder默认是ResponseEntityDecoder，将json字符串转换成java对象，也就是方法的返回类型，metadata.returnType()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">decode</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DecodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画个图总结"><a href="#画个图总结" class="headerlink" title="画个图总结"></a>画个图总结</h2><p><img src="/img/spring-cloud/Feign请求处理机制-7217603.jpg" alt="Feign请求处理机制"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;a href=&quot;#接口方法与MethodHandler映射map的生成机制&quot; class=&quot;headerlink&quot; title=&quot;接口方法与MethodHandler映射map的生成机制&quot;&gt;&lt;/a&gt;接口方法与MethodHandler映射map的生成机制&lt;/h1&gt;&lt;p&gt;在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;String, MethodHandler&amp;gt; nameToHandler = targetToHandlersByName.apply(target);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里面就完成了SpringMVCContract对方法的解析&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ReflectiveFeign.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;String, MethodHandler&amp;gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Target key)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 这就用contract完成了方法上的SpringMVC注解的转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ServiceAClient的每一个方法都会被解析成MethodMetadata&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;MethodMetadata&amp;gt; metadata = contract.parseAndValidatateMetadata(key.type());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Map&amp;lt;String, MethodHandler&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String, MethodHandler&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 遍历方法元数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (MethodMetadata md : metadata) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BuildTemplateByResolvingArgs buildTemplate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!md.formParams().isEmpty() &amp;amp;&amp;amp; md.template().bodyTemplate() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildFormEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (md.bodyIndex() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildEncodedTemplateFromArgs(md, encoder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buildTemplate = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BuildTemplateByResolvingArgs(md);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在这里就创建了SynchronousMethodHandler，key就是方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.put(md.configKey(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign02-动态代理创建FeignClient的实例</title>
    <link href="http://www.saily.top/2020/04/18/springcloud/feign02/"/>
    <id>http://www.saily.top/2020/04/18/springcloud/feign02/</id>
    <published>2020-04-18T05:05:39.000Z</published>
    <updated>2020-04-18T09:09:42.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理创建FeignClient的实例"><a href="#动态代理创建FeignClient的实例" class="headerlink" title="动态代理创建FeignClient的实例"></a>动态代理创建FeignClient的实例</h1><p>在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 每个服务对应一个Spring容器，里面就包含了所有的FeignClientSpecification，在FeignAutoConfiguration中定义好了</span></span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   <span class="comment">// Feign对象构建器，Feign包含了动态代理生成对象的代码，详细分析在下一节</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">         url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面先看下Feign.Builder是如何构造的</p><h2 id="Feign-Builder构造过程以及Feign在SpringCloud中的默认组件"><a href="#Feign-Builder构造过程以及Feign在SpringCloud中的默认组件" class="headerlink" title="Feign.Builder构造过程以及Feign在SpringCloud中的默认组件"></a>Feign.Builder构造过程以及Feign在SpringCloud中的默认组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 这里的所有组件默认bean，定义都是在FeignClientsConfiguration里</span></span><br><span class="line"><span class="comment">// 除非用@FeignClients的defaultConfiguration覆盖</span></span><br><span class="line"><span class="comment">// 或者用@FeignClient的configuration覆盖</span></span><br><span class="line"><span class="comment">// 优先级 代码可以在NamedContextFactory.createContext查看</span></span><br><span class="line"><span class="comment">// 1、@FeignClient的configuration</span></span><br><span class="line"><span class="comment">// 2、@FeignClients的defaultConfiguration</span></span><br><span class="line"><span class="comment">// 3、SpringCloud的FeignClientsConfiguration</span></span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 去ServiceA对应的Spring容器里获取自己的FeignLoggerFactory，默认是DefaultFeignLoggerFactory</span></span><br><span class="line">   FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);</span><br><span class="line">   <span class="comment">// type就是feignClient的class</span></span><br><span class="line">   <span class="comment">// Slf4jLogger</span></span><br><span class="line">   Logger logger = loggerFactory.create(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder</span></span><br><span class="line">   <span class="comment">// 否则是Feign.Builder，那么默认就是Feign.Builder</span></span><br><span class="line">   <span class="comment">// @formatter:off</span></span><br><span class="line">   Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">         <span class="comment">// required values</span></span><br><span class="line">         .logger(logger)</span><br><span class="line">         <span class="comment">// 默认是SpringEncoder</span></span><br><span class="line">         .encoder(get(context, Encoder.class))</span><br><span class="line">       <span class="comment">// 默认是ResponseEntityDecoder</span></span><br><span class="line">         .decoder(get(context, Decoder.class))</span><br><span class="line">         <span class="comment">// 默认是SpringMvcContract</span></span><br><span class="line">         .contract(get(context, Contract.class));</span><br><span class="line">   <span class="comment">// @formatter:on</span></span><br><span class="line">   <span class="comment">// 读取application.yml设置一些参数，feign.client开头的，超时、日志级别等</span></span><br><span class="line">   configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>从ServiceA对应的Spring容器读取FeignLoggerFactory，默认是DefaultFeignLoggerFactory</li><li>DefaultFeignLoggerFactory创建并设置Logger，是Slf4jLogger</li><li>从ServiceA对应的Spring容器读取并设置Feign.Builder，如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder，默认是Feign.Builder</li><li>从ServiceA对应的Spring容器读取并设置Encoder，默认是SpringEncoder</li><li>从ServiceA对应的Spring容器读取并设置Decoder，默认是ResponseEntityDecoder</li><li>从ServiceA对应的Spring容器读取并设置Contract，默认是SpringMvcContract</li><li>读取并设置application.yml属性</li></ol><h2 id="超时、日志级别、拦截器等属性设置"><a href="#超时、日志级别、拦截器等属性设置" class="headerlink" title="超时、日志级别、拦截器等属性设置"></a>超时、日志级别、拦截器等属性设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 用@FeignClient指定的configuration进行配置，和读取application.yml</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureFeign</span><span class="params">(FeignContext context, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">  FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.class);</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个默认是true</span></span><br><span class="line">    <span class="keyword">if</span> (properties.isDefaultToProperties()) &#123;</span><br><span class="line">      <span class="comment">// 读取configuration</span></span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line"> <span class="comment">// 全局配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      <span class="comment">// 特定服务配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    configureUsingConfiguration(context, builder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureUsingProperties</span><span class="params">(FeignClientProperties.FeignClientConfiguration config, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getLoggerLevel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.logLevel(config.getLoggerLevel());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getConnectTimeout() != <span class="keyword">null</span> &amp;&amp; config.getReadTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.options(<span class="keyword">new</span> Request.Options(config.getConnectTimeout(), config.getReadTimeout()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRetryer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Retryer retryer = getOrInstantiate(config.getRetryer());</span><br><span class="line">      builder.retryer(retryer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getErrorDecoder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ErrorDecoder errorDecoder = getOrInstantiate(config.getErrorDecoder());</span><br><span class="line">      builder.errorDecoder(errorDecoder);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRequestInterceptors() != <span class="keyword">null</span> &amp;&amp; !config.getRequestInterceptors().isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// this will add request interceptor to builder, not replace existing</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;RequestInterceptor&gt; bean : config.getRequestInterceptors()) &#123;</span><br><span class="line">         RequestInterceptor interceptor = getOrInstantiate(bean);</span><br><span class="line">         builder.requestInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getDecode404() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getDecode404()) &#123;</span><br><span class="line">         builder.decode404();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置读取过程详解：</p><ol><li><p>读取@FeignClient中指定的MyConfiguration配置，比如Logger.Level，Retryer，ErrorDecoder，Request.Options，RequestInterceptors。</p></li><li><p>读取application.yml中feign.client开头的配置，application.yml的优先级更高。</p></li><li>读取application.yml中feign.client.serviceA开头的配置，这个优先级最高</li></ol><h2 id="动态代理创建ServiceAClient的实例"><a href="#动态代理创建ServiceAClient的实例" class="headerlink" title="动态代理创建ServiceAClient的实例"></a>动态代理创建ServiceAClient的实例</h2><p>根据配置构造好了Feign.Builder后，就要开始创建Feign.Client的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查@FeignClient是否配置了url地址</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 拼了一个http://ServiceA出来</span></span><br><span class="line">         url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="comment">// Target 一般就是和动态代理有关的类，即被代理的对象</span></span><br><span class="line">      <span class="comment">// HardCodedTarget包含了 type:接口类class(ServiceAClient)，name(ServiceA)和url(http://ServiceA)。</span></span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>如果@FeignClient没有配置url属性，就将服务名拼接成<a href="http://ServiceA）这样的地址" target="_blank" rel="noopener">http://ServiceA）这样的地址</a></li><li>构造了一个HardCodedTarget，包含了type:接口类class(ServiceAClient)，name(ServiceA)和url(<a href="http://ServiceA)，和Feign.Builder、FeignContext一起传入loadBalance。" target="_blank" rel="noopener">http://ServiceA)，和Feign.Builder、FeignContext一起传入loadBalance。</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 从上下文中获得一个LoadBalancerFeignClient，这里，就和ribbon结合起来了</span></span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      builder.client(client);</span><br><span class="line">      <span class="comment">// 那么targeter就是动态代理的组件</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>从上下文获取了一个Client，通过IDEA强大的源码查看能力，找到一个实现类LoadBalancerFeignClient，取决于不同的实现，可能会由<code>DefaultFeignLoadBalancedConfiguration</code> 或者<code>HttpClientFeignLoadBalancedConfiguration</code>或者<code>OkHttpFeignLoadBalancedConfiguration</code>定义的，通过FeignRibbonClientAutoConfiguration的@Import注解导入。默认是Default开头的。LoadBalancerFeignClient就是基于Ribbon，可负载均衡的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span><br><span class="line">      OkHttpFeignLoadBalancedConfiguration.class,</span><br><span class="line">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>从Spring容器中获取到targeter动态代理的组件，Targeter的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 这个条件明显是成立的，所以代码拿到的肯定是HystrixTargeter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"feign.hystrix.HystrixFeign"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"feign.hystrix.HystrixFeign"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在HystrixTargeter中，如果没有开启feign.hystrix.enabled配置，那么就进入默认的Feign.Builder.target方法，不过在生产环境中，一般都会开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认情况下是Feign.Builder，所以会进入这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   feign.target(target)方法里，将Feign.Builder中所有的的东西集成在一起，构造一个ReflectiveFeign，调用newInstance方法，传入target生成动态代理</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">    <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                         logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">    <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                            errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>调用newInstance方法，传入target，生成ServiceAClient的动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 关键代码，接口中的每个方法的名称，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  <span class="comment">// 接口中的每个方法对应的Method对象，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  <span class="comment">// 到时候每一个handler，都会去触发真正的调用</span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 反射遍历ServiceAClient的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 基于工厂创建的InvocationHandler，JDK动态代理的组件, 这里是ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">// 基于JDK的动态代理创建了一个动态代理对象，这个proxy对象，就实现了ServiceAClient接口</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>创建完成后，对象被放入Sping容器中，可以被其他类注入使用。</li></ol><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/feign动态代理的构造过程.jpg" alt="feign动态代理的构造过程"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;a href=&quot;#动态代理创建FeignClient的实例&quot; class=&quot;headerlink&quot; title=&quot;动态代理创建FeignClient的实例&quot;&gt;&lt;/a&gt;动态代理创建FeignClient的实例&lt;/h1&gt;&lt;p&gt;在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>Feign01-流程大体分析和源码分析入口</title>
    <link href="http://www.saily.top/2020/04/12/springcloud/feign01/"/>
    <id>http://www.saily.top/2020/04/12/springcloud/feign01/</id>
    <published>2020-04-12T11:05:39.000Z</published>
    <updated>2020-04-18T08:41:02.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign的组件简介"><a href="#Feign的组件简介" class="headerlink" title="Feign的组件简介"></a>Feign的组件简介</h1><p>Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件</p><ol><li>编码器和解码器：Encoder和Decoder。<br>Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。<br>Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。</li><li>Logger：用于打印接口请求相关的调用日志</li><li>Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 </li><li>Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。</li><li>FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。</li></ol><a id="more"></a><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a><strong>默认配置</strong></h2><p>Spring Cloud对feign的默认组件</p><ul><li>Encoder:SpringEncoder</li><li>Decoder:ResponseEntityDecoder</li><li>Logger:Sl4jLogger</li><li>Contract:SpringMvcContract，解析Spring web mvc的注解</li><li>Feign.Builder:HystrixFeign.Builder，和Hystrix整合使用</li><li>FeignClient:LoadBalancerFeignClient，底层还是和Ribbon整合</li></ul><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a><strong>自定义配置</strong></h2><p>可以通过自定义配置覆盖一些默认的组件，也可以定义拦截器配置，可实现对feign的请求进行拦截，可用于在发起请求之前动态添加请求头，或者打印日志等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"serviceA"</span>,configuration=MyConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyRequestInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><h3 id="feign配置"><a href="#feign配置" class="headerlink" title="feign配置"></a>feign配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 某个服务的配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      ServiceA:</span></span><br><span class="line"><span class="attr">        connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">        loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">        decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      default:</span></span><br><span class="line"><span class="attr">        connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">        loggerLevel:</span> <span class="string">full</span></span><br></pre></td></tr></table></figure><h3 id="启用feign的压缩"><a href="#启用feign的压缩" class="headerlink" title="启用feign的压缩"></a>启用feign的压缩</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">    compression:</span></span><br><span class="line"><span class="attr">        request:</span></span><br><span class="line"><span class="attr">            enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line"><span class="attr">            min-request-size:</span> <span class="number">2048</span></span><br><span class="line"><span class="attr">        response:</span></span><br><span class="line"><span class="attr">            enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="启用请求日志"><a href="#启用请求日志" class="headerlink" title="启用请求日志"></a>启用请求日志</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">logging.level.com.zhss.service.ServiceAClient:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><h2 id="大体流程画图"><a href="#大体流程画图" class="headerlink" title="大体流程画图"></a>大体流程画图</h2><p>大体分析一下Feign是如何完成请求的，包含动态代理，路径和参数的拼装，与Ribbon的整合等。</p><p><img src="/img/spring-cloud/Feign的核心工作流程.jpg" alt="Feign的核心工作流程"></p><h1 id="Feign源码入口"><a href="#Feign源码入口" class="headerlink" title="Feign源码入口"></a>Feign源码入口</h1><p>在分析feign源码之前，应该从哪里入手？那么我们在接入feign的时候，有2个很重要的注解，分别是@EnableFeignClients开启feign，和每个接口上的@FeignClient。</p><p>分别看一下注解源码上的javadoc。</p><h2 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h2><p>用@FeignClient注解标记的接口，会被创建为一个Rest Client，可以被其他组件注入使用。</p><p>如果Ribbon启用的话，就会采用负载均衡的方式发送http请求。负载均衡器可以用@RibbonClient来配置，RibbonClient的和名字要和FeignClient的名字一样。就是@FeignClient(“serviceA”)可以通过下面的配置来指定对应服务Ribbon的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"serviceA"</span>, configuration = ServiceAConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;ribbon.client.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"client"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                         serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><p>扫描那些标记了@FeignClient的接口，指定要扫描哪些包下面的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FeignClientsRegistrar是非常重要的一个类，SpringBoot大多数的EnableXXX注解都是通过@Import来完成功能开启的，所以我们猜测，SpringBoot项目启动后，在识别到EnableFeignClients注解后，FeignClientsRegistrar肯定是扫描了标记@FeignClient的接口，完成了@FeignClient的注册。这部分代码和RibbonClientConfigurationRegistrar的相似的，都是先加载了一个default开头的默认配置，然后将每个服务对应的client的配置再加载一些，包装了FeignClientSpecification类放在spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerDefaultConfiguration"><a href="#registerDefaultConfiguration" class="headerlink" title="registerDefaultConfiguration"></a>registerDefaultConfiguration</h3><p>注册默认配置和注册FeignClient，这儿和Ribbon的代码差不多。</p><p>1、Application启动类的全的限定名</p><p>2、获取@EnableFeignClients注解里配置的defaultConfiguration属性</p><p>3、利用以上2个属性，构建一个FeignClientSpecification，注册到了Spring上下文中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 拿到EnableFeignClients注解所有配置的属性</span></span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 属性里是否包含defaultConfiguration配置</span></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="comment">// 组装成default.com.demo.DemoApplication这样的name</span></span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册feign Client配置</span></span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Object configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是Spring用来构建Bean实例用的构建器，这里搞一个FeignClientSpecification的实例</span></span><br><span class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">    .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">  builder.addConstructorArgValue(name);</span><br><span class="line">  builder.addConstructorArgValue(configuration);</span><br><span class="line">  <span class="comment">// 这儿就是default.com.demo.DemoApplication.org.springframework.cloud.netflix.feign.FeignClientSpecification作为bean的name,FeignClientSpecification的实例作为对象，注册到了Spring的上下文中。</span></span><br><span class="line">  registry.registerBeanDefinition(</span><br><span class="line">    name + <span class="string">"."</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">    builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerFeignClients"><a href="#registerFeignClients" class="headerlink" title="registerFeignClients"></a>registerFeignClients</h3><p>这个方法会扫描配置的包，然后将标注了@FeignClient注解的接口，进行配置的注册。</p><ol><li>获得组件扫描器ClassPathScanningCandidateComponentProvider，这是个内部类。</li><li>如果没有配置clients属性，设置扫描的组件为标记了@FeignClient注解类或者接口。读取@EnableFeignClients的basePackages属性</li><li>如果没有配置basePackages属性，就会根据注解所在的类设置为扫描的包，例如DemoApplication所在的包</li><li>如果配置了clients属性，则不会开启扫描，直接使用配置的clients。一般不会配置</li><li>遍历basePackages，扫描所有注解了@FeignClient的类或者接口。判断的逻辑在内部匿名类ClassPathScanningCandidateComponentProvider.isCandidateComponent方法里</li><li>得到标记了@FeignClient的接口</li><li>根据@FeignClient的配置注册serviceId对应的个性化配置</li><li>根据配置的属性，构建器模式构建基于FeignClientFactoryBean的BeanDefinition并注册到BeanDefinitionRegistry中。此时FeignClient类的实例并没有生成，只是构建了一个FeignClientFactoryBean的BeanDefinition，并将其注册到了BeanDefinitionRegistry（也就是Spring上下文）里。大胆猜一下，应该是在后面才会用动态代理去创建FeignClient接口的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 扫描用的组件</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">   </span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient.class);</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">   <span class="comment">// 如果没有配置clients属性</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 扫描标记了@FeignClient注解的接口</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 扫描EnableFeignClients里配置的basePackages</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则遍历配置的clients，加载相应配置。</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 如果EnableFeignClients没有配置basePackages，则扫描DemoApplication所在的包</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// 找到标记了@FeignClient的注解</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line">            <span class="comment">// 拿到@FeignClient注解配置的属性</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient.class.getCanonicalName());</span><br><span class="line"><span class="comment">// 拿到配置的serviceId</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 根据配置的configuration，注册服务名个性化的配置</span></span><br><span class="line">            <span class="comment">// ServiceA.org.springframework.cloud.netflix.feign.FeignClientSpecification</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line"><span class="comment">// 注册FeignClient</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 构建器模式构建基于FeignClientFactoryBean的BeanDefinition</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">   validate(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// ServiceA</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// ServiceAFeignClient</span></span><br><span class="line">   String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">   <span class="comment">// 构建器构造完成</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画图总结流程"><a href="#画图总结流程" class="headerlink" title="画图总结流程"></a>画图总结流程</h3><p><img src="/img/spring-cloud/扫描@FeignClient注解的机制.jpg" alt="扫描@FeignClient注解的机制"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Feign的组件简介&quot;&gt;&lt;a href=&quot;#Feign的组件简介&quot; class=&quot;headerlink&quot; title=&quot;Feign的组件简介&quot;&gt;&lt;/a&gt;Feign的组件简介&lt;/h1&gt;&lt;p&gt;Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码器和解码器：Encoder和Decoder。&lt;br&gt;Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。&lt;br&gt;Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。&lt;/li&gt;
&lt;li&gt;Logger：用于打印接口请求相关的调用日志&lt;/li&gt;
&lt;li&gt;Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 &lt;/li&gt;
&lt;li&gt;Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。&lt;/li&gt;
&lt;li&gt;FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="feign" scheme="http://www.saily.top/tags/feign/"/>
    
  </entry>
  
  <entry>
    <title>分析Ribbon源码，Ribbon在底层如何拉取服务列表、进行负载均衡选择并发起Http请求</title>
    <link href="http://www.saily.top/2020/03/31/springcloud/ribbon01/"/>
    <id>http://www.saily.top/2020/03/31/springcloud/ribbon01/</id>
    <published>2020-03-31T15:05:39.000Z</published>
    <updated>2020-04-17T04:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><strong>服务注册</strong>，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。</p><p><strong>服务发现</strong>就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。</p><p><strong>负载均衡</strong>就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。</p><a id="more"></a><h1 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h1><p>Spring Cloud Ribbon组件，也是基于Netflix Ribbon做的封装。</p><p>Ribbon包含几个核心组件：</p><ul><li><p>IRule:负载均衡规则组件，轮询，随机，权重等。</p></li><li><p>IPing: 用于检测服务是否存活，剔除宕机的服务。</p></li><li><p>ServerList: 针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及eureka的DomainExtractingServerList。</p></li><li>ILoadBalancer:负载均衡器，选择服务用，包含了IRule、IPing和ServerList。</li><li>LoadBalancerClient: 这是SpringCloud二次封装的一层组件，基于以上组件进行服务列表更新，过滤，选择并发起http调用。</li></ul><p>大体流程如下图所示：</p><p><img src="/img/spring-cloud/image-20200331230023575.png" alt="image-20200331230023575"></p><ol><li>自动装配LoadBalancerAutoConfiguration</li><li>在自动配置类中，会为RestTemplate添加拦截器LoadBalancerInterceptor</li><li>调用请求后，拦截器中获取host，并在LoadBalancerClient中对host信息进行转换，得到真正的服务器地址。</li><li>LoadBalancerClient中从Eureka client得到服务实例列表，然后通过包含了负载均衡规则IRule，选出要发起调用的server。</li><li>交给负责Http通讯的组件LoadBalancerRequest执行真正的http请求。</li></ol><h2 id="RestTemplate如何拥有负载均衡的能力"><a href="#RestTemplate如何拥有负载均衡的能力" class="headerlink" title="RestTemplate如何拥有负载均衡的能力"></a>RestTemplate如何拥有负载均衡的能力</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LoadBalanced的源码： 标记RestTemplate被配置为使用LoadBalancerClient。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient</span><br></pre></td></tr></table></figure><p>定位在这个注解所在的jar包，可以发现有如下的类：</p><p><img src="/img/spring-cloud/image-20200402225210595.png" alt="image-20200402225210595"></p><p>根据SpringBoot的命名习惯，自动装配的类一般都是XXXAutoConfiguration，所以我们应该重点关注LoadBalancerAutoConfiguration这个类，进去看看，我省略掉部分代码，找到我们最应该关注的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto configuration for Ribbon (client side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will Tran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gang Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(LoadBalancerClient.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(LoadBalancerRetryProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  .....省略部分代码</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplateCustomizer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">restTemplate.getInterceptors());</span><br><span class="line">list.add(loadBalancerInterceptor);</span><br><span class="line">restTemplate.setInterceptors(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  ....省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里给系统里的RestTemplate添加了拦截器，LoadBalancerInterceptor。在声明了LoadBalancerInterceptor后，用RestTemplateCustomizer定制化了拦截器<code>restTemplate.setInterceptors(list);</code>。</p><p>去LoadBalancerInterceptor看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"><span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line"><span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// for backwards compatibility</span></span><br><span class="line"><span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 原来是在这个方法里替换了host，将host通过loadBalancer转换成了实际要访问的ip:port</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    <span class="comment">// 这里是serviceA</span></span><br><span class="line">String serviceName = originalUri.getHost();</span><br><span class="line">Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">    <span class="comment">// 通过拦截器处理后，将serviceA转换为ip:port，在拦截器里去执行了真正的http请求</span></span><br><span class="line">    <span class="comment">// cmd + option + B 可以在IDEA直接定位到实现类RibbonLoadBalancerClient的源码</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个源码打开一看，我们一下就明朗了，原来SpringCloud是这样通过拦截器实现了restTeplate.getForObject(“<a href="http://serviceA/hello&quot;" target="_blank" rel="noopener">http://serviceA/hello&quot;</a>) 到restTeplate.getForObject(“<a href="http://192.168.21.100:8080/hello&quot;)的转换。" target="_blank" rel="noopener">http://192.168.21.100:8080/hello&quot;)的转换。</a></p><p>在RibbonLoadBalancerClient的类上按option(alt) + F7，可以迅速的找到在哪里声明创建的这个类的实例，如下图所示，也就是在RibbonAutoConfiguration类里。</p><p><img src="/img/spring-cloud/image-20200404224238571.png" alt="image-20200404224238571"></p><p>接着看一下RibbonLoadBalancerClient的execute方法具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonLoadBalancerClient，execute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找服务对应的负载均衡器，因为每个服务ribbon配置可能不一样</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// getServer方法里，会调用loadBalancer.chooseServer方法。</span></span><br><span class="line">  <span class="comment">// 这个server就已经包含了具体的ip和port</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">                                                                           serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行真正的http请求</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....省略部分代码</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// chooseServer方法会去执行真正的IRule实现逻辑，利用负载均衡规则筛选出适合的服务实例</span></span><br><span class="line">  <span class="keyword">return</span> loadBalancer.chooseServer(<span class="string">"default"</span>); <span class="comment">// <span class="doctag">TODO:</span> better handling of key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡器ILoadBalancer"><a href="#负载均衡器ILoadBalancer" class="headerlink" title="负载均衡器ILoadBalancer"></a>负载均衡器ILoadBalancer</h2><p>那么看到上面有个ILoadBalancer，ILoadBalancer维护了一份服务列表，并提供了过滤服务和用负载均衡选择server等功能。这个ILoadBalancer在SpringCloud中默认是用的什么实现呢，这里的实例是用SpringClientFactory.getLoadBalancer方法获取的，<strong>这个SpringClientFactory是SpringCloud对Ribbon的一层封装，为每一个服务都创建了一个Spring ApplicationContext，每一个服务都有自己的client，load balancer 和 client configuration实例。</strong>这个<code>SpringClientFactory</code>非常重要，它是为每一个服务指定不同配置的基础例如不同的服务采用不同的负载均衡规则，就是通过这个机制实现的。</p><p>在SpringClientFactory.getLoadBalancer方法里，调用了<code>getInstance(name, ILoadBalancer.class);</code>跟到代码里去看是如何获取实例的，最后跟到父类里，发现是用map维护了服务和上下文的对应关系，serviceA -&gt; AnnotationConfigApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个ILoadBalancer的实例究竟是在哪里创建的呢？还是老办法，option + F7，去找一个叫XXXConfiguration的类，于是在RibbonClientConfiguration的类里，发现了Bean的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ILoadBalancer定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                     serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是使用<strong>ZoneAwareLoadBalancer</strong>，父类是：DynamicServerListLoadBalancer，再往上的父类是BaseLoadBalancer。</p><blockquote><p>这里多说一句，其实RibbonClientConfiguration的加载，是在NamedContextFactory.createContext里加载的，而且优先级是最低的，具体可以看本文最后一节引用文章，现在不必细究，等把整体流程了解的差不多以后，再去看这种细节问题。</p></blockquote><h2 id="Ribbon如何获取到服务列表"><a href="#Ribbon如何获取到服务列表" class="headerlink" title="Ribbon如何获取到服务列表"></a>Ribbon如何获取到服务列表</h2><p>在ZoneAwareLoadBalancer中，并没有找到和服务列表相关的代码，去父类的构造方法看下，调用了restOfInit方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer，restOfInit方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> primeConnection = <span class="keyword">this</span>.isEnablePrimingConnections();</span><br><span class="line">  <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">// 初始化并加载服务列表，会调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  enableAndInitLearnNewServersFeature();</span><br><span class="line">  <span class="comment">// 调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  updateListOfServers();</span><br><span class="line">  <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="keyword">this</span>.getPrimeConnections() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getPrimeConnections()</span><br><span class="line">      .primeConnections(getReachableServers());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">  LOGGER.info(<span class="string">"DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;"</span>, clientConfig.getClientName(), <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来serverListImpl，也就是ServerList就是获取服务列表的关键。那么这个ServerList是在构造方法里传入的，所以回到ZoneAwareLoadBalancer的Bean定义的地方，可以看到他是通过依赖注入获取到的。</p><p>通过IDEA看一下接口有哪些实现类：</p><p><img src="/img/spring-cloud/image-20200408233824757.png" alt="image-20200408233824757"></p><p>可以看到，针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及在spring cloud eureka包下面的DomainExtractingServerList。</p><p>由此可以断定，SpringCloud在和Ribbon和Eureka整合的时候，一定使用了DomainExtractingServerList这个类。更进一步的，找到了DomainExtractingServerList创建的地方，发现他又是包装了一层DiscoveryEnabledNIWSServerList，这个DiscoveryEnabledNIWSServerList是com.netflix.niws.loadbalancer;包下面的，在ribbon-eureka.jar里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ServerList的定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config,</span><br><span class="line">                                      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">    config, eurekaClientProvider);</span><br><span class="line">  DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">    discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line">  <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下面截图是DiscoveryEnabledNIWSServerList的getInitialListOfServers和getUpdatedListOfServers方法，在这里看到了前面熟悉的eurekaClient，通过eurekaClient获取到了实例列表，并且转成了List<discoveryenabledserver>返回，我们在用IDEA分析源码的时候，真的是非常的方便，可以通过查看类或者方法的引用，来找到创建或者使用的代码。也可以很方便的通过继承关系查看，就找到可能的具体的实现。</discoveryenabledserver></p><p><img src="/img/spring-cloud/image-20200409210354113.png" alt="image-20200409210354113"></p><p>最后，将拿到的服务列表存入了成员变量allServerList中。</p><p><img src="/img/spring-cloud/image-20200409215159851.png" alt="image-20200409215159851"></p><p>已经找到了更新服务列表的地方，那么他是什么时候去更新的呢，实际上在restOfInit方法调用的enableAndInitLearnNewServersFeature方法里，就调用了一个更新器：serverListUpdater，他会定时去更新，在构造方法里，构造了PollingServerListUpdater的实例，他是在启动1秒后，每隔30秒就会执行一次，去从eureka client里将服务列表定时同步到LoadBalancer的allServerList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableAndInitLearnNewServersFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGGER.info(<span class="string">"Using serverListUpdater &#123;&#125;"</span>, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">  <span class="comment">// 这里的updateAction，就是调用updateListOfServers()方法。</span></span><br><span class="line">  serverListUpdater.start(updateAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法如何选择一个server"><a href="#负载均衡算法如何选择一个server" class="headerlink" title="负载均衡算法如何选择一个server"></a>负载均衡算法如何选择一个server</h2><p>前面有提到，在获取到负载均衡器（ILoadBalancer）后，就会调用chooseServer方法去选择一个server，看了眼他的逻辑，对每个机房都搞了个LoadBalancer，最后还是调用的BaseLoadBalancer.chooseServer方法，也就是父类的chooseServer方法，咱们在这里，就找到了rule.choose(key)的调用，所以接下来，我们就重点关注一下rule是哪里来的，他的默认实现又是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseLoadBalancer.chooseServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    counter = createCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  counter.increment();</span><br><span class="line">  <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ZoneAwareLoadBalancer的定义类里，也就是RibbonClientConfiguration里，也声明了IRule的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration.ribbonRule</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">  rule.initWithNiwsConfig(config);</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在ZoneAvoidanceRule里，并没有找到choose方法，看一眼他的层级结构，choose方法在父类PredicateBasedRule里。</p><p><img src="/img/spring-cloud/image-20200409221508995.png" alt="image-20200409221508995"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PredicateBasedRule.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来过滤服务列表的核心逻辑，可利用自己的实现进行个性化的实例过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">  <span class="comment">// 过滤然后轮询选择服务列表</span></span><br><span class="line">  Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">  <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> server.get();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPredicate().chooseRoundRobinAfterFiltering，先过滤后再用轮询算法选择一个Server。这个具体算法可以在incrementAndGetModulo里找到，算出一个索引值，然后去List里取一个server。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractServerPredicate.java </span></span><br><span class="line"><span class="comment">// 先过滤后，再用轮询算法一次取下一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先过滤服务列表</span></span><br><span class="line">  List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">  <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.absent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轮训算法计算索引值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = nextIndex.get();</span><br><span class="line">    <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">    <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/spring-cloud/image-20200409224739519.png" alt="image-20200409224739519"></p><p>在这里说一句题外话，其实在工作中，这个地方我们可以大做文章，比如编写自己的Rule，实现自己的负责均衡算法。也可以利用getEligibleServers的过滤服务实例机制，去实现自己Predicate，从而实现一些灰度发布等操作。关于SpringCloud的灰度发布，可参考开源框架Nepxion Discovery：<strong><a href="https://github.com/Nepxion/Discovery" target="_blank" rel="noopener">https://github.com/Nepxion/Discovery</a></strong></p><h2 id="拿到server后如何发起真正的请求"><a href="#拿到server后如何发起真正的请求" class="headerlink" title="拿到server后如何发起真正的请求"></a>拿到server后如何发起真正的请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #RibbonLoadBalancerClient.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Server server = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">      server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">         .getLoadBalancerContext(serviceId);</span><br><span class="line">   RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      T returnVal = request.apply(serviceInstance);</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure><p>在选择到服务实例以后，RibbonLoadBalancerClient.execute()就要发起真正的调用了。用了一个回调，将被请求的服务器信息当作参数穿进去，完成了http的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T returnVal = request.apply(serviceInstance);</span><br></pre></td></tr></table></figure><p>所以回到LoadBalancerInterceptor类里，request是一个匿名内部类，在里面对request和服务实例进行了包装，将具体执行交给了ClientHttpRequestExecution。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerInterceptor.java</span></span><br><span class="line">requestFactory.createRequest(request, body, execution)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadBalancerRequestFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                               <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequest&lt;ClientHttpResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">apply</span><span class="params">(<span class="keyword">final</span> ServiceInstance instance)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, loadBalancer);</span><br><span class="line">      <span class="keyword">if</span> (transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : transformers) &#123;</span><br><span class="line">          serviceRequest = transformer.transformRequest(serviceRequest, instance);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> execution.execute(serviceRequest, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了ClientHttpRequestExecution里面，其实已经到了spring-web的类里了，spring-web从ServiceRequestWrapper获取到真正的请求URL地址，发起了http请求。所以spring-web的源码，这里就不再去看了，但是需要关注ServiceRequestWrapper，ServiceRequestWrapper完成了对真实请求地址的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奥秘所在类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance instance;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceRequestWrapper</span><span class="params">(HttpRequest request, ServiceInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params"> LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.instance = instance;</span><br><span class="line"><span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写了HttpRequest的getURI方法，利用LoadBalancerClient获取到了真正的请求地址。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">URI uri = <span class="keyword">this</span>.loadBalancer.reconstructURI(</span><br><span class="line"><span class="keyword">this</span>.instance, getRequest().getURI());</span><br><span class="line"><span class="keyword">return</span> uri;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonLoadBalancerClient.java</span></span><br><span class="line"><span class="comment">// 利用服务实例的host和端口以及path信息，拼接出真正的请求地址</span></span><br><span class="line"><span class="comment">// http://serviceA/sayHello -&gt; http://192.168.10.1:8080/sayHello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(instance, <span class="string">"instance can not be null"</span>);</span><br><span class="line">  String serviceId = instance.getServiceId();</span><br><span class="line">  RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">    .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">  URI uri;</span><br><span class="line">  Server server;</span><br><span class="line">  <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">    RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">    server = ribbonServer.getServer();</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(),</span><br><span class="line">                        instance.getPort());</span><br><span class="line">    IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">    ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                           serverIntrospector, server);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图总结下：</p><p><img src="/img/spring-cloud/image-20200410001159973.png" alt="image-20200410001159973"></p><h2 id="Ribbon-IPing检查服务是否存活"><a href="#Ribbon-IPing检查服务是否存活" class="headerlink" title="Ribbon IPing检查服务是否存活"></a>Ribbon IPing检查服务是否存活</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "Ping" Discovery Client</span></span><br><span class="line"><span class="comment"> * i.e. we dont do a real "ping". We just assume that the server is up if Discovery Client says so</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIWSDiscoveryPing</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerPing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (server!=<span class="keyword">null</span> &amp;&amp; server <span class="keyword">instanceof</span> DiscoveryEnabledServer)&#123;</span><br><span class="line">            DiscoveryEnabledServer dServer = (DiscoveryEnabledServer)server;            </span><br><span class="line">            InstanceInfo instanceInfo = dServer.getInstanceInfo();</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo!=<span class="keyword">null</span>)&#123;                </span><br><span class="line">                InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line">                <span class="keyword">if</span> (status!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> isAlive;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ribbon和eureka整合的时候，并不会真正的去检查服务是否存活，而是利用Discovery Client本来就会有定时更新服务列表的机制。</p><p>在BaseLoadBalancer类里，可以找到IPing的调用之处，他启动了一个定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">"NFLoadBalancer-PingTimer-"</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认是每隔30秒，就执行一次PingTask，task里用了一个读写锁完成了ping之后的服务实例列表计算，最后更新upServerList。</p><h2 id="其他几种自带的负载均衡规则"><a href="#其他几种自带的负载均衡规则" class="headerlink" title="其他几种自带的负载均衡规则"></a>其他几种自带的负载均衡规则</h2><p>BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。</p><p>AvailabilityFilteringRule：过滤掉那些一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态。</p><p>ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server。</p><p>RandomRule：随机选择一个Server。</p><p>RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server。</p><p>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server。</p><p>ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule。</p><p>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低。</p><h2 id="服务宕机后Ribbon多久能感知到"><a href="#服务宕机后Ribbon多久能感知到" class="headerlink" title="服务宕机后Ribbon多久能感知到"></a>服务宕机后Ribbon多久能感知到</h2><p>在和eureka结合使用的情况下，因为eureka server是靠心跳来摘除服务实例，那么他是需要duration * 2 =180秒，eureka client 从server同步(recentlyChangedQueue)默认是需要30秒，Ribbon从Eureka Client同步也是30秒，所以最多可能需要240秒，也就是4分钟才能知道一个服务已经宕机了，他是有可能访问到宕机的服务，不过SpringCloud是借用了Hystrix降级和熔断的机制来解决这个问题，一定次数错误后会屏蔽某个实例。</p><p><img src="/img/spring-cloud/默认的负载均衡算法可能存在的问题.png" alt="默认的负载均衡算法可能存在的问题"></p><h2 id="SpringCloud和Ribbon的全局配置和特定配置"><a href="#SpringCloud和Ribbon的全局配置和特定配置" class="headerlink" title="SpringCloud和Ribbon的全局配置和特定配置"></a>SpringCloud和Ribbon的全局配置和特定配置</h2><p>这有篇文章写的比较清晰，说明了SpringCloud在读取Ribbon配置的时候是通过懒加载去读取配置的，也就是第一次发起调用的时候，才会通过NamedContextFactory.createContext去初始化@RibbonClients和@RibbonClient指定的配置。 但是@RibbonClients和@RibbonClient的配置被放入NamedContextFactory的configurations字段中，是在RibbonClientConfigurationRegistrar这个类里，结合源码看看文章，就很清楚了。</p><p><a href="https://www.cnblogs.com/trust-freedom/p/11216280.html" target="_blank" rel="noopener">https://www.cnblogs.com/trust-freedom/p/11216280.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务发现&lt;/strong&gt;就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="ribnon" scheme="http://www.saily.top/tags/ribnon/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码05-服务集群初始化和同步原理分析</title>
    <link href="http://www.saily.top/2020/03/28/springcloud/eureka05/"/>
    <id>http://www.saily.top/2020/03/28/springcloud/eureka05/</id>
    <published>2020-03-28T03:05:39.000Z</published>
    <updated>2020-04-12T06:19:21.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-server集群相关源码分析"><a href="#eureka-server集群相关源码分析" class="headerlink" title="eureka server集群相关源码分析"></a>eureka server集群相关源码分析</h1><p>前面的文章分别介绍了服务启动、注册、下线、故障和自我保护机制等原理，这里就开始介绍集群相关的东西。</p><p><img src="/img/spring-cloud/image-20200329222305903.png" alt="image-20200329222305903"><br><a id="more"></a></p><h2 id="集群信息初始化"><a href="#集群信息初始化" class="headerlink" title="集群信息初始化"></a>集群信息初始化</h2><p>eureka server集群高可用，是需要相互注册的，然后会相互同步服务实例列表。前面分析eureka server启动流程的时候，在EurekaBootstrap的初始化代码里有一段和集群相关的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五步，处理peer节点相关的事情</span></span><br><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">  registry,</span><br><span class="line">  eurekaServerConfig,</span><br><span class="line">  eurekaClient.getEurekaClientConfig(),</span><br><span class="line">  serverCodecs,</span><br><span class="line">  applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个PeerEurekaNodes的start方法，在DefaultEurekaServerContext的初始化代码中被调用。它会解析配置文件中配置的其他eureka server的地址，基于URL地址构造一个一个的PeerEurekaNode，然后将其他节点的信息保存到本地。默认是每隔10分钟，会定时基于这个配置刷新集群配置信息。</p><h2 id="集群数据同步"><a href="#集群数据同步" class="headerlink" title="集群数据同步"></a>集群数据同步</h2><p>在初始化集群的节点信息后，还需要同步其他节点的注册表到本地。也就是EurekaBootstrap初始化代码里的registry.syncUp();，因为自己本来也是一个eureka client，<a href="http://www.saily.top/2020/03/21/springcloud/eureka03/#eureka-client%E5%85%A8%E9%87%8F%E6%8A%93%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8">所以在启动初始化的时候，就已经从任意一个其他的eureka server节点拉取到注册表在本地</a>，在这里只需要将缓存的实例信息取出来，然后在挨个本地注册一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果第一次没有在本地的eureka client 中获取任何注册表</span></span><br><span class="line">      <span class="comment">// 那么就等待30秒，看DiscoveryClient.fetchRegistry是否已经执行完成。</span></span><br><span class="line">      Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是读取的eureka client在本地初始化的时候拉取的全量注册表缓存。</span></span><br><span class="line">  Applications apps = eurekaClient.getApplications();</span><br></pre></td></tr></table></figure><p>那么在源码里我们可以看到，这里有一个重试的机制，里面还包含了sleep的代码，其实就是因为eureka client在本地的缓存可能还没有生成成功，就先执行了这里的代码，所以会等到30秒后再重试，看是否缓存已经有了数据。</p><p>这里也包含了上一节中提到的统计服务实例数量，后续会用来计算预期收到的心跳次数。</p><h2 id="注册、下线、故障集群间同步"><a href="#注册、下线、故障集群间同步" class="headerlink" title="注册、下线、故障集群间同步"></a>注册、下线、故障集群间同步</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>还记得eureka server处理注册请求的代码，在ApplicationResource.addInstance方法中，调用PeerAwareInstanceRegistryImpl.register方法进行注册，那么replicateToPeers方法，就会将注册数据同步到其他节点，此时这里的<code>isReplication</code>参数是false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">  <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">  <span class="comment">// 将注册信息同步到其他集群节点</span></span><br><span class="line">  replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到这个方法里面看一下，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，但是这里和client调用是有区别的，他底层的调用发起类是JerseyReplicationClient，在发起http请求的时候，一定会带上请求头：<code>webResource.header(PeerEurekaNode.HEADER_REPLICATION, &quot;true&quot;);</code>，那么其他节点在收到请求的时候，上面的<code>isReplication</code>就是肯定是true了。当<code>isReplication</code>是true的时候，不会像其他节点进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> Cancel:</span><br><span class="line">    node.cancel(appName, id);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Heartbeat:</span><br><span class="line">    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Register:</span><br><span class="line">    node.register(info);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> StatusUpdate:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.statusUpdate(appName, id, newStatus, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DeleteStatusOverride:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.deleteStatusOverride(appName, id, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册逻辑的批处理"><a href="#注册逻辑的批处理" class="headerlink" title="注册逻辑的批处理"></a>注册逻辑的批处理</h2><p>跟到node.register(info);里去看，这块代码有点复杂，他用了一个三层队列做了一个批处理请求。</p><ol><li>集群同步的机制：client可以找任意一个几点发送请求，然后这个server会将请求同步到其他所有的节点上去，但是其他的server仅仅只会在本地执行，不会再往其他节点同步。</li><li>数据同步的异步批处理机制：有三个队列，第一个队列纯写入（acceptorQueue），第二个队列用来根据时间和大小来拆分队列（processingOrder），第三个队列用来放批处理任务(batchWorkQueue)—&gt;任务批处理机制。</li></ol><p>流程如下图所示。</p><p><img src="/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在看完Eureka集群的源码以后，关于Eureka的核心概念涉及到的源码已经分析完成。在SpringCloud中，其实只是做了一层简单的封装，比如把配置文件从读取properties文件改成了从application.yml里，然后利用SpringBoot的自动装配去做了一些自动配置，并没有什么新鲜的东西。下面一张图总结下eureka 核心流程和原理</p><p><img src="/img/spring-cloud/image-20200330224323248.png" alt="image-20200330224323248"></p><ol><li>eureka server启动：注册中心</li><li>eureka client启动：服务实例</li><li>服务注册：map数据结构</li><li>eureka server集群：注册表的同步，三层队列任务批处理机制</li><li>全量拉取注册表：多级缓存机制，</li><li>增量拉取注册表：一致性hash比对机制，recentChangedQueue</li><li>心跳机制：服务续约，renew，刷新时间</li><li>服务下线：cancel</li><li>服务故障：expiration，eviction</li><li>自我保护机制：自动识别eureka server出现网络故障了，上一分钟心跳次数少于期望的心跳次数。</li><li>控制台：jsp页面。</li></ol><p><img src="/img/spring-cloud/未命名文件.jpg" alt="未命名文件"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eureka-server集群相关源码分析&quot;&gt;&lt;a href=&quot;#eureka-server集群相关源码分析&quot; class=&quot;headerlink&quot; title=&quot;eureka server集群相关源码分析&quot;&gt;&lt;/a&gt;eureka server集群相关源码分析&lt;/h1&gt;&lt;p&gt;前面的文章分别介绍了服务启动、注册、下线、故障和自我保护机制等原理，这里就开始介绍集群相关的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/image-20200329222305903.png&quot; alt=&quot;image-20200329222305903&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码04-服务心跳、下线、故障和服务自我保护机制流程分析</title>
    <link href="http://www.saily.top/2020/03/22/springcloud/eureka04/"/>
    <id>http://www.saily.top/2020/03/22/springcloud/eureka04/</id>
    <published>2020-03-22T10:05:39.000Z</published>
    <updated>2020-04-12T06:19:16.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务心跳流程分析"><a href="#服务心跳流程分析" class="headerlink" title="服务心跳流程分析"></a>服务心跳流程分析</h1><p>eureka client每隔一定的时间，会给eureka server发送心跳，保持心跳，让eureka server认为自己还活着。</p><p>心跳在代码里，叫做续约。</p><ol><li><p>还是在DiscoveryClient初始化的时候，有一个心跳的定时任务，由<code>HeartbeatThread</code>执行。</p></li><li><p>默认值是每隔30秒去发送一个心跳。DEFAULT_LEASE_RENEWAL_INTERVAL</p></li><li><p>接下来是用jersy去给eureka server发送心跳的http请求。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>请求的地址是：<code>PUT apps/{appName}/{id}</code></p></li><li><p>我们根据这个接口去找下是什么类处理的请求，这个又是让我好一顿找：在ApplicationsResource里有个<code>@Path(&quot;{appId}&quot;)</code>，这里已经组成了路径<code>apps/{appId}</code>，然后在ApplicationsResource里边又有一个<code></code>@Path(“{id}”)<code>方法，到这里就是</code>apps/{appId}/{id}`，是不是刚好符合客户端的请求路径，但是还是没有定位到PUT方法在哪里，继续看InstanceResource里的renewLease方法，配合参数看下，终于才找到了server端处理心跳逻辑的代码。<em>不得不说这个隐藏的真是比较深，你看那个getInstanceInfo方法，你很难想到这个get方法只是一个路径的节点，具体的处理还得继续往里跟。应该是也因为我不熟悉jersy这个框架，不知道怎么快速定位一个mvc路径的执行代码。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationsResource</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">        @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">    CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ApplicationResource</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> InstanceResource <span class="title">getInstanceInfo</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceResource(<span class="keyword">this</span>, id, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstanceResource</span></span><br><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>通过注册表的renew方法，完成服务续约的逻辑。registry.renew，实际还是进入AbstractInstanceRegistry.renew这个方法里。</p></li><li><p>用appName获取服务注册表那个map，做了一些检查。最后执行续约的逻辑（leaseToRenew.renew();）其实就是更新了一下lastUpdateTimestamp的时间，加上了duration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line"><span class="comment">// 一些代码</span></span><br><span class="line">leaseToRenew.renew();</span><br></pre></td></tr></table></figure></li></ol><h1 id="服务下线流程分析"><a href="#服务下线流程分析" class="headerlink" title="服务下线流程分析"></a>服务下线流程分析</h1><p>下面看一下DiscoveryClient的shutdown方法的逻辑。</p><ol><li><p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。关注里边的unregister();方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</span><br></pre></td></tr></table></figure><p>对应的路径是，<code>DELETE apps/{appName}/{id}</code>，和上面一样，是在InstanceResource类里的cancelLease方法。</p></li><li><p>最后跟着源码里走，执行的的逻辑是AbstractInstanceRegistry.internalCancel方法。</p></li><li><p>取到注册表的map，直接调用remove从map里给移除了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">....</span><br><span class="line">gMap.remove(id);</span><br></pre></td></tr></table></figure></li><li><p>然后调用了leaseToCancel.cancel();，设置了evictionTimestamp时间。</p></li><li><p>在recentlyChangedQueue里新增了一条服务实例变更记录，保留3分钟。（用于在客户端进行增量更新的时候进行合并）</p></li><li><p>调用invalidateCache，让缓存失效，从readWriteCacheMap里全部清理掉。会有定时任务每隔30秒让readOnlyCacheMap和readWriteCacheMap进行同步。这部分逻辑在上一篇文章有分析到。</p></li><li><p><strong>下次所有的eureka client来拉取增量注册表的时候，就会返回recentlyChangedQueue里的数据，然后在本地进行合并，比对hash值，再决定是否重新拉取全量注册表的逻辑。</strong></p></li></ol><p><img src="/img/spring-cloud/image-20200322230318802.png" alt="image-20200322230318802"></p><p>这里再一次体现了，无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能60秒才能感知到服务的下线。</p><h1 id="服务故障流程分析"><a href="#服务故障流程分析" class="headerlink" title="服务故障流程分析"></a>服务故障流程分析</h1><p>如果客户端在故障后，没有通知eureka server服务下线。那么就需要用到eureka server自己的故障感应机制，以及服务实例摘除的机制。</p><p>eureka server是靠心跳来感知服务是否存活，如果在一定时间内没有收到心跳，那么就认为服务已经宕机了，此时会修改服务状态，并进行摘除。</p><p>可以判定，肯定是有一个定时任务，在定时的判断。就是EurekaBootStrap初始化方法里的这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line">AbstractInstanceRegistry.postInit()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    renewsLastMin.start();</span><br><span class="line">    <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        evictionTaskRef.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">    evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔60秒，会执行一次任务，判断服务实例的租约是否已经过期了，虽然定时任务是60秒一次，这里有个getCompensationTimeMs();方法，计算上次心跳，到这次任务执行的时间差到底是多少，从而保证准确的计算过期时间，因为可能jvm gc原因或者时钟原因，并没有刚好60秒执行这次的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前时间</span></span><br><span class="line">  <span class="keyword">long</span> currNanos = getCurrentTimeNano();</span><br><span class="line">  <span class="comment">// 上次任务的时间</span></span><br><span class="line">  <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</span><br><span class="line">  <span class="keyword">if</span> (lastNanos == <span class="number">0l</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0l</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 间隔时间是和配置的时间间隔，getEvictionIntervalTimerInMs默认是60秒</span></span><br><span class="line">  <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</span><br><span class="line">  <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</span><br><span class="line">  <span class="keyword">return</span> compensationTime &lt;= <span class="number">0l</span> ? <span class="number">0l</span> : compensationTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line"><span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line"><span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">  Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">  <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">      Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        expiredLeases.add(lease);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否过期</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if the lease of a given &#123;<span class="doctag">@link</span> com.netflix.appinfo.InstanceInfo&#125; has expired or not.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that due to renew() doing the 'wrong" thing and setting lastUpdateTimestamp to +duration more than</span></span><br><span class="line"><span class="comment">     * what it should be, the expiry will actually be 2 * duration. This is a minor bug and should only affect</span></span><br><span class="line"><span class="comment">     * instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will</span></span><br><span class="line"><span class="comment">     * not be fixed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalLeaseMs any additional lease time to add to the lease evaluation in ms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lastUpdateTimestamp上次心跳时间+90秒+比预期的任务时间晚了多少秒。</span></span><br><span class="line">  <span class="comment">// 看似这里的逻辑是，在不计算预期任务执行的时间情况下，90s没有收到过心跳就认为已经过期</span></span><br><span class="line">  <span class="comment">// 但是看上面的注释，其实这里是有一个bug，因为在心跳的时候，时间就已经+了duration，比如上次心跳的时间 22:47:44，那么lastUpdateTimestamp就是22:49:14</span></span><br><span class="line">  <span class="comment">// 所以在这里判断的时候，真正判断的过期时间是22:50:44，相比上次心跳，已经是过去了180s的时间。</span></span><br><span class="line">  <span class="comment">// 并且这个bug不打算修复</span></span><br><span class="line">  <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，要3分钟没有收到心跳，才会剔除一个服务的实例。</p><p>接着后面就是拆除服务实例的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性不能摘除太多的实例，因为有可能是eureka server节点自己的网络故障原因，导致没有心跳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line"><span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line"><span class="comment">// 所以想下面计算了一个比例，比如当前注册表的大小是20，getRenewalPercentThreshold的默认值是0.85，</span></span><br><span class="line"><span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line"><span class="comment">// 这里是17</span></span><br><span class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line"><span class="comment">// 所以限制最多只能是3个</span></span><br><span class="line"><span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设expiredLeases过期了6个，和3个里选个最小值，这里是3，随机再从6个里选3个摘除，最后调用internalCancel（服务下线的方法）</span></span><br><span class="line"><span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line"><span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">    <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">    <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br></pre></td></tr></table></figure><p>最后调用internalCancel（服务下线的方法）。所以说一个服务如果没有心跳了，可能需要定时任务60秒+心跳时间90秒+过期判断90s，也许要4分钟以上，才能感知一个服务下线了，再加上客户端同步的间隔时间，时间就会更长。</p><h1 id="服务自我保护机制"><a href="#服务自我保护机制" class="headerlink" title="服务自我保护机制"></a>服务自我保护机制</h1><p>下面看一下eureka server自我保护机制。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>如果有20个服务实例，在1分钟以内，只有8个服务保持了心跳，那么eureka server会将剩余的12个没有心跳的服务实例全部摘除吗？其实不是的，有可能是由于eureka server自己的机器所在的网络故障了，导致那些服务心跳发送不过来，导致eureka server一直没有更新心跳的时间。</p><p>进入自我保护机制以后，就不会摘除任何实例了。</p><p>还是看上面一节的evict方法，第一行就有一个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否允许主动删除实例，和自我保护机制有关</span></span><br><span class="line"><span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码命名其实也是非常奇怪的，你光看名字，永远也想不到isLeaseExpirationEnabled方法里会包含自我保护机制的触发代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果关闭自我保护机制，随时可以清理实例</span></span><br><span class="line">  <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">    <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 会触发自我保护机制</span></span><br><span class="line">  <span class="comment">// numberOfRenewsPerMinThreshold 期望所有服务实例1分钟要有发送多少次心跳过来</span></span><br><span class="line">  <span class="comment">// getNumOfRenewsInLastMin() 上1分钟所有服务实例一共发送多少次心跳</span></span><br><span class="line">  <span class="comment">// 如果上一分钟的心跳次数（假设是102次） &gt; 我所期望的心跳次数，那么返回true，就可以清理服务实例</span></span><br><span class="line">  <span class="comment">// 如果上次心跳次数（假设20次） &lt; 我期望的100次，此时返回false，表示不清理服务实例。</span></span><br><span class="line">  <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="isLeaseExpirationEnabled方法判断自我保护机制开启"><a href="#isLeaseExpirationEnabled方法判断自我保护机制开启" class="headerlink" title="isLeaseExpirationEnabled方法判断自我保护机制开启"></a>isLeaseExpirationEnabled方法判断自我保护机制开启</h3><p>在evict服务故障的定时任务中，有个isLeaseExpirationEnabled方法会判断<strong>上一分钟的心跳次数</strong>是否小于<strong>期望的一分钟内心跳次数</strong>，如果小于，那么不会清理服务实例。</p><h3 id="如何计算期望的一分钟心跳次数"><a href="#如何计算期望的一分钟心跳次数" class="headerlink" title="如何计算期望的一分钟心跳次数"></a>如何计算期望的一分钟心跳次数</h3><p><strong>numberOfRenewsPerMinThreshold的值是如何设定的？</strong></p><ol><li><p>EurekaBootStrap是启动初始化的类，有一行registry.openForTraffic（开启故障检查）的代码，完成了numberOfRenewsPerMinThreshold的初始化。<br>首先调用sync方法，从相邻的eureka server节点拷贝注册表（调用服务实例列表后注册到本地），拿到服务实例的数量。服务实例数量 <em> 2 </em> getRenewalPercentThreshold(0.85)。得到numberOfRenewsPerMinThreshold。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></span><br><span class="line"><span class="comment">// 如果心跳时间间隔修改了怎么办？这里不应该硬编码，应该用心跳间隔时间作来计算。</span></span><br><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// count * 2 * 0.85</span></span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">  (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure><blockquote><p>实际上这里的*2的操作，是很迷的一种写法，首先他这个地方硬编码了。然后他想表达的意思是，如果有10个实例，那么就在1分钟以内，要收到20次心跳，因为30秒一次心跳嘛。可是如果用户自己修改了心跳的间隔2时间，那这个地方不就BUG了吗？</p></blockquote></li><li><p>在注册、下线、故障的时候，肯定也会更新值，这里有个小技巧，我们要查找一个变量在哪些地方赋值过。可以在IDEA里按快捷 <code>ALT+F7</code>，在看源码的时候非常有用，如截图所示，在前边有红色一根笔的小图标，可以看得出来是写操作，绿色一本书是读操作。<br><img src="/img/spring-cloud/image-20200329171857177.png" alt="image-20200329171857177"><br>AbstractInstanceRegistry.register方法中，这里再一次做了硬编码，新注册一个实例后，每分钟期望的心跳次数就会 <code>+ 2</code>。一样的，下线就是<code>-2</code>。<strong>那么故障的时候有更新这个值吗？我反正是没有找到，直接调用internalCancel方法不会去更新这个值，所以这应该是一个BUG！！！因为如果都是因为故障下线的，这个期望的心跳值并没有更新，实际的心跳次数又变少。那么每次在清除实例的时候，可能导致快速的开启了自我保护机制，而不再去清理任何的实例了。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">(<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure></li><li><p>定时更新，根据<code>ALT+F7</code>的方式，PeerAwareInstanceRegistryImpl初始化的时候，启了定时调度任务，默认是15分钟执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      updateRenewalThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span><br><span class="line">                 serverConfig.getRenewalThresholdUpdateIntervalMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在updateRenewalThreshold任务中，从别的服务同步并合并注册表。然后计算出一个服务实例的数量。如果拉取到的服务实例数量，大于本地的期望的服务实例数量<em>0.85。**我觉得这里是不是写错了，numberOfRenewsPerMinThreshold本来就是count\</em>2*0.85，这里判断再*0.85？？？*<em>接着再次计算了一下服务实例列表的count，count </em> 2 <em> 0.85。这个代码也是骚的很，刚计算了expectedNumberOfRenewsPerMin=count </em> 2，下面却不用这个变量，又写了一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">  <span class="comment">// Update threshold only if the threshold is greater than the</span></span><br><span class="line">  <span class="comment">// current expected threshold of if the self preservation is disabled.</span></span><br><span class="line">  <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</span><br><span class="line">      || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span><br><span class="line">    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="实际的上一分钟心跳次数是如何计算的？"><a href="#实际的上一分钟心跳次数是如何计算的？" class="headerlink" title="实际的上一分钟心跳次数是如何计算的？"></a>实际的上一分钟心跳次数是如何计算的？</h3><p>回到前面判断是否开启自我保护的代码，实际的上一分钟心跳次数getNumOfRenewsInLastMin()，用到了MeasuredRate，我们可以用<code>ALT + F7</code>去找increment方法的调用处，直接定位到了renew(心跳)的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际的上一分钟心跳次数 + 1</span></span><br><span class="line">renewsLastMin.increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部实现细节----如何计算并保持上1分钟的数据？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每分钟一次，设置到lastBucket中，currentBucket设置为0</span></span><br><span class="line"><span class="comment">// lastBucket是用来读的，currentBucket是用来写的</span></span><br><span class="line"><span class="comment">// Zero out the current bucket.</span></span><br><span class="line">lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="自我保护机制的触发"><a href="#自我保护机制的触发" class="headerlink" title="自我保护机制的触发"></a>自我保护机制的触发</h3><p>如果上一分钟，实际的心跳次数少于了期望的心跳次数，那么就会开启自我保护机制，不允许摘除任何服务实例。此时认为自己的eureka server出现网络故障，大量的服务实例无法发送心跳过来。</p><p><img src="/img/spring-cloud/image-20200329182748663.png" alt="image-20200329182748663"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务心跳流程分析&quot;&gt;&lt;a href=&quot;#服务心跳流程分析&quot; class=&quot;headerlink&quot; title=&quot;服务心跳流程分析&quot;&gt;&lt;/a&gt;服务心跳流程分析&lt;/h1&gt;&lt;p&gt;eureka client每隔一定的时间，会给eureka server发送心跳，保持心跳，让eureka server认为自己还活着。&lt;/p&gt;
&lt;p&gt;心跳在代码里，叫做续约。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;还是在DiscoveryClient初始化的时候，有一个心跳的定时任务，由&lt;code&gt;HeartbeatThread&lt;/code&gt;执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认值是每隔30秒去发送一个心跳。DEFAULT_LEASE_RENEWAL_INTERVAL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来是用jersy去给eureka server发送心跳的http请求。
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码03-服务列表同步分析</title>
    <link href="http://www.saily.top/2020/03/21/springcloud/eureka03/"/>
    <id>http://www.saily.top/2020/03/21/springcloud/eureka03/</id>
    <published>2020-03-21T02:05:39.000Z</published>
    <updated>2020-04-17T04:13:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-client全量抓取注册表"><a href="#eureka-client全量抓取注册表" class="headerlink" title="eureka client全量抓取注册表"></a>eureka client全量抓取注册表</h1><p>eureka client第一次启动的时候，会从eureka server端抓取全量的注册表，在本地进行缓存。后续每隔30秒从eureka server端抓取增量的注册表信息，和本地缓存进行合并。</p><p>先找到第一次抓取全量注册表的源码，没记错的话应该是在创建DiscoveryClient的构造方法里。就是下面这几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">  fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个fetchRegistry方法，就是抓取注册表的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiscoveryClient.fetchRegistry()</span></span><br><span class="line"><span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line"><span class="comment">// applications</span></span><br><span class="line"><span class="comment">// 本地的Application缓存，在执行完成后续的全量注册表拉取后，也会将数据缓存到这个地方</span></span><br><span class="line">Applications applications = getApplications();</span><br><span class="line"><span class="keyword">if</span> 一大堆条件 &#123;</span><br><span class="line">  <span class="comment">// localRegionApps.set(this.filterAndShuffle(apps));</span></span><br><span class="line">  <span class="comment">// 用jeresy从server端获取全量注册表，然后缓存到本地（也就是上方的getApplications()）</span></span><br><span class="line">  getAndStoreFullRegistry();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 增量</span></span><br><span class="line">  getAndUpdateDelta(applications);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="eureka-server端处理抓取注册表的请求（多级缓存机制）"><a href="#eureka-server端处理抓取注册表的请求（多级缓存机制）" class="headerlink" title="eureka server端处理抓取注册表的请求（多级缓存机制）"></a>eureka server端处理抓取注册表的请求（多级缓存机制）</h1><p>根据客户端请求的接口（GET ip:port/v2/apps），去服务端找对应的处理方法。是在ApplicationsResource.getContainers方法。</p><p>eureka server端，有一套多级缓存的机制，这里的cacheKey，就是缓存用的Key，然后下面就是从缓存读取数据的逻辑，注意这里的key是ALL_APPS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">                       ResponseCacheImpl.ALL_APPS,</span><br><span class="line">                       keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">);</span><br><span class="line">Response response;</span><br><span class="line"><span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">  response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">    .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">    .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response = Response.ok(responseCache.get(cacheKey))</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eureka server的缓存，是基于ResponseCache这样的一个接口开发的。实现类是ResponseCacheImpl，看下它的get方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line">String get(final Key key, boolean useReadOnlyCache) &#123;</span><br><span class="line">    Value payload = getValue(key, useReadOnlyCache);</span><br><span class="line">    if (payload == null || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return payload.getPayload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的条件useReadOnlyCache，是通过配置读取的。再跟进去看看源码，getValue方法里，看到有了2个map，做了两级缓存，分别是readOnlyCacheMap和readWriteCacheMap，readWriteCacheMap是基于Guava Cache封装的一个缓存，程序先从只读缓存里去读，如果没有的话，会从读写缓存里去读，还是没有的话，才会从registry的map里读。实际上在ResponseCacheImpl的构造方法里，就包含了readWriteCacheMap数据初始化的逻辑。</p><blockquote><p>generatePayload方法中，从注册表中获取所有的Applications，通过ServerCodecs组件，将Applications对象序列化成一个json字符串，然后放入读写缓存（readWriteCacheMap）。接着，放入只读缓存中（readOnlyCacheMap）。</p></blockquote><p><img src="/img/spring-cloud/image-20200322172453943.png" alt="image-20200322172453943"></p><h2 id="多级缓存过期机制"><a href="#多级缓存过期机制" class="headerlink" title="多级缓存过期机制"></a>多级缓存过期机制</h2><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>有新的服务实例发生注册、下线、故障的时候，会刷新readWriteCacheMap。PeerAwareInstanceRegistryImpl的javadoc，说这个类会同步一些状态变化到其他节点，同时我们也看他也维护了注册表信息，并且注册的register方法也是在这里面，我们在register方法里，找到invalidateCache代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invalidate cache</span></span><br><span class="line">responseCache.invalidate(appName, vipAddress, secureVipAddress);</span><br></pre></td></tr></table></figure><p>这不就是调用responseCache的主动过期方法吗？之前注册的时候看不懂的逻辑，现在一切都明了。借助IDEA的快捷键，在invalidateCache方法上按<code>option + F7</code>，还能找到所有调用的方法，分别是：register、internalCancel、statusUpdate、deleteStatusOverride。</p><h3 id="定时过期"><a href="#定时过期" class="headerlink" title="定时过期"></a>定时过期</h3><p>被动过期在初始化缓存的时候就已经设置了过期属性，<code>.expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</code>，默认值是180秒。</p><h3 id="被动过期"><a href="#被动过期" class="headerlink" title="被动过期"></a>被动过期</h3><p>readOnlyCacheMap是在初始化的时候，设置了一个定时器，默认每隔30从readWriteCacheMap里对数据进行比对，如果数据不一致，就同步数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以说有服务注册、故障或者下线了，因为缓存的原因，其他客户端可能要30秒才能感知到。</p><h1 id="增量抓取注册表"><a href="#增量抓取注册表" class="headerlink" title="增量抓取注册表"></a>增量抓取注册表</h1><p>上面有说到，在eureka client初始化的时候，会全量的抓取一次注册表，然后在initScheduledTasks里启动了一个定时任务，每隔30秒会定时增量同步一次注册表的信息，具体的执行类叫做<code>CacheRefreshThread</code>。</p><ol><li>定时任务，30秒一次</li><li>因为本地有缓存的Applications，所以走增量抓取的逻辑</li><li>走eurekaHttpClient的getDelta接口，<code>GET apps/delta</code></li><li>ApplicationsResources.getContainerDifferential处理增量请求</li><li>一样是走多级缓存机制，key是ALL_APPS_DELTA。后面就是一样了，唯一的区别就是因为key不一样，所以在generatePayload方法里，执行的逻辑不一样，这里不再用registry.getApplications()获取全量数据，而是用registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));获取增量的注册表信息。</li><li>这儿有个recentlyChangedQueue，在状态变化的时候会往里边放数据，代表着最近有变化的服务实例，增量信息就是从这里边去抓取。在Registry初始化的时候有个定时任务，每隔30秒检查一次，这个队列里面的服务实例变更信息是否已经超过180秒了，如果超过会移除。所以这个队列里保留的其实是最近3分钟的服务实例变更数据。</li><li>eureka client每隔30秒，去抓取增量注册表的时候，会拿到最近3分钟内有变化的服务实例的注册表。</li><li>抓取到的注册表和本地缓存的注册表进行合并，完成服务实例的增删改。updateDelta(delta);</li><li>对合并后的注册表计算一个hash值，之前返回的delta带了一个eureka server全量注册表的hash值。对这2个值进行对比，如果不一致，此时会从eureka server抓取全量的注册表到本地。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/spring-cloud/image-20200322183205931.png" alt="image-20200322183205931"></p><h3 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h3><ol><li>如果要保存增量的最新数据变更，可以基于LinkedQueue将最新变更的数据放入这个queue中，然后用定时任务在队列超过一定时间的数据移除，保持这个队列中就是最近几分钟内变更的增量数据。</li><li>数据同步的hash值对：如果在分布式系统里，在不同的地方进行数据的同步，可以采用hash值的思想，从一个地方计算一个hash值，在另外一个地方也计算一个hash值，保证两个hash值是一样的，这样可以保证数据的准确性。 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eureka-client全量抓取注册表&quot;&gt;&lt;a href=&quot;#eureka-client全量抓取注册表&quot; class=&quot;headerlink&quot; title=&quot;eureka client全量抓取注册表&quot;&gt;&lt;/a&gt;eureka client全量抓取注册表&lt;/h1&gt;&lt;p&gt;eureka client第一次启动的时候，会从eureka server端抓取全量的注册表，在本地进行缓存。后续每隔30秒从eureka server端抓取增量的注册表信息，和本地缓存进行合并。&lt;/p&gt;
&lt;p&gt;先找到第一次抓取全量注册表的源码，没记错的话应该是在创建DiscoveryClient的构造方法里。就是下面这几行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clientConfig.shouldFetchRegistry() &amp;amp;&amp;amp; !fetchRegistry(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fetchRegistryFromBackup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码02-服务注册流程分析</title>
    <link href="http://www.saily.top/2020/03/18/springcloud/eureka02/"/>
    <id>http://www.saily.top/2020/03/18/springcloud/eureka02/</id>
    <published>2020-03-18T12:05:39.000Z</published>
    <updated>2020-04-12T06:19:06.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eureka-client启动流程"><a href="#eureka-client启动流程" class="headerlink" title="eureka client启动流程"></a>eureka client启动流程</h1><p>上一篇文章，我们分析了eureka server的启动流程，这一篇来分析一下eureka client的启动流程。我们先要找到启动入口在哪里。在eureka-examples里，有一个ExampleEurekaClient的测试类。要执行这个类，首先需要复制一段代码，设置一些基础属性，这是从eureka-server的单元测试里复制过来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This will be read by server internal discovery client. We need to salience it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEurekaConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">  String myHostName = InetAddress.getLocalHost().getHostName();</span><br><span class="line">  String myServiceUrl = <span class="string">"http://"</span> + myHostName + <span class="string">":8080/v2/"</span>;</span><br><span class="line"></span><br><span class="line">  System.setProperty(<span class="string">"eureka.region"</span>, <span class="string">"default"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.name"</span>, <span class="string">"eureka"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.vipAddress"</span>, <span class="string">"eureka.mydomain.net"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.port"</span>, <span class="string">"8080"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.preferSameZone"</span>, <span class="string">"false"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.shouldUseDns"</span>, <span class="string">"false"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.shouldFetchRegistry"</span>, <span class="string">"false"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.serviceUrl.defaultZone"</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.serviceUrl.default.defaultZone"</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.awsAccessId"</span>, <span class="string">"fake_aws_access_id"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.awsSecretKey"</span>, <span class="string">"fake_aws_secret_key"</span>);</span><br><span class="line">  System.setProperty(<span class="string">"eureka.numberRegistrySyncRetries"</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在main方法的第一行调用一下上面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    injectEurekaConfiguration();</span><br><span class="line">    ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the client</span></span><br><span class="line">    ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">    EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the client</span></span><br><span class="line">    sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown the client</span></span><br><span class="line">    eurekaClient.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下上面这个方法，这段逻辑几乎和上一篇文章中介绍的eureka server启动流程中，初始化eureka client逻辑的是一样的。</p><ol><li>读取eureka-client.properties配置文件，形成服务实例配置，基于接口对外提供服务实例配置项的读取。（MyDataCenterInstanceConfig）</li><li>基于服务实例配置，构造服务实例（InstanceInfo）</li><li>基于eureka client配置和服务实例，构造服务实例管理器（ApplicationInfoManager）</li><li>读取eureka-client.properties配置文件，形成一个eureka client的配置，基于接口对外提供eureka client配置项读取（DefaultEurekaClientConfig）。</li><li>基于eureka client配置，和服务实例管理器构造了一个EurekaClient（DiscoveryClient），保存了一些配置，处理服务的注册和注册表的抓取，启动了几个线程池，启动了网络通信组件，启动了一些调度任务，注册了监控项。</li></ol><p>在DiscoveryClient的构造方法里，做了很多操作，具体可以看下图。</p><h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/eureka client启动流程.jpg" alt="eureka client启动流程"></p><h1 id="eureka-client服务注册逻辑"><a href="#eureka-client服务注册逻辑" class="headerlink" title="eureka client服务注册逻辑"></a>eureka client服务注册逻辑</h1><p>上面的逻辑咱们理完了后，发现不知道服务注册是哪一个步骤完成的，实际上注册的逻辑，是在初始化调度任务那里，和心跳任务一起初始化的<code>InstanceInfoReplicator</code>任务里。<strong>这儿其实感觉比较奇怪，注册服务和实例信息复制，在我们常见的分布式系统里应该是不同的概念，比如redis、mongodb、elastic search里都有副本的概念（Replica），但是在eureka这里，这里面实际上却是注册服务的逻辑。</strong></p><ol><li><code>InstanceInfoReplicator</code>的start方法里，将自己作为一个线程放到一个调度线程池中去了，默认</li></ol><p>是延迟40秒执行。</p><ol start="2"><li><p>那么执行线程的时候，是执行run()方法。</p></li><li><p>在run方法里，刷新了一下服务实例的信息discoveryClient.refreshInstanceInfo();，里面其实是调用ApplicationInfoManager的一些方法刷新了服务实例的配置，看看配置有没有改变，如果改变了，就刷新一下；用健康检查器检查状态，将状态设置到了ApplicationInfoManager中，更新服务实例状态。</p></li><li><p>然后调用discoveryClient.register();进行服务注册。</p></li><li><p>服务注册的时候，是基于EurekaClient的register()方法去注册的，调用的是底层的eurekaTransport的registrationClient，将InstanceInfo服务实例的信息，通过http请求，调用eureka server对外暴露的一个restful接口，将InstanceInfo发送过去。注意：EurekaTransport在构造的下一行代码的时候，调用了<strong>scheduleServerEndpointTask</strong>（一个令人迷惑的方法名），其实这个方法里就初始化了专门用于注册的registrationClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line"><span class="comment">// 其实是初始化eurekaTransport</span></span><br><span class="line">scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line">......</span><br><span class="line">httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br></pre></td></tr></table></figure></li><li><p>然后实际上底层执行发送请求的逻辑，实在是非常难找，代码嵌套过多，最后在EurekaHttpClient的子类里，寻找和http库有关的类，我们找到了AbstractJersey2EurekaHttpClient，在这里的<code>register</code>方法，发现了实际发送注册请求的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送请求，http://localhost:8080/v2/apps/ServiceA</span></span><br><span class="line"><span class="comment">// 发送的是post请求，服务实例的对象打成了一个json发送过去，包含了自己的主机，ip，端口号</span></span><br><span class="line"><span class="comment">// eureka server就知道这个ServiceA这个服务，有一个服务实例，比如是在172.16.21.33、dev-server、8080</span></span><br><span class="line">Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>eureka client在服务注册的这块代码，可以也是看到有用到工厂模式、装饰器模式，但是也有很多<strong>槽点</strong>：</p><ol><li>服务注册，不应该放在<code>InstanceInfoReplicator</code>中，语意不明朗。</li><li>负责发送请求的HttpClient，类体系过于<strong>复杂</strong>，导致看代码的人根本找不到对应的client，最后是根据顶层接口(EurekaHttpClient)和项目依赖实际是使用jersey框架来进行restful接口暴露和调用，才找到真正发送服务注册请求的地方(AbstractJersey2EurekaHttpClient)。</li></ol><h1 id="eureka-server收到注册请求的处理"><a href="#eureka-server收到注册请求的处理" class="headerlink" title="eureka server收到注册请求的处理"></a>eureka server收到注册请求的处理</h1><p>上面分析到了，eureka client向eureka server发起了http请求进行注册，下面就看一下在eureka server中，是如何接收并处理注册请求的。</p><p>因为eureka是基于jersey开发，所以我们去找/v2/apps/{appId}这样的post请求路径处理类，这个请求是在eureka-core模块中<code>ApplicationsResource</code>的<code>getApplicationResource</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">  @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">  CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到ApplicationResource里去找处理post的方法，就找到了接收注册请求的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>接收的是InstanceInfo，代表了一个服务实例。</p><p>在单元测试里，有一个ApplicationResourceTest类，包含了许多功能的测试。接下来，在ApplicationResourceTest里，用断点的方式执行testGoodRegistration方法，对注册流程进行调试和源码分析。</p><p><img src="/img/spring-cloud/image-20200319222757757.png" alt="image-20200319222757757"></p><p>InstanceInfo主要包含2部分数据：</p><ol><li>主机名、ip地址、端口号、url地址</li><li>lease（租约）的信息：保持心跳的间隔时间，最近心跳的时间，服务注册的时间，服务启动的时间。</li></ol><p>register逻辑：</p><ol><li><p>检查了一些必要的参数</p></li><li><p>判断是否是在AWS数据中心，做额外的操作</p></li><li><p>调用registry.register(info, “true”.equals(isReplication));（PeerAwareInstanceRegistry）。向服务实例注册表里注册。</p></li><li><p>调用<a href="http://www.saily.top/2020/03/15/springcloud/eureka01/#%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E6%83%85">PeerAwareInstanceRegistry</a>父类的register方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    read.lock();</span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">    REGISTER.increment(isReplication);</span><br><span class="line">    <span class="comment">// 如果是第一次注册，这个map肯定是null</span></span><br><span class="line">    <span class="comment">// 对Map进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">      <span class="comment">// 一个服务会有多个实例，所以这样存</span></span><br><span class="line">      gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">      <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        gMap = gNewMap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次执行，这里肯定也是null</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">    ......省略部分代码</span><br><span class="line">    <span class="comment">// 如果是服务第一次注册，将服务实例信息放到map中</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">    <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">    gMap.put(registrant.getId(), lease);</span><br></pre></td></tr></table></figure><p>这里的registry，他的数据结构里面就是保存的服务和实例信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"APP_A"</span>:&#123;</span><br><span class="line">    <span class="attr">"00000"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">"00001"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">"00002"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"APP_B"</span>:&#123;</span><br><span class="line">    <span class="attr">"10000"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line"> <span class="attr">"20001"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">"30002"</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>将服务实例的服务名和实例ID访问一个队列中（recentRegisteredQueue）</p></li><li><p>再后面也是更新一些状态。</p></li></ol><p><strong>所以服务注册，最终数据就是服务实例信息放在了一个内存的注册表中：<code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</code>。</strong></p><p>注册这里包含了一个读写锁的应用，ReentrantReadWriteLock，在这里注册的时候，上的是读锁，多个服务实例，可以同时注册。灵活运用读写锁，可以控制多线程的并发，有些操作是可以并发执行的，有些操作的互斥的。</p><h2 id="画图总结-1"><a href="#画图总结-1" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/image-20200319232127915.png" alt="image-20200319232127915"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eureka-client启动流程&quot;&gt;&lt;a href=&quot;#eureka-client启动流程&quot; class=&quot;headerlink&quot; title=&quot;eureka client启动流程&quot;&gt;&lt;/a&gt;eureka client启动流程&lt;/h1&gt;&lt;p&gt;上一篇文章，我们分析了eureka server的启动流程，这一篇来分析一下eureka client的启动流程。我们先要找到启动入口在哪里。在eureka-examples里，有一个ExampleEurekaClient的测试类。要执行这个类，首先需要复制一段代码，设置一些基础属性，这是从eureka-server的单元测试里复制过来的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * This will be read by server internal discovery client. We need to salience it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;injectEurekaConfiguration&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; UnknownHostException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String myHostName = InetAddress.getLocalHost().getHostName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String myServiceUrl = &lt;span class=&quot;string&quot;&gt;&quot;http://&quot;&lt;/span&gt; + myHostName + &lt;span class=&quot;string&quot;&gt;&quot;:8080/v2/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.region&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;default&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.name&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;eureka&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.vipAddress&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;eureka.mydomain.net&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.port&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;8080&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.preferSameZone&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.shouldUseDns&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.shouldFetchRegistry&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;false&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.serviceUrl.defaultZone&quot;&lt;/span&gt;, myServiceUrl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.serviceUrl.default.defaultZone&quot;&lt;/span&gt;, myServiceUrl);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.awsAccessId&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;fake_aws_access_id&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.awsSecretKey&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;fake_aws_secret_key&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.setProperty(&lt;span class=&quot;string&quot;&gt;&quot;eureka.numberRegistrySyncRetries&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码01-eureka启动流程</title>
    <link href="http://www.saily.top/2020/03/15/springcloud/eureka01/"/>
    <id>http://www.saily.top/2020/03/15/springcloud/eureka01/</id>
    <published>2020-03-15T09:05:39.000Z</published>
    <updated>2020-04-12T06:19:00.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何阅读一个开源框架的源码"><a href="#如何阅读一个开源框架的源码" class="headerlink" title="如何阅读一个开源框架的源码"></a>如何阅读一个开源框架的源码</h1><p>如果要阅读一个开源框架的源码，我们应该从什么地方入手。首先应该想到的是，从框架启动的入口入手，比如Eureka，肯定是从Eureka服务本身启动的入口开始。或者我们也可以从框架的单元测试开始看，因为单元测试都包含了框架的核心流程和功能。所以我们通过这2个入口，可以通过打断点执行的方式阅读代码的逻辑。下面我将开始学习Eureka的源码，我将基于<a href="https://github.com/Netflix/eureka.git" target="_blank" rel="noopener">https://github.com/Netflix/eureka.git</a> 的v1.7.2分支进行阅读，因为我目前所用的SpringCloud引入的就是这个版本。<br><a id="more"></a></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>IDE选用idea2018版本进行阅读，为什么选2018版本，eureka的源码是基于gradle构建的，v1.7.2的分支是基于2.10的gradle版本，这个现在已经比较旧了，在JDK10以上的版本，无法运行，而dea2019已经开始用JDK11开始运行，具体情况可以看这篇文章，<a href="https://blog.csdn.net/jiajane/article/details/103014036" target="_blank" rel="noopener">https://blog.csdn.net/jiajane/article/details/103014036</a>，是类似的问题。经过一番倒腾我最终也没有能在2019版本上加载依赖，所以我还是选择了2018版本开始源码的阅读，使用上没有区别。</p><p>先看下Eureka的核心流程，核心功能包括：</p><ul><li>服务注册</li><li>服务发现</li><li>client向server发送心跳</li><li>client向server获取服务注册表</li><li>服务实例摘除</li><li>自我保护机制</li><li>通信</li></ul><p>下面将从源码找到eureka的启动类，并作为入口进行源码分析。</p><h1 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h1><p>eureka-server依赖了eureka-client和eureka-core2个模块，server又当服务器，又当作客户端，因为在集群模式下，他们也会相互注册。注册中心相关核心的代码都在eureka-core模块里，也能看出来eureka是基于jersey（类似spring mvc)开发的接口，和客户端http请求，在服务之间相互通信。</p><p><img src="/img/spring-cloud/image-20200315153312195.png" alt="image-20200315153312195"><img src="/img/spring-cloud/image-20200315153257597.png" alt="image-20200315153257597"></p><p>然后eureka-resources里，其实就是一些css、js和jsp文件。</p><p><img src="/img/spring-cloud/image-20200315153346879.png" alt="image-20200315153346879"></p><p>那么eureka-server本质上其实就是一个web应用，并且在eureka-server里发现还有一个web.xml文件，所以我们应该重点分析下<code>web.xml</code>文件，里面包含了一些listener和filter，这些类应该都是我们要重点看一下的源码，先猜一下这几个类都是干什么的。</p><ul><li>com.netflix.eureka.EurekaBootStrap（初始化逻辑？）</li><li>com.netflix.eureka.StatusFilter（状态管理？）</li><li>com.netflix.eureka.ServerRequestAuthFilter（授权认证相关？）</li><li>com.netflix.eureka.RateLimitingFilter（限流控制？）</li><li>com.netflix.eureka.GzipEncodingEnforcingFilter（压缩和编码相关？）</li><li>com.sun.jersey.spi.container.servlet.ServletContainer（jersey框架初始化加载类，类似Spring MVC的DispatcherServlet）</li></ul><p>文件下面的filter-mapping里默认没有开启限流的过滤器，Gzip也只过滤<code>/v2/apps</code>路径下的请求。</p><h2 id="EurekaBootStrap（启动类，重要）"><a href="#EurekaBootStrap（启动类，重要）" class="headerlink" title="EurekaBootStrap（启动类，重要）"></a>EurekaBootStrap（启动类，重要）</h2><p>这个类在eureka-core里，监听器要关注<code>contextInitialized</code>方法，这里就是eureka-server启动，初始化的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initEurekaEnvironment();</span><br><span class="line">    initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">    ServletContext sc = event.getServletContext();</span><br><span class="line">    sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initEurekaEnvironment"><a href="#initEurekaEnvironment" class="headerlink" title="initEurekaEnvironment"></a>initEurekaEnvironment</h3><ol><li>在initEurekaEnvironment中，ConfigurationManager.getConfigInstance()初始化ConcurrentCompositeConfiguration实例，基于<strong>双检锁单例模式</strong>的配置管理器，管理eureka的所有配置，。</li><li>初始化dataCenter，数据中心的配置，如果没有配置的话，就给个默认的（default）。</li><li>初始化eureka.environment，默认是test环境。</li></ol><h3 id="initEurekaServerContext"><a href="#initEurekaServerContext" class="headerlink" title="initEurekaServerContext"></a>initEurekaServerContext</h3><h4 id="加载eureka-server-properties文件中的配置"><a href="#加载eureka-server-properties文件中的配置" class="headerlink" title="加载eureka-server.properties文件中的配置"></a>加载eureka-server.properties文件中的配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br></pre></td></tr></table></figure><p>DefaultEurekaServerConfig的init方法中，加载了一个properties文件，文件名默认叫eureka-server.properties（<code>EUREKA_PROPS_FILE</code>变量），通过ConfigurationManager加载到内存中，然后EurekaServerConfig的方法，再用configInstance获取对应的值。EurekaServerConfig是个接口，有很多get方法，包含了eureka server需要的所有配置，都可以通过这个接口获取。通过接口，对properties文件里的配置项进行了封装，增加了代码的可读性，不像我们自己可能做的有些项目里，读取配置文件都是去调用get某个key。</p><p>在DefaultEurekaServerConfig的方法中，也能看到大量的硬编码配置项和默认值。</p><h4 id="初始化ApplicationInfoManager"><a href="#初始化ApplicationInfoManager" class="headerlink" title="初始化ApplicationInfoManager"></a>初始化ApplicationInfoManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">  ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">  : <span class="keyword">new</span> MyDataCenterInstanceConfig();</span><br><span class="line"></span><br><span class="line">applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</span><br><span class="line">  instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</span><br></pre></td></tr></table></figure><p>查看ApplicationInfoManager的javadoc说明，这个类用来初始化服务注册和被其他服务发现的一些配置，其中配置通过EurekaInstanceConfig设置，从MyDataCenterInstanceConfig的父类的构造方法可以看到，其实也是读取的eureka-client.properties文件加载的。和<code>DefaultEurekaServerConfig</code>一样<code>EurekaInstanceConfig</code>也是提供了一些方法，实际是从配置文件读取，同时也提供了默认值。</p><p><code>new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get()</code>方法返回了InstanceInfo。InstanceInfo是服务实例本身的信息，用<strong>构造器模式</strong><code>InstanceInfo.Builder.newBuilder()</code>构造了一个<code>InstanceInfo.Builder</code>实例，从instanceConfig里获取了大量配置，再加创建的几个类完成了构造。</p><p>最后，EurekaInstanceConfig和InstnaceInfo，构造了ApplicationInfoManager，作为服务实例的一个管理器。</p><h4 id="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"><a href="#初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）" class="headerlink" title="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"></a>初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br></pre></td></tr></table></figure><p>DefaultEurekaClientConfig一样也是面向接口的配置项读取方式，也同样是读取了eureka-client.properties配置，不过它只读取了eureka开头的配置项，在DefaultEurekaTransportConfig里可看到，包含了很多client相关的配置项。<strong>EurekaClientConfig</strong>配置，和前面构建好的<strong>ApplicationInfoManager</strong>（包含了服务的实例信息、配置，作为服务实例管理的一个组件）构建了eurekaClient的子类DiscoveryClient。</p><p>DiscoveryClient我们可以看一下构造方法，初始化了很多东西，重点处理：</p><ol><li>是否需要拉取注册信息，shouldRegisterWithEureka</li><li>是否要注册自己，shouldRegisterWithEureka</li><li>初始化调度线程池，scheduler</li><li>初始化心跳线程池，heartbeatExecutor</li><li>初始化缓存刷新的线程池，cacheRefreshExecutor</li><li>new EurekaTransport()，支持底层eureka client和eureka server通信的一些初始化。</li><li>如果要抓取注册表，则抓取注册表表，fetchRegistryFromBackup();</li><li>初始化调度任务，initScheduledTasks(); 定时抓取注册表、心跳。初始化服务实例副本传播器（instanceInfoReplicator），服务实例状态变更监听器（statusChangeListener）。</li></ol><h4 id="处理注册相关的事情"><a href="#处理注册相关的事情" class="headerlink" title="处理注册相关的事情"></a>处理注册相关的事情</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        eurekaClient</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过javadoc看下PeerAwareInstanceRegistryImpl是干什么用的：将所有操作复制到集群里对等的Eureka节点，以使它们保持同步。复制的主要操作是Registers,Renewals,Cancels,Expirations 和 Status Changes。</p><h4 id="处理peer节点相关的事情"><a href="#处理peer节点相关的事情" class="headerlink" title="处理peer节点相关的事情"></a>处理peer节点相关的事情</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">        registry,</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>初始化Eureka集群的信息，PeerEurekaNode包含了每个节点自己分享给其他节点的信息。</p><h4 id="完成eureka-server上下文（context）的构建以及初始化"><a href="#完成eureka-server上下文（context）的构建以及初始化" class="headerlink" title="完成eureka-server上下文（context）的构建以及初始化"></a>完成eureka-server上下文（context）的构建以及初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        serverCodecs,</span><br><span class="line">        registry,</span><br><span class="line">        peerEurekaNodes,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br><span class="line">EurekaServerContextHolder.initialize(serverContext);</span><br></pre></td></tr></table></figure><p>serverContext.initialize方法中调用了peerEurekaNodes.start();，定时当前的eureka server同步集群里其他eureka server的一些信息。</p><p>registry.init(peerEurekaNodes);</p><p>用从集群获取的到的信息，初始化本实例的注册表。其实就是和集群之间的信息同步，这个研究这块的时候再细看。</p><h4 id="从相邻的eureka节点拷贝注册信息"><a href="#从相邻的eureka节点拷贝注册信息" class="headerlink" title="从相邻的eureka节点拷贝注册信息"></a>从相邻的eureka节点拷贝注册信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</span><br></pre></td></tr></table></figure><p>看syncUp的javadoc，从一个节点拷贝注册信息，如果失败就换个节点。细节后面再看。</p><h4 id="处理监控统计项"><a href="#处理监控统计项" class="headerlink" title="处理监控统计项"></a>处理监控统计项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EurekaMonitors.registerAllStats();</span><br></pre></td></tr></table></figure><p>注册一些监控和统计。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>启动流程，到这里就结束了，我们总结一下，源码里用了不少设计模式和优秀的实现机制，例如基于双检锁的单例模式、构建器模式，面向接口的配置读取等，这都是我们值得去学习的。</p><p><img src="/img/spring-cloud/eureka server启动流程图.jpg" alt="eureka server启动流程图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何阅读一个开源框架的源码&quot;&gt;&lt;a href=&quot;#如何阅读一个开源框架的源码&quot; class=&quot;headerlink&quot; title=&quot;如何阅读一个开源框架的源码&quot;&gt;&lt;/a&gt;如何阅读一个开源框架的源码&lt;/h1&gt;&lt;p&gt;如果要阅读一个开源框架的源码，我们应该从什么地方入手。首先应该想到的是，从框架启动的入口入手，比如Eureka，肯定是从Eureka服务本身启动的入口开始。或者我们也可以从框架的单元测试开始看，因为单元测试都包含了框架的核心流程和功能。所以我们通过这2个入口，可以通过打断点执行的方式阅读代码的逻辑。下面我将开始学习Eureka的源码，我将基于&lt;a href=&quot;https://github.com/Netflix/eureka.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Netflix/eureka.git&lt;/a&gt; 的v1.7.2分支进行阅读，因为我目前所用的SpringCloud引入的就是这个版本。&lt;br&gt;
    
    </summary>
    
      <category term="spring-cloud" scheme="http://www.saily.top/categories/spring-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="eureka" scheme="http://www.saily.top/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-5-SpringBoot整合Spring MVC</title>
    <link href="http://www.saily.top/2020/01/30/springcloud/microservices-5/"/>
    <id>http://www.saily.top/2020/01/30/springcloud/microservices-5/</id>
    <published>2020-01-30T13:50:39.000Z</published>
    <updated>2020-03-15T14:42:05.446Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及到的源码：<a href="https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture" target="_blank" rel="noopener">https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture</a></p><p>拖延中。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文涉及到的源码：&lt;a href=&quot;https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://githu
      
    
    </summary>
    
      <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-4-SpringBoot日志，JSP，WebSocket等</title>
    <link href="http://www.saily.top/2019/11/23/springcloud/microservices-4/"/>
    <id>http://www.saily.top/2019/11/23/springcloud/microservices-4/</id>
    <published>2019-11-23T14:50:39.000Z</published>
    <updated>2019-11-23T10:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot日志处理"><a href="#SpringBoot日志处理" class="headerlink" title="SpringBoot日志处理"></a>SpringBoot日志处理</h2><p>默认情况下，SpringBoot会引入spring-boot-starter-logging，也就是logback的日志实现。</p><p>在resources下新建<code>logback-spring.xml</code>可以自定义日志配置，这是约定的文件名字。</p><p>在spring-boot-starter-logging-2.1.4.RELEASE这个依赖中，在/org/springframework/boot/logging/logback/base.xml位置可以找到SpringBoot提供的一个默认配置，基于这个配置进行自定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/base.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.test.springlecture"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.test.springlecture"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>可以指定不同的springProfile，可以做到当在开发环境的时候打印debug日志，在生产的时候则打印info。</p><p>也可以直接在application.yml里配置日志级别：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h2 id="SprintBoot整合JSP"><a href="#SprintBoot整合JSP" class="headerlink" title="SprintBoot整合JSP"></a>SprintBoot整合JSP</h2><p>现在用JSP的项目应该已经很少了，大部分都是前后端分离的项目。不过SpringBoot还是提供了对JSP的支持。</p><p>在SpringBoot中访问jsp，需要新增一个依赖，没有这个依赖，SpringBoot是无法编译jsp文件的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;org.apache.tomcat.embed:tomcat-embed-jasper&apos;</span><br></pre></td></tr></table></figure><p>以及路径配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mvc:</span></span><br><span class="line"><span class="attr">    view:</span></span><br><span class="line"><span class="attr">      prefix:</span> <span class="string">/WEB-INF/jsp</span></span><br><span class="line"><span class="attr">      suffix:</span> <span class="string">.jsp</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合WebSocket"><a href="#SpringBoot整合WebSocket" class="headerlink" title="SpringBoot整合WebSocket"></a>SpringBoot整合WebSocket</h2><p>SpringBoot对WebSocket也提供了强有力的支持，这里简单介绍一下如何在SpringBoot里开发WebSocket接口，首先引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;org.springframework.boot:spring-boot-starter-websocket&apos;,</span><br><span class="line">&apos;org.springframework.boot:spring-boot-starter-json&apos;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEchoService</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String echoFormat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEchoService</span><span class="params">(String echoFormat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.echoFormat = echoFormat != <span class="keyword">null</span> ? echoFormat : <span class="string">"%s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="keyword">this</span>.echoFormat, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是用户的业务代码，下面是要实现TextWebSocketHandler，对WebSocket连接进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoWebSocketHandler</span><span class="params">(EchoService echoService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.echoService = echoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"连接建立"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.close(CloseStatus.SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String echoMessage = echoService.getMessage(message.getPayload());</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> TextMessage(echoMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对所有的类进行配置，注意添加@EnableWebSocket注解和实现WebSocketConfigurer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(webSocketHandler(), <span class="string">"/echo"</span>).setAllowedOrigins(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EchoService <span class="title">echoService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultEchoService(<span class="string">"You said \"%s\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">webSocketHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EchoWebSocketHandler(echoService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试页面</p><p><a href="http://www.websocket.org/echo.html" target="_blank" rel="noopener">http://www.websocket.org/echo.html</a></p><p><img src="/img/spring-cloud/sc04-1.png" alt="sc04-1"></p><h2 id="SpringBoot单元测试"><a href="#SpringBoot单元测试" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h2><p>SpringBoot为单元测试提供了非常方便的集成，引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;org.springframework.boot:spring-boot-starter-test&apos;</span><br></pre></td></tr></table></figure><p>编写单元测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpMockMvc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/api/person"</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line">      HTTP Method = GET</span><br><span class="line">      Request URI = /api/person</span><br><span class="line">       Parameters = &#123;&#125;</span><br><span class="line">          Headers = [Content-Type:&quot;application/json;charset=UTF-8&quot;, Accept:&quot;application/json;charset=UTF-8&quot;]</span><br><span class="line">             Body = null</span><br><span class="line">    Session Attrs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Handler:</span><br><span class="line">             Type = com.test.springlecture.controller.MyController</span><br><span class="line">           Method = public com.test.springlecture.domain.Person com.test.springlecture.controller.MyController.getPerson()</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">    Async started = false</span><br><span class="line">     Async result = null</span><br><span class="line"></span><br><span class="line">Resolved Exception:</span><br><span class="line">             Type = null</span><br><span class="line"></span><br><span class="line">ModelAndView:</span><br><span class="line">        View name = null</span><br><span class="line">             View = null</span><br><span class="line">            Model = null</span><br><span class="line"></span><br><span class="line">FlashMap:</span><br><span class="line">       Attributes = null</span><br><span class="line"></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line">           Status = 200</span><br><span class="line">    Error message = null</span><br><span class="line">          Headers = [Content-Type:&quot;application/json;charset=UTF-8&quot;]</span><br><span class="line">     Content type = application/json;charset=UTF-8</span><br><span class="line">             Body = &#123;&quot;id&quot;:18,&quot;name&quot;:&quot;张三&quot;,&quot;birthday&quot;:&quot;2019-11-23T09:59:18.761+0000&quot;&#125;</span><br><span class="line">    Forwarded URL = null</span><br><span class="line">   Redirected URL = null</span><br><span class="line">          Cookies = []</span><br></pre></td></tr></table></figure><p>SpringBoot重要组件就介绍到这里，后面的文章会介绍Apache kafka的使用以及和SpringBoot应用的集成。</p><p>本文涉及到的源码：<a href="https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture" target="_blank" rel="noopener">https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot日志处理&quot;&gt;&lt;a href=&quot;#SpringBoot日志处理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot日志处理&quot;&gt;&lt;/a&gt;SpringBoot日志处理&lt;/h2&gt;&lt;p&gt;默认情况下，SpringBoot会引入spring-boot-starter-logging，也就是logback的日志实现。&lt;/p&gt;
&lt;p&gt;在resources下新建&lt;code&gt;logback-spring.xml&lt;/code&gt;可以自定义日志配置，这是约定的文件名字。&lt;/p&gt;
&lt;p&gt;在spring-boot-starter-logging-2.1.4.RELEASE这个依赖中，在/org/springframework/boot/logging/logback/base.xml位置可以找到SpringBoot提供的一个默认配置，基于这个配置进行自定义&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;Configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;resource&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;org/springframework/boot/logging/logback/base.xml&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.test.springlecture&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;level&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;DEBUG&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;springProfile&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;default&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.test.springlecture&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;level&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;INFO&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;springProfile&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;Configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-3-SpringBoot源码初探</title>
    <link href="http://www.saily.top/2019/10/13/springcloud/microservices-3/"/>
    <id>http://www.saily.top/2019/10/13/springcloud/microservices-3/</id>
    <published>2019-10-13T14:50:39.000Z</published>
    <updated>2019-11-23T10:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h1><p>Class that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application:</p><ul><li>Create an appropriate ApplicationContext instance (depending on your classpath)</li><li>Register a CommandLinePropertySource to expose command line arguments as Spring properties</li><li>Refresh the application context, loading all singleton beans</li><li>Trigger any CommandLineRunner beans</li></ul><a id="more"></a><p> SpringApplications can read beans from a variety of different sources. It is generally recommended that a single @Configuration class is used to bootstrap your application, however, you may also set sources from:</p><ul><li>The fully qualified class name to be loaded by AnnotatedBeanDefinitionReader</li><li>The location of an XML resource to be loaded by XmlBeanDefinitionReader, or a groovy script to be loaded by GroovyBeanDefinitionReader</li><li>The name of a package to be scanned by ClassPathBeanDefinitionScanner</li></ul><p>除了用@Configuration标记的类可以启动应用，还有上面介绍的3种方式可以启动应用。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>看看构造方法的说明：</p><blockquote><p>Create a new SpringApplication instance. The application context will load beans from the specified primary sources (see class-level documentation for details. The instance can be customized before calling run(String…).</p></blockquote><p>创建一个SpringApplication，应用上下文从指定的primary sources加载bean。</p><p>构造方法的实现里有一行this.webApplicationType=WebApplicationType.deduceFromClasspath();，这行决定了应用是用的什么web容器启动的，非web环境，Servlet容器，或者Reactive（Spring 5新增的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>里面的具体内容都干了些什么。</p><p>从getSpringFactoriesInstances方法代码里执行跟到SpringFactoriesLoader.loadSpringFactories这个方法中，有行很关键的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The location to look for factories.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br></pre></td></tr></table></figure><p>urls就包含了所有jar包里的spring.factories文件。</p><p>SpringFactoriesLoader是框架内部用来加载工厂的一种机制，它会读取META-INF/spring.factories这个文件的内容，这个文件存在于多个jar文件中（所有的spring.factories都会被读取并加载），随便看一个，比如spring-boot-autoconfigure-2.1.4.RELEASE.jar里的，定义了7种类型的类，Spring会去加载这个文件中定义的工厂信息配置文件，左边都是接口或者抽象类，右边都是具体的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>在读取了这些文件内容以后，文件里的内容就会作为缓存把数据放入到<code>private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</code>中。</p><p>接下来，就获取了key为<code>org.springframework.context.ApplicationContextInitializer</code>的类列表。</p><p>这里也对应了前面提到过的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br></pre></td></tr></table></figure></p><p>后面就是通过反射的方式来创建这些ApplicationContextInitializer工厂类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">classLoader, args, names);</span><br></pre></td></tr></table></figure></p><p>再下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>也是一样的逻辑，只不过这次是从缓存里获取的class名称了。</p><p>到这里ApplicationContextInitializer和ApplicationListener都实例化完成。</p><p>再往下面看<code>this.mainApplicationClass = deduceMainApplicationClass();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line"><span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="comment">// Swallow and continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万万没想到，Spring Boot竟然是通过这种方式来找到main方法所在类的，直接new一个RuntimeException()，然后从堆栈里去找main方法所在的类。</p><p>SpringApplication对象构造完成后，接下来就调用了run()方法。</p><h2 id="run-方法-amp-ApplicationContext"><a href="#run-方法-amp-ApplicationContext" class="headerlink" title="run()方法&amp; ApplicationContext"></a>run()方法&amp; ApplicationContext</h2><p>运行Spring应用，创建并且刷新一个新的ApplicationContext，在run方法中执行了很多代码，下面一一进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就声明了变量，ConfigurableApplicationContext context = null;</p><p><code>ApplicationContext</code>是Spring里非常重要的一个接口，看看它的注释。</p><p>是一个中心的接口，为一个应用提供了配置。当应用在运行的时候，它是只读的，但是如果实现支持的话，可以被重新加载。</p><p>提供的功能如下：</p><ul><li>提供了访问应用组件的bean工厂方法，继承自ListableBeanFactory</li><li>加载文件资源的能力，继承自 ResourceLoader接口</li><li>向注册的监听器发布事件的能力，继承自ApplicationEventPublisher接口</li><li>解析消息的能力，支持国际化，继承自MessageSource接口</li><li>继承父上下文的相关信息。子上下文有更高的优先级</li></ul><p>ConfigurableApplicationContext会被大多数应用上下文实现，比<code>ApplicationContext</code>又多补充了些功能。</p><p>再往下就是异常报告器，用于支持对SpringBootApplication启动错误的报告。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>再往下的代码，就是将系统属性设置为无头模式，表示是没有界面的服务器程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureHeadlessProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(</span><br><span class="line">            SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(<span class="keyword">this</span>.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这行代码，获取了非常重要的<code>SpringApplicationRunListener</code>，这个监听器提供了很多应用生命周期不同阶段的事件监听，例如启动，上下文加载后，停止等。而这里的<code>SpringApplicationRunListener</code>正是读取的<code>spring.factories</code>文件中定义的监听器。紧接着就触发了启动事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br></pre></td></tr></table></figure><p>在后续的几行代码也可以看到对listeners的environmentPrepared，contextPrepared，contextLoaded，started，running等方法的调用。</p><p>如下图，EventPublishingRunListener会去SimpleApplicationEventMulticaster发送真正的event事件，这是设计模式中的观察者模式在Spring应用中的体现。</p><p><img src="/img/spring-cloud/sc03-1.jpg" alt></p><p><img src="/img/spring-cloud/sc03-2.jpg" alt></p><p>ConfigurableEnvironment也是Spring中非常重要的一个组件，包含了2部分： profiles 和 properties，profile用来分组不同的属性，表示当前应用启动的环境，同一时刻只会有一个profile处于激活状态，例如dev,test,uat,prod等，property通常用${…}这种placeholder的方式被开发人员获取。</p><p>prepareEnvironment方法里面就会调用这2个方法，对property和profile进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurePropertySources(environment, args);</span><br><span class="line">configureProfiles(environment, args);</span><br></pre></td></tr></table></figure><p>然后就是banner的打印，默认打印的代码实现在SpringBootBanner里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure><p>创建应用上下文，会通过webApplicationType变量判断创建不同的上下文类型，然后准备、刷新上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br></pre></td></tr></table></figure><p>在prepareContext方法里，有logStartupInfo和logStartupProfileInfo打印启动的日志，加载profile的日志。</p><p>refreshContext就调用了ApplicationContext的refresh方法，对上下文里的东西做了很多初始化。</p><p>最后，stopWatch.stop();记录了应用启动的耗时，并进行日志打印，到此，SpringBoot应用启动流程完成。</p><p>callRunners触发调用我们自定义的ApplicationRunner和CommandLineRunner，等于是应用启动完成之后的回调。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringApplication&quot;&gt;&lt;a href=&quot;#SpringApplication&quot; class=&quot;headerlink&quot; title=&quot;SpringApplication&quot;&gt;&lt;/a&gt;SpringApplication&lt;/h1&gt;&lt;p&gt;Class that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create an appropriate ApplicationContext instance (depending on your classpath)&lt;/li&gt;
&lt;li&gt;Register a CommandLinePropertySource to expose command line arguments as Spring properties&lt;/li&gt;
&lt;li&gt;Refresh the application context, loading all singleton beans&lt;/li&gt;
&lt;li&gt;Trigger any CommandLineRunner beans&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-2-SpringBoot起步</title>
    <link href="http://www.saily.top/2019/04/12/springcloud/microservices-2/"/>
    <id>http://www.saily.top/2019/04/12/springcloud/microservices-2/</id>
    <published>2019-04-12T06:16:21.000Z</published>
    <updated>2019-05-24T08:37:03.739Z</updated>
    
    <content type="html"><![CDATA[<p>微服务学习笔记</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p><a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">https://spring.io/projects/spring-boot#learn</a></p><p>要创建一个Spring Boot项目，可以去<a href="https://start.spring.io/，一键创建。" target="_blank" rel="noopener">https://start.spring.io/，一键创建。</a></p><p><img src="/img/spring-cloud/sc02-1.png" alt></p><p>依赖中加入Web，然后点击<code>Generate Project</code>，就会下载一个压缩包。<br><a id="more"></a><br>解压后看看目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">spring-lecture tree</span><br><span class="line">.</span><br><span class="line">├── HELP.md</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── test</span><br><span class="line">    │   │           └── springlecture</span><br><span class="line">    │   │               └── SpringLectureApplication.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.properties</span><br><span class="line">    │       ├── static</span><br><span class="line">    │       └── templates</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── test</span><br><span class="line">                    └── springlecture</span><br><span class="line">                        └── SpringLectureApplicationTests.java</span><br><span class="line"></span><br><span class="line">16 directories, 10 files</span><br></pre></td></tr></table></figure><p>在build.gradle中包含了依赖的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.1.4.RELEASE'</span></span><br><span class="line">id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.test'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'1.8'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到引入了spring-boot-starter-web的依赖，因为<code>io.spring.dependency-management</code>插件的关系，所以在配置文件里不需要写版本号，就像maven里的dependencyManagement一样。</p><p>源码地址：</p><p><a href="https://github.com/sail-y/spring-cloud-lecture" target="_blank" rel="noopener">https://github.com/sail-y/spring-cloud-lecture</a></p><p>执行命令<code>gradle bootRun</code>，就能启动，访问 <a href="http://127.0.0.1:9090/api/test" target="_blank" rel="noopener">http://127.0.0.1:9090/api/test</a></p><p>返回</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: 18,</span><br><span class="line">  name: "zhangsan",</span><br><span class="line">  birthday: "2019-04-10T12:15:53.666+0000"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎所有的配置都可以在<code>application.properties</code>文件里完成，这里用<code>server.port</code>配置了一个端口号，Spring Boot也支持yml格式的配置文件。这也是我自己在项目中一直使用的格式。</p><h2 id="bootJar"><a href="#bootJar" class="headerlink" title="bootJar"></a>bootJar</h2><p>执行<code>gradle task</code>，可以看到Spring Boot插件为我们提供了几个任务，其中一个是bootRun，可以直接启动应用。bootJar，可以把应用打包成一个<strong>fat jar</strong>。用<code>java -jar spring-lecture-0.0.1-SNAPSHOT.jar</code>就可以启动应用，这跟普通的jar包不一样。</p><p>现在解压这个jar包来看看里面的内容，跟传统的jar或者war包不一样，解压后并没有看到我们自己的代码编译后的文件在哪里，在根目录下的org里的class文件却并不是我们自己写的，下面分析一下解压后的目录结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf spring-lecture-<span class="number">0.0</span>.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> libs (master✔)ls</span><br><span class="line">BOOT-INF  META-INF  org </span><br><span class="line">➜  libs (master✔)tree BOOT-INF -d</span><br><span class="line">BOOT-INF</span><br><span class="line">├── classes</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── <span class="built_in">test</span></span><br><span class="line">│   │       └── springlecture</span><br><span class="line">│   │           ├── controller</span><br><span class="line">│   │           └── domain</span><br><span class="line">│   ├── static</span><br><span class="line">│   └── templates</span><br><span class="line">└── lib</span><br><span class="line"></span><br><span class="line">9 directories</span><br></pre></td></tr></table></figure><p><code>BOOT-INF</code>里包含了我们自己项目里编译后的配置文件和class文件，以及<code>lib</code>里包含的项目依赖的三方jar。</p><p>接下来看META-INF</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  libs (master✔)cat META-INF/MANIFEST.MF </span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Start-Class: com.test.springlecture.SpringLectureApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Spring-Boot-Version: <span class="number">2.1</span>.4.RELEASE</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>Main-Class是打包的jar包含main方法的启动类，Start-Class是Spring Boot自定义的属性。</p><p><strong>注意Main-Class最后有一个回车换行，这个是必须的，不然无法使用。</strong></p><p>接下来看另外一个文件夹<code>org</code>，这里面的类是Spring Boot打包插件在打jar包的时候自动放进去的，Spring Boot这些类功能很巧妙的解决了fat jar是如何打包出来的，以及BOOT-INF下面的类和jar包是如何被加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">org</span><br><span class="line">└── springframework</span><br><span class="line">    └── boot</span><br><span class="line">        └── loader</span><br><span class="line">            ├── ExecutableArchiveLauncher.class</span><br><span class="line">            ├── JarLauncher.class</span><br><span class="line">            ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">            ├── LaunchedURLClassLoader.class</span><br><span class="line">            ├── Launcher.class</span><br><span class="line">            ├── MainMethodRunner.class</span><br><span class="line">            ├── PropertiesLauncher$<span class="number">1</span>.class</span><br><span class="line">            ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">            ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">            ├── PropertiesLauncher.class</span><br><span class="line">            ├── WarLauncher.class</span><br><span class="line">            ├── archive</span><br><span class="line">            ├── data</span><br><span class="line">            ├── jar</span><br><span class="line">            └── util</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> directories, <span class="number">50</span> files</span><br></pre></td></tr></table></figure><p>这都是SpringBoot提供的类，发现没有？org.springframework.boot.loader.JarLauncher就在这里。这样的文件结构，和这些类都是什么意思呢？</p><p>如果我们要查看org.springframework.boot.loader.JarLauncher的源码，需要引入以下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.springframework.boot:spring-boot-loader&apos;</span><br></pre></td></tr></table></figure><p>这是插件的一个依赖，在实际开发中，我们并不需要引入这个依赖，现在我们可以查看这个类的源码。</p><p><img src="/img/spring-cloud/sc02-2.png" alt></p><p>javadoc解释了，Launcher假设依赖包在/BOOT-INF/lib文件夹中，应用的class文件在/BOOT-INF/classes中。</p><p><code>ExecutableArchiveLauncher</code>的子类除了<code>JarLauncher</code>，还有一个<code>WarLauncher</code>。从名字就能看出来，是分别用于启动Jar包和War包的启动类。</p><p>main方法：</p><p><code>new JarLauncher().launch(args);</code></p><p>launch方法doc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application. This method is the initial entry point that should be</span></span><br><span class="line"><span class="comment"> * called by a subclass &#123;<span class="doctag">@code</span> public static void main(String[] args)&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the incoming arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the application fails to launch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JarFile.registerUrlProtocolHandler();</span><br><span class="line">ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里构建了一个类加载器。</p><blockquote><p>它会找到类当前路径所在的jar包，得到一个archive对象。因为jar包的标准是只能加载根目录下的class文件，无法加载jar包里面的jar包，所以spring boot自己实现了类加载器来加载我们应用的第三方依赖和classes文件。</p></blockquote><blockquote><p><code>JarLauncher.isNestedArchive</code>就包含了这部分的判断逻辑。处理了BOOT-INF/classes/的目录和以BOOT-INF/lib/开头的文件，此方法在getClassPathArchives内部被调用。</p></blockquote><p><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code>则是为了加载这2个目录下的class和jar包，最后代码跟踪到<code>new LaunchedURLClassLoader(urls, getClass().getClassLoader());</code>。LaunchedURLClassLoader就是Spring Boot提供的全新的类加载器了。</p><blockquote><p>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。</p></blockquote><p>再来关注<code>launch(args, getMainClass(), classLoader);</code>这行代码，getMainClass()从Manifest文件里读取了<code>Start-Class</code>，也就是我们自己的应用的启动类。</p><p>然后是<code>launch</code>方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br></pre></td></tr></table></figure><p>把SpringBoot提供的类加载器，设置成线程上下文类加载器。</p><p>createMainMethodRunner创建main方法的执行器。这里有关键代码，我们的启动类是如何被加载和启动的。</p><p>MainMethodRunner.run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(<span class="string">"main"</span>, String[].class);</span><br><span class="line">mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得之前设置的类加载器，进行类加载，然后用反射的方式调用main方法。</p><p><code>mainMethod.invoke(null, new Object[] { this.args });</code>这行代码反射，前面是null，是因为main方法是静态的，所以不需要传对象进去。</p><p>以上就解释了jar包里的文件夹结构，以及加载启动类的流程。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>增加一行代码打印SpringLectureApplication这个类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringLectureApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(SpringLectureApplication.class.getClassLoader());</span><br><span class="line">SpringApplication.run(SpringLectureApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试想一下，用java -jar启动，和在IDE里右键启动，打印出来的内容会是一样的吗？</p><p>右键启动输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@58644d46</span><br></pre></td></tr></table></figure><p>jar包启动输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader@17a7cec2</span><br></pre></td></tr></table></figure><h2 id="JDWP远程调试"><a href="#JDWP远程调试" class="headerlink" title="JDWP远程调试"></a>JDWP远程调试</h2><p>Java Debug Wire Protocol，Java调试协议</p><p>我们可以用远程的方式去调试一个正在运行的应用，比如打断点什么的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ java -agentlib:jdwp=<span class="built_in">help</span></span><br><span class="line">               Java Debugger JDWP Agent Library</span><br><span class="line">               --------------------------------</span><br><span class="line"></span><br><span class="line">  (see http://java.sun.com/products/jpda <span class="keyword">for</span> more information)</span><br><span class="line"></span><br><span class="line">jdwp usage: java -agentlib:jdwp=[<span class="built_in">help</span>]|[&lt;option&gt;=&lt;value&gt;, ...]</span><br><span class="line">Option Name and Value            Description                       Default</span><br><span class="line">---------------------            -----------                       -------</span><br><span class="line"><span class="built_in">suspend</span>=y|n                      <span class="built_in">wait</span> on startup?                  y</span><br><span class="line">transport=&lt;name&gt;                 transport spec                    none</span><br><span class="line">address=&lt;listen/attach address&gt;  transport spec                    <span class="string">""</span></span><br><span class="line">server=y|n                       listen <span class="keyword">for</span> debugger?              n</span><br><span class="line">launch=&lt;<span class="built_in">command</span> line&gt;            run debugger on event             none</span><br><span class="line">onthrow=&lt;exception name&gt;         debug on throw                    none</span><br><span class="line">onuncaught=y|n                   debug on any uncaught?            n</span><br><span class="line">timeout=&lt;timeout value&gt;          <span class="keyword">for</span> listen/attach <span class="keyword">in</span> milliseconds n</span><br><span class="line">mutf8=y|n                        output modified utf-8             n</span><br><span class="line">quiet=y|n                        control over terminal messages    n</span><br><span class="line"></span><br><span class="line">Obsolete Options</span><br><span class="line">----------------</span><br><span class="line">strict=y|n</span><br><span class="line">stdalloc=y|n</span><br><span class="line"></span><br><span class="line">Examples</span><br><span class="line">--------</span><br><span class="line">  - Using sockets connect to a debugger at a specific address:</span><br><span class="line">    java -agentlib:jdwp=transport=dt_socket,address=localhost:8000 ...</span><br><span class="line">  - Using sockets listen <span class="keyword">for</span> a debugger to attach:</span><br><span class="line">    java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y ...</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">  - A timeout value of 0 (the default) is no timeout.</span><br><span class="line"></span><br><span class="line">Warnings</span><br><span class="line">--------</span><br><span class="line">  - The older -Xrunjdwp interface can still be used, but will be removed <span class="keyword">in</span></span><br><span class="line">    a future release, <span class="keyword">for</span> example:</span><br><span class="line">        java -Xdebug -Xrunjdwp:[<span class="built_in">help</span>]|[&lt;option&gt;=&lt;value&gt;, ...]</span><br></pre></td></tr></table></figure><p>有一些参数，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  spring-lecture (master) ✗)java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5050 -jar build/libs/spring-lectListening <span class="keyword">for</span> transport dt_socket at address: 5050</span><br></pre></td></tr></table></figure><p>调试器的服务端已经启动，等待调试器连接，现在我们去用idea的调试器去调试。</p><p>选择Remote类型，选择Attach to remote JVM，设置端口为5050，可以看到idea自动为我们生产了参数：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5050</code>。</p><p><img src="/img/spring-cloud/sc02-3.png" alt></p><p>这样的话，点击debug按钮，IDEA就能走到我们断点的地方。</p><p>这样就可以在启动的时候用debug的方式去跟踪SpringBoot启动的流程。</p><p>通过这个图就可以看到，这里是archives对象里包含的就是应用里依赖的所有第三方jar包。</p><p><img src="/img/spring-cloud/sc02-4.png" alt></p><p>在获取到jar的url以后，会创建一个LaunchedURLClassLoader，用于加载这些jar包，同时这里也指定了父加载器。</p><p><img src="/img/spring-cloud/sc02-5.png" alt><br><img src="/img/spring-cloud/sc02-6.png" alt></p><p>继续往下走，就能验证上一节说的读取Start-Class具体的类名。</p><p><img src="/img/spring-cloud/sc02-7.png" alt></p><p>在设置上下文类加载器之前，它的值是AppClassLoader</p><p><img src="/img/spring-cloud/sc02-8.png" alt></p><p>再往下，就是根据找到的MainClass创建一个MainMethodRunner，通过之前设置的线程上下文类加载获取之前设置的类加载器，来加载MainClass，然后用反射的方式执行。</p><p><img src="/img/spring-cloud/sc02-9.png" alt></p><h2 id="SpringBotApplication"><a href="#SpringBotApplication" class="headerlink" title="@SpringBotApplication"></a>@SpringBotApplication</h2><p>接下来回到源代码上，SpringLectureApplication上面的@SpringBootApplication，标识了一个SpringBoot应用，他会自动扫描这个类，以及这个类以下的子包。</p><p>如果不加这个注解，会怎么样？试试看，会得到一个错误missing ServletWebServerFactory bean，没有这个注解，SpringBoot是无法启动的，除了SpringBootApplication注解，各种注解在SpringBoot项目中扮演着很重要的角色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.</span><br></pre></td></tr></table></figure><p>现在是SpringApplication的静态方法启动的应用，实际上我们可以手动一步一步的启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(SpringLectureApplication.class.getClassLoader());</span><br><span class="line"><span class="comment">//SpringApplication.run(SpringLectureApplication.class, args);</span></span><br><span class="line"></span><br><span class="line">SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SpringLectureApplication.class);</span><br><span class="line">springApplication.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">springApplication.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对于使用者来讲，SpringBoot和传统的Spring MVC应用差别并不是很大，都是通过注解的方式来写Controller，Controller里面持有service变量，再层层调用。那么SpringBoot的便利之处就在于配置变少了，约定优于配置。</p><p>看一下<code>SpringBootApplication</code>注解的源码，相当于同时声明了3个注解@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan。@SpringBootConfiguration里面又包含了@Configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM,</span><br><span class="line">classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// instantiate, configure and return bean ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Via AnnotationConfigApplicationContext</span><br><span class="line"><span class="meta">@Configuration</span> classes are typically bootstrapped using either AnnotationConfigApplicationContext or its web-capable variant, AnnotationConfigWebApplicationContext. A simple example with the former follows:</span><br><span class="line">   AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">   <span class="comment">// use myBean ...</span></span><br></pre></td></tr></table></figure><p>@Configuration是通过AnnotationConfigApplicationContext或者AnnotationConfigWebApplicationContext启动的，通过AnnotationConfigApplicationContext将AppConfig注册到上下文中，就能从上下文获取MyBean的实例了。</p><p>JDK源码里的文档，详细介绍了@Configuration注解相关的另外内容，其中包括：</p><ul><li>@ComponentScan </li><li>@Autowired Environment env</li><li>@PropertySource</li><li>@Import</li><li>@Profile</li><li>@ImportResource</li><li>@Lazy </li><li>@RunWith</li><li>@ContextConfiguration</li><li>等等</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined</p><p>it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you’re not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched.</p><p>Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations).</p><p>自动装配，注解扫描当前包及以下的@Configuration类，所以建议放在到根目录下。自动装配的bean通常用@Conditional一类的注解修饰。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>配置扫描@Configuration组件的目录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务学习笔记&lt;/p&gt;
&lt;h1 id=&quot;Spring-Boot&quot;&gt;&lt;a href=&quot;#Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot&quot;&gt;&lt;/a&gt;Spring Boot&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-boot#learn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://spring.io/projects/spring-boot#learn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要创建一个Spring Boot项目，可以去&lt;a href=&quot;https://start.spring.io/，一键创建。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://start.spring.io/，一键创建。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/sc02-1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;依赖中加入Web，然后点击&lt;code&gt;Generate Project&lt;/code&gt;，就会下载一个压缩包。&lt;br&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务-1-什么是微服务</title>
    <link href="http://www.saily.top/2019/04/10/springcloud/microservices-1/"/>
    <id>http://www.saily.top/2019/04/10/springcloud/microservices-1/</id>
    <published>2019-04-10T10:56:58.000Z</published>
    <updated>2019-08-01T10:10:13.191Z</updated>
    
    <content type="html"><![CDATA[<p>微服务学习笔记</p><h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><p><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p><blockquote><p>“Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing. We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications. Sadly, however, there’s not much information that outlines what the microservice style is and how to do it.</p></blockquote><a id="more"></a><p>单体应用 -&gt; 微服务应用</p><p><a href="https://time.geekbang.org/column/article/13882" target="_blank" rel="noopener">从0开始学微服务-胡忠想</a></p><h2 id="单体架构存在的缺点"><a href="#单体架构存在的缺点" class="headerlink" title="单体架构存在的缺点"></a>单体架构存在的缺点</h2><ul><li>复杂性逐渐变高</li><li>技术债务逐渐上升</li><li>部署速度逐渐变慢</li><li>阻碍技术创新</li><li>无法按需伸缩</li></ul><h2 id="什么是微服务-1"><a href="#什么是微服务-1" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ul><li>Martin Fowler：简而言之，微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。<strong>其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。</strong>这些服务围绕这些功能进行构建，并能通过全自动的部署机制来进行独立部署。<strong>这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。</strong>对这些微服务我们仅做最低限度的集中管理。</li><li>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体的业务进行构建，并且能够独立地被部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</li><li>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</li></ul><h2 id="微服务是一种架构风格"><a href="#微服务是一种架构风格" class="headerlink" title="微服务是一种架构风格"></a>微服务是一种架构风格</h2><ul><li>服务组件化（Componentization via Services）</li><li>服务围绕业务（Organized around Business Capabilities）</li><li>产品开发模式（Products not Projects）</li><li>轻量级通信机制（Smart endpoints and dumb pipes）</li><li>去中心化治理（Decentralized Governance）</li><li>去中心化数据设计（Decentralized Data Management）</li><li>故障处理设计（Design for failure）</li><li>演进式设计（Evolutionary Design）</li><li>基础设施自动化（Infrastructure Automation）</li></ul><h2 id="微服务的优点和挑战"><a href="#微服务的优点和挑战" class="headerlink" title="微服务的优点和挑战"></a>微服务的优点和挑战</h2><ul><li>开发简单</li><li>技术栈灵活</li><li>服务独立</li><li>按需扩展</li></ul><hr><ul><li>运维复杂</li><li>数据一致性问题</li><li>集成测试复杂</li><li>重复代码</li><li>监控困难</li></ul><h3 id="微服务具备的特性"><a href="#微服务具备的特性" class="headerlink" title="微服务具备的特性"></a>微服务具备的特性</h3><ul><li>每个微服务可独立运行在自己的进程里</li><li>一系列独立运行的微服务共同构建起了整个系统</li><li>每个服务为独立的业务开发，一个微服务一般完成某个特定的功能，比如：订单管理，用户管理等</li><li>微服务之间通过一些轻量的通信机制进行通信，例如通过REST API或者RPC的方式进行调用</li></ul><h3 id="微服务的优点"><a href="#微服务的优点" class="headerlink" title="微服务的优点"></a>微服务的优点</h3><ul><li>易于开发和维护</li><li>启动较快</li><li>局部修改容易部署</li><li>技术栈不受限</li><li>按需伸缩</li><li>DevOps</li></ul><h3 id="微服务带来的挑战"><a href="#微服务带来的挑战" class="headerlink" title="微服务带来的挑战"></a>微服务带来的挑战</h3><ul><li>运维要求较高</li><li>分布式的复杂性</li><li>接口调整成本高</li><li>重复劳动</li></ul><h3 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h3><ul><li>单一职责原则</li><li>服务自治原则</li><li>轻量级通信原则</li><li>接口明确原则</li></ul><h1 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h1><p>很多人会把SOA和微服务搞混，甚至理解为同一个东西。实际上SOA已经面世20多年了，和微服务是不一样的，接下来去维基百科看看SOA到底是什么。</p><p><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Service-oriented_architecture</a></p><p>学技术，一定要去阅读原版的英文资料。</p><blockquote><p><strong>Service-oriented architecture (SOA)</strong> is a style of software design where services are provided to the other components by application components, through a communication protocol over a network. The basic principles of service-oriented architecture are independent of vendors, products and technologies.[1] A service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card statement online.</p></blockquote><blockquote><p>A service has four properties according to one of many definitions of SOA:[2]</p></blockquote><blockquote><ol><li>It logically represents a business activity with a specified outcome.        </li><li>It is self-contained.        </li><li>It is a black box for its consumers.</li><li>It may consist of other underlying services.[3]</li></ol><p>Different services can be used in conjunction to provide the functionality of a large software application,[5] a principle SOA shares with modular programming. Service-oriented architecture integrates distributed, separately-maintained and -deployed software components. It is enabled by technologies and standards that facilitate components’ communication and cooperation over a network, especially over an IP network.</p></blockquote><p>SOA是一种软件设计风格，SOA包含了一些服务，服务是通过应用组件的形式，通过网络上的一些通信协议像向其他应用提供服务。不同的服务可以联合起来构成一个大型的应用，SOA遵循模块化编程，它的这种架构集成了分布式的，独自维护的，独自部署的软件组件。也是通过网络来通信的。</p><p>好像看起来SOA的和微服务的概念也没什么太大差别？</p><blockquote><p>In SOA, services use protocols that describe how they pass and parse messages using description metadata. This metadata describes both the functional characteristics of the service and quality-of-service characteristics. Service-oriented architecture aims to allow users to combine large chunks of functionality to form applications which are built purely from existing services and combining them in an ad hoc manner. A service presents a simple interface to the requester that abstracts away the underlying complexity acting as a black box. Further users can also access these independent services without any knowledge of their internal implementation.[6]</p></blockquote><p>在SOA里，服务是用元数据描述的服务的功能特性和质量特性。有没有想起wsdl实现的webservice？</p><p>SOA里有3个角色</p><ul><li>Service provider</li><li>Service broker, service registry or service repository</li><li>Service requester/consumer</li></ul><p>SOA可以借助webservice实现，通过标准的internet协议，通过网络来访问这些功能。比如SOAP，Jini，CORBA，Rest</p><p>有很多技术都可以实现SOA，比如</p><ul><li>Web services based on WSDL and SOAP</li><li>Messaging, e.g., with ActiveMQ, JMS, RabbitMQ</li><li>RESTful HTTP, with Representational state transfer (REST) constituting its own constraints-based architectural style</li><li>OPC-UA</li><li>WCF (Microsoft’s implementation of Web services, forming a part of WCF)</li><li>Apache Thrift</li><li>SORCER</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>SOA已经被Web Service合并了，然而Web Service只是实现SOA的一种方式。在缺乏本地或二进制的数据传递调用的情况下，远程调用和效率都会变慢。XML是比较慢的，JSON相比XML会好一些。</p><p>有状态的服务不利于管理。</p><p>SOA主要的挑战是元数据的管理，服务于服务之间的通信会生成大量的消息。</p><p>难以测试。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务是现代化的SOA架构，用于构建分布式的软件系统。在微服务架构中的服务都是一些进程，它们之间是通过网络来进行通信去完成一个目标。这些服务使用技术不可知的协议，在服务内部去封装语言和框架。微服务是一种SOA的一种新的实现方式，从2014年开始变得流行起来（在引入DevOps后）。它强调的是持续的部署和其他敏捷的实现。</p><p>微服务没有统一的定义，但是有以下特征和原则</p><ul><li>fine-grained interfaces (to independently deployable services),</li><li>business-driven development (e.g. domain-driven design),</li><li>IDEAL cloud application architectures,</li><li>polyglot programming and persistence,</li><li>lightweight container deployment,</li><li>decentralized continuous delivery, and</li><li>DevOps with holistic service monitoring.</li></ul><h1 id="SOA和微服务的差异性"><a href="#SOA和微服务的差异性" class="headerlink" title="SOA和微服务的差异性"></a>SOA和微服务的差异性</h1><h2 id="文章1"><a href="#文章1" class="headerlink" title="文章1"></a>文章1</h2><p><a href="https://www.ibm.com/blogs/cloud-computing/2018/09/06/soa-versus-microservices/" target="_blank" rel="noopener">https://www.ibm.com/blogs/cloud-computing/2018/09/06/soa-versus-microservices/</a></p><blockquote><p>The main distinction comes down to scope. To put it simply, service-oriented architecture (SOA) has an enterprise scope, while the microservices architecture has an application scope.</p></blockquote><p>SOA着重点在企业范围，微服务着重点在应用范围。</p><p><img src="https://www.ibm.com/blogs/cloud-computing/wp-content/uploads/2018/08/SOA_microservices.png" alt></p><p>从这个图可以看出来，SOA的范围更大，他关注的是应用与应用之间的关系。而微服务是应用内部的关联。</p><h2 id="文章2"><a href="#文章2" class="headerlink" title="文章2"></a>文章2</h2><p><a href="https://dzone.com/articles/microservices-vs-soa-is-there-any-difference-at-al" target="_blank" rel="noopener">https://dzone.com/articles/microservices-vs-soa-is-there-any-difference-at-al</a></p><blockquote><p>Service Oriented Architecture is less about how to modularize an application, and more about how to compose an application by integration of distributed, separately-maintained and deployed software components. It is enabled by technologies and standards that make it easier for components to communicate and cooperate over a network, especially an IP network.</p></blockquote><p><img src="/img/spring-cloud/sc01-1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务学习笔记&lt;/p&gt;
&lt;h1 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务&quot;&gt;&lt;/a&gt;什么是微服务&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://martinfowler.com/articles/microservices.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing. We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications. Sadly, however, there’s not much information that outlines what the microservice style is and how to do it.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.saily.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring Cloud" scheme="http://www.saily.top/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud基于用户和ip的灰度发布方案</title>
    <link href="http://www.saily.top/2019/02/28/springcloud/spring-cloud-nepxion-gray/"/>
    <id>http://www.saily.top/2019/02/28/springcloud/spring-cloud-nepxion-gray/</id>
    <published>2019-02-28T03:32:01.000Z</published>
    <updated>2019-02-28T03:52:48.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于用户和ip的灰度发布方案"><a href="#基于用户和ip的灰度发布方案" class="headerlink" title="基于用户和ip的灰度发布方案"></a>基于用户和ip的灰度发布方案</h1><p>为了能够更好的解决系统新版本上线无法验证的风险，我们通常需要在升级的时候进行灰度发布，下面调研了一个上线灰度发布的流程。</p><p>下面先看一张图，然后再用一段文字描述整个发布的逻辑。</p><p><img src="/img/spring-cloud/灰度流量V2.jpg" alt></p><a id="more"></a><p>在正常情况下，用户的流量是可以随意打到A，A1，A2服务上的，A到B的流量，也是可以随意打的。<br>当灰度发布的开关打开以后，如图上所示，例如A3,B2,C4的链路为灰度路由的配置。此时将切断正常用户对A3,B2,C4的服务实例的访问，并且正常流量到A1以后，也不会再打到B2上。<br>当指定的测试账号访问系统的时候，所有的测试流量都会打到A3,B2,C4的链路服务实例上，第一步流量到A3以后，也不会将A调用B的流量打到B1的服务实例上。<br>当测试将这一组验证完毕后，即可将对配置进行修改，进而发布下一组。<br>当所有的实例都发布完成后，再将灰度发布开关关闭，此时，发布完成。<br>所有的这些操作，都可以在Apollo配置中心一键完成。</p><p>链路配置格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sevice-demo-a"</span>: <span class="string">"172.16.101.90:5000"</span>,</span><br><span class="line">    <span class="attr">"sevice-demo-b"</span>: <span class="string">"172.16.101.90:5020"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>本方案基于Nepxion Discovery开发</p><blockquote><p>Nepxion Discovery is an enhancement for Spring Cloud Discovery on Eureka + Consul + Zookeeper + Nacos with Nacos + Apollo config for gray release, router and isolation 灰度发布、服务隔离、服务路由、服务权重、黑/白名单过滤 <a href="http://www.nepxion.com" target="_blank" rel="noopener">http://www.nepxion.com</a></p></blockquote><p>要了解灰度发布的原理，首先需要知道SpringCloud是基于Ribbon实现负载均衡算法的，以及是如何从注册中心拉取的服务列表。</p><p>灰度路由除了可以根据请求头来路由请求，也可以跟服务实例本身的版本号来决定路由。下面给出一个逻辑图，以及两个个源码解析的UML图。</p><p><img src="/img/spring-cloud/版本和IP路由逻辑.jpg" alt="版本和IP路由逻辑"></p><p><img src="/img/spring-cloud/版本号过滤服务列表逻辑.jpg" alt="版本号过滤服务列表逻辑"></p><p><img src="/img/spring-cloud/根据请求头执行负载均衡规则（权重逻辑）.jpg" alt="根据请求头执行负载均衡规则（权重逻辑）"></p><p>nepxion本来就提供了良好的服务过滤扩展，所以我的代码就是核心的一个过滤策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本策略实现了当灰度开关开启，对服务实例的ip进行过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/01/02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrayIpDiscoveryEnabledStrategy</span> <span class="keyword">implements</span> <span class="title">DiscoveryEnabledStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IS_GRAY_USER = <span class="string">"isGrayUser"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_IP = <span class="string">"serviceIp"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GRAY_SWITCH = <span class="string">"graySwitch"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceStrategyContextHolder serviceStrategyContextHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; serviceIpMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> graySwitch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.plugin.namespace&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namespace;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = ConfigService.getConfig(namespace);</span><br><span class="line">        serviceIpMap = toMap(config.getProperty(SERVICE_IP, <span class="string">"&#123;&#125;"</span>));</span><br><span class="line">        graySwitch = config.getBooleanProperty(SWITCH, Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">        config.addChangeListener(changeEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ip配置发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (changeEvent.isChanged(SERVICE_IP)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String newValue = changeEvent.getChange(SERVICE_IP).getNewValue();</span><br><span class="line">                <span class="keyword">final</span> String oldValue = changeEvent.getChange(SERVICE_IP).getOldValue();</span><br><span class="line">                log.info(<span class="string">"service ip map changed, oldValue is &#123;&#125;, newValue is &#123;&#125;"</span>, () -&gt; oldValue, () -&gt; newValue);</span><br><span class="line">                serviceIpMap = toMap(newValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开关发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (changeEvent.isChanged(GRAY_SWITCH)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String newValue = changeEvent.getChange(GRAY_SWITCH).getNewValue();</span><br><span class="line">                <span class="keyword">final</span> String oldValue = changeEvent.getChange(GRAY_SWITCH).getOldValue();</span><br><span class="line">                log.info(<span class="string">"graySwitch changed, oldValue is &#123;&#125;, newValue is &#123;&#125;"</span>, () -&gt; oldValue, () -&gt; newValue);</span><br><span class="line">                graySwitch = Boolean.valueOf(changeEvent.getChange(GRAY_SWITCH).getNewValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, Sets.newHashSet(SERVICE_IP, GRAY_SWITCH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Server server, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ip过滤</span></span><br><span class="line">        <span class="keyword">boolean</span> enabled = applyIpFilter(server, metadata);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当灰度开关打开后，正在灰度的region不能被正常流量访问到</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyIpFilter</span><span class="params">(Server server, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!graySwitch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String appName = server.getMetaInfo().getAppName();</span><br><span class="line">        String ip = server.getHostPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ip匹配，灰度请求，灰度实例可访问</span></span><br><span class="line">        <span class="keyword">final</span> String ipHost = serviceIpMap.get(appName);</span><br><span class="line">        <span class="keyword">if</span> (ipHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> ipMatch = ip.equals(ipHost);</span><br><span class="line"></span><br><span class="line">            ServletRequestAttributes restAttributes = serviceStrategyContextHolder.getRestAttributes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非http请求</span></span><br><span class="line">            <span class="keyword">if</span> (restAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                log.info(<span class="string">"The ServletRequestAttributes object is null, ignore to do gray ip filter for service=&#123;&#125;"</span>, appName);</span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String isGrayUser = restAttributes.getRequest().getHeader(IS_GRAY_USER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无法识别是否是灰度用户</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(isGrayUser)) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                log.info(<span class="string">"The isGrayUser header is null, ignore to do gray ip filter for service=&#123;&#125;"</span>, appName);</span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 灰度用户</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.valueOf(isGrayUser)) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，通过访问</span></span><br><span class="line">                <span class="keyword">if</span> (ipMatch) &#123;</span><br><span class="line">                    log.info(<span class="string">"found gray user request, service &#123;&#125; route to ip &#123;&#125;"</span>, appName, ipHost);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ipMatch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非灰度用户</span></span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">toMap</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = getParametricTypeJavaType(String.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(str, javaType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JavaType <span class="title">getParametricTypeJavaType</span><span class="params">(Class... clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.getTypeFactory().constructParametricType(HashMap.class, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nepxion discovery框架的作者是个很用心的作者，我在开发的时候也遇到了一些问题，作者都耐心的和我一起分析，一一帮我解决了，推荐大家去Star，去学习。</p><p><a href="https://github.com/Nepxion/Discovery" target="_blank" rel="noopener">https://github.com/Nepxion/Discovery</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基于用户和ip的灰度发布方案&quot;&gt;&lt;a href=&quot;#基于用户和ip的灰度发布方案&quot; class=&quot;headerlink&quot; title=&quot;基于用户和ip的灰度发布方案&quot;&gt;&lt;/a&gt;基于用户和ip的灰度发布方案&lt;/h1&gt;&lt;p&gt;为了能够更好的解决系统新版本上线无法验证的风险，我们通常需要在升级的时候进行灰度发布，下面调研了一个上线灰度发布的流程。&lt;/p&gt;
&lt;p&gt;下面先看一张图，然后再用一段文字描述整个发布的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/spring-cloud/灰度流量V2.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring boot/cloud" scheme="http://www.saily.top/categories/spring-boot-cloud/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="灰度发布" scheme="http://www.saily.top/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Security OAuth2 定制错误消息</title>
    <link href="http://www.saily.top/2019/01/09/java/spring-security-oauth2-custom-exception-response/"/>
    <id>http://www.saily.top/2019/01/09/java/spring-security-oauth2-custom-exception-response/</id>
    <published>2019-01-09T12:32:49.000Z</published>
    <updated>2019-01-12T15:46:31.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在搭建一个Spring Cloud的项目，在搭建途中，遇到了一些问题，这里记录一下。<br>在搭建AuthorizationServer的时候，就遇到了问题，我的授权模式是用的password模式，然后是集成了JWT生成access_token。</p><p>基本上我是参照这个项目搭建的，<a href="https://gitee.com/log4j/pig" target="_blank" rel="noopener">https://gitee.com/log4j/pig</a> 。不过因为只是参考，所以我还做了一些改动，而且我们Spring Cloud的版本也不一样，我是F版的。</p><a id="more"></a><h2 id="问题1-oauth-token-401问题"><a href="#问题1-oauth-token-401问题" class="headerlink" title="问题1 /oauth/token 401问题"></a>问题1 /oauth/token 401问题</h2><p>在AuthorizationServer搭建完成以后，启动访问/oauth/token接口获取access_token。传入用户名和密码，然后一直得到一个401错误，日志也没有，我最开始还以为是Spring Security把这个接口给拦截了，后来DEBUG了一下源码，发现在BasicAuthenticationFilter.doFilterInternal()里有这么一句判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String header = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (header == <span class="keyword">null</span> || !header.toLowerCase().startsWith(<span class="string">"basic "</span>)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是如果你的header里面没有Authorization(BasicAuthenticationFilter.doFilterInternal)，或者Authorization不是以basic 开头的，直接就返回401了。虽然我忘记了传这个参数，但是日志里没有任何提示，这个错误真是让我好一顿找才给解决。</p><p>这里面是<code>client_id:client_secret</code>的base64编码。到这还没完，因为Spring Cloud F版会有那个PasswordEncoder，所以他在校验secret的时候会和服务器配置的时候会进行加密，如果存储的密钥不是相应的加密方式，他也会报错，这个错误在网上都搜得到了。</p><p><a href="http://springcloud.cn/view/13" target="_blank" rel="noopener">Spring Security 4.x -&gt; 5.x 踩坑记录</a></p><p>DaoAuthenticationProvider.additionalAuthenticationChecks()方法里，就是检查密码的地方。</p><h2 id="问题2-Unsupported-grant-type-password"><a href="#问题2-Unsupported-grant-type-password" class="headerlink" title="问题2 Unsupported grant type: password"></a>问题2 Unsupported grant type: password</h2><p>接着我又开始遇到这个错误，搜了一下说是AuthenticationManager无法注入。</p><p>在AuthorizationServerEndpointsConfigurer.getDefaultTokenGranters里面，如果AuthenticationManager类的实例的话，那么就不支持password的授权模式，也就是ResourceOwnerPasswordTokenGranter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TokenGranter&gt; <span class="title">getDefaultTokenGranters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ClientDetailsService clientDetails = clientDetailsService();</span><br><span class="line">AuthorizationServerTokenServices tokenServices = tokenServices();</span><br><span class="line">AuthorizationCodeServices authorizationCodeServices = authorizationCodeServices();</span><br><span class="line">OAuth2RequestFactory requestFactory = requestFactory();</span><br><span class="line"></span><br><span class="line">List&lt;TokenGranter&gt; tokenGranters = <span class="keyword">new</span> ArrayList&lt;TokenGranter&gt;();</span><br><span class="line">tokenGranters.add(<span class="keyword">new</span> AuthorizationCodeTokenGranter(tokenServices, authorizationCodeServices, clientDetails,</span><br><span class="line">requestFactory));</span><br><span class="line">tokenGranters.add(<span class="keyword">new</span> RefreshTokenGranter(tokenServices, clientDetails, requestFactory));</span><br><span class="line">ImplicitTokenGranter implicit = <span class="keyword">new</span> ImplicitTokenGranter(tokenServices, clientDetails, requestFactory);</span><br><span class="line">tokenGranters.add(implicit);</span><br><span class="line">tokenGranters.add(<span class="keyword">new</span> ClientCredentialsTokenGranter(tokenServices, clientDetails, requestFactory));</span><br><span class="line"><span class="keyword">if</span> (authenticationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">tokenGranters.add(<span class="keyword">new</span> ResourceOwnerPasswordTokenGranter(authenticationManager, tokenServices,</span><br><span class="line">clientDetails, requestFactory));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tokenGranters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://springcloud.cn/view/13" target="_blank" rel="noopener">Spring Security 4.x -&gt; 5.x 踩坑记录</a>的也提到了这个问题，不过我这里遇到了更奇怪的现象，在WebSecurityConfigurerAdapter加上下面的配置后，并没有解决我的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果我发现在我的项目中，AuthorizationServerConfig竟然比WebSecurityConfigurer先加载，所以在<code>public void configure(AuthorizationServerEndpointsConfigurer endpoints)</code>注入并设置endpoints.authenticationManager(authenticationManager)的时候，放的是一个null进去。</p><p>我还觉得蛮奇怪的，下面的代码也会注入一个null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br></pre></td></tr></table></figure><p>然后我把这个参数改到构造方法里面去启动，结果就告诉我循环依赖，后来想了想，可能是因为Spring在处理循环依赖的时候，把一些注入类自动处理成null了。</p><p>在我解决了循环依赖以后，我就能登录成功了。</p><h2 id="问题3-如何定制BadCredentialsException-UserNameNotFound的异常消息"><a href="#问题3-如何定制BadCredentialsException-UserNameNotFound的异常消息" class="headerlink" title="问题3 如何定制BadCredentialsException,UserNameNotFound的异常消息"></a>问题3 如何定制BadCredentialsException,UserNameNotFound的异常消息</h2><p>接下来就是输入错误密码的时候得到的错误了，如果用户名或者密码错误了，Spring Security会返回一个</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"error"</span>: <span class="string">"invalid_grant"</span>,</span><br><span class="line"><span class="attr">"error_ description"</span>: <span class="string">"坏的凭证"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个错误信息太不友好了，我们一般给客户端返回的消息都是统一标准的格式，比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"code"</span>:<span class="string">"401"</span>,</span><br><span class="line"><span class="attr">"msg"</span>:<span class="string">"用户名或密码错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样另类的消息格式是绝对不允许的。所以我就想定制化这个消息格式，是相信Spring Security肯定提供了相应的机制来供我们实现这个消息的定制，我先是在网上搜了很久，都没有找到解决方案，只是找到了一些哥们跟我有同样的问题，但是却没有人给出解决方案。</p><p>比如这个stackoverflow.com上的这个<a href="https://stackoverflow.com/questions/38109842/how-to-change-the-badcredentialsexception-usernamenotfound-exception-messages-in" target="_blank" rel="noopener">哥们</a>。</p><p>没办法了，找不到方案就自己想办法吧，我就从抛出异常的地方开始一行一行的debug，接着发现这个异常被TokenEndpoint类里的一个ExceptionHandler给拦截然后输出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(OAuth2Exception.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;OAuth2Exception&gt; <span class="title">handleException</span><span class="params">(OAuth2Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Handling error: "</span> + e.getClass().getSimpleName() + <span class="string">", "</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getExceptionTranslator().translate(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个getExceptionTranslator到底是个什么东西，最后翻了一下到底是在哪里设置的这个属性，最终发现是AuthorizationServerEndpointsConfigurer的一个字段，是不是很眼熟？</p><p>和设置AuthenticationManager的是同一个类，所以定制一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebResponseExceptionTranslator</span> <span class="keyword">implements</span> <span class="title">WebResponseExceptionTranslator</span>&lt;<span class="title">OAuth2Exception</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(RestResp.error(CommonErrorCode.AUTHORIZED_ERROR), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在AuthorizationServerConfig里加上配置，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    endpoints</span><br><span class="line">            <span class="comment">//......其他配置</span></span><br><span class="line">            .exceptionTranslator(customWebResponseExceptionTranslator)</span><br><span class="line">            .authenticationManager(authenticationManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到了我们想要的输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"401"</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"用户名或密码错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题4-invalid-token-错误消息定制"><a href="#问题4-invalid-token-错误消息定制" class="headerlink" title="问题4 invalid_token 错误消息定制"></a>问题4 invalid_token 错误消息定制</h2><p>如果传入的token是错误的，那么会得到这样格式的一个错误消息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"invalid_token"</span>,</span><br><span class="line">  <span class="attr">"error_description"</span>: <span class="string">"Cannot convert access token to JSON"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上有可能是这个token在redis里没有等好几种错误</p><p>DefaultTokenServices.loadAuthentication(String accessTokenValue)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">"Invalid access token: "</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (accessToken.isExpired()) &#123;</span><br><span class="line">tokenStore.removeAccessToken(accessToken);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">"Access token expired: "</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OAuth2Authentication result = tokenStore.readAuthentication(accessToken);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// in case of race condition</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">"Invalid access token: "</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要定制化这个错误消息，需要制定一个AuthExceptionEntryPoint.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthExceptionEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Token失效，禁止访问 &#123;&#125;"</span>, request.getRequestURI());</span><br><span class="line">        response.setCharacterEncoding(StandardCharsets.UTF_8.displayName());</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">        RestResp result = RestResp.error(CommonErrorCode.UNAUTHORIZED, <span class="string">"Token错误"</span>);</span><br><span class="line">        response.setStatus(HttpStatus.SC_OK);</span><br><span class="line">        PrintWriter printWriter = response.getWriter();</span><br><span class="line">        printWriter.append(objectMapper.writeValueAsString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后ResourceServerConfiguration里增加配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;</span><br><span class="line">    resources.expressionHandler(expressionHandler);</span><br><span class="line">    resources.authenticationEntryPoint(authExceptionEntryPoint);</span><br><span class="line">    resources.accessDeniedHandler(iuMiaoAccessDeniedHandler);</span><br><span class="line">    resources.tokenStore(redisTokenStore());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能得到自定义的错误。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"10000401"</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"未授权: Token错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在搭建一个Spring Cloud的项目，在搭建途中，遇到了一些问题，这里记录一下。&lt;br&gt;在搭建AuthorizationServer的时候，就遇到了问题，我的授权模式是用的password模式，然后是集成了JWT生成access_token。&lt;/p&gt;
&lt;p&gt;基本上我是参照这个项目搭建的，&lt;a href=&quot;https://gitee.com/log4j/pig&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/log4j/pig&lt;/a&gt; 。不过因为只是参考，所以我还做了一些改动，而且我们Spring Cloud的版本也不一样，我是F版的。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.saily.top/categories/spring/"/>
    
    
      <category term="spring security" scheme="http://www.saily.top/tags/spring-security/"/>
    
  </entry>
  
</feed>
