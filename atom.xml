<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的博客</title>
  <icon>https://www.gravatar.com/avatar/5e6c22ad69915102664d6eb06cca090f</icon>
  <subtitle>扬帆起航</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.saily.top/"/>
  <updated>2018-09-19T05:15:04.128Z</updated>
  <id>http://www.saily.top/</id>
  
  <author>
    <name>帆</name>
    <email>hyyangfan@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ElasticSearch05-搜索详解</title>
    <link href="http://www.saily.top/2018/09/19/elasticSearch05/"/>
    <id>http://www.saily.top/2018/09/19/elasticSearch05/</id>
    <published>2018-09-19T03:36:54.000Z</published>
    <updated>2018-09-19T05:15:04.128Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><p>前面讲了Document的增删改查和集群原理，接下来就是ES的重头戏了，搜索。</p><h1 id="search结果解析"><a href="#search结果解析" class="headerlink" title="_search结果解析"></a>_search结果解析</h1><p>当发出一个搜索请求的时候，会拿到很多结果，下面说一下搜索结果里的各种数据，都代表了什么含义。<br><a id="more"></a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">GET _search</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">".kibana"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"config"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"5.2.0"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"buildNum"</span>: <span class="number">14695</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"8"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"10"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"test_field1"</span>: <span class="string">"test1"</span>,</span><br><span class="line">          <span class="attr">"test_field2"</span>: <span class="string">"updated test2"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"jiajieshi yagao"</span>,</span><br><span class="line">          <span class="attr">"desc"</span>: <span class="string">"youxiao fangzhu"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">25</span>,</span><br><span class="line">          <span class="attr">"producer"</span>: <span class="string">"jiajieshi producer"</span>,</span><br><span class="line">          <span class="attr">"tags"</span>: [</span><br><span class="line">            <span class="string">"fangzhu"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"gaolujie yagao"</span>,</span><br><span class="line">          <span class="attr">"desc"</span>: <span class="string">"gaoxiao meibai"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">30</span>,</span><br><span class="line">          <span class="attr">"producer"</span>: <span class="string">"gaolujie producer"</span>,</span><br><span class="line">          <span class="attr">"tags"</span>: [</span><br><span class="line">            <span class="string">"meibai"</span>,</span><br><span class="line">            <span class="string">"fangzhu"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"7"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"test_index1"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"test"</span>: <span class="string">"hello es"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">        <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">        <span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"zhonghua yagao"</span>,</span><br><span class="line">          <span class="attr">"desc"</span>: <span class="string">"caoben zhiwu"</span>,</span><br><span class="line">          <span class="attr">"price"</span>: <span class="number">40</span>,</span><br><span class="line">          <span class="attr">"producer"</span>: <span class="string">"zhonghua producer"</span>,</span><br><span class="line">          <span class="attr">"tags"</span>: [</span><br><span class="line">            <span class="string">"qingxin"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>took</code>：整个搜索请求花费了多少毫秒</li><li><code>hits.total</code>：本次搜索，返回了几条结果</li><li><code>hits.max_score</code>：本次搜索的所有结果中，最大的相关度分数是多少，每一条document对于search的相关度，越相关，<code>_score</code>分数越大，排位越靠前</li><li><code>hits.hits</code>：默认查询前10条数据，包含完整数据，<code>_score</code>降序排序</li><li><code>shards</code>：shards fail的条件（primary和replica全部挂掉），不影响其他shard。默认情况下来说，一个搜索请求，会打到一个index的所有primary shard上去，当然了，每个primary shard都可能会有一个或多个replic shard，所以请求也可以到primary shard的其中一个replica shard上去。</li><li><p><code>timeout</code>：默认没有所谓的timeout，如果搜索特别慢每个shard都要好几分钟，那么搜索请求会一直等待结果返回。ES提供了timeout机制，指定每个shard在设置的timeout时间内马上已经搜索到的数据（可能是部分，也可能是全部），直接返回给client程序，而不是等到所有的数据全部搜索出来以后再返回。确保一次请求可以在用户指定的timeout时常内完成，为一些时间敏感的搜索应用提供良好支持。</p><p>  <code>GET /_search?timeout=10m</code></p></li></ul><h1 id="multi-index和multi-type搜索模式"><a href="#multi-index和multi-type搜索模式" class="headerlink" title="multi-index和multi-type搜索模式"></a>multi-index和multi-type搜索模式</h1><p>如何一次性搜索多个index和多个type下的数据</p><ul><li><code>/_search</code>：所有索引，所有type下的所有数据都搜索出来</li><li><code>/index1/_search</code>：指定一个index，搜索其下所有type的数据</li><li><code>/index1,index2/_search</code>：同时搜索两个index下的数据</li><li><code>/*1,*2/_search</code>：按照通配符去匹配多个索引</li><li><code>/index1/type1/_search</code>：搜索一个index下指定的type的数据</li><li><code>/index1/type1,type2/_search</code>：可以搜索一个index下多个type的数据</li><li><code>/index1,index2/type1,type2/_search</code>：搜索多个index下的多个type的数据</li><li><code>/_all/type1,type2/_search</code>：_all，可以代表搜索所有index下的指定type的数据</li></ul><h2 id="搜索基本原理"><a href="#搜索基本原理" class="headerlink" title="搜索基本原理"></a>搜索基本原理</h2><p>客户端发送一个搜索请求，会把请求分配到所有的primary shard上去执行，因为每个shard都包含部分数据，所以每个shard上都可能会包含搜索请求的结果。但是如果primary shard有replica shard，那么请求也可以分配到replica shard上去执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;p&gt;前面讲了Document的增删改查和集群原理，接下来就是ES的重头戏了，搜索。&lt;/p&gt;
&lt;h1 id=&quot;search结果解析&quot;&gt;&lt;a href=&quot;#search结果解析&quot; class=&quot;headerlink&quot; title=&quot;_search结果解析&quot;&gt;&lt;/a&gt;_search结果解析&lt;/h1&gt;&lt;p&gt;当发出一个搜索请求的时候，会拿到很多结果，下面说一下搜索结果里的各种数据，都代表了什么含义。&lt;br&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.saily.top/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.saily.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch04-Document、Index详解和操作以及并发问题</title>
    <link href="http://www.saily.top/2018/08/19/elasticSearch04/"/>
    <id>http://www.saily.top/2018/08/19/elasticSearch04/</id>
    <published>2018-08-19T09:40:30.000Z</published>
    <updated>2018-09-19T03:36:04.356Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h1 id="Document元数据"><a href="#Document元数据" class="headerlink" title="Document元数据"></a>Document元数据</h1><h2 id="index元数据"><a href="#index元数据" class="headerlink" title="_index元数据"></a>_index元数据</h2><ol><li>代表一个document存放在哪个index中。</li><li>类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如company index，就不合适。<a id="more"></a></li><li>index中包含了很多类似的document：类似是什么意思，其实指的就是这些document的fields很大一部分是相同的，比如你放了3个document，每个document的fields都完全不一样，这就不是类似了，就不太适合放到一个index里面去了。</li><li>索引名称必须是小写的，不能用下划线开头，不能包含逗号，例如：product，website，blog</li></ol><h2 id="type元数据"><a href="#type元数据" class="headerlink" title="_type元数据"></a>_type元数据</h2><ol><li>代表document属于index中的哪个类别（type）</li><li>一个索引通常会划分为多个type，逻辑上对index中有些许不同的几类数据进行分类：因为一批相同的数据，可能有很多相同的fields，但是还是可能会有一些轻微的不同，可能会有少数fields是不一样的，举个例子，比如商品，可能划分为电子商品，生鲜商品，日化商品，等等。</li><li>type名称可以是大写或者小写，但是同时不能用下划线开头，不能包含逗号</li></ol><h2 id="id元数据"><a href="#id元数据" class="headerlink" title="_id元数据"></a>_id元数据</h2><ol><li>代表document的唯一标识，与index和type一起，可以唯一标识和定位一个document</li><li>我们可以手动指定document的id（put /index/type/id），也可以不指定，由es自动为我们创建一个id</li></ol><h3 id="手动指定document-id"><a href="#手动指定document-id" class="headerlink" title="手动指定document id"></a>手动指定document id</h3><h4 id="根据应用情况看是否满足手动指定document-id的前提"><a href="#根据应用情况看是否满足手动指定document-id的前提" class="headerlink" title="根据应用情况看是否满足手动指定document id的前提"></a>根据应用情况看是否满足手动指定document id的前提</h4><p>一般来说，是从某些其他的系统中导入一些数据到es时，会采取这种方式，就是使用系统中已有数据的唯一标识，作为es中document的id。</p><blockquote><p>举个例子，我们现在在开发一个电商网站，做搜索功能，或者是OA系统的做员工检索功能。这个时候，数据首先会在网站系统或者IT系统内部的数据库中，会先有一份，此时就肯定会有一个数据库的primary key（自增长，UUID，或者是业务编号）。如果将数据导入到es中，此时就比较适合采用数据在数据库中已有的primary key。</p></blockquote><p>但是如果是在做一个系统，这个系统主要的数据存储就是es，也就是数据产生出来以后，可能就没有id，直接就存es。那么这个时候，可能就不太适合手动指定document id的形式了，因为你也不知道id应该是什么，此时可以采取下面的让es自动生成id的方式。</p><h4 id="put-index-type-id"><a href="#put-index-type-id" class="headerlink" title="put /index/type/id"></a>put /index/type/id</h4><p>手动指定ID的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_content"</span>: <span class="string">"my test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动生成document-id"><a href="#自动生成document-id" class="headerlink" title="自动生成document id"></a>自动生成document id</h3><h4 id="post-index-type"><a href="#post-index-type" class="headerlink" title="post /index/type"></a>post /index/type</h4><p>后面不加ID，ES会为我们自动生成ID</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /test_index/test_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_content"</span>: <span class="string">"my test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"AVp4RN0bhjxldOOnBxaE"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h4><p>自动生成的id，它的长度为20个字符，是URL安全的，基于base64编码。基于GUID的算法，分布式系统并行生成时不可能会发生冲突。</p><h2 id="source元数据"><a href="#source元数据" class="headerlink" title="_source元数据"></a>_source元数据</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field1"</span>: <span class="string">"test field1"</span>,</span><br><span class="line">  <span class="attr">"test_field2"</span>: <span class="string">"test field2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /test_index/test_type/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field1"</span>: <span class="string">"test field1"</span>,</span><br><span class="line">    <span class="attr">"test_field2"</span>: <span class="string">"test field2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_source元数据：在创建一个document的时候，传入的json传在默认情况下，在get的时候，会原封不动的给我们返回回来。</p><p>如果要定制返回的结果，可以加<code>_srouce</code>参数，指定返回哪些字段，多个字段用逗号分隔。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/1?_source=test_field1,test_field2</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field2"</span>: <span class="string">"test field2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Document的创建、替换和删除"><a href="#Document的创建、替换和删除" class="headerlink" title="Document的创建、替换和删除"></a>Document的创建、替换和删除</h1><h2 id="document的全量替换"><a href="#document的全量替换" class="headerlink" title="document的全量替换"></a>document的全量替换</h2><ol><li>语法与创建文档是一样的，如果document id不存在，那么就是创建；如果document id已经存在，那么就是全量替换操作，替换document的json串内容。</li><li>其实document是不可变的，如果要修改document的内容，第一种方式就是全量替换，直接对document重新建立索引，替换里面所有的内容。</li><li>es会将老的document标记为deleted，然后新增我们给定的一个document，当我们创建越来越多的document的时候，es会在适当的时机在后台自动删除标记为deleted的document。</li></ol><h2 id="document的强制创建"><a href="#document的强制创建" class="headerlink" title="document的强制创建"></a>document的强制创建</h2><p>创建文档与全量替换的语法是一样的，有时我们只是想新建文档，不想替换文档，如果强制进行创建呢？</p><p><code>PUT /index/type/id?op_type=create，PUT /index/type/id/_create</code></p><p>但是强制创建一个已经存在的Document会得到一个冲突的错误。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"root_cause"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">        <span class="attr">"reason"</span>: <span class="string">"[test_type][1]: version conflict, document already exists (current version [1])"</span>,</span><br><span class="line">        <span class="attr">"index_uuid"</span>: <span class="string">"arBg_MfmRWCMSKQHqGIrDw"</span>,</span><br><span class="line">        <span class="attr">"shard"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"index"</span>: <span class="string">"test_index1"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"[test_type][1]: version conflict, document already exists (current version [1])"</span>,</span><br><span class="line">    <span class="attr">"index_uuid"</span>: <span class="string">"arBg_MfmRWCMSKQHqGIrDw"</span>,</span><br><span class="line">    <span class="attr">"shard"</span>: <span class="string">"3"</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"test_index1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="document的删除"><a href="#document的删除" class="headerlink" title="document的删除"></a>document的删除</h2><p><code>DELETE /index/type/id</code></p><p>ES不会立即物理删除，只会将其标记为deleted，当数据越来越多的时候，在后台自动删除。</p><h1 id="Elasticsearch并发冲突问题"><a href="#Elasticsearch并发冲突问题" class="headerlink" title="Elasticsearch并发冲突问题"></a>Elasticsearch并发冲突问题</h1><p>多个线程去同时访问es中的一份数据，然后各自去修改之后更新到es，由于线程的先后顺序不同，可能会导致后续的修改覆盖掉之前的修改，显然一些场景下我们是不允许发生这种并发冲突的问题，例如电商库存的修改等</p><h2 id="悲观锁和乐观锁并发控制方案"><a href="#悲观锁和乐观锁并发控制方案" class="headerlink" title="悲观锁和乐观锁并发控制方案"></a>悲观锁和乐观锁并发控制方案</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p><p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul><li><p>如何理解悲观锁 </p><p>  它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。<br>  在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。<br>  如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>  如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>  其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p></li><li><p>优点与不足<br>  悲观锁的优点：方便，直接加锁，对应用程序来说透明，不需要额外的操作；<br>  悲观锁的缺点：并发能力很低，同一时间只能有一条线程操作数据。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3></li><li><p>如何理解乐观锁<br>  它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p></li><li>与悲观锁区别<br>  相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。<br>  <strong>数据版本</strong>是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。<br>  实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</li><li>优点与不足<br>  乐观锁的优点：并发能力很高，不给数据加锁，可以进行大量线程并发操作；<br>  乐观锁的缺点：麻烦，每次更新的时候都要先比对版本号，然后可能需要重新加载数据，再次修改，在写；这个过程可能要重复好几次。</li></ul><h2 id="基于-version字段进行乐观锁并发控制"><a href="#基于-version字段进行乐观锁并发控制" class="headerlink" title="基于_version字段进行乐观锁并发控制"></a>基于_version字段进行乐观锁并发控制</h2><h3 id="version元数据"><a href="#version元数据" class="headerlink" title="_version元数据"></a>_version元数据</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/6</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test test"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"6"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次创建一个document的时候，它的_version内部版本号就是1；以后，每次对这个document执行修改或者删除操作，都会对这个_version版本号自动加1；哪怕是删除，也会对这条数据的版本号加1</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"6"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"deleted"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，在删除一个document之后，可以从一个侧面证明，它不是立即物理删除掉的，因为它的一些版本号等信息还是保留着的。先删除一条document，再重新创建这条document，其实会在delete version基础之上，再把version号加1。</p><blockquote><p>ES内部很多类似于副本集的同步请求，都是多线程异步的，也就意味着多个修改请求之间是乱序的，所以ES内部也是采用了乐观锁的方案，基于version版本号去进行并发控制。</p></blockquote><h2 id="并发控制方案"><a href="#并发控制方案" class="headerlink" title="并发控制方案"></a>并发控制方案</h2><h3 id="上机动手实战演练基于-version进行乐观锁并发控制"><a href="#上机动手实战演练基于-version进行乐观锁并发控制" class="headerlink" title="上机动手实战演练基于_version进行乐观锁并发控制"></a>上机动手实战演练基于_version进行乐观锁并发控制</h3><p>1、先模拟一条数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/7</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、模拟两个客户端，都获取到了同一条数据（开2个kibana的网页）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET test_index/test_type/7</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"7"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field"</span>: <span class="string">"test test"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、其中一个客户端先更新了数据</p><p>更新时带上了数据的版本号，确保ES中数据的版本号跟客户端的版本号是相同的才能修改。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"7"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、另外一个客户端尝试基于version=1的数据去进行修改，也带上version版本号，进行乐观锁的并发控制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"root_cause"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">        <span class="attr">"reason"</span>: <span class="string">"[test_type][7]: version conflict, current version [2] is different than the one provided [1]"</span>,</span><br><span class="line">        <span class="attr">"index_uuid"</span>: <span class="string">"I8nYYk8URXmXpcx0SS7wyw"</span>,</span><br><span class="line">        <span class="attr">"shard"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"index"</span>: <span class="string">"test_index"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"[test_type][7]: version conflict, current version [2] is different than the one provided [1]"</span>,</span><br><span class="line">    <span class="attr">"index_uuid"</span>: <span class="string">"I8nYYk8URXmXpcx0SS7wyw"</span>,</span><br><span class="line">    <span class="attr">"shard"</span>: <span class="string">"3"</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"test_index"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本冲突，更新失败。</p><p>5、在乐观锁成功阻止并发问题之后，尝试正确的完成更新</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/7</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"7"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field"</span>: <span class="string">"test client 1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先去查询ES里当前数据的版本号，然后带上最新的版本号去修改数据，可能这个步骤会需要反复执行好几次才能成功，特别是在多线程并发更新同一条数据很频繁的情况下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"7"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上机动手实战演练基于external-version进行乐观锁并发控制"><a href="#上机动手实战演练基于external-version进行乐观锁并发控制" class="headerlink" title="上机动手实战演练基于external version进行乐观锁并发控制"></a>上机动手实战演练基于external version进行乐观锁并发控制</h3><p>ES提供了一个功能可以让我们不用它提供的内部_version版本号来进行并发控制，我们可以基于自己维护的一个本版好类进行并发控制。举个例子，假如你的数据在MYSQL里也有一份，然后在MYSQL里维护了一个版本号，无论是怎么生成的，这个时候进行乐观锁并发控制，可能并不是想要用es内部的_version来进行控制，而是用自己维护的那个version来进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?version=1</span><br><span class="line">?version=1&amp;version_type=external</span><br></pre></td></tr></table></figure><blockquote><p>区别：只有当你提供的version与es中的_version一样的时候才能修改，否则就报错；当version_type=external的时候，只要你提供的version比es中的_version大，就能完成修改。</p></blockquote><p>1、先构造一条数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/8</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"8"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、模拟两个客户端同时查询到这条数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"8"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field"</span>: <span class="string">"test"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、第一个客户端先进行修改，此时客户端在自己的数据库中获取到了这条数据的最新版本号，比如说是3</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=3&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"8"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、模拟第二个客户端，同时拿到了自己数据库中维护的那个版本号，也是3，同时基于version=3发起了修改</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=3&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"root_cause"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">        <span class="attr">"reason"</span>: <span class="string">"[test_type][8]: version conflict, current version [3] is higher or equal to the one provided [3]"</span>,</span><br><span class="line">        <span class="attr">"index_uuid"</span>: <span class="string">"I8nYYk8URXmXpcx0SS7wyw"</span>,</span><br><span class="line">        <span class="attr">"shard"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"index"</span>: <span class="string">"test_index"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"[test_type][8]: version conflict, current version [3] is higher or equal to the one provided [3]"</span>,</span><br><span class="line">    <span class="attr">"index_uuid"</span>: <span class="string">"I8nYYk8URXmXpcx0SS7wyw"</span>,</span><br><span class="line">    <span class="attr">"shard"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"test_index"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的，也是并发冲突，只不过这次是基于我们自己提供的version来控制的，而且报错的提示是必须大于等于3。</p><p>5、在并发冲突以后，重新基于新的版本号发起更新</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=6&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field"</span>: <span class="string">"test client 2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"8"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="partial-update"><a href="#partial-update" class="headerlink" title="partial update"></a>partial update</h1><p>partial update是修改文档的另一种方式</p><p>之前的PUT操作对应到应用程序中，每次的执行流程是这样的：</p><ol><li>应用程序先发起一个get请求，获取到document，展示到前台界面，供用户查看和修改</li><li>用户在前台界面修改数据，发送到后台</li><li>后台代码，会将用户修改的数据在内存中进行执行，然后封装好修改后的全量数据</li><li>然后发送PUT请求，到es中，进行全量替换</li><li>es将老的document标记为deleted，然后重新创建一个新的document</li></ol><p>partial update</p><p>post /index/type/id/_update<br>{<br>   “doc”: {<br>      “要修改的少数几个field即可，不需要全量的数据”<br>   }<br>}</p><p>看起来，好像就比较方便了，每次就传递少数几个发生修改的field即可，不需要将全量的document数据发送过去</p><h2 id="partial-update实现原理以及其优点"><a href="#partial-update实现原理以及其优点" class="headerlink" title="partial update实现原理以及其优点"></a>partial update实现原理以及其优点</h2><p>partial update直接将数据更新到document中就完成了修改，不用事先先发起一个GET请求数据进行修改然后在将修改后的数据发回去。</p><p>es内部：partial update的执行和全量替换一致。</p><ol><li>内部先get获取document</li><li>将更新的field更新到document的json中</li><li>将老的document标记为deleted</li><li>创建新的document</li></ol><p>优点：</p><ol><li>所有查询，修改和写回操作均发生在同一个shard内，避免了不必要的网络数据传输带来的开销，大大提升了性能（减少了两次请求，一次GET请求，一次回写请求）</li><li>减少修改和查询中的时间间隔，有效减少并发冲突的情况</li><li>内置乐观锁并发控制</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test_index/test_type/id/_update?retry_on_conflict=2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"num"</span>:<span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果更新失败，则获取最新的版本号再次进行更新，最多重试retry_on_conflict指定的次数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test_index/test_type/11/_update?version=3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"num"</span>:<span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index/test_type/10</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test_field1"</span>: <span class="string">"test1"</span>,</span><br><span class="line">  <span class="attr">"test_field2"</span>: <span class="string">"test2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /test_index/test_type/10/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"test_field2"</span>: <span class="string">"updated test2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h1><h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><p>如果一条一条的查询100条数据，那么就要发送100次网络请求，这个开销还是很大的<br>如果进行批量查询的话，查询100条数据，就只要发送1次网络请求，网络请求的性能开销缩减100倍。</p><p>ES提供了批量查询的API，它的mget的语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"docs"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> : <span class="string">"test_index"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :  <span class="string">"test_type"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :    <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_index"</span> : <span class="string">"test_index"</span>,</span><br><span class="line">         <span class="attr">"_type"</span> :  <span class="string">"test_type"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :    <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">      <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">      <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"found"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span>: <span class="string">"test_index"</span>,</span><br><span class="line">      <span class="attr">"_type"</span>: <span class="string">"test_type"</span>,</span><br><span class="line">      <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"found"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、如果查询的document是一个index下的不同type种的话</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"docs"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_type"</span> :  <span class="string">"test_type"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :    <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"_type"</span> :  <span class="string">"test_type"</span>,</span><br><span class="line">         <span class="attr">"_id"</span> :    <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果查询的数据都在同一个index下的同一个type下，最简单了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"ids"</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量增删改"><a href="#批量增删改" class="headerlink" title="批量增删改"></a>批量增删改</h2><p>ES对于批量增删改，是提供的bulk api。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"test_index"</span>, <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"3"</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"test_index"</span>, <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"12"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>: <span class="string">"test12"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_index"</span>: <span class="string">"test_index"</span>, <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>: <span class="string">"replaced test2"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"update"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"test_index"</span>, <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"1"</span>, <span class="attr">"_retry_on_conflict"</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123;<span class="attr">"test_field2"</span> : <span class="string">"bulk test1"</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>上面是一些例子，它的语法是每一个操作有两个json，语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"action"</span>: &#123;<span class="attr">"metadata"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"data"</span>&#125;</span><br></pre></td></tr></table></figure><p>举例，比如你现在要创建一个文档，放bulk里面，看起来会是这样子的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;"index": &#123;"_index": "test_index", "_type", "test_type", "_id": "1"&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"test_field1"</span>: <span class="string">"test1"</span>, <span class="attr">"test_field2"</span>: <span class="string">"test2"</span>&#125;</span><br></pre></td></tr></table></figure><p>bulk api提供了以下4种操作：</p><ol><li>delete：删除一个文档，只要1个json串就可以了</li><li>create：PUT /index/type/id/_create，强制创建</li><li>index：普通的put操作，可以是创建文档，也可以是全量替换文档</li><li>update：执行的partial update操作</li></ol><p>bulk api对json的语法，有严格的要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行。</p><p>bulk操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /test_index/_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"3"</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"12"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>:    <span class="string">"test12"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_type"</span>: <span class="string">"test_type"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>:    <span class="string">"auto-generate id test"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>:    <span class="string">"replaced test2"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"update"</span>: &#123; <span class="attr">"_type"</span>: <span class="string">"test_type"</span>, <span class="attr">"_id"</span>: <span class="string">"1"</span>, <span class="attr">"_retry_on_conflict"</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123;<span class="attr">"test_field2"</span> : <span class="string">"bulk test1"</span>&#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /test_index/test_type/_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"3"</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"12"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>:    <span class="string">"test12"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>: <span class="string">"auto-generate id test"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>:  &#123; <span class="attr">"_id"</span>: <span class="string">"2"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"test_field"</span>: <span class="string">"replaced test2"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"update"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"1"</span>, <span class="attr">"_retry_on_conflict"</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123;<span class="attr">"test_field2"</span> : <span class="string">"bulk test1"</span>&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="bulk-size最佳大小"><a href="#bulk-size最佳大小" class="headerlink" title="bulk size最佳大小"></a>bulk size最佳大小</h3><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000~5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。</p><h1 id="Document数据路由"><a href="#Document数据路由" class="headerlink" title="Document数据路由"></a>Document数据路由</h1><p>在ES中，一个index的数据会分散在多个分片(shard)中，所以当客户端创建Document的时候，需要决定这个Document放在ES的哪一个shard上，这个过程被称之为<strong>数据路由</strong>。</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p><code>shard = hash(routing) % number_of_primary_shards</code></p><p>举个例子，一个index有3个primary shard，P0，P1，P2。每次增删改查一个document的时候，都会带过来一个routing number，默认就是这个document的_id（可能是手动指定，也可能是自动生成）。所以routing = _id，假设_id=1，会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21。然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0<br>就决定了，这个document就放在P0上。<strong>决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的</strong>。无论hash值是几，无论是什么数字，对<code>number_of_primary_shards</code>求余数，结果一定是在<code>0~number_of_primary_shards</code>-1之间这个范围内的，这里是0,1,2。</p><h2 id="id还是自定义routing值"><a href="#id还是自定义routing值" class="headerlink" title="_id还是自定义routing值"></a>_id还是自定义routing值</h2><p>默认的routing就是_id<br>也可以在发送请求的时候，手动指定一个routing值，比如<code>put /index/type/id?routing=user_id</code></p><p>手动指定routing value是很有用的，可以保证某一类document一定被路由到一个shard上去，那么在后续进行应用级别的负载均衡，以及提升批量读取的性能的时候，是很有帮助的。</p><blockquote><p>比如在实际的工作当中，如果大量的查询是基于某一个字段的查询，那么可以在添加数据的时候设置这个字段的ID为routing值，比如用户ID，这样在做查询和聚合的时候，ES只需要去一个shard里就能找到所有的数据，提升性能。</p></blockquote><h2 id="primary-shard数量不可变的谜底"><a href="#primary-shard数量不可变的谜底" class="headerlink" title="primary shard数量不可变的谜底"></a>primary shard数量不可变的谜底</h2><p>ES在创建index的时候设置了primary shard数量和replica shard数量，replica数量是可以修改的，但是primary shard的数量却不能修改。正是因为跟Document的路由公式有关，所以如果primary shard数量发生了变化，如果后面根据ID去查询一个数据，新的路由算法去计算分配，会发现根本找不到这个数据，间接导致数据丢失。</p><h1 id="Document增删改的内部原理"><a href="#Document增删改的内部原理" class="headerlink" title="Document增删改的内部原理"></a>Document增删改的内部原理</h1><p>客户端先选择一个节点发送请求，在一般的ES部署架构中，会有一个client节点，专门用来接收客户端的请求，它既不保存元数据，也不保存数据，只是协调请求转发和数据的聚合，分担master节点的压力。</p><p>节点对请求进行路由，将请求转发到路由以后的节点上，然后primary shard会在自己本地创建Document，建立索引，最后把响应结果返回给client。</p><p>所有的增删改操作，都只能由primary shard处理。</p><h1 id="写一致性原理"><a href="#写一致性原理" class="headerlink" title="写一致性原理"></a>写一致性原理</h1><p>我们在发送任何一个增删改操作的时候，比如说put /index/type/id，都可以带上一个consistency参数，指明我们想要的写一致性是什么？<br>put /index/type/id?consistency=quorum</p><ul><li>one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行</li><li>all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作</li><li>quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作</li></ul><h2 id="quorum机制"><a href="#quorum机制" class="headerlink" title="quorum机制"></a>quorum机制</h2><p>写之前必须确保大多数shard都可用，那么大多数是多少？这里有一个算法：</p><blockquote><p>quroum=<code>int( (primary + number_of_replicas) / 2 ) + 1</code>，当<code>number_of_replicas&gt;1</code>时才生效</p></blockquote><p>举个例子，3个primary shard，<code>number_of_replicas</code>=1，总共有3 + 3 * 1 = 6个shard。</p><p><code>quorum = int( (3 + 1) / 2 ) + 1 = 3</code></p><p>所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作。</p><p>如果节点数量少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作。</p><p>比如3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上(primary shard和replica shard不能放在一台机器上，同一个primary shard的replica shard也不能放在同一个机器上)，如果说只有1台机器的话，3个shard肯定都没法分配齐全，此时就可能会出现写操作无法执行的情况。</p><p>但是ES提供了一种特殊的处理场景，就是说当<code>number_of_replicas</code>&gt;1时才生效，因为假如说，你就一个primary shard，replica=1，此时就2个shard，套用公式算一下。</p><p>(1 + 1 / 2) + 1 = 2，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作。</p><p>quorum不齐全的时候，ES会等待，默认1分钟。等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout。</p><p>我们其实可以在写操作的时候，加一个timeout参数，比如说put /index/type/id?timeout=30，这个就是自己去设定quorum不齐全的时候，es的timeout时长，可以缩短，也可以增长。</p><h1 id="ES查询原理"><a href="#ES查询原理" class="headerlink" title="ES查询原理"></a>ES查询原理</h1><p>对于读请求，coordinate node（协作节点）不一定会将请求转发到primary节点上去，因为replica也是可以服务读请求的，而且在转发的时候会采用轮询的负载均衡算法，让读请求均匀的转发到replica shard上。</p><p>如果Document正在建立索引的过程中，只在primary shard上存在，此时replica shard上没有，但是协调节点可能将请求转发到replica shard上，此时就会找不到这个Document。</p><h1 id="bulk-api原理"><a href="#bulk-api原理" class="headerlink" title="bulk api原理"></a>bulk api原理</h1><p>上面在学bulk api的时候，ES对json格式要求非常严格，格式紧凑，对换行也有要求。</p><p>1、bulk中的每个操作都可能要转发到不同的node的shard去执行</p><p>2、如果采用比较良好的json数组格式</p><p>允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理</p><ol><li>将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象</li><li>解析json数组里的每个json，对每个请求中的document进行路由</li><li>为路由到同一个shard上的多个请求，创建一个请求数组</li><li>将这个请求数组序列化</li><li>将序列化后的请求数组发送到对应的节点上去</li></ol><p>3、耗费更多内存，更多的jvm gc开销</p><p>我们之前提到过bulk size最佳大小的那个问题，一般建议说在几千条，然后大小在10MB左右，所以可怕的事情来了。假设说现在100个bulk请求发送到了一个节点上去，然后每个请求是10MB，100个请求，就是1000MB = 1GB，然后每个请求的json都copy一份为jsonarray对象，此时内存中的占用就会翻倍，就会占用2GB的内存，甚至还不止。因为弄成jsonarray之后，还可能会多搞一些其他的数据结构，2GB+的内存占用。</p><p>占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。<br>另外的话，占用内存更多，就会导致java虚拟机的垃圾回收次数更多，跟频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多。</p><p>4、现在的奇特格式</p><p>{“action”: {“meta”}}\n<br>{“data”}\n<br>{“action”: {“meta”}}\n<br>{“data”}\n</p><ol><li>不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json</li><li>对每两个一组的json，读取meta，进行document路由</li><li>直接将对应的json发送到node上去</li></ol><p>5、最大的优势在于，不需要将json数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h1 id=&quot;Document元数据&quot;&gt;&lt;a href=&quot;#Document元数据&quot; class=&quot;headerlink&quot; title=&quot;Document元数据&quot;&gt;&lt;/a&gt;Document元数据&lt;/h1&gt;&lt;h2 id=&quot;index元数据&quot;&gt;&lt;a href=&quot;#index元数据&quot; class=&quot;headerlink&quot; title=&quot;_index元数据&quot;&gt;&lt;/a&gt;_index元数据&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;代表一个document存放在哪个index中。&lt;/li&gt;
&lt;li&gt;类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如company index，就不合适。
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.saily.top/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.saily.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM01-类加载</title>
    <link href="http://www.saily.top/2018/08/16/understandjvm-1/"/>
    <id>http://www.saily.top/2018/08/16/understandjvm-1/</id>
    <published>2018-08-16T07:55:41.000Z</published>
    <updated>2018-09-15T15:36:28.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。</p><ol><li>类加载常见的行为是将磁盘上的class文件加载到内存中</li><li>连接将是类与类之间的关系处理好</li><li>初始化对一些静态的变量进行赋值</li></ol><a id="more"></a><p>这提供了更大的灵活性，增加了更多的可能性。</p><h2 id="类加载深入剖析"><a href="#类加载深入剖析" class="headerlink" title="类加载深入剖析"></a>类加载深入剖析</h2><p>加载类的工具，叫做类加载器</p><h3 id="Java虚拟机的生命周期"><a href="#Java虚拟机的生命周期" class="headerlink" title="Java虚拟机的生命周期"></a>Java虚拟机的生命周期</h3><p>在如下几种情况，Java虚拟机将结束生命周期</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="类的加载、连续、与初始化"><a href="#类的加载、连续、与初始化" class="headerlink" title="类的加载、连续、与初始化"></a>类的加载、连续、与初始化</h2><ul><li>加载：查找并加载类的二进制数据</li><li><p>连接</p><ul><li>验证：确保被加载的类的正确性</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值。</li></ul><h2 id="类的使用和卸载"><a href="#类的使用和卸载" class="headerlink" title="类的使用和卸载"></a>类的使用和卸载</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;p&gt;在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载常见的行为是将磁盘上的class文件加载到内存中&lt;/li&gt;
&lt;li&gt;连接将是类与类之间的关系处理好&lt;/li&gt;
&lt;li&gt;初始化对一些静态的变量进行赋值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.saily.top/categories/JVM/"/>
    
    
      <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
      <category term="JVM" scheme="http://www.saily.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 第三版-条款1_考虑使用静态工厂方法而非构造方法</title>
    <link href="http://www.saily.top/2018/08/13/effective-java-3rd-1/"/>
    <id>http://www.saily.top/2018/08/13/effective-java-3rd-1/</id>
    <published>2018-08-13T06:33:51.000Z</published>
    <updated>2018-08-25T08:36:42.797Z</updated>
    
    <content type="html"><![CDATA[<p>先尝试自己翻译，再和龙哥的译文进行对比。</p><h1 id="条款1-考虑使用静态工厂方法而非构造方法"><a href="#条款1-考虑使用静态工厂方法而非构造方法" class="headerlink" title="条款1: 考虑使用静态工厂方法而非构造方法"></a>条款1: 考虑使用静态工厂方法而非构造方法</h1><p>传统方式允许客户端获取一个类的实例，是提供一个公有的构造方法。有另外一种技术获取实例，它应该在每个程序员的工具箱里。类可以提供一个公有的静态工厂方法，就是一个简单的静态方法，它会返回这个类的实例。这里有一个来自<code>Boolean</code>(原生类型boolean的包装类)类的简单例子，这个方法将一个原生类型的布尔值转换成一个Boolean对象引用：<br><a id="more"></a></p><blockquote><p>对于一个类来说，若想让客户端能够获取到其实例，传统⽅式是提供⼀个公有的构造⽅法。 实际上，还有另外一种技术应该成为每个程序员⼯具箱的一部分。类可以提供⼀个公有的静态⼯厂方法，它仅仅是一个可以返回类实例的静态⽅法⽽已。如下这个简单的示例来⾃于 Boolean(即boolean装箱后的类型)。该方法会将⼀个boolean原⽣值转换为⼀一个Boolean对象引用:</p></blockquote><blockquote><p>The traditional way for a class to allow a client to obtain an instance is to provide a public constructor. There is another technique that should be a part of every programmer’s toolkit. A class can provide a public static factory method, which is simply a static method that returns an instance of the class. Here’s a simple example from Boolean (the boxed primitive class for boolean). This method translates a boolean primitive value into a Boolean object reference:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意静态工厂方法和设计模式[Gamma95]里的<code>工厂方法模式</code>并不一样，这里描述的静态工厂方法跟设计模式没有关联。</p><blockquote><p>请注意，上面这个静态⼯厂⽅法与设计模式[Gamma95]中的⼯厂方法模式并不一样。本条款所介绍的静态⼯厂⽅法在设计模式一书中并没有直接的等价物。</p><p>Note that a static factory method is not the same as the Factory Method pattern from Design Patterns [Gamma95]. The static factory method described in this item has no direct equivalent in Design Patterns.</p></blockquote><p>一个类可以提供静态工厂方法给它的客户端以替代构造方法。用静态工厂方法替代构造方法既有好处，也有坏处。</p><blockquote><p>除了了公有构造方法外，类还可以向其客户端提供静态⼯厂方法。相⽐于公有构造方法来说，提供静态⼯厂⽅法有利也有弊。</p></blockquote><blockquote><p>A class can provide its clients with static factory methods instead of, or in addition to, public constructors. Providing a static factory method instead of a public constructor has both advantages and disadvantages.</p></blockquote><p><strong>静态工厂方法的一个好处是不像构造方法，它们有方法名字</strong>。如果是构造方法，它的参数并不能描述构造方法返回的实例，但是有一个好名字的静态工厂方法更好理解，也让客户端代码更有易读性。举个例子，构造方法<strong>BigInteger(int, int, Random)</strong>返回一个可能为质数的BigInteger，用静态工厂方法<strong>BigInteger.probablePrime</strong>(此方法在 Java 4中加入)可能会更好表达它的意思。</p><blockquote><p>静态⼯厂⽅法的一个好处在于，相⽐于构造方法来说，他们拥有名字。如果构造方法的参数本身没有描述出将要返回的对象，那么拥有恰当名字的静态⼯厂将会更加易于使用，所生成的客户端代码的可读性也更好。比如说，构造方法BigInteger(int, int, Random)会返回⼀一个可能为质数的BigInteger，不不过使⽤用静态⼯厂方法BigInteger.probablePrime的表述性会更更棒(该⽅法是在Java 4中被加⼊进来的)。</p><p>One advantage of static factory methods is that, unlike constructors, they have names. If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read. For example, the constructor BigInteger(int, int, Random), which returns a BigInteger that is probably prime, would have been better expressed as a static factory method named BigInteger.probablePrime. (This method was added in Java 4.)</p></blockquote><p>一个类只能有一个相同签名的构造方法。程序员知道如何绕过这个限制，那就是提供2个构造方法，但是参数的顺序不一样。这是很糟糕的主意，用户永远不能记住哪个构造方法是哪个，然后会不小心调用到错误的构造方法。人们在读代码的时候如果不看类的文档也不会知道这些构造方法干了些什么。</p><blockquote><p>一个类只能拥有唯⼀一个具有给定签名的构造⽅法。程序员们已经知道如何绕过这个限制了， 那就是提供两个构造方法，这两个构造方法之间唯一的差别就是参数列列表中参数类型的顺序是不同的。这是一个⾮常差劲的想法。这种API的使用者永远都记不住哪个构造⽅法是哪个，最终陷⼊到调用了错误的构造⽅法的窘境。当⽤户阅读了使用这种构造⽅法的代码时，他们在不查阅类文档的情况下是不可能搞清楚代码到底在做什么事情。</p><p>A class can have only a single constructor with a given signature. Program- mers have been known to get around this restriction by providing two constructors whose parameter lists differ only in the order of their parameter types. This is a really bad idea. The user of such an API will never be able to remember which constructor is which and will end up calling the wrong one by mistake. People reading code that uses these constructors will not know what the code does without referring to the class documentation.</p></blockquote><p>因为它们有名字，静态工厂方法没有前面提到的限制。如果一个类需要多个相同签名的构造方法，用静态工厂方法替代构造方法，<del>并小心地给它们取名字以标记它们的不同之处</del>。</p><blockquote><p>由于拥有名字，因此静态⼯厂方法不会遇到上面所讨论的限制。当⼀个类需要多个拥有相同签名的构造方法时，只需使⽤静态⼯厂⽅法来代替构造方法，<font color="red">并精心选择好名字来明确他们之间的差别即可。</font></p><p>Because they have names, static factory methods don’t share the restriction discussed in the previous paragraph. In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods <font color="red">and carefully chosen names to highlight their differences.</font></p></blockquote><p><strong>静态工厂方法的第二个好处是不像构造方法，它们不需要每次被调用的时候都创建一个新的对象。</strong>这允许不可变对象（条款17）用一个预设好的实例，<del>或者缓存一个已经创建好的实例</del>，这样可以反复的分发它们来避免创建不必要的重复对象。<strong>Boolean.valueOf(boolean)</strong>方法<del>说明</del>了这种技巧：它永远不创建对象。这种技巧跟享元模式比较相似，如果相同的对象经常被请求到，它可以大幅度地提升性能，特别是当创建对象开销很大的时候。</p><blockquote><p>静态⼯厂⽅法的第2个好处在于，相⽐比于构造⽅法来说，他们不必在每次调用时都创建⼀个新的对象。这样就可以让不变类使⽤用预先构造好的实例，<font color="red">或是在构造时将其缓存起来</font>，从⽽避免了创建不必要的重复对象的情况。Boolean.valueOf(boolean)⽅法就<strong>使用</strong>了这项技术: 它永远不会创建对象。该项技术类似于享元模式。如果经常需要请求同样的对象，那么这种做法将会极大改进性能，特别是在对象创建成本很高的情况下更是如此。</p><p>A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked. This allows immutable classes (Item 17) to use preconstructed instances, <font color="red">or to cache instances as they’re constructed</font>, and dispense them repeatedly to avoid creating unnecessary duplicate objects. The Boolean.valueOf(boolean) method <strong>illustrates</strong> this technique: it never creates an object. This technique is similar to the Flyweight pattern [Gamma95]. It can greatly improve performance if equivalent objects are requested often, especially if they are expensive to create.</p></blockquote><p><del>静态工厂方法返回经常被请求的同一个对象的能力允许类在任何时刻都对这些实例维持严格的控制</del>。能做到这样的类被称为实例受控的类。<del>有很多理由去写实例受控的类</del>，实例受控允许一个类保证它是单例的（条款3）或者不可实例化（条款4）。而且，它能让一个不可变的值类（条款17）保证不会有2个相等的实例存在：有且只有当a == b时候，才会有a.equals(b)。这是享元模式的基础，枚举也提供了这种保证。</p><blockquote><p><font color="red">静态⼯厂⽅法可以在重复调⽤的情况下返回同一个对象的能力使得类可以在任何时候都能严格控制哪些实例可以存在</font>。采取这种做法的类叫做实例控制。<font color="red">编写实例控制类有几个原因</font>。 借助于实例控制，类可以确保它⾃身是一个单例或是不可实例化的。此外，还可以让不可变的值类确保不会存在两个相等的实例:当且仅当a == b时，a.equals(b)才为true。这是享元模式的基础。枚举类型提供了这种保证。</p><p><font color="red">The ability of static factory methods to return the same object from repeated invocations allows classes to maintain strict control over what instances exist at any time.</font> Classes that do this are said to be instance-controlled. <font color="red">There are several reasons to write instance-controlled classes.</font> Instance control allows a class to guar- antee that it is a singleton (Item 3) or noninstantiable (Item 4). Also, it allows an immutable value class (Item 17) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a == b. This is the basis of the Flyweight pattern [Gamma95]. Enum types (Item 34) provide this guarantee.</p></blockquote><p><strong>静态工厂方法第三个好处是不像构造方法，它们可以返回它返回类型的任何子类的对象。</strong>这给你了很大的灵活性去选择返回对象的类型。</p><blockquote><p>静态⼯厂⽅法的第3个好处在于，相比于构造方法来说，他们可以返回所声明的返回类型的任何子类型的对象。这样，我们在选择所返回的对象类型时就拥有了更大的灵活性。</p><p>A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type. This gives you great flexibility in choosing the class of the returned object.</p></blockquote><p><del>灵活性的一种应用是一个API可以返回非公有类的对象。用这种方式隐藏类的实现提供了很紧凑的API。这种技术适用于基于接口的框架(interface-based frameworks 条款20)，接口为静态工厂方法提供了自然的返回类型。</del></p><blockquote><font color="red">这种灵活性的⼀个应⽤用场景就是API能够在无需将类声明为公有的情况下就可以返回对象。 以这种⽅式隐藏实现类使得API变得⾮常紧凑。这项技术也被应⽤用到了基于接口的框架中， 其中接口就为静态⼯厂⽅法提供了了⾃然⽽然的返回类型。<br><br>One application of this flexibility is that an API can return objects without making their classes public. Hiding implementation classes in this fashion leads to a very compact API. This technique lends itself to interface-based frameworks (Item 20), where interfaces provide natural return types for static factory methods.</font></blockquote><p>在Java 8之前，接口不能有静态方法。按照惯例，<code>Type</code>接口的静态工厂方法会被放进叫做<code>Types</code>的不可实例化的伴生类中(noninstantiable companion class)。例如，Java集合框架对它们自己的接口有45个实用的实现，提供不可变的集合，同步的集合等等。差不多所有的实现都是通过静态工厂方法导出到一个不可实例化的类中（java.util.Collections），所有返回对象的类都是非公有的。</p><blockquote><p>在Java 8之前，接口是不能拥有静态方法的。根据约定，针对名为Type的接口的静态⼯厂⽅法会被放到名为Types的不可实例例化的伴生类当中。⽐如说，Java集合框架有接⼝的45个辅助实现，提供了不可修改的集合、同步集合等等。⼏乎所有这些实现都是通过⼀个不可实例化的类(java.util.Collections)中的静态⼯厂⽅方法公开的。所返回对象的类型都是⾮公有的。</p><p>Prior to Java 8, interfaces couldn’t have static methods. By convention, static factory methods for an interface named Type were put in a noninstantiable companion class (Item 4) named Types. For example, the Java Collections Framework has forty-five utility implementations of its interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly all of these implemen- tations are exported via static factory methods in one noninstantiable class (java.util.Collections). The classes of the returned objects are all nonpublic.</p></blockquote><p><del>集合框架API比导出45个独立的公共类要小得多，每个类都有一个方便的实现</del>。减少的不仅仅是大量的API，还有概念的权重: 程序员为了使用API必须掌握的概念的数量和难度。<del>程序员知道返回的对象精确地具有其接口指定的API</del>，所以不需要阅读额外的实现类的类文档。此外，用这种静态工厂方法需要客户端通过接口引用返回的对象，而不是通过实现类引用，这通常是很好的实践（条款64）。</p><blockquote><p><font color="red">集合框架API要⽐它本来的样⼦小很多，它公开了45个独立的公有类，每个类都针对于⼀个便捷的实现</font>。这并不仅仅只是API的数量少了，更为重要的是概念上的数量少了:程序员使用API所需掌握的概念的数量和难度都降低了了。<font color="red">程序员知道所返回的对象是由其接口API所精确描述的</font>，因此⽆需再去阅读实现类的⽂档了。此外，使用这种静态工厂⽅法要求客户端引用接口而非实现类所返回的对象，这通常来说是⼀个很好的实践。</p><p><font color="red">The Collections Framework API is much smaller than it would have been had it exported forty-five separate public classes, one for each convenience implementation</font>. It is not just the bulk of the API that is reduced but the conceptual weight: the number and difficulty of the concepts that programmers must master in order to use the API. <font color="red">The programmer knows that the returned object has precisely the API specified by its interface</font>, so there is no need to read additional class documentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64).</p></blockquote><p>对Java8来说，接口不能包含静态方法的限制已经被移除了，所以没有理由为接口提供一个不可实例化的伴生类。许多这样的类中的公有静态成员变量应该放在接口中。但是，请注意，这些静态方法的一些实现代码还是有必要放在一个单独包级别的私有类中。这是因为Java8要求所有接口的静态成员都是公有的。Java 9允许私有的静态方法，但是静态变量和静态成员类仍然只能是公有的。</p><blockquote><p>Java 8已经取消了接口中不能包含静态⽅法的限制，这样一般来说，我们就没必要再为接⼝提供不可实例化的伴生类了。很多本应该位于这种类中的公有静态成员现在应该放到接⼝自身当中了。不过，值得注意的是，我们还是需要将这些静态⽅法的实现代码放到单独的包级别的私有类中。这是因为Java 8要求接口的所有静态成员都必须是公有的。Java 9允许私有的静态方法，不过静态字段与静态成员类依旧得是公有的。</p><p>As of Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable companion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note, however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public.</p></blockquote><p><strong>静态工厂的第四个好处是返回对象的类型作为输入参数的函数，它可以随调用的不同而变化。</strong>所声明返回类型的任何子类型都是被允许的。<del>返回对象的类型也可以随着版本的变化而变化。</del></p><blockquote><p><strong>静态⼯厂的第4个好处在于，作为输入参数的函数，返回对象所属的类会随着调⽤用的不同而不同</strong>。所声明的返回类型的任何子类型都是允许的。返回对象所属的类也会随着调⽤的不同而不不同。</p><p>A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. Any sub- type of the declared return type is permissible. The class of the returned object can also vary from release to release.</p></blockquote><p><strong>EnumSet</strong>类（条款36）没有公有的构造方法，只有静态工厂。在<strong>OpenJDK</strong>的实现里，他们会返回2个子类中的一个实例，这取决于枚举类型的长度：<del>如果它有64以下个元素，那么大多数枚举类型会返回<strong>RegularEnumSet</strong>的实例</del>，底层是用一个long实现的；如果枚举类型有超过65个元素，那么静态工厂方法会返回<strong>JumboEnumSet</strong>的实例，底层是用一个long数组实现的。</p><blockquote><p>EnumSet类(条款36)并没有公有构造⽅方法，只有静态工厂。在OpenJDK实现中，他们会返回两个子类的实例，到底返回哪⼀一个则取决于底层枚举类型的⼤小:<font color="red">如果拥有的元素数量小于等于64个(这也是⼤大多数枚举类型的情况)，那么静态⼯厂就会返回⼀个RegularEnumSet实例</font>，其底层是个long类型;如果枚举类型拥有的元素数量⼤于等于65个，那么⼯厂就会返回⼀个JumboEnumSet实例，其底层是个long类型的数组。</p><p>The EnumSet class (Item 36) has no public constructors, only static factories. In the OpenJDK implementation, they return an instance of one of two subclasses, depending on the size of the underlying enum type: <font color="red">if it has sixty-four or fewer elements, as most enum types do, the static factories return a RegularEnumSet instance</font>, which is backed by a single long; if the enum type has sixty-five or more elements, the factories return a JumboEnumSet instance, backed by a long array.</p></blockquote><p>这2个实现类对客户端来说是不可见的，<del>如果<strong>RegularEnumSet</strong>停止对小枚举类型提供高性能的优势</del>，它可以在未来的发布中被移除掉，且不会有什么副作用。同样地，在将来的发布中也可以添加第三种或者第四种<strong>EnumSet</strong>的实现，如果能带来性能上的提升。客户端也不需要关心从工厂获得的对象类型是什么；他们只需要知道那是<strong>EnumSet</strong>的某个子类。</p><blockquote><p>这两个实现类对于客户端来说是不可见的。如果RegularEnumSet对于小的枚举类型不再有性能上的优势，那么就可以在未来的版本中将其剔除而不会产⽣生任何副作用。与之类似，如果经过验证能够提供更好的性能，那么未来的版本中就可以增加第3种或是第4种EnumSet实现。客户端既不不知晓，也不不关⼼心他们从⼯厂中所得到的对象的真正类型是什么;他们只关 ⼼所得到的是EnumSet的某个⼦类。</p><p>The existence of these two implementation classes is invisible to clients. <font color="red">If RegularEnumSet ceased to offer performance advantages for small enum types</font>, it could be eliminated from a future release with no ill effects. Similarly, a future release could add a third or fourth implementation of EnumSet if it proved beneficial for performance. Clients neither know nor care about the class of the object they get back from the factory; they care only that it is some subclass of EnumSet.</p></blockquote><p><del><strong>静态工厂的第五个好处是当返回对象的类包含了需要的方法，这个类不需要存在。</strong></del>这样灵活的静态工厂方法是服务提供者框架（<em>service provider frameworks</em>）的基础，就像<strong>Java Database Connectivity API (JDBC)</strong>。<del>一个服务提供者框架是系统提供一个服务的实现</del>，系统让实现对客户端可用，对客户端实现进行解耦。</p><blockquote><p><font color="red">静态⼯厂的第5个好处在于，在使用包含了方法的类时，返回对象所属的类不必事先存在。</font> 这种灵活的静态工厂方法构成了服务提供者框架的基础，比如说Java Database Connectivity API(JDBC)。<font color="red">服务提供者框架是这样一种系统，提供者实现了某个服务，系统将其实现公开给客户端</font>，从⽽实现了客户端与实现之间的解耦。</p><p><font color="red">A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written.</font> Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). <font color="red">A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients</font> decoupling the clients from the implementations.</p></blockquote><p>服务提供者框架有三个基本的组件：一个服务接口，代表一个实现；一个提供者注册的API，提供用来注册实现；一个服务访问API，客户端用来获得一个服务的实例。客户端访问API可能会允许客户端指定一个特定的标准来选择一个实现。如果没有这样的标准，API会返回一个默认实现的实例，或者让客户端遍历所有可用的实现。服务访问API是灵活的静态工厂，构成了服务提供者框架的基础。</p><blockquote><p>服务提供者框架存在3个基本组件:服务接口(表示实现)、提供者注册API(提供者通过它来注册实现)以及服务访问API(客户端通过它来获取服务实例例)。客户端可以通过服务访问API来指定标准，从⽽而选择相应的实现。如果不存在这样的标准，那么API就会返回默认实现的实例，或是让客户端遍历所有可用的实现。服务访问API是一种灵活的静态⼯厂，它构成了服务提供者框架的基础。</p><p>There are three essential components in a service provider framework: a service interface, which represents an implementation; a provider registration API, which providers use to register implementations; and a service access API, which clients use to obtain instances of the service. The service access API may allow clients to specify criteria for choosing an implementation. In the absence of such criteria, the API returns an instance of a default implementation, or allows the client to cycle through all available implementations. The service access API is the flexible static factory that forms the basis of the service provider framework.</p></blockquote><p>服务提供者框架的第四个可选组件是服务提供者接口，它描述了生产服务接口实例的工厂对象。在没有服务提供者接口的情况下，实现必须以反射的方式实例化（条款65）。在JDBC中，<strong>Connection</strong>扮演了服务接口，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API，Driver是服务提供者接口。</p><blockquote><p>服务提供者框架第4个可选的组件是服务提供者接口，它描述了了⽤于⽣产服务接口实例的⼯⼚对象。如果服务提供者接口不存在，那么实现就必须要通过反射的方式来实例化(条款 65)。对于JDBC来说，Connection就扮演着服务接⼝的⻆色， DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问 API，而Driver则是服务提供者接口。</p><p>An optional fourth component of a service provider framework is a service provider interface, which describes a factory object that produce instances of the service interface. In the absence of a service provider interface, implementations must be instantiated reflectively (Item 65). In the case of JDBC, Connection plays the part of the service interface, DriverManager.registerDriver is the provider registration API, DriverManager.getConnection is the service access API, and Driver is the service provider interface.</p></blockquote><p>有许多服务提供者框架的变种。例如，服务访问API可以向客户端返回一个比服务提供者供应的更丰富的接口。这是<em>桥接模式</em>。依赖注入框架可以被认为是一个很强的服务提供者，从Java6开始，平台包含了一个<del>强大</del>的服务提供者框架，<strong>java.util.ServiceLoader</strong>，所以你不需要通常也不应该自己写一个（条款59）。JDBC不用ServiceLoader，因为它更早发布。</p><blockquote><p>服务提供者框架模式有很多变种。⽐如说，服务访问API可以向客户端返回比提供者所规定的更为宽泛的服务接口。这就是桥接模式[Gamma95]。依赖注⼊框架(条款5)可以看作是一种强大的服务提供者。从Java 6开始，平台包含了一个<font color="red">通⽤</font>的服务提供者框架，即 java.util.ServiceLoader。因此，你无需，通常来说也不应该再编写⾃己的了(条款59)。 JDBC并未使用ServiceLoader，因为前者出现的时间要更早⼀些。</p><p>There are many variants of the service provider framework pattern. For exam- ple, the service access API can return a richer service interface to clients than the one furnished by providers. This is the Bridge pattern [Gamma95]. Dependency injection frameworks (Item 5) can be viewed as powerful service providers. Since Java 6, the platform includes a <font color="red">general-purpose</font> service provider framework, java.util.ServiceLoader, so you needn’t, and generally shouldn’t, write your own (Item 59). JDBC doesn’t use ServiceLoader, as the former predates the latter.</p></blockquote><p>仅提供静态工厂方法的主要限制是，没有公有或受保护构造函数的类不能被子类化。例如，<del>子类化集合框架的实现类就很方便(翻译的什么鬼)</del>。可以说这是一种因祸得福的做法，因为它鼓励程序员用组合而不是继承（条款18），并且对于不可变类是必须的。</p><blockquote><p>只提供静态⼯厂方法的主要限制在于，没有公有或是受保护构造⽅法的类是⽆法被⼦子类化的。<br>⽐如说，<font color="red">我们⽆法子类化集合框架中的任何便捷实现类</font>。另一方面，这么做会⿎鼓励程序员们使⽤用组合⽽而⾮继承(条款18)，并且这对于不变类型来说也是需要的(条款17)。<br>The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed. For example, <font color="red">it is impossible to subclass any of the convenience implementation classes in the Collections Framework</font>. Arguably this can be a blessing in disguise because it encourages programmers to use composition instead of inheritance (Item 18), and is required for immutable types (Item 17).</p></blockquote><p>静态工厂方法的第二个缺点是程序员很难找到它们。它们在API文档中不像构造函数那样清晰，因此很难弄清楚如何用提供的静态工厂方法实例化一个类而不是构造函数。<del>Javadoc工具某一天可能将注意力转换到静态工厂方法上</del>。与此同时，<del>你可以通过在类或接口的静态工厂方法的文档上引起注意(<font color="red">是多注意文档里的静态工厂方法</font>)</del>，以及遵守通用命名约定来减少这个问题。下面是一些静态工厂方法的常见名称，这个列表还远远不够详尽：</p><blockquote><p>静态⼯厂方法的第2个缺点在于，程序员们很难找到他们。他们并不像构造⽅法那样在API⽂档中有清楚的说明，这样对于既提供静态⼯厂⽅法，⼜提供构造方法的类来说，我们就很难知晓到底该⽤那种⽅式来实例化它。可能在未来的某⼀一天，Javadoc工具会<font color="red">重视</font>起静态⼯厂方法。与此同时，<font color="red">你可以多注意到类或接⼝文档中的静态⼯厂</font>并坚持使用常见的命名约定来减少此类问题的发生。如下是静态工⼚方法的一些常⻅见名字，这个列表只是部分，还不不完全:</p><p>A second shortcoming of static factory methods is that they are hard for programmers to find. They do not stand out in API documentation in the waythat constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors. The Javadoc tool may someday draw attention to static factory methods. In the meantime, you can reduce this problem by <font color="red">drawing attention to static factories in class or interface documentation</font> and by adhering to common naming conventions. Here are some common names for static factory methods. This list is far from exhaustive:</p></blockquote><ul><li><p><strong>form</strong>–一个<em>类型转换方法</em>接受单个参数，并返回这个类型一个相应的实例，例如：</p><p>  <code>Date d = Date.from(instant);</code></p></li><li><p><strong>of</strong>–一个<em>聚合方法</em>接受多个参数，并返回一个组装他们的类型的实例，例如：</p><p>  <code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></p></li><li><p><strong>valueOf</strong>–from和of的一种冗长的形式，例如：</p><p>  <code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></p></li><li><p><strong>instance或者getInstance</strong>–根据它的参数返回一个实例，但是他们不是相同的值，例如：</p><p>  <code>StackWalker luke = StackWalker.getInstance(options);</code></p></li><li><p><strong>create或者newInstance</strong>–跟instance或者getInstance是一样的，但是方法能保证每次返回的都是新的实例，例如：</p><p>  <code>Object newArray = Array.newInstance(classObject, arrayLen);</code></p></li><li><p><strong>getType</strong>–和getInstance一样，但是这个工厂方法是用在另外一个不同的类中。<strong>Type</strong>是工厂方法返回对象的类型。例如：</p><p>  <code>FileStore fs = Files.getFileStore(path);</code></p></li><li><p><strong>newType</strong>–和newInstance一样，但是这个工厂方法是用在另外一个不同的类中。<strong>Type</strong>是工厂方法返回对象的类型。例如：</p><p>  <code>BufferedReader br = Files.newBufferedReader(path);</code></p></li><li><p><strong>type</strong>–getType和newType的一种另外一种简介的形式，例如：</p><p>  <code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></p></li></ul><p>总之，静态工厂方法和公有的构造方法都有各自的用途，理解它们的有点是值得的。通常静态工厂更好，所以避免在没有首先考虑静态工厂的情况下提供公有的构造方法。</p><blockquote><p>总结⼀一下，静态⼯厂方法与公有的构造方法都有各自的适用场景，我们需要理解他们各自的优点。通常，静态⼯厂是优先选择的，这样可以避免习惯性地在没有考虑静态⼯厂的情况下<br>就提供公有构造⽅方法的情况发⽣生。</p><p>In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first consid- ering static factories.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先尝试自己翻译，再和龙哥的译文进行对比。&lt;/p&gt;
&lt;h1 id=&quot;条款1-考虑使用静态工厂方法而非构造方法&quot;&gt;&lt;a href=&quot;#条款1-考虑使用静态工厂方法而非构造方法&quot; class=&quot;headerlink&quot; title=&quot;条款1: 考虑使用静态工厂方法而非构造方法&quot;&gt;&lt;/a&gt;条款1: 考虑使用静态工厂方法而非构造方法&lt;/h1&gt;&lt;p&gt;传统方式允许客户端获取一个类的实例，是提供一个公有的构造方法。有另外一种技术获取实例，它应该在每个程序员的工具箱里。类可以提供一个公有的静态工厂方法，就是一个简单的静态方法，它会返回这个类的实例。这里有一个来自&lt;code&gt;Boolean&lt;/code&gt;(原生类型boolean的包装类)类的简单例子，这个方法将一个原生类型的布尔值转换成一个Boolean对象引用：&lt;br&gt;
    
    </summary>
    
      <category term="Effective Java" scheme="http://www.saily.top/categories/Effective-Java/"/>
    
    
      <category term="java" scheme="http://www.saily.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装redis4.0.10并进行生产环境部署</title>
    <link href="http://www.saily.top/2018/07/19/redis-install/"/>
    <id>http://www.saily.top/2018/07/19/redis-install/</id>
    <published>2018-07-19T15:24:16.000Z</published>
    <updated>2018-09-15T15:27:07.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>直奔主题，官网下载redis最新版本（2018年07月19日）</p><p><a href="http://download.redis.io/releases/redis-4.0.10.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.10.tar.gz</a></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装tcl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install tcl</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="安装单机版Reids"><a href="#安装单机版Reids" class="headerlink" title="安装单机版Reids"></a>安装单机版Reids</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/redis &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis</span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class="line">tar -zxvf redis-4.0.10.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-4.0.10</span><br><span class="line">make &amp;&amp; make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>最后一步可能需要等的有点久，安装完成以后就开始进行生产环境配置。</p><h1 id="Redis生产环境启动方案"><a href="#Redis生产环境启动方案" class="headerlink" title="Redis生产环境启动方案"></a>Redis生产环境启动方案</h1><ol><li>redis的<code>utils</code>目录下，有个<code>redis_init_script</code>脚本</li><li><p>将<code>redis_init_script</code>脚本拷贝到linux的<code>/etc/init.d</code>目录中，将<code>redis_init_script</code>重命名为<code>redis_6370</code>，<code>6370</code>是我们希望这个redis实例监听的端口号</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/redis/redis-4.0.10/utils/redis_init_scrip /etc/init.d/redis_6370</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>修改<code>redis_6370</code>脚本的第6行的REDISPORT，设置为相同的端口号（默认是6379）</li><li>创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6370（存放redis的持久化文件）</li><li><p>修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6370.conf</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/redis/redis-4.0.10/redis.conf /etc/redis/6370.conf</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>修改redis.conf中的部分配置为生产环境</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让redis以daemon进程运行</span></span><br><span class="line">daemonizeyes</span><br><span class="line"><span class="comment"># 设置redis的pid文件位置</span></span><br><span class="line">pidfile/var/run/redis_6370.pid </span><br><span class="line"><span class="comment"># 设置redis的监听端口号</span></span><br><span class="line">port6370</span><br><span class="line"><span class="comment"># 设置持久化文件的存储位置</span></span><br><span class="line">dir /var/redis/6370</span><br><span class="line"><span class="comment"># 打开数据持久化</span></span><br><span class="line">appendonly  yes </span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass yourpass   </span><br><span class="line"><span class="comment"># 设置连接Redis的地址</span></span><br><span class="line"><span class="comment"># 如果提供给其他机器访问，请在此处设置IP为机器IP</span></span><br><span class="line"><span class="built_in">bind</span>  127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>启动redis</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">chmod 777 redis_6370</span><br><span class="line">./redis_6370 start</span><br></pre></td></tr></table></figure></li><li><p>确认redis进程是否启动</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li><li><p>让redis跟随系统启动自动启动，在<code>/etc/init.d/redis_6370</code>脚本中，最上面，加入两行注释</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># chkconfig:   2345 90 10</span><br><span class="line"># description:  Redis is a persistent key-value database</span><br></pre></td></tr></table></figure><p> 然后执行命令:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig redis_6370 on</span><br></pre></td></tr></table></figure></li></ol><h1 id="redis-cli测试"><a href="#redis-cli测试" class="headerlink" title="redis-cli测试"></a>redis-cli测试</h1><h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6370 -a yourpass PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h2 id="停机"><a href="#停机" class="headerlink" title="停机"></a>停机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6370 SHUTDOWN</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6370 </span><br><span class="line">127.0.0.1:6370&gt; auth yourpass</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6370&gt; PING</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6370&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6370&gt; get k1</span><br><span class="line"><span class="string">"v1"</span></span><br></pre></td></tr></table></figure><p>是不是很简单明了？文章到此结束。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;&lt;p&gt;直奔主题，官网下载redis最新版本（2018年07月19日）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.redis.io/releases/redis-4.0.10.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://download.redis.io/releases/redis-4.0.10.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;p&gt;安装tcl&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install tcl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.saily.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.saily.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch03-集群和架构讲解</title>
    <link href="http://www.saily.top/2018/06/20/elasticSearch03/"/>
    <id>http://www.saily.top/2018/06/20/elasticSearch03/</id>
    <published>2018-06-20T00:57:00.000Z</published>
    <updated>2018-08-25T08:13:19.672Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h2 id="ES基础分布式架构"><a href="#ES基础分布式架构" class="headerlink" title="ES基础分布式架构"></a>ES基础分布式架构</h2><h3 id="Elasticsearch对复杂分布式机制的透明隐藏特性"><a href="#Elasticsearch对复杂分布式机制的透明隐藏特性" class="headerlink" title="Elasticsearch对复杂分布式机制的透明隐藏特性"></a>Elasticsearch对复杂分布式机制的透明隐藏特性</h3><p>Elasticsearch是一套分布式的系统，分布式就是为了应对大数据量。它隐藏了复杂的分布式机制，其中有几个很重要的机制和概念。</p><ul><li>分片机制（之前将一些document插入到es集群中去，不用关心数据怎么进行分片的，数据到哪个shard中去，这是ES自动完成的）<a id="more"></a></li><li><p>cluster discovery（集群发现机制：在第一篇文章中做那个集群status从yellow转green的实验里，直接启动了第二个es进程，那个进程就作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据）</p></li><li><p>shard负载均衡（举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求）</p></li></ul><p>总结下来就是：分片副本，请求路由，集群扩容，分片重分配</p><h3 id="Elasticsearch的垂直扩容与水平扩容"><a href="#Elasticsearch的垂直扩容与水平扩容" class="headerlink" title="Elasticsearch的垂直扩容与水平扩容"></a>Elasticsearch的垂直扩容与水平扩容</h3><ul><li><p>垂直扩容：采购更强大的服务器，成本非常高昂，而且会有瓶颈，假设世界上最强大的服务器容量就是10T，但是当你的总数据量达到5000T的时候，你要采购多少台最强大的服务器？</p></li><li><p>水平扩容：这是业界经常采用的方案，采购越来越多的普通服务器，虽然性能比较一般，但是很多普通服务器组织在一起，就能构成强大的计算和存储能力。</p></li></ul><p>例如：</p><p>普通服务器：1T，1万一台，需要100万<br>强大服务器：10T，50万一台，需要500万</p><p>一般是采用水平扩容的方式</p><h3 id="增减或减少节点时的数据rebalance"><a href="#增减或减少节点时的数据rebalance" class="headerlink" title="增减或减少节点时的数据rebalance"></a>增减或减少节点时的数据rebalance</h3><p>每当增加或者减少节点的时候，ES会自动的负载均衡保持每个节点的shard负载均衡，保证每台服务器的分片数量均衡。</p><h3 id="master节点作用"><a href="#master节点作用" class="headerlink" title="master节点作用"></a>master节点作用</h3><p>ES集群都有一个master节点，用来管理ES集群的元数据：比如索引的创建和删除，维护索引的元数据；节点的增加和移除等等。</p><p>默认情况下会自动的选出一台节点作为master节点，master不承载请求，所以没有单点瓶颈。</p><h3 id="节点对等的分布式架构"><a href="#节点对等的分布式架构" class="headerlink" title="节点对等的分布式架构"></a>节点对等的分布式架构</h3><p>所有的节点都可以接受请求，也可以存储数据，如果数据不在自己的节点上，就去别的节点将数据找到然后返回给客户端。</p><ol><li>节点对等，每个节点都能接收所有的请求</li><li>自动请求路由</li><li>响应收集</li></ol><p><img src="/img/es/03/ES的基础分布式架构.png" alt="ES的基础分布式架构"></p><h2 id="shard-amp-replica机制再次梳理"><a href="#shard-amp-replica机制再次梳理" class="headerlink" title="shard&amp;replica机制再次梳理"></a>shard&amp;replica机制再次梳理</h2><ol><li>一个index包含一个或者多个shard</li><li>每个shard都是一个最小工作单元，它承载部分数据，每一个都是lucene实例，具有完整的建立索引和处理请求的能力。</li><li>增减节点时，shard会自动在nodes中负载均衡</li><li>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard。</li><li>replica shard是primary shard的副本，负责容错，以及承担读请求负载。</li><li>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改。</li><li>primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard</li><li>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上。</li></ol><h2 id="单node环境下创建index是什么样子的"><a href="#单node环境下创建index是什么样子的" class="headerlink" title="单node环境下创建index是什么样子的"></a>单node环境下创建index是什么样子的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /test_index</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 3,</span><br><span class="line">      &quot;number_of_replicas&quot; : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>单node环境下，创建一个index，它有3个primary shard，3个replica shard</li><li><p>集群status是yellow</p><p> <img src="/img/es/03/单机集群状态.png" alt="单机集群状态"></p></li><li><p>这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的（primary shard不能和自己的replica shard放在同一个节点上，集群状态是yellow的原因）</p></li><li>集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求</li></ol><h2 id="2个node环境下replica-shard是如何分配的"><a href="#2个node环境下replica-shard是如何分配的" class="headerlink" title="2个node环境下replica shard是如何分配的"></a>2个node环境下replica shard是如何分配的</h2><ol><li>replica shard分配：5个primary shard，5个replica shard，2个node</li><li>primary和replica的数据是同步的</li><li>primary/replica都可能会收到读请求</li></ol><p><img src="/img/es/03/2个节点的分片和副本分配.png" alt="2个节点的分片和副本分配"></p><p>上面有灰色边框的是primary shard</p><h2 id="横向扩容的过程，如何超出扩容极限，以及如何提升容错性"><a href="#横向扩容的过程，如何超出扩容极限，以及如何提升容错性" class="headerlink" title="横向扩容的过程，如何超出扩容极限，以及如何提升容错性"></a>横向扩容的过程，如何超出扩容极限，以及如何提升容错性</h2><ol><li>如果本身是2个节点，扩容1个节点后primary&amp;replica会自动负载均衡。6个shard，3 primary，3 replica会平均的被分配3个节点中。</li><li>扩容后每个node有更少的shard，意味着IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好。</li><li>扩容的极限是什么？如果是6个shard（3 primary，3 replica），那么最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，这个时候性能最好。</li><li>如果要超出扩容极限，那就动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量。</li><li>在3台机器的情况下，9个shard（3 primary，6 replica），虽然资源更少，但是容错性更好，最多容纳2台机器宕机，如果是配置的6个shard那么只能容纳1台机器宕机。</li><li>这里的这些知识点综合起来看，一方面是说扩容的原理，怎么扩容，怎么提升系统整体吞吐量；另一方面要考虑到系统的容错性，怎么保证提高容错性，让尽可能多的服务器宕机，保证数据不丢失。</li></ol><h2 id="Elasticsearch容错机制：master选举，replica容错，数据恢复"><a href="#Elasticsearch容错机制：master选举，replica容错，数据恢复" class="headerlink" title="Elasticsearch容错机制：master选举，replica容错，数据恢复"></a>Elasticsearch容错机制：master选举，replica容错，数据恢复</h2><p>假设我们一共有9 shard，3个node。</p><ol><li>如果master node宕机了，那么ES集群会自动进行master选举，自动选举另外一个node成为新的master，这个时候集群状态会变成red。</li><li>replica容错：新的master将replica shard提升为primary shard，集群状态变成yellow。</li><li>然后我们再重启宕机的node，master会将确实的副本复制到该node，会使用原有的shard并同步宕机后的修改，然后集群变成green。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h2 id=&quot;ES基础分布式架构&quot;&gt;&lt;a href=&quot;#ES基础分布式架构&quot; class=&quot;headerlink&quot; title=&quot;ES基础分布式架构&quot;&gt;&lt;/a&gt;ES基础分布式架构&lt;/h2&gt;&lt;h3 id=&quot;Elasticsearch对复杂分布式机制的透明隐藏特性&quot;&gt;&lt;a href=&quot;#Elasticsearch对复杂分布式机制的透明隐藏特性&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch对复杂分布式机制的透明隐藏特性&quot;&gt;&lt;/a&gt;Elasticsearch对复杂分布式机制的透明隐藏特性&lt;/h3&gt;&lt;p&gt;Elasticsearch是一套分布式的系统，分布式就是为了应对大数据量。它隐藏了复杂的分布式机制，其中有几个很重要的机制和概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分片机制（之前将一些document插入到es集群中去，不用关心数据怎么进行分片的，数据到哪个shard中去，这是ES自动完成的）
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.saily.top/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.saily.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>高可用缓存架构实战6-缓存雪崩及解决方案</title>
    <link href="http://www.saily.top/2018/06/12/cache06/"/>
    <id>http://www.saily.top/2018/06/12/cache06/</id>
    <published>2018-06-12T13:19:12.000Z</published>
    <updated>2018-08-25T08:01:21.014Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩这种场景，缓存架构中非常重要的一个环节，应对缓存雪崩的解决方案，避免缓存雪崩的时候，造成整个系统崩溃，带来巨大的经济损失</p><a id="more"></a><h2 id="缓存雪崩的过程和后果"><a href="#缓存雪崩的过程和后果" class="headerlink" title="缓存雪崩的过程和后果"></a>缓存雪崩的过程和后果</h2><p>缓存雪崩，一般首先是redis集群彻底崩溃，它导致崩溃的流程如下：</p><ol><li>redis集群彻底崩溃</li><li>缓存服务大量对redis的请求hang住，占用资源</li><li>缓存服务大量的请求打到源头服务去查询mysql，直接打死mysql</li><li>源头服务因为mysql被打死也崩溃，对源服务的请求也hang住，占用资源</li><li>缓存服务大量的资源全部耗费在访问redis和源服务无果，最后自己被拖死，无法提供服务</li><li>nginx无法访问缓存服务，redis和源服务，只能基于本地缓存提供服务，但是缓存过期后，没有数据提供</li><li>网站崩溃</li></ol><p><img src="/img/cache/缓存雪崩的过程和后果.png" alt="缓存雪崩的过程和后果"></p><h1 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h1><p>相对来说，考虑的比较完善的一套方案，分为事前，事中，事后三个层次去思考怎么来应对缓存雪崩的场景</p><h2 id="事前解决方案"><a href="#事前解决方案" class="headerlink" title="事前解决方案"></a>事前解决方案</h2><p>所谓事前解决方案，就是发生缓存雪崩之前，事情之前，怎么去避免redis彻底挂掉。</p><p>那就是保证redis的高可用性，我们利用redis本身的高可用性，复制，主从架构等功能，操作主节点去读写，数据同步到从节点，一旦主节点挂掉，从节点就跟上。</p><p>一般是建议双机房部署，一套redis cluster，部分机器在一个机房，另一部分机器在另外一个机房。</p><p>还有一种部署方式，两套redis cluster，两套redis cluster之间做一个数据的同步，redis集群是可以搭建成树状的结构的。一旦单个机房出了故障，至少另外一个机房还能有些redis实例提供服务。</p><h2 id="事中解决方案"><a href="#事中解决方案" class="headerlink" title="事中解决方案"></a>事中解决方案</h2><p>如果redis cluster已经彻底崩溃了，已经开始大量的访问无法访问到redis了，那之前文章讲到过的多级缓存就起作用了。</p><p>ehcache缓存，第一应对零散的redis中数据被清除掉的现象，另外一个主要是预防redis彻底崩溃。这样多台机器上部署的缓存服务实例的内存中，还有一套ehcache的缓存，可以基于本地的ehcache的缓存提供一部分的数据。</p><p>一旦redis集群彻底崩溃了需要做以下几个步骤：</p><ol><li>对redis的访问做资源隔离，避免所有资源hang在访问redis上</li><li>对redis访问失败的情况做相应的熔断和降级策略</li><li>使用ehcache本地缓存</li><li>对源服务访问的限流以及资源隔离（mysql层）</li></ol><h2 id="事后解决方案"><a href="#事后解决方案" class="headerlink" title="事后解决方案"></a>事后解决方案</h2><p>如何恢复Redis Cluster，有两种情况</p><ol><li>redis数据可以恢复，做了备份，redis数据备份和恢复，redis重新启动起来</li><li>redis数据彻底丢失了，或者数据过旧，快速缓存预热，redis重新启动起来</li></ol><p>其实这套方案没什么东西，事前的Redis文章前面也说了，事中ehcache也做过了。但是，如何将缓存服务如何设计成高可用的架构，需要配合Hystrix来开发。我们的熔断，降级，限流等等操作都需要Hystrix的配合。</p><p><a href="http://www.saily.top/categories/hystrix/">Hystrix系列文章</a></p><p><img src="/img/cache/缓存雪崩的事前事中事后的解决方案.png" alt="缓存雪崩的事前事中事后的解决方案"></p><h1 id="使用Hystrix对Redis进行资源隔离"><a href="#使用Hystrix对Redis进行资源隔离" class="headerlink" title="使用Hystrix对Redis进行资源隔离"></a>使用Hystrix对Redis进行资源隔离</h1><p>接下来就要对redis的访问这一块加上保护措施，给商品服务的访问加上限流的保护措施。redis这一块，全都用hystrix的command进行封装，做资源隔离，确保redis的访问只能在固定的线程池内的资源来进行访问，哪怕是redis访问的很慢，有等待和超时，也不要紧，只有少量额线程资源用来访问，缓存服务不会被拖垮。</p><p>找到之前的缓存项目<a href="https://github.com/sail-y/eshop-cache，引入Hystrix的依赖" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache，引入Hystrix的依赖</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-metrics-event-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在CacheServiceImpl里有几处用到redis的地方，我们就需要开发几个相应的command。</p><h2 id="SaveProductInfo2RedisCacheCommand"><a href="#SaveProductInfo2RedisCacheCommand" class="headerlink" title="SaveProductInfo2RedisCacheCommand"></a>SaveProductInfo2RedisCacheCommand</h2><p><strong>SaveProductInfo2RedisCacheCommand.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveProductInfo2RedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductInfo productInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveProductInfo2RedisCacheCommand</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RedisGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.productInfo = productInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"product_info_"</span> + productInfo.getId();</span><br><span class="line">        redisTemplate.opsForValue().set(key, JSON.toJSONString(productInfo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用command替换之前的实现</p><p><strong>CacheServiceImpl.saveProductInfo2RedisCache</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将商品信息保存到redis中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveProductInfo2RedisCache</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">    SaveProductInfo2RedisCacheCommand command = <span class="keyword">new</span> SaveProductInfo2RedisCacheCommand(productInfo);</span><br><span class="line">    command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SaveShopInfo2RedisCacheCommand"><a href="#SaveShopInfo2RedisCacheCommand" class="headerlink" title="SaveShopInfo2RedisCacheCommand"></a>SaveShopInfo2RedisCacheCommand</h2><p><strong>SaveShopInfo2RedisCacheCommand.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存商品信息到Redis</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveShopInfo2RedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ShopInfo shopInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveShopInfo2RedisCacheCommand</span><span class="params">(ShopInfo shopInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RedisGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.shopInfo = shopInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"shop_info_"</span> + shopInfo.getId();</span><br><span class="line">        redisTemplate.opsForValue().set(key, JSONObject.toJSONString(shopInfo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用command替换之前的实现</p><p><strong>CacheServiceImpl.saveShopInfo2RedisCache</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将店铺信息保存到redis中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shopInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveShopInfo2RedisCache</span><span class="params">(ShopInfo shopInfo)</span> </span>&#123;</span><br><span class="line">    SaveShopInfo2RedisCacheCommand command = <span class="keyword">new</span> SaveShopInfo2RedisCacheCommand(shopInfo);</span><br><span class="line">    command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetProductInfoFromRedisCacheCommand"><a href="#GetProductInfoFromRedisCacheCommand" class="headerlink" title="GetProductInfoFromRedisCacheCommand"></a>GetProductInfoFromRedisCacheCommand</h2><p><strong>GetProductInfoFromRedisCacheCommand.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis获取商品Command</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoFromRedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoFromRedisCacheCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RedisGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"product_info_"</span> + productId;</span><br><span class="line">        String json = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(json, ProductInfo.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用command替换之前的实现</p><p><strong>CacheServiceImpl.getProductInfoFromRedisCache</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis从获取商品信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">getProductInfoFromRedisCache</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    GetProductInfoFromRedisCacheCommand command = <span class="keyword">new</span> GetProductInfoFromRedisCacheCommand(id);</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetShopInfoFromRedisCacheCommand"><a href="#GetShopInfoFromRedisCacheCommand" class="headerlink" title="GetShopInfoFromRedisCacheCommand"></a>GetShopInfoFromRedisCacheCommand</h2><p><strong>GetShopInfoFromRedisCacheCommand.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis获取店铺信息Command</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetShopInfoFromRedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ShopInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetShopInfoFromRedisCacheCommand</span><span class="params">(Long shopId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RedisGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.shopId = shopId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShopInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"shop_info_"</span> + shopId;</span><br><span class="line">        String json = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(json, ShopInfo.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用command替换之前的实现</p><p><strong>CacheServiceImpl.getShopInfoFromRedisCache</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis中获取商品店铺信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShopInfo <span class="title">getShopInfoFromRedisCache</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    GetShopInfoFromRedisCacheCommand command = <span class="keyword">new</span> GetShopInfoFromRedisCacheCommand(id);</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Hystrix对Redis访问进行降级"><a href="#使用Hystrix对Redis访问进行降级" class="headerlink" title="使用Hystrix对Redis访问进行降级"></a>使用Hystrix对Redis访问进行降级</h1><p>上面已经通过hystrix command对redis的访问进行了资源隔离，避免redis访问频繁失败，或者频繁超时的时候，耗尽大量的tomcat容器的资源去hang在redis的访问上。</p><p>这样就限定只有一部分线程资源可以用来访问redis，如果redis集群彻底崩溃了，这个时候，可能command对redis的访问大量的报错和timeout超时，熔断（短路），我们就需要对redis进行降级，用Hystrix的fallback机制。建议是使用fail silent模式，fallback里面直接返回一个空值，比如一个null，最简单。</p><p>在外面调用redis的代码（CacheService类），只要你把timeout、熔断、熔断恢复、降级，都做好了，是感知不到redis的访问异常的。可能会出现的情况是，当redis集群崩溃的时候，CacheService会获取到的是大量的null空值。</p><p>根据这个null空值，我们还可以去做多级缓存的降级访问，nginx本地缓存，redis分布式集群缓存，ehcache本地缓存等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便回顾一下之前CacheController的代码，在从redis里获取null值以后，会自动去别的地方一步步获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getProductInfo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">getProductInfo</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从Redis从获取数据</span></span><br><span class="line">    ProductInfo productInfo = cacheService.getProductInfoFromRedisCache(productId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"=================从redis中获取缓存，商品信息="</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        productInfo = cacheService.getProductInfoFromLocalCache(productId);</span><br><span class="line">        System.out.println(<span class="string">"================从ehcache从获取缓存，商品信息="</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 就需要从数据源重新拉取数据，重建缓存，模拟获取</span></span><br><span class="line">        String productInfoJSON = <span class="string">"&#123;\"id\": "</span> + productId + <span class="string">", \"name\": \"iphone7手机\", \"price\": 5599, \"pictureList\":\"a.jpg,b.jpg\", \"specification\": \"iphone7的规格\", \"service\": \"iphone7的售后服务\", \"color\": \"红色,白色,黑色\", \"size\": \"5.5\", \"shopId\": 2, \"modifiedTime\": \"2018-02-21 22:11:34\"&#125;"</span>;</span><br><span class="line">        productInfo = JSONObject.parseObject(productInfoJSON, ProductInfo.class);</span><br><span class="line">        <span class="comment">// 将数据推送到一个内存队列中</span></span><br><span class="line">        RebuildCacheQueue rebuildCacheQueue = RebuildCacheQueue.getInstance();</span><br><span class="line">        rebuildCacheQueue.putProductInfo(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> productInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样一个简单的改造，我们使用Hystrix对redis的线程资源隔离和降级都很容易的完成了。</p><h1 id="Redis集群崩溃定制化熔断策略"><a href="#Redis集群崩溃定制化熔断策略" class="headerlink" title="Redis集群崩溃定制化熔断策略"></a>Redis集群崩溃定制化熔断策略</h1><p>缓存雪崩的事中解决方案</p><p>redis集群崩溃的时候，Hystrix会怎么样？</p><ol><li>大量的等待，超时，报错</li><li>如果是短时间内报错，会直接走fallback降级，直接返回null</li><li>超时控制，应该是判断redis访问超过了多长时间，就直接给报错timeout了</li></ol><p>不推荐用默认的值，一般不太精准，redis的访问先统计一下访问时长的百分比，hystrix dashboard里可以看到TP90，TP95，TP99的时间分别是多少。一般redis访问TP99在100ms以内，那么此时timeout时长稍微设置多一些，比如100ms。</p><h2 id="timeout设置"><a href="#timeout设置" class="headerlink" title="timeout设置"></a>timeout设置</h2><p>HystrixCommandProperties.Setter()<br>   .withExecutionTimeoutInMilliseconds(int value)</p><p>意义在于哪里？一旦redis出现了大面积的故障，此时肯定是访问的时候大量的超过100ms，大量的在等待和超时，这样就可以确保大量的请求不会hang住过长的时间，比如hang住个1s，500ms。如果100ms直接就报timeout，就会走fallback降级了。</p><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>开启熔断有2个参数</p><h3 id="circuitBreaker-requestVolumeThreshold"><a href="#circuitBreaker-requestVolumeThreshold" class="headerlink" title="circuitBreaker.requestVolumeThreshold"></a>circuitBreaker.requestVolumeThreshold</h3><p>设置一个rolling window，滑动窗口中，最少要有多少个请求时，才触发开启短路。举例，如果设置为20（默认值），那么在一个10秒的滑动窗口内，如果只有19个请求，即使这19个请求都是异常的，也是不会触发开启短路器的。</p><p>HystrixCommandProperties.Setter()<br>   .withCircuitBreakerRequestVolumeThreshold(int value)</p><p>我们应该根据我们自己的平时的访问流量去设置，而不是用默认值，比如，我们认为平时一般的时候，流量也可以在每秒在QPS 100，10秒的滑动窗口就是1000，一般可以设置600或者800一个值，需要根据自己的系统的流量去设置。假如你设置的太少了，或者太多了，都不太合适。举个例子，你设置一个20，结果在晚上最低峰的时候，刚好是30，可能晚上的时候因为访问不频繁，大量的找不到缓存，可能超时频繁了一些，结果直接就给短路了。</p><h3 id="circuitBreaker-errorThresholdPercentage"><a href="#circuitBreaker-errorThresholdPercentage" class="headerlink" title="circuitBreaker.errorThresholdPercentage"></a>circuitBreaker.errorThresholdPercentage</h3><p>设置异常请求量的百分比，当异常请求达到这个百分比时，就触发打开短路器，默认是50，也就是50%</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerErrorThresholdPercentage(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure><p>我们最好还是自己定制，自己设置，如果是要50%的时候才短路的话，会有什么情况呢?10%短路，也不太靠谱，90%异常，才短路也不行。这个值可以稍微高一些，如果redis集群彻底崩溃，那么基本上就是所有的请求，100%都会异常，所以一般设置60%，70%。也有可能偶然出现网络的抖动，导致比如说就这10秒钟，访问延时高了一些，其实可能并不需要立即就短路，可能下个10秒马上就恢复了。</p><p>金融支付类的接口，可能这个比例就会设置的很低，因为对异常系统必须要很敏感，可能就是10%异常了，就直接短路了，不让继续访问了。金融支付类的接口是很重要的，而且必须是很稳定，我们不能容忍任何的延迟或者是报错。一旦支付类的接口，有10%的异常的话，我们基本就可以认为这个接口已经出问题了，再继续访问的话，也许访问的就是有问题的接口，可能造成资金的错乱，给公司造成损失。所以直接熔断吧，不让访问了，走降级策略，这就是对整个系统的一个安全性保障。</p><h3 id="circuitBreaker-sleepWindowInMilliseconds"><a href="#circuitBreaker-sleepWindowInMilliseconds" class="headerlink" title="circuitBreaker.sleepWindowInMilliseconds"></a>circuitBreaker.sleepWindowInMilliseconds</h3><p>设置在短路之后，需要在多长时间内直接reject请求，然后在这段时间之后，再重新导half-open状态，尝试允许请求通过以及自动恢复，默认值是5000毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerSleepWindowInMilliseconds(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure><p>如果redis集群崩溃了，会在5s内就直接恢复。</p><h1 id="Hystrix保护源服务，防止Mysql崩溃"><a href="#Hystrix保护源服务，防止Mysql崩溃" class="headerlink" title="Hystrix保护源服务，防止Mysql崩溃"></a>Hystrix保护源服务，防止Mysql崩溃</h1><p>做缓存服务，redis集群彻底崩溃的时候，除了对redis本身做资源隔离、超时控制、熔断策略。还要保护源服务，因为Redis集群崩溃后，大量的请求会高并发会去访问源服务-商品服务（提供商品数据）。如果QPS10000去访问商品服务，基于mysql去查询，那mysql肯定会挂掉，商品服务也就死掉了。</p><p>所以要对商品服务这种源服务的访问施加限流的措施，限流怎么限，hystrix本身就是提供了两种机制，线程池（内部做了异步化处理，可以处理超时），semaphore（信号量，让tomcat线程执行运行逻辑，没有内部的异步化处理，一旦超时，会导致tomcat线程就hang住了）。</p><p>一般推荐线程池用来做有网络访问的这种资源隔离，因为涉及到网络，就很容易超时；sempahore是用来做对服务纯内存的一些复杂业务逻辑的操作进行限流，因为不涉及网络访问，就是纯粹为了避免说对内存内的复杂业务逻辑进行太高并发的访问，造成系统本身的故障。semaphore在以下情况是很合适的：比如一些推荐、搜索，有部分算法，复杂的算法，是放在服务内部纯内存去运行的，一个服务暴露出来的就是某个算法的执行。</p><p>我们这里是访问外部的商品服务，所以还是用线程池做限流，需要算一下，要限多少，怎么限？</p><p>假设每次商品服务的访问性能在200ms，1个线程一秒可以执行5次访问，假设我们一个缓存服务实例对这个商品服务的访问每秒在150次。所以这个时候，我们就需要30个线程，每个线程每秒可以访问5次，总共每秒30个线程可以访问150次。</p><p>我们算的这个每秒150次访问时正常情况下，如果是非正常情况下，每秒1000次，甚至1w次，此时就可以自然限流，因为我们的线程池就30个。在非正常情况下，直接线程池+等待队列全满，此时就会出现大量的reject操作，然后就会去调用降级逻辑。接着我们要做限流，设置的就是线程池的大小，还有等待队列的大小，30个线程可以每秒处理150个请求，但是偶尔会多一些出来，同时30个线程处理150个请求会快一些，不用花费1秒钟，等待队列给一些buffer，不要偶尔1秒钟来了200条请求，50条直接给reject掉了。等待队列设置150个，30个线程直接500ms处理完了，等待队列中的50个请求就可以继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ProductInfoService"</span>))</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"GetProductInfoPool"</span>))</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">12</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">8</span>)</span><br><span class="line">                        .withMaximumSize(<span class="number">30</span>)</span><br><span class="line">                        .withAllowMaximumSizeToDivergeFromCoreSize(<span class="keyword">true</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">1</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">50</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">100</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        <span class="comment">// 多少个请求以上才会判断断路器是否需要开启。</span></span><br><span class="line">                        .withCircuitBreakerRequestVolumeThreshold(<span class="number">30</span>)</span><br><span class="line">                        <span class="comment">// 错误的请求达到40%的时候就开始断路。</span></span><br><span class="line">                        .withCircuitBreakerErrorThresholdPercentage(<span class="number">40</span>)</span><br><span class="line">                        <span class="comment">// 3秒以后尝试恢复</span></span><br><span class="line">                        .withCircuitBreakerSleepWindowInMilliseconds(<span class="number">4000</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String productInfoJSON = <span class="string">"&#123;\"id\": "</span> + productId + <span class="string">", \"name\": \"iphone7手机\", \"price\": 5599, \"pictureList\":\"a.jpg,b.jpg\", \"specification\": \"iphone7的规格\", \"service\": \"iphone7的售后服务\", \"color\": \"红色,白色,黑色\", \"size\": \"5.5\", \"shopId\": 1, \"modifiedTime\": \"2017-01-01 12:01:00\"&#125;"</span>;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.parseObject(productInfoJSON, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源服务fallback降级机制"><a href="#源服务fallback降级机制" class="headerlink" title="源服务fallback降级机制"></a>源服务fallback降级机制</h2><p>现在nginx本地缓存没有，redis集群崩溃，ehcache也找不到这条数据对应的缓存，只能去源头服务里面查询，但是查询的请求又被限流了，现在请求到了这里，被限流了以后只能走降级逻辑。</p><p>这里的一种降级机制叫做<a href="http://www.saily.top/2018/04/15/hystrix03/">stubbed fallback降级机制</a>（残缺的降级），就是用请求参数中少量的数据，加上纯内存中缓存的少量的数据来提供残缺的数据服务。</p><h1 id="缓存雪崩预防和解决方案回顾"><a href="#缓存雪崩预防和解决方案回顾" class="headerlink" title="缓存雪崩预防和解决方案回顾"></a>缓存雪崩预防和解决方案回顾</h1><ol><li><p>事前，redis高可用性，redis cluster，sentinal，复制，主从，从-&gt;主，双机房部署</p></li><li><p>事中，ehcache可以扛一扛，redis挂掉之后的资源隔离、超时控制、熔断，商品服务的访问限流、多级降级，缓存服务在雪崩场景下存活下来，基于ehcache和存活的商品服务提供数据</p></li><li><p>事后，快速恢复Redis，备份+恢复，快速的缓存预热的方案</p></li></ol><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>如果一直访问的根本不存在的时候，那么就会导致缓存穿透，所有的这种请求都会直接到mysql这边来。</p><p><img src="/img/cache/缓存穿透的现象.png" alt="缓存穿透的现象"></p><p>缓存穿透的解决方案其实非常简单，就是如果从源服务（商品服务）查询到的数据是空，就说明这个数据根本就不存在。那么如果这个数据不存在的话，我们也往redis和ehcache等缓存中写入一个数据，可以写入一个空的数据，比如说空的productInfo的json串，给nginx也是，返回一个空的productInfo的json串。</p><p>我们有异步监听数据变更的机制在里面，如果数据变更的话，某个数据本来是没有的，可能会导致缓存穿透，所以我们给了个空数据，但是现在这个数据有了，我们接收到这个变更的消息过后，就可以将数据再次从源服务中查询出来，然后设置到各级缓存中去了。</p><h1 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h1><p>之前在nginx中设置本地的缓存的时候，给了一个过期的时间（10分钟）。10分钟以后自动过期，过期了以后，就会重新从redis中去获取数据。10分钟到期自动过期，就叫做缓存的失效。如果缓存失效以后，那么实际上此时，就会有大量的请求回到redis中去查询。</p><p>如果说同一时间来了1000个请求，都将缓存cache在了nginx自己的本地，缓存失效的时间都设置了10分钟，那么是不是可能导致10分钟过后，这些数据，就自动全部在同一时间失效了。如果同一时间全部失效，会不会导致说同一时间大量的请求过来，在nginx里找不到缓存数据，全部高并发走到redis上去了。加重大量的网络请求，网络负载也会加重。</p><p>解决方案很简单，就是把10分钟的时间改成一个随机数,随机一个失效的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">math.randomseed(tostring(os.time()):reverse():sub(1, 7))</span><br><span class="line"><span class="built_in">local</span> expireTime = math.random(600, 1200)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程笔记，记录以供以后翻看&lt;/p&gt;
&lt;h1 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h1&gt;&lt;p&gt;缓存雪崩这种场景，缓存架构中非常重要的一个环节，应对缓存雪崩的解决方案，避免缓存雪崩的时候，造成整个系统崩溃，带来巨大的经济损失&lt;/p&gt;
    
    </summary>
    
      <category term="高可用缓存架构实战" scheme="http://www.saily.top/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="多级缓存架构" scheme="http://www.saily.top/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix监控和运维</title>
    <link href="http://www.saily.top/2018/06/10/hystrix04/"/>
    <id>http://www.saily.top/2018/06/10/hystrix04/</id>
    <published>2018-06-10T10:03:59.000Z</published>
    <updated>2018-08-25T08:18:24.841Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="为什么需要监控与报警？"><a href="#为什么需要监控与报警？" class="headerlink" title="为什么需要监控与报警？"></a>为什么需要监控与报警？</h3><p>HystrixCommand执行的时候，会生成一些执行耗时等方面的统计信息。这些信息对于系统的运维来说，是很有帮助的，因为我们通过这些统计信息可以看到整个系统是怎么运行的。hystrix对每个command key都会提供一份metric，而且是秒级统计粒度的。<br><a id="more"></a><br>这些统计信息，无论是单独看，还是聚合起来看，都是很有用的。如果将一个请求中的多个command的统计信息拿出来单独查看，包括耗时的统计，对debug系统是很有帮助的。聚合起来的metric对于系统层面的行为来说，是很有帮助的，很适合做报警或者报表。hystrix dashboard就很适合。</p><h3 id="hystrix的事件类型"><a href="#hystrix的事件类型" class="headerlink" title="hystrix的事件类型"></a>hystrix的事件类型</h3><p>对于hystrix command来说，只会返回一个值，execute只有一个event type，fallback也只有一个event type，那么返回一个SUCCESS就代表着命令执行的结束</p><p>对于hystrix observable command来说，多个值可能被返回，所以emit event代表一个value被返回，success代表成功，failure代表异常</p><h4 id="execute-event-type"><a href="#execute-event-type" class="headerlink" title="execute event type"></a>execute event type</h4><p>EMIT                    observable command返回一个value<br>SUCCESS                 完成执行，并且没有报错<br>FAILURE                    执行时抛出了一个异常，会触发fallback<br>TIMEOUT                    开始执行了，但是在指定时间内没有完成执行，会触发fallback<br>BAD_REQUEST                执行的时候抛出了一个HystrixBadRequestException<br>SHORT_CIRCUITED            短路器打开了，触发fallback<br>THREAD_POOL_REJECTED    线程成的容量满了，被reject，触发fallback<br>SEMAPHORE_REJECTED        信号量的容量满了，被reject，触发fallback</p><h4 id="fallback-event-type"><a href="#fallback-event-type" class="headerlink" title="fallback event type"></a>fallback event type</h4><p>FALLBACK_EMIT            observable command，fallback value被返回了<br>FALLBACK_SUCCESS        fallback逻辑执行没有报错<br>FALLBACK_FAILURE        fallback逻辑抛出了异常，会报错<br>FALLBACK_REJECTION        fallback的信号量容量满了，fallback不执行，报错<br>FALLBACK_MISSING        fallback没有实现，会报错</p><h4 id="其他的event-type"><a href="#其他的event-type" class="headerlink" title="其他的event type"></a>其他的event type</h4><p>EXCEPTION_THROWN        command生命自周期是否抛出了异常<br>RESPONSE_FROM_CACHE        command是否在cache中查找到了结果<br>COLLAPSED                command是否是一个合并batch中的一个</p><h4 id="thread-pool-event-type"><a href="#thread-pool-event-type" class="headerlink" title="thread pool event type"></a>thread pool event type</h4><p>EXECUTED                线程池有空间，允许command去执行了<br>REJECTED                 线程池没有空间，不允许command执行，reject掉了</p><h4 id="collapser-event-type"><a href="#collapser-event-type" class="headerlink" title="collapser event type"></a>collapser event type</h4><p>BATCH_EXECUTED            collapser合并了一个batch，并且执行了其中的command<br>ADDED_TO_BATCH            command加入了一个collapser batch<br>RESPONSE_FROM_CACHE        没有加入batch，而是直接取了request cache中的数据</p><h3 id="metric-storage"><a href="#metric-storage" class="headerlink" title="metric storage"></a>metric storage</h3><p>metric被生成之后，就会按照一段时间来存储，存储了一段时间的数据才会推送到其他系统中，比如hystrix dashboard。</p><p>另外一种方式，就是每次生成metric就实时推送metric流到其他地方，但是这样的话，会给系统带来很大的压力。</p><p>hystrix的方式是将metric写入一个内存中的数据结构中，在一段时间之后就可以查询到，hystrix 1.5x之后，采取的是为每个command key都生成一个start event和completion event流，而且可以订阅这个流。每个thread pool key也是一样的，包括每个collapser key也是一样的。</p><p>每个command的event是发送给一个线程安全的RxJava中的rx.Subject，因为是线程安全的，所以不需要进行线程同步。</p><p>因此每个command级别的，threadpool级别的，每个collapser级别的，event都会发送到对应的RxJava的rx.Subject对象中。这些rx.Subject对象接着就会被暴露出Observable接口，可以被订阅。</p><h3 id="metric统计相关的配置"><a href="#metric统计相关的配置" class="headerlink" title="metric统计相关的配置"></a>metric统计相关的配置</h3><h4 id="metrics-rollingStats-timeInMilliseconds"><a href="#metrics-rollingStats-timeInMilliseconds" class="headerlink" title="metrics.rollingStats.timeInMilliseconds"></a>metrics.rollingStats.timeInMilliseconds</h4><p>设置统计的rolling window，单位是毫秒，hystrix只会维持这段时间内的metric供短路器统计使用</p><p>这个属性是不允许热修改的，默认值是10000，就是10秒钟</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingStatisticalWindowInMilliseconds(int value)</p><h4 id="metrics-rollingStats-numBuckets"><a href="#metrics-rollingStats-numBuckets" class="headerlink" title="metrics.rollingStats.numBuckets"></a>metrics.rollingStats.numBuckets</h4><p>该属性设置每个滑动窗口被拆分成多少个bucket，而且滑动窗口对这个参数必须可以整除，同样不允许热修改</p><p>默认值是10，也就是说，每秒钟是一个bucket</p><p>随着时间的滚动，比如又过了一秒钟，那么最久的一秒钟的bucket就会被丢弃，然后新的一秒的bucket会被创建</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingStatisticalWindowBuckets(int value)</p><h4 id="metrics-rollingPercentile-enabled"><a href="#metrics-rollingPercentile-enabled" class="headerlink" title="metrics.rollingPercentile.enabled"></a>metrics.rollingPercentile.enabled</h4><p>控制是否追踪请求耗时，以及通过百分比方式来统计，默认是true</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileEnabled(boolean value)</p><h4 id="metrics-rollingPercentile-timeInMilliseconds"><a href="#metrics-rollingPercentile-timeInMilliseconds" class="headerlink" title="metrics.rollingPercentile.timeInMilliseconds"></a>metrics.rollingPercentile.timeInMilliseconds</h4><p>设置rolling window被持久化保存的时间，这样才能计算一些请求耗时的百分比，默认是60000，60s，不允许热修改</p><p>相当于是一个大的rolling window，专门用于计算请求执行耗时的百分比</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileWindowInMilliseconds(int value)</p><h4 id="metrics-rollingPercentile-numBuckets"><a href="#metrics-rollingPercentile-numBuckets" class="headerlink" title="metrics.rollingPercentile.numBuckets"></a>metrics.rollingPercentile.numBuckets</h4><p>设置rolling percentile window被拆分成的bucket数量，上面那个参数除以这个参数必须能够整除，不允许热修改</p><p>默认值是6，也就是每10s被拆分成一个bucket</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileWindowBuckets(int value)</p><h4 id="metrics-rollingPercentile-bucketSize"><a href="#metrics-rollingPercentile-bucketSize" class="headerlink" title="metrics.rollingPercentile.bucketSize"></a>metrics.rollingPercentile.bucketSize</h4><p>设置每个bucket的请求执行次数被保存的最大数量，如果在一个bucket内，执行次数超过了这个值，那么就会重新覆盖从bucket的开始再写</p><p>举例来说，如果bucket size设置为100，而且每个bucket代表一个10秒钟的窗口，但是在这个bucket内发生了500次请求执行，那么这个bucket内仅仅会保留100次执行</p><p>如果调大这个参数，就会提升需要耗费的内存，来存储相关的统计值，不允许热修改</p><p>默认值是100</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileBucketSize(int value)</p><h4 id="metrics-healthSnapshot-intervalInMilliseconds"><a href="#metrics-healthSnapshot-intervalInMilliseconds" class="headerlink" title="metrics.healthSnapshot.intervalInMilliseconds"></a>metrics.healthSnapshot.intervalInMilliseconds</h4><p>控制成功和失败的百分比计算，与影响短路器之间的等待时间，默认值是500毫秒</p><p>HystrixCommandProperties.Setter()<br>   .withMetricsHealthSnapshotIntervalInMilliseconds(int value)</p><h2 id="监控部署"><a href="#监控部署" class="headerlink" title="监控部署"></a>监控部署</h2><p>找到之前的eshop-cache-ha项目，引入配置：</p><p><a href="https://github.com/sail-y/eshop-cache-ha" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache-ha</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-metrics-event-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再注册一个servlet的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">indexServletRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> HystrixMetricsStreamServlet());</span><br><span class="line">    registration.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tomcat</strong></p><p>准备一个tomcat部署HystrixDashboard，网上下载一个<code>hystrix-dashboard-1.5.12.war</code>，再装一个turbin，turbin是用来监控一个集群的，可以将一个集群的所有机器都配置在这里。</p><p>在/WEB-INF/classes下添加一个配置文件，告诉turbin需要监控哪些实例。</p><p><strong>config.properties</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">turbine.ConfigPropertyBasedDiscovery.default.instances=localhost</span><br><span class="line">turbine.instanceUrlSuffix=:8081/hystrix.stream</span><br></pre></td></tr></table></figure><p><img src="/img/hystrix/hystrix-running.png" alt=""></p><p>然后启动我们自己的<code>eshop-cache-ha</code>项目，</p><p>访问页面查看</p><p><a href="http://localhost:8080/hystrix-dashboard/" target="_blank" rel="noopener">http://localhost:8080/hystrix-dashboard/</a></p><p>填入我们要监控的URL.</p><p><img src="/img/hystrix/hystrix-running2.png" alt=""></p><p><a href="http://localhost:8081/hystrix.stream，监控单个机器" target="_blank" rel="noopener">http://localhost:8081/hystrix.stream，监控单个机器</a></p><p><a href="http://localhost:8080/turbine/turbine.stream，监控整个集群" target="_blank" rel="noopener">http://localhost:8080/turbine/turbine.stream，监控整个集群</a></p><p>现在还看不到什么东西，我们对项目发送几个请求，再看看效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控请求测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=1"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/hystrix/hystrix-running3.png" alt=""></p><p>hystrix的dashboard可以支持实时监控metric</p><p>netflix开始用这个dashboard的时候，大幅度优化了工程运维的操作，帮助节约了恢复系统的时间。大多数生产系统的故障持续时间变得很短，而且影响幅度小了很多，主要是因为hystrix dashborad提供了可视化的监控。</p><p>截图说明，dashboard上的指标都是什么？</p><p>圆圈的颜色和大小代表了健康状况以及流量，折线代表了最近2分钟的请求流量</p><p>集群中的机器数量，请求延时的中位数以及平均值</p><p>最近10秒内的异常请求比例，请求QPS，每台机器的QPS，以及整个集群的QPS</p><p>断路器的状态</p><p>最近一分钟的请求延时百分比，TP90，TP99，TP99.5</p><p>几个有颜色的数字，代表了最近10秒钟的统计，以1秒钟为粒度</p><p>成功的请求数量，绿颜色的数字; 短路的请求数量，蓝色的数字; timeout超时的请求数量，黄色的数字; 线程池reject的请求数量，紫色的数字; 请求失败，抛出异常的请求数量，红色的数字</p><h2 id="生产环境运维"><a href="#生产环境运维" class="headerlink" title="生产环境运维"></a>生产环境运维</h2><p>如果发现了严重的依赖调用延时，先不用急着去修改配置，如果一个command被限流了，可能本来就应该限流</p><p>在netflix早期的时候，经常会有人在发现短路器因为访问延时发生的时候，去热修改一些配置，比如线程池大小，队列大小，超时时长，等等，给更多的资源，但是这其实是不对的。</p><p>如果我们之前对系统进行了良好的配置，然后现在在高峰期，系统在进行线程池reject，超时，短路，那么此时我们应该集中精力去看底层根本的原因，而不是调整配置</p><p>为什么在高峰期，一个10个线程的线程池，搞不定这些流量呢？那就是代码写的太烂了，可以使用异步，或者更好的算法。</p><p>千万不要急于给你的依赖调用过多的资源，比如线程池大小，队列大小，超时时长，信号量容量，等等，因为这可能导致我们自己对自己的系统进行DDOS攻击。</p><p>举例来说，想象一下，我们现在有100台服务器组成的集群，每台机器有10个线程大小的线程池去访问一个服务，那么我们对那个服务就有1000个线程资源去访问了，在正常情况下，可能只会用到其中200~300个线程去访问那个后端服务。但是如果再高峰期出现了访问延时，可能导致1000个线程全部被调用去访问那个后端服务，如果我们调整到每台服务器20个线程呢？</p><p>如果因为你的代码等问题导致访问延时，即使有20个线程可能还是会导致线程池资源被占满，此时就有2000个线程去访问后端服务，可能对后端服务就是一场灾难。</p><p>这就是断路器的作用了，如果我们把后端服务打死了，或者产生了大量的压力，有大量的timeout和reject，那么就自动短路，一段时间后，等流量洪峰过去了，再重启访问。</p><p>简单来说，让系统自己去限流，短路，超时，以及reject，直到系统重新变得正常了，就是不要随便乱改资源配置，不要随便乱增加线程池大小，等待队列大小，异常情况是正常的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h2 id=&quot;监控&quot;&gt;&lt;a href=&quot;#监控&quot; class=&quot;headerlink&quot; title=&quot;监控&quot;&gt;&lt;/a&gt;监控&lt;/h2&gt;&lt;h3 id=&quot;为什么需要监控与报警？&quot;&gt;&lt;a href=&quot;#为什么需要监控与报警？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要监控与报警？&quot;&gt;&lt;/a&gt;为什么需要监控与报警？&lt;/h3&gt;&lt;p&gt;HystrixCommand执行的时候，会生成一些执行耗时等方面的统计信息。这些信息对于系统的运维来说，是很有帮助的，因为我们通过这些统计信息可以看到整个系统是怎么运行的。hystrix对每个command key都会提供一份metric，而且是秒级统计粒度的。&lt;br&gt;
    
    </summary>
    
      <category term="hystrix" scheme="http://www.saily.top/categories/hystrix/"/>
    
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch02-快速入门</title>
    <link href="http://www.saily.top/2018/06/05/elasticSearch02/"/>
    <id>http://www.saily.top/2018/06/05/elasticSearch02/</id>
    <published>2018-06-05T14:34:18.000Z</published>
    <updated>2018-08-25T08:13:14.589Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="环境准备和安装"><a href="#环境准备和安装" class="headerlink" title="环境准备和安装"></a>环境准备和安装</h2><ol><li>安装JDK，至少1.8.0_73以上版本，java -version</li><li>下载和解压缩Elasticsearch安装包（<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0）" target="_blank" rel="noopener">https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0）</a><a id="more"></a></li><li><p>启动Elasticsearch：bin\elasticsearch，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂的，直接启动就可以用了。</p><p> <img src="/img/es/02/es_start.png" alt=""></p></li><li><p>检查ES是否启动成功：<a href="http://localhost:9200/?pretty" target="_blank" rel="noopener">http://localhost:9200/?pretty</a></p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">name: node名称</span><br><span class="line">cluster_name: 集群名称（默认的集群名称就是elasticsearch）</span><br><span class="line">version.number: 5.2.0，es版本号</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"4onsTYV"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"nKZ9VK_vQdSQ1J0Dx9gx1Q"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"5.2.0"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"24e05b9"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2017-01-24T19:52:35.800Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"6.4.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改集群名称：elasticsearch.yml</p><p> 修改<code>elasticsearch.yml</code>里面的<code>cluster.name: my-application</code>即可。</p></li><li><p>下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口</p><p> <a href="https://www.elastic.co/downloads/past-releases/kibana-5-2-0" target="_blank" rel="noopener">https://www.elastic.co/downloads/past-releases/kibana-5-2-0</a></p><p> <img src="/img/es/02/kibana_start.png" alt=""></p><p> 访问<a href="http://localhost:5601/，使用devtools进行测试和开发" target="_blank" rel="noopener">http://localhost:5601/，使用devtools进行测试和开发</a></p><p> <img src="/img/es/02/kibana_health.png" alt="GET _cluster/health">    </p></li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>学习一门新技术，搭建好环境后第一件事当然是做个helloworld的demo，我们来做个crud</p><h3 id="document数据格式"><a href="#document数据格式" class="headerlink" title="document数据格式"></a>document数据格式</h3><ol><li>es的数据结构存储模式，熟悉mongodb的人应该知道，他们的数据结构是差不多的，都是面向文档的，一条数据就是一个json。</li><li>对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦。</li><li>ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> EmployeeInfo info;</span><br><span class="line">  <span class="keyword">private</span> Date joinDate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeInfo</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String bio; <span class="comment">// 性格</span></span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> String[] interests; <span class="comment">// 兴趣爱好</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EmployeeInfo info = <span class="keyword">new</span> EmployeeInfo();</span><br><span class="line">info.setBio(<span class="string">"curious and modest"</span>);</span><br><span class="line">info.setAge(<span class="number">30</span>);</span><br><span class="line">info.setInterests(<span class="keyword">new</span> String[]&#123;<span class="string">"bike"</span>, <span class="string">"climb"</span>&#125;);</span><br><span class="line"></span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.setEmail(<span class="string">"zhangsan@sina.com"</span>);</span><br><span class="line">employee.setFirstName(<span class="string">"san"</span>);</span><br><span class="line">employee.setLastName(<span class="string">"zhang"</span>);</span><br><span class="line">employee.setInfo(info);</span><br><span class="line">employee.setJoinDate(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>上述代码，在mysql中，肯定就是两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据<br>employee表：email，first_name，last_name，join_date，4个字段<br>employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表</p><h3 id="demo背景"><a href="#demo背景" class="headerlink" title="demo背景"></a>demo背景</h3><p>有一个电商网站，需要为其基于ES构建一个后台系统，提供以下功能：</p><ol><li>对商品信息进行CRUD（增删改查）操作</li><li>执行简单的结构化查询</li><li>可以执行简单的全文检索，以及复杂的phrase（短语）检索</li><li>对于全文检索的结果，可以进行高亮显示</li><li>对数据进行简单的聚合分析</li></ol><h3 id="简单的集群管理"><a href="#简单的集群管理" class="headerlink" title="简单的集群管理"></a>简单的集群管理</h3><h4 id="快速检查集群的健康状况"><a href="#快速检查集群的健康状况" class="headerlink" title="快速检查集群的健康状况"></a>快速检查集群的健康状况</h4><p>es提供了一套api，叫做cat api，可以查看es中各种各样的数据</p><p><code>GET /_cat/health?v</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1528602515 11:48:35  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br></pre></td></tr></table></figure><p><strong>如何快速了解集群的健康状况？green、yellow、red？</strong></p><ul><li>green：每个索引的primary shard和replica shard都是active状态的</li><li>yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li><li>red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li></ul><p>为什么现在会处于一个yellow状态？</p><p>我们现在就一个笔记本电脑，就启动了一个es进程，相当于就只有一个node。现在es中有一个index，就是kibana自己内置建立的index。由于默认的配置是给每个index分配5个primary shard和5个replica shard，而且primary shard和replica shard不能在同一台机器上（为了容错）。现在kibana自己建立的index是1个primary shard和1个replica shard。当前就一个node，所以只有1个primary shard被分配了和启动了，但是一个replica shard没有第二台机器去启动。</p><p>做一个小实验：此时只要启动第二个es进程，就会在es集群中有2个node，然后那1个replica shard就会自动分配过去，然后cluster status就会变成green状态。</p><h4 id="快速查看集群中有哪些索引"><a href="#快速查看集群中有哪些索引" class="headerlink" title="快速查看集群中有哪些索引"></a>快速查看集群中有哪些索引</h4><p>GET /_cat/indices?v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   .kibana T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br></pre></td></tr></table></figure><h4 id="简单的索引操作"><a href="#简单的索引操作" class="headerlink" title="简单的索引操作"></a>简单的索引操作</h4><p>创建索引：PUT /test_index?pretty</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">health status index      uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   test_index cyS7pUwcQKmvTFtUCGNgHg   5   1          0            0       650b           650b</span><br><span class="line">yellow open   .kibana    T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">删除索引：DELETE /test_index?pretty</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   .kibana T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br></pre></td></tr></table></figure><h3 id="商品的CRUD操作"><a href="#商品的CRUD操作" class="headerlink" title="商品的CRUD操作"></a>商品的CRUD操作</h3><h4 id="新增商品：新增文档，建立索引"><a href="#新增商品：新增文档，建立索引" class="headerlink" title="新增商品：新增文档，建立索引"></a>新增商品：新增文档，建立索引</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PUT /ecommerce/product/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"gaolujie yagao"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"gaoxiao meibai"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"producer"</span> :      <span class="string">"gaolujie producer"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"meibai"</span>, <span class="string">"fangzhu"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /ecommerce/product/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"jiajieshi yagao"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"youxiao fangzhu"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"producer"</span> :      <span class="string">"jiajieshi producer"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"fangzhu"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /ecommerce/product/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"zhonghua yagao"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"caoben zhiwu"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">40</span>,</span><br><span class="line">    <span class="attr">"producer"</span> :      <span class="string">"zhonghua producer"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"qingxin"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询商品：检索文档"><a href="#查询商品：检索文档" class="headerlink" title="查询商品：检索文档"></a>查询商品：检索文档</h4><p>GET /index/type/id</p><p>GET /ecommerce/product/1</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"gaolujie yagao"</span>,</span><br><span class="line">    <span class="attr">"desc"</span>: <span class="string">"gaoxiao meibai"</span>,</span><br><span class="line">    <span class="attr">"price"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"producer"</span>: <span class="string">"gaolujie producer"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [</span><br><span class="line">      <span class="string">"meibai"</span>,</span><br><span class="line">      <span class="string">"fangzhu"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">#### 修改商品：替换文档</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">PUT /ecommerce/product/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"jiaqiangban gaolujie yagao"</span>,</span><br><span class="line">    <span class="attr">"desc"</span> :  <span class="string">"gaoxiao meibai"</span>,</span><br><span class="line">    <span class="attr">"price"</span> :  <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"producer"</span> :      <span class="string">"gaolujie producer"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: [ <span class="string">"meibai"</span>, <span class="string">"fangzhu"</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换方式有一个不好，即使必须带上所有的field，才能去进行信息的修改，否则文档的数据结构会被修改。</p><h4 id="修改商品：更新文档"><a href="#修改商品：更新文档" class="headerlink" title="修改商品：更新文档"></a>修改商品：更新文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST /ecommerce/product/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"jiaqiangban gaolujie yagao"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除商品：删除文档"><a href="#删除商品：删除文档" class="headerlink" title="删除商品：删除文档"></a>删除商品：删除文档</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELETE /ecommerce/product/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"ecommerce"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"product"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"deleted"</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多种搜索方式"><a href="#多种搜索方式" class="headerlink" title="多种搜索方式"></a>多种搜索方式</h3><p>上面做了CRUD，接下里就是ES里最重要的搜索部分。</p><h4 id="query-string-search"><a href="#query-string-search" class="headerlink" title="query string search"></a>query string search</h4><p>搜索全部商品：GET /ecommerce/product/_search</p><p><img src="/img/es/02/kibana_search01.png" alt=""></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">took：耗费了几毫秒</span><br><span class="line">timed_out：是否超时，这里没有</span><br><span class="line">_shards：数据拆成了5个分片，所以对于搜索请求，会分配所有的primary shard（或者是它的某个replica shard）</span><br><span class="line">hits.total：查询结果的数量，3个document</span><br><span class="line">hits.max_score：score的含义，就是document对于一个search的相关度的匹配分数，越相关，就越匹配，分数也高</span><br><span class="line">hits.hits：包含了匹配搜索的document的详细数据</span><br></pre></td></tr></table></figure><p>query string search的由来，因为search参数都是以http请求的query string来附带的(也就是?后面的)</p><p>搜索商品名称中包含yagao的商品，而且按照售价降序排序：</p><p><code>GET /ecommerce/product/_search?q=name:yagao&amp;sort=price:desc</code></p><p>适用于临时的在命令行使用一些工具，比如curl，快速的发出请求，来检索想要的信息；但是如果查询请求很复杂，是很难去构建的。在生产环境中，几乎很少使用query string search</p><h4 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h4><p>DSL：Domain Specified Language，特定领域的语言。<br>http request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了</p><p><strong>查询所有的商品</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123; <span class="attr">"match_all"</span>: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询名称包含yagao的商品，同时按照价格降序排序</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"yagao"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123; <span class="attr">"price"</span>: <span class="string">"desc"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123; <span class="attr">"match_all"</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定要查询出来商品的名称和价格就可以</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123; <span class="attr">"match_all"</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>, <span class="string">"price"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加适合生产环境的使用，可以构建复杂的查询。</p><h4 id="query-filter"><a href="#query-filter" class="headerlink" title="query filter"></a>query filter</h4><p>搜索商品名称包含yagao，而且售价大于25元的商品</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : &#123;</span><br><span class="line">                <span class="attr">"match"</span> : &#123;</span><br><span class="line">                    <span class="attr">"name"</span> : <span class="string">"yagao"</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123; <span class="attr">"gt"</span> : <span class="number">25</span> &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="full-text-search（全文检索）"><a href="#full-text-search（全文检索）" class="headerlink" title="full-text search（全文检索）"></a>full-text search（全文检索）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"producer"</span> : <span class="string">"yagao producer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为查询了2个单词，producer这个字段，会先被拆解，建立倒排索引。</p><p>在分词以后，只要任意命中其中一个单词，都会被查询出来，如果2个单词都命中会排在前面。</p><h4 id="phrase-search（短语搜索）"><a href="#phrase-search（短语搜索）" class="headerlink" title="phrase search（短语搜索）"></a>phrase search（短语搜索）</h4><p>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回。</p><p>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"producer"</span> : <span class="string">"yagao producer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="highlight-search（高亮搜索结果）"><a href="#highlight-search（高亮搜索结果）" class="headerlink" title="highlight search（高亮搜索结果）"></a>highlight search（高亮搜索结果）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"producer"</span> : <span class="string">"producer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">        <span class="attr">"fields"</span> : &#123;</span><br><span class="line">            <span class="attr">"producer"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合分析快速入门"><a href="#聚合分析快速入门" class="headerlink" title="聚合分析快速入门"></a>聚合分析快速入门</h3><h4 id="计算每个tag下的商品数量"><a href="#计算每个tag下的商品数量" class="headerlink" title="计算每个tag下的商品数量"></a>计算每个tag下的商品数量</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"group_by_tags"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123; <span class="attr">"field"</span>: <span class="string">"tags"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/es/02/aggs_error.png" alt=""></p><p>报错了，text类型的字段默认不支持聚合，得做个操作让它支持聚合，将文本field的fielddata属性设置为true。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">PUT /ecommerce/_mapping/product</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"tags"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="attr">"fielddata"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再测试一次聚合查询，就好了</p><p><img src="/img/es/02/aggs_normal.png" alt=""></p><h4 id="对名称中包含yagao的商品，计算每个tag下的商品数量"><a href="#对名称中包含yagao的商品，计算每个tag下的商品数量" class="headerlink" title="对名称中包含yagao的商品，计算每个tag下的商品数量"></a>对名称中包含yagao的商品，计算每个tag下的商品数量</h4><p>在聚合分析的基础上加上条件筛选</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"yagao"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"all_tags"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"tags"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先分组，再算每组的平均值，计算每个tag下的商品的平均价格"><a href="#先分组，再算每组的平均值，计算每个tag下的商品的平均价格" class="headerlink" title="先分组，再算每组的平均值，计算每个tag下的商品的平均价格"></a>先分组，再算每组的平均值，计算每个tag下的商品的平均价格</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"group_by_tags"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"tags"</span> &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                    <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max_score"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"hits"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">    <span class="attr">"group_by_tags"</span>: &#123;</span><br><span class="line">      <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"buckets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"fangzhu"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">27.5</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"meibai"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"qingxin"</span>,</span><br><span class="line">          <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">40</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"><a href="#计算每个tag下的商品的平均价格，并且按照平均价格降序排序" class="headerlink" title="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"></a>计算每个tag下的商品的平均价格，并且按照平均价格降序排序</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"all_tags"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"tags"</span>, <span class="attr">"order"</span>: &#123; <span class="attr">"avg_price"</span>: <span class="string">"desc"</span> &#125; &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span> : &#123;</span><br><span class="line">                    <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"><a href="#按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格" class="headerlink" title="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"></a>按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"group_by_price"</span>: &#123;</span><br><span class="line">      <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">20</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">40</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">50</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"group_by_tags"</span>: &#123;</span><br><span class="line">          <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"tags"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"average_price"</span>: &#123;</span><br><span class="line">              <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;h2 id=&quot;环境准备和安装&quot;&gt;&lt;a href=&quot;#环境准备和安装&quot; class=&quot;headerlink&quot; title=&quot;环境准备和安装&quot;&gt;&lt;/a&gt;环境准备和安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装JDK，至少1.8.0_73以上版本，java -version&lt;/li&gt;
&lt;li&gt;下载和解压缩Elasticsearch安装包（&lt;a href=&quot;https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0）&lt;/a&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.saily.top/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.saily.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch01-介绍</title>
    <link href="http://www.saily.top/2018/06/03/elasticSearch01/"/>
    <id>http://www.saily.top/2018/06/03/elasticSearch01/</id>
    <published>2018-06-03T03:46:54.000Z</published>
    <updated>2018-08-25T08:13:06.823Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网：<a href="http://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">http://www.elastic.co/products/elasticsearch</a></p><p>系列文章版本基于ElasticSearch5.2</p><h2 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch"></a>什么是Elasticsearch</h2><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p><a id="more"></a><h3 id="什么是搜索？"><a href="#什么是搜索？" class="headerlink" title="什么是搜索？"></a>什么是搜索？</h3><p>百度：我们比如说想找寻任何的信息的时候，就会上百度去搜索一下，比如说找一部自己喜欢的电影，或者说找一本喜欢的书，或者找一条感兴趣的新闻（提到搜索的第一印象）<br>但是百度 != 搜索，这是不对的</p><p>还有一种是垂直搜索（站内搜索）：</p><p>互联网的搜索：电商网站，招聘网站，新闻网站，各种app<br>IT系统的搜索：OA软件，办公自动化软件，会议管理，日程管理，项目管理，员工管理，搜索“张三”，“张三儿”，“张小三”；有个电商网站，卖家，后台管理系统，搜索“牙膏”，订单，“牙膏相关的订单”</p><p>搜索，就是在任何场景下，找寻你想要的信息，输入一段你要搜索的关键字，期望找到这个关键字相关的有些信息</p><h3 id="如果用数据库做搜索会怎么样？"><a href="#如果用数据库做搜索会怎么样？" class="headerlink" title="如果用数据库做搜索会怎么样？"></a>如果用数据库做搜索会怎么样？</h3><p>做软件开发或者对IT、计算机有一定的了解的话，都知道数据都是存储在数据库里面的，比如说电商网站的商品信息，招聘网站的职位信息，新闻网站的新闻信息，等等。所以说很自然的一点，如果说从技术的角度去考虑，如何实现如电商网站内部的搜索功能，就可以考虑去使用数据库去进行搜索。</p><p><strong>弊端：</strong></p><ol><li>每条记录的指定字段的文本，可能会很长，比如说“商品描述”字段的长度，有长达数千个，甚至数万个字符，这个时候，每次都要对每条记录的所有文本进行扫描，懒判断，包不包含指定的关键词（比如说“牙膏”）</li><li>不能将搜索词拆分开来，尽可能去搜索更多的符合你的期望的结果，比如输入“生化机”，就搜索不出来“生化危机”，也就是没有分词功能。</li></ol><p>而且用数据库来实现搜索，是不太靠谱的。通常来说，性能会很差。</p><h3 id="什么是全文检索和Lucene？"><a href="#什么是全文检索和Lucene？" class="headerlink" title="什么是全文检索和Lucene？"></a>什么是全文检索和Lucene？</h3><ol><li><p>全文检索，倒排索引</p><p> <img src="/img/es/01/什么是全文检索.png" alt=""></p></li><li><p>lucene，就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。另外的话，我们也可以用lucene提供的一些功能和api来针对磁盘上额</p></li></ol><h3 id="什么是Elasticsearch？"><a href="#什么是Elasticsearch？" class="headerlink" title="什么是Elasticsearch？"></a>什么是Elasticsearch？</h3><p><img src="/img/es/01/什么是Elasticsearch.png" alt=""></p><h2 id="Elasticsearch功能介绍"><a href="#Elasticsearch功能介绍" class="headerlink" title="Elasticsearch功能介绍"></a>Elasticsearch功能介绍</h2><h3 id="分布式的搜索引擎和数据分析引擎"><a href="#分布式的搜索引擎和数据分析引擎" class="headerlink" title="分布式的搜索引擎和数据分析引擎"></a>分布式的搜索引擎和数据分析引擎</h3><p>搜索：百度，网站的站内搜索，IT系统的检索</p><p>数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些</p><h3 id="全文检索，结构化检索，数据分析"><a href="#全文检索，结构化检索，数据分析" class="headerlink" title="全文检索，结构化检索，数据分析"></a>全文检索，结构化检索，数据分析</h3><ul><li>全文检索：我想搜索商品名称包含牙膏的商品，<code>select * from products where product_name like &quot;%牙膏%&quot;</code></li><li><p>结构化检索：我想搜索商品分类为日化用品的商品都有哪些，<code>select * from products where category=&#39;日化用品&#39;</code></p><p>  部分匹配、自动完成、搜索纠错、搜索推荐</p></li><li>数据分析：我们分析每一个商品分类下有多少个商品，<code>select category_id,count(*) from products group by category_id</code></li></ul><h3 id="对海量数据进行近实时的处理"><a href="#对海量数据进行近实时的处理" class="headerlink" title="对海量数据进行近实时的处理"></a>对海量数据进行近实时的处理</h3><ul><li>分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索</li><li>海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了</li><li>近实时：如果检索数据要花费1小时（这就不叫近实时，这叫离线批处理，batch-processing）；近实时是在秒级别对数据进行搜索和分析</li></ul><p>跟分布式/海量数据相反：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量</p><h3 id="Elasticsearch的适用场景"><a href="#Elasticsearch的适用场景" class="headerlink" title="Elasticsearch的适用场景"></a>Elasticsearch的适用场景</h3><ol><li>维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐</li><li>The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</li><li>Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</li><li>GitHub（开源代码管理），搜索上千亿行代码</li><li>电商网站，检索商品</li><li>日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）</li><li>商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</li><li>BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</li><li>国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）</li></ol><h3 id="Elasticsearch的特点"><a href="#Elasticsearch的特点" class="headerlink" title="Elasticsearch的特点"></a>Elasticsearch的特点</h3><ol><li>可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司</li><li>Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat）</li><li>对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂</li><li>数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不能提供的很多功能</li></ol><h2 id="ElasticSearch核心概念"><a href="#ElasticSearch核心概念" class="headerlink" title="ElasticSearch核心概念"></a>ElasticSearch核心概念</h2><h3 id="lucene和elasticsearch的前世今生"><a href="#lucene和elasticsearch的前世今生" class="headerlink" title="lucene和elasticsearch的前世今生"></a>lucene和elasticsearch的前世今生</h3><p>elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）</p><ol><li>分布式的文档存储引擎</li><li>分布式的搜索引擎和分析引擎</li><li>分布式海量数据，支持PB级数据</li></ol><p>开箱即用，优秀的默认参数，不需要任何额外设置，完全开源</p><p>关于elasticsearch的一个传说，有一个程序员失业了，陪着自己老婆去英国伦敦学习厨师课程。程序员在失业期间想给老婆写一个菜谱搜索引擎，觉得lucene实在太复杂了，就开发了一个封装了lucene的开源项目，compass。后来程序员找到了工作，是做分布式的高性能项目的，觉得compass不够，就写了elasticsearch，让lucene变成分布式的系统。</p><h3 id="elasticsearch的核心概念"><a href="#elasticsearch的核心概念" class="headerlink" title="elasticsearch的核心概念"></a>elasticsearch的核心概念</h3><ol><li><p>Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级</p><p> <img src="/img/es/01/Elasticsearch近实时概念的解释.png" alt="Elasticsearch近实时概念的解释"></p></li></ol><ol start="2"><li>Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常</li><li>Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群</li><li>Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。</li><li>Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。</li><li><p>Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">商品index，里面存放了所有的商品数据，商品document</span><br><span class="line"></span><br><span class="line">但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field</span><br><span class="line"></span><br><span class="line">type，日化商品type，电器商品type，生鲜商品type</span><br><span class="line"></span><br><span class="line">日化商品type：product_id，product_name，product_desc，category_id，category_name</span><br><span class="line">电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period</span><br><span class="line">生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period</span><br><span class="line"></span><br><span class="line">每一个type里面，都会包含一堆document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;product_id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;product_name&quot;: &quot;长虹电视机&quot;,</span><br><span class="line">  &quot;product_desc&quot;: &quot;4k高清&quot;,</span><br><span class="line">  &quot;category_id&quot;: &quot;3&quot;,</span><br><span class="line">  &quot;category_name&quot;: &quot;电器&quot;,</span><br><span class="line">  &quot;service_period&quot;: &quot;1年&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;product_id&quot;: &quot;3&quot;,</span><br><span class="line">  &quot;product_name&quot;: &quot;基围虾&quot;,</span><br><span class="line">  &quot;product_desc&quot;: &quot;纯天然，冰岛产&quot;,</span><br><span class="line">  &quot;category_id&quot;: &quot;4&quot;,</span><br><span class="line">  &quot;category_name&quot;: &quot;生鲜&quot;,</span><br><span class="line">  &quot;eat_period&quot;: &quot;7天&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li>shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。</li><li><p>replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。</p><p> <img src="/img/es/01/shard和replica的解释.png" alt="shard和replica的解释"></p></li></ol><h3 id="elasticsearch核心概念-vs-数据库核心概念"><a href="#elasticsearch核心概念-vs-数据库核心概念" class="headerlink" title="elasticsearch核心概念 vs. 数据库核心概念"></a>elasticsearch核心概念 vs. 数据库核心概念</h3><table><thead><tr><th>Elasticsearch</th><th style="text-align:center">数据库</th></tr></thead><tbody><tr><td>Document</td><td style="text-align:center">行</td></tr><tr><td>Type</td><td style="text-align:center">表</td></tr><tr><td>Index</td><td style="text-align:center">库</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;http://www.elastic.co/products/elasticsearch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.elastic.co/products/elasticsearch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;系列文章版本基于ElasticSearch5.2&lt;/p&gt;
&lt;h2 id=&quot;什么是Elasticsearch&quot;&gt;&lt;a href=&quot;#什么是Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;什么是Elasticsearch&quot;&gt;&lt;/a&gt;什么是Elasticsearch&lt;/h2&gt;&lt;p&gt;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.saily.top/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.saily.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix高级进阶</title>
    <link href="http://www.saily.top/2018/04/15/hystrix03/"/>
    <id>http://www.saily.top/2018/04/15/hystrix03/</id>
    <published>2018-04-15T02:33:01.000Z</published>
    <updated>2018-09-19T08:32:37.973Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h2 id="请求合并技术"><a href="#请求合并技术" class="headerlink" title="请求合并技术"></a>请求合并技术</h2><p>前面的两篇文章讲解了hystrix的入门，以及它的原理和执行流程。</p><p>之前我们有提到<a href="http://www.saily.top/2018/03/26/hystrix02/#Request-Cache">Request Cache</a>，在一次请求上下文中，如果有多个command，参数都是一样的，调用的接口也是一样的，其实结果可以认为也是一样的。<br><a id="more"></a></p><p>但是如果获取多个商品，需要发送多次网络请求，调用多次接口才能拿到结果。Hystrix还为我们提供了一种叫做请求合并的技术，可以使用HystrixCollapser将多个HystrixCommand合并到一起，多个command放在一个command里面去执行，发送一次网络请求，就拉取到多条数据。用请求合并技术，将多个请求合并起来，可以减少高并发访问下需要使用的线程数量以及网络连接数量，可以提升性能。</p><h3 id="请求合并有多种级别"><a href="#请求合并有多种级别" class="headerlink" title="请求合并有多种级别"></a>请求合并有多种级别</h3><ol><li>global context，tomcat所有调用线程，对一个依赖服务的任何一个command调用都可以被合并在一起，hystrix就传递一个HystrixRequestContext</li><li>user request context，tomcat内某一个调用线程，将某一个tomcat线程对某个依赖服务的多个command调用合并在一起</li><li>object modeling，基于对象的请求合并，如果有几百个对象，遍历后依次调用每个对象的某个方法，可能导致发起几百次网络请求，基于hystrix可以自动将对多个对象模型的调用合并到一起</li></ol><h3 id="请求合并技术的开销有多大"><a href="#请求合并技术的开销有多大" class="headerlink" title="请求合并技术的开销有多大"></a>请求合并技术的开销有多大</h3><p>使用请求合并技术的开销就是导致延迟大幅度增加，因为需要一定的时间将多个请求合并起来。比如发送过来10个请求，每个请求本来大概是2ms可以返回，要把10个请求合并在一个command内，统一一起执行，先后等待一下，可能就需要5ms（延时翻N倍了）。</p><p>所以说，要考量一下使用请求合并技术是否合适，如果一个请求本来耗费的时间就比较长，那么进行请求合并，增加一些延迟影响并不大，这样可以大幅度削减你的线程池的资源耗费，也可以减少后端服务的网络资源开销。如果一个请求本来就很快，用请求合并后反而还变慢了很多倍了，那就没有必要了。</p><blockquote><p>每个请求就2ms，batch，8~10ms，延迟增加了4~5倍</p></blockquote><blockquote><p>每个请求本来就30ms~50ms，batch，35ms~55ms，延迟增加不太明显</p></blockquote><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>批量查询本质上我们还是采用HystrixObservableCommand，HystrixCommand+request cache，依然每个商品发起一次网络请求。</p><p>什么意思？就是一个批量的商品过来以后，我们还是多个command的方式去执行，request collapser+request cache，相同的商品还是就查询一次，不同的商品合并到一起通过一个网络请求得到结果，我们结合之前的request cache开发。</p><p>我们需要开发合并请求的命令，还需要开发一个批量查询商品的接口。</p><h4 id="collapser开发"><a href="#collapser开发" class="headerlink" title="collapser开发"></a>collapser开发</h4><p><a href="https://github.com/sail-y/eshop-cache-ha/blob/master/src/main/java/com/roncoo/eshop/cache/ha/hystrix/command/GetProductInfosCollapser.java" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache-ha/blob/master/src/main/java/com/roncoo/eshop/cache/ha/hystrix/command/GetProductInfosCollapser.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfosCollapser</span> <span class="keyword">extends</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">List</span>&lt;<span class="title">ProductInfo</span>&gt;, <span class="title">ProductInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfosCollapser</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getRequestArgument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HystrixCommand&lt;List&lt;ProductInfo&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests) &#123;</span><br><span class="line">        String params = requests.stream().map(CollapsedRequest::getArgument).map(Object::toString).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">        System.out.println(<span class="string">"createCommand方法执行，params="</span> + params);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BatchCommand(requests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(List&lt;ProductInfo&gt; batchResponse, Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;ProductInfo, Long&gt; request : requests) &#123;</span><br><span class="line">            request.setResponse(batchResponse.get(count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">List</span>&lt;<span class="title">ProductInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BatchCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ProductInfoService"</span>))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"GetProductInfosCollapserBatchCommand"</span>)));</span><br><span class="line">            <span class="keyword">this</span>.requests = requests;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> List&lt;ProductInfo&gt; <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将一个批次内的商品id给拼接到了一起</span></span><br><span class="line">            String params = requests.stream().map(CollapsedRequest::getArgument).map(Object::toString).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将多个商品id合并到一个batch内，直接发送一次网络请求，获取所有的商品</span></span><br><span class="line">            String url = <span class="string">"http://localhost:8082/getProductInfos?productIds="</span> + params;</span><br><span class="line"></span><br><span class="line">            String response = HttpUtil.get(url);</span><br><span class="line"></span><br><span class="line">            List&lt;ProductInfo&gt; productInfos = JSONArray.parseArray(response, ProductInfo.class);</span><br><span class="line">            <span class="keyword">for</span> (ProductInfo productInfo : productInfos) &#123;</span><br><span class="line">                System.out.println(<span class="string">"BatchCommand内部， productInfo="</span> + JSON.toJSONString(productInfo));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> productInfos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量查询接口开发"><a href="#批量查询接口开发" class="headerlink" title="批量查询接口开发"></a>批量查询接口开发</h4><p><a href="https://github.com/sail-y/eshop-product-ha/blob/master/src/main/java/com/roncoo/esjop/product/ha/controller/ProductController.java" target="_blank" rel="noopener">https://github.com/sail-y/eshop-product-ha/blob/master/src/main/java/com/roncoo/esjop/product/ha/controller/ProductController.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getProductInfos"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProductInfos</span><span class="params">(String productIds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"getProductInfos接收到一次请求，productIds="</span> + productIds);</span><br><span class="line"></span><br><span class="line">    JSONArray jsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String productId : productIds.split(<span class="string">","</span>)) &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"id\": "</span> + productId + <span class="string">", \"name\": \"iphone7手机\", \"price\": 5599, \"pictureList\":\"a.jpg,b.jpg\", \"specification\": \"iphone7的规格\", \"service\": \"iphone7的售后服务\", \"color\": \"红色,白色,黑色\", \"size\": \"5.5\", \"shopId\": 2, \"modifiedTime\": \"2018-02-21 21:11:34\", \"cityId\": 1&#125;"</span>;</span><br><span class="line">        jsonArray.add(JSON.parse(json));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonArray.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请求合并测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfos?productIds=1,2,3,4,5,6,7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CacheController#getProductInfos</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;ProductInfo&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String productId : productIds.split(<span class="string">","</span>)) &#123;</span><br><span class="line">    GetProductInfosCollapser getProductInfosCollapser = <span class="keyword">new</span> GetProductInfosCollapser(Long.valueOf(productId));</span><br><span class="line">    futures.add(getProductInfosCollapser.queue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Future&lt;ProductInfo&gt; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"CacheController结果："</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把所有需要查询的商品通过HystrixCollapser发送，HystrixCollapser会为自动为我们讲请求合并以后访问。可能第一次访问的时候会超时，因为开发环境项目刚启动，第一次访问比较慢，第二次就好了。</p><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">createCommand方法执行，params=1,2,3,4,5,6,7</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:1,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:2,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:3,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:4,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:5,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:6,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo=&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:7,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">CacheController结果：ProductInfo(id=1, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=2, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=3, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=4, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=5, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=6, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br><span class="line">CacheController结果：ProductInfo(id=7, name=iphone7手机, price=5599.0, pictureList=a.jpg,b.jpg, specification=iphone7的规格, service=iphone7的售后服务, color=红色,白色,黑色, size=5.5, shopId=2, modifiedTime=2018-02-21 21:11:34, cityId=1, cityName=null, brandId=null, brandName=null)</span><br></pre></td></tr></table></figure><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>HystrixCollapser提供了一些配置：</p><ol><li><p>maxRequestsInBatch</p><p> 控制一个Batch中最多允许多少个request被合并，然后才会触发一个batch的执行</p></li><li><p>timerDelayInMilliseconds</p><p> 控制一个batch创建之后，多长时间以后就自动触发batch的执行，默认是10毫秒</p></li></ol><h2 id="fail-fast和fail-silent"><a href="#fail-fast和fail-silent" class="headerlink" title="fail-fast和fail-silent"></a>fail-fast和fail-silent</h2><p>HystrixCommand如果命令执行执行中出错了，或者抛异常了它有两种方式后续逻辑：</p><ul><li>fail-fast，就是不给fallback降级逻辑，HystrixCommand.run()，会直接从Hystrix的线程池中抛出异常，打印出日志，无法在调用方捕获</li><li>fail-silent，给一个fallback降级逻辑，如果HystrixCommand.run()，报错了，会走fallback降级，但是降级逻辑返回一个null值</li></ul><p>很少会用fail-fast模式，比较常用的可能还是fail-silent，不过既然都到了fallback里面，肯定要做点降级的事情。</p><h3 id="stubbed-fallback"><a href="#stubbed-fallback" class="headerlink" title="stubbed fallback"></a>stubbed fallback</h3><p>stubbed fallback: 残缺的降级</p><p>用请求中的部分数据拼装成结果，然后再填充一些默认值返回。比如说你发起了一个请求，然后请求中可能本身就附带了一些信息，如果主请求失败了，走到降级逻辑。在降级逻辑里面，可以将这个请求中的数据，以及部分本地缓存有的数据拼装在一起，再给数据填充一些简单的默认值<br>然后尽可能将自己有的数据返回到请求方。</p><h3 id="多级降级"><a href="#多级降级" class="headerlink" title="多级降级"></a>多级降级</h3><p>先降一级，尝试用一个备用方案去执行，如果备用方案失败了，再用最后下一个备用方案去执行。</p><p>hystrix command fallback语义，很容易就可以实现多级降级的策略，command嵌套command就可以达到多级降级的效果，第二个command其实是第一级降级策略。常见的多级降级的做法有一个操作，如果访问MySQL数据库，mysql数据库访问报错，降级，去redis中获取数据，如果说redis又挂了，然后就去从本地ehcache缓存中获取数据。</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FirstLevelFallbackCommand(productId).execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstLevelFallbackCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FirstLevelFallbackCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第一级的降级策略，因为这个command是运行在fallback中的</span></span><br><span class="line"><span class="comment">// 所以至关重要的一点是，在做多级降级的时候，要将降级command的线程池单独做一个出来</span></span><br><span class="line"><span class="comment">// 如果主流程的command都失败了，可能线程池都已经被占满了</span></span><br><span class="line"><span class="comment">// 降级command必须用自己的独立的线程池</span></span><br><span class="line"><span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ProductInfoService"</span>))</span><br><span class="line">.andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"FirstLevelFallbackCommand"</span>))</span><br><span class="line">.andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"FirstLevelFallbackPool"</span>))</span><br><span class="line">);  </span><br><span class="line"><span class="keyword">this</span>.productId = productId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 这里，因为是第一级降级的策略，所以说呢，其实是要从备用机房的机器去调用接口</span></span><br><span class="line"><span class="comment">// 但是，我们这里没有所谓的备用机房，所以说还是调用同一个服务来模拟</span></span><br><span class="line"><span class="keyword">if</span>(productId.equals(-<span class="number">2L</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line">String url = <span class="string">"http://127.0.0.1:8082/getProductInfo?productId="</span> + productId;</span><br><span class="line">String response = HttpClientUtils.sendGetRequest(url);</span><br><span class="line"><span class="keyword">return</span> JSONObject.parseObject(response, ProductInfo.class);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 第二级降级策略，第一级降级策略，都失败了</span></span><br><span class="line">ProductInfo productInfo = <span class="keyword">new</span> ProductInfo();</span><br><span class="line"><span class="comment">// 从请求参数中获取到的唯一条数据</span></span><br><span class="line">productInfo.setId(productId); </span><br><span class="line"><span class="comment">// 从本地缓存中获取一些数据</span></span><br><span class="line">productInfo.setBrandId(BrandCache.getBrandId(productId));</span><br><span class="line">productInfo.setBrandName(BrandCache.getBrandName(productInfo.getBrandId()));  </span><br><span class="line">productInfo.setCityId(LocationCache.getCityId(productId)); </span><br><span class="line">productInfo.setCityName(LocationCache.getCityName(productInfo.getCityId()));  </span><br><span class="line"><span class="comment">// 手动填充一些默认的数据</span></span><br><span class="line">productInfo.setColor(<span class="string">"默认颜色"</span>);  </span><br><span class="line">productInfo.setModifiedTime(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">productInfo.setName(<span class="string">"默认商品"</span>);  </span><br><span class="line">productInfo.setPictureList(<span class="string">"default.jpg"</span>);  </span><br><span class="line">productInfo.setPrice(<span class="number">0.0</span>);  </span><br><span class="line">productInfo.setService(<span class="string">"默认售后服务"</span>);  </span><br><span class="line">productInfo.setShopId(-<span class="number">1L</span>);  </span><br><span class="line">productInfo.setSize(<span class="string">"默认大小"</span>);  </span><br><span class="line">productInfo.setSpecification(<span class="string">"默认规格"</span>);   </span><br><span class="line"><span class="keyword">return</span> productInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动降级"><a href="#手动降级" class="headerlink" title="手动降级"></a>手动降级</h3><ul><li>手动降级实现方式是写一个command，在这个command它的主流程中，根据一个标识位，判断要执行哪个流程，可以执行主流程，也可以执行一个备用降级的command。</li></ul><ul><li><p>它的使用场景：一般来说都是去执行一个主流程的command，如果说你现在知道主流程有问题了，希望能够手动降级的话，动态给服务发送个请求。在请求中修改标识位，自动就让command以后都直接过来执行备用command。</p></li><li><p>一般会嵌套3个command，套在最外面的command，是用semaphore信号量做限流和资源隔离的，因为这个command不用去care timeout的问题，嵌套调用的command会自己去管理timeout超时的</p></li></ul><p>代码片段如下，通过<code>IsDegrade.isDegrade()</code>可以设置是否手动降级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoFacadeCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoFacadeCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ProductInfoService"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"GetProductInfoFacadeCommand"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">15</span>)));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!IsDegrade.isDegrade()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GetProductInfoCommand(productId).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GetProductInfoFromMySQLCommand(productId).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了这么多Hystrix的配置和使用方式，我们在生产环境里最需要关注的点是什么？</p><ol><li>线程池大小设置</li><li>timeout时长设置</li></ol><p>这个配置也没有说固定是多少，但是有一些规律可循。一般一开始需要将一些关键配置设置的大一些，比如timeout超时时长，线程池大小，或信号量容量。然后逐渐优化这些配置，直到在一个生产系统中运作良好。</p><ol><li>一开始先不要设置timeout超时时长，默认就是1000ms，也就是1s</li><li>一开始也不要设置线程池大小，默认就是10</li><li>直接部署hystrix到生产环境，如果运行的很良好，那么就让它这样运行好了</li><li>让hystrix应用，24小时运行在生产环境中</li><li>依赖标准的监控和报警机制来捕获到系统的异常运行情况</li><li>在24小时之后，看一下调用延迟的占比，以及流量，来计算出让短路器生效的最小的配置数字</li><li>直接对hystrix配置进行热修改，然后继续在hystrix dashboard上监控</li><li>看看修改配置后的系统表现有没有改善</li></ol><p><strong>最佳方案：</strong></p><ol><li>线程池大小：假设一个请求200ms，QPS30。那么每秒的高峰访问次数 * 99%的访问延时 + buffer = 30 * 0.2 + 4 = 10线程，10个线程每秒处理30次访问应该足够了，每个线程处理3次访问。</li><li>timeout：合理的timeout设置应该为300ms，也就是99.5%的访问延时，计算方法是，因为判断每次访问延时最多在250ms（TP99如果是200ms的话），再加一次重试时间50ms，就是300ms，感觉也应该足够了</li></ol><p>如果线程池设置得比较死，那么如果某个服务高峰期来了线程不够用，别的服务又占着线程池不用，这样就很不合理了，所以Hystrix也为我们提供了动态调整线程池的方案。</p><ol><li><p>coreSize</p><p> 设置线程池的大小，默认是10</p><p> HystrixThreadPoolProperties.Setter()</p><pre><code>.withCoreSize(int value)</code></pre></li><li><p>maximumSize</p><p> 设置线程池的最大大小，只有在设置<code>allowMaximumSizeToDivergeFromCoreSize</code>的时候才能生效</p><p> 默认是10</p><p> <code>HystrixThreadPoolProperties.Setter().withMaximumSize(int value)</code></p></li><li><p>keepAliveTimeMinutes</p><p> 设置保持存活的时间，单位是分钟，默认是1</p><p> 如果设置<code>allowMaximumSizeToDivergeFromCoreSize</code>为true，那么coreSize就不等于maxSize，此时线程池大小是可以动态调整的，可以获取新的线程，也可以释放一些线程</p><p> 如果coreSize &lt; maxSize，那么这个参数就设置了一个线程多长时间空闲之后，就会被释放掉</p><p> <code>HystrixThreadPoolProperties.Setter().withKeepAliveTimeMinutes(int value)</code></p></li><li><p>allowMaximumSizeToDivergeFromCoreSize</p><p> 允许线程池大小自动动态调整，设置为true之后，maxSize就生效了，此时如果一开始是coreSize个线程，随着并发量上来，那么就会自动获取新的线程，但是如果线程在keepAliveTimeMinutes内空闲，就会被自动释放掉</p><p> 默认是false</p><p> <code>HystrixThreadPoolProperties.Setter().withAllowMaximumSizeToDivergeFromCoreSize(boolean value)</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h2 id=&quot;请求合并技术&quot;&gt;&lt;a href=&quot;#请求合并技术&quot; class=&quot;headerlink&quot; title=&quot;请求合并技术&quot;&gt;&lt;/a&gt;请求合并技术&lt;/h2&gt;&lt;p&gt;前面的两篇文章讲解了hystrix的入门，以及它的原理和执行流程。&lt;/p&gt;
&lt;p&gt;之前我们有提到&lt;a href=&quot;http://www.saily.top/2018/03/26/hystrix02/#Request-Cache&quot;&gt;Request Cache&lt;/a&gt;，在一次请求上下文中，如果有多个command，参数都是一样的，调用的接口也是一样的，其实结果可以认为也是一样的。&lt;br&gt;
    
    </summary>
    
      <category term="hystrix" scheme="http://www.saily.top/categories/hystrix/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 不停机发布服务(0-downtime Blue/Green deployments)</title>
    <link href="http://www.saily.top/2018/04/14/spring-cloud-gray/"/>
    <id>http://www.saily.top/2018/04/14/spring-cloud-gray/</id>
    <published>2018-04-14T06:06:48.000Z</published>
    <updated>2018-04-26T16:48:46.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目初期由于BUG和需求改动可能都会比较多，我们会很频繁的发布我们的应用。但是如果不进行处理，在升级的过程中会导致用户服务中断。<br><a id="more"></a></p><p>通常我们需要发布的内容如下：</p><ol><li>某一个服务BUG紧急修复。</li><li>某一个服务新的需求上线。</li></ol><p>实际上针对这两种情况，在传统的应用中我们是很容易做到不停机升级的。例如nginx负载均衡2台tomcat实例，在升级的时候切断其中一台访问，升级完成以后切换流量，再升级另外一台。但是我这里用的是Spring Cloud，所有的实例状态都维护在Eureka中，Eureka本身也提供了很多保护机制，所以你的服务在down掉的时候，不会立马从服务列表中剔除掉。具体的配置项可以周立老师一篇文章里查看：<a href="http://www.itmuch.com/spring-cloud-sum-eureka/" target="_blank" rel="noopener">如何解决Eureka Server不踢出已关停的节点的问题</a>。</p><p>所以如果我们想要做到不停机去升级/发布一个服务，需要我们从Spring Cloud架构本身上着手去进行一些改造。我们需要去了解Eureka的使用方式，Spring Retry的使用，Spring Cloud的负载均衡规则等等，最终达到这个目的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果一个不了解Spring Cloud的人来做这种不停机发布，比如运维部门的同事。他会将某个需要升级的实例新版本启动起来，然后将老版本的进程杀掉。但是因为Spring Cloud的特性，被干掉的实例并没有被踢出服务列表，客户端仍然会访问到一个不存在的实例，直接返回500错误。可能需要等1~2分钟以后才能恢复正常。</p><p>我们知道这个是因为Eureka的机制问题，但是它注定不可能做成实时感知上下线的。Eureka是通过定期扫描去下线已经down掉的服务，不过他的默认时间是60秒，我们可以优化这个配置，让它能比较快的感知到服务已经下线。</p><h2 id="关于Eureka的常见问题"><a href="#关于Eureka的常见问题" class="headerlink" title="关于Eureka的常见问题"></a>关于Eureka的常见问题</h2><ul><li><p>问题可以参考：<a href="http://www.itmuch.com/spring-cloud-sum-eureka/" target="_blank" rel="noopener">Spring Cloud中，Eureka常见问题总结</a></p></li><li><p>生产环境最佳配置：<a href="http://www.saily.top/2018/04/14/spring-cloud-eureka/">eureka缓存细节以及生产环境的最佳配置</a></p></li></ul><p><strong>中小规模生产环境参考配置：</strong></p><p><strong>Eureka Server</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span>           <span class="comment"># 中小规模下，自我保护模式坑比好处多，所以关闭它</span></span><br><span class="line"><span class="attr">    eviction-interval-timer-in-ms:</span> <span class="number">5000</span>       <span class="comment"># 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms）从服务列表中剔除</span></span><br><span class="line"><span class="attr">    use-read-only-response-cache:</span> <span class="literal">false</span>       <span class="comment"># 禁用readOnlyCacheMap</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">      lease-renewal-interval-in-seconds:</span> <span class="number">5</span>      <span class="comment"># 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line"><span class="attr">      lease-expiration-duration-in-seconds:</span> <span class="number">10</span>  <span class="comment"># 没有心跳的淘汰时间，10秒，即服务续约到期时间（缺省为90s）</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="string">$&#123;defaultZone:http://peer2:8760/eureka/&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Eureka Client</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    lease-renewal-interval-in-seconds:</span> <span class="number">5</span>      <span class="comment"># 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line"><span class="attr">    lease-expiration-duration-in-seconds:</span> <span class="number">10</span>  <span class="comment"># 没有心跳的淘汰时间，10秒，即服务续约到期时间（缺省为90s）</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 向注册中心注册</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 服务清单的缓存更新时间，默认30秒一次</span></span><br><span class="line"><span class="attr">    registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="string">$&#123;defaultZone:http://$&#123;DISCOVERY_URL:discovery&#125;:8761/eureka/&#125;</span></span><br></pre></td></tr></table></figure><p>通过优化Eureka配置，服务在启动后能够较快的被使用上，Eureka也能较快的感知到服务以及下线并踢出服务列表。</p><h2 id="巧用Spring-Retry重试机制"><a href="#巧用Spring-Retry重试机制" class="headerlink" title="巧用Spring Retry重试机制"></a>巧用Spring Retry重试机制</h2><p>我在搜寻解决方案的时候，也看到了Github上讨论的一个issue：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1290" target="_blank" rel="noopener">Best practices for using Eureka for 0-downtime Blue/Green deployments #1290</a>.</p><p>这里面讨论了利用重试机制去实现不停机发布的一种方式。前面的Eureka配置已经缩短了服务上线和服务下线的时间，但是这中间仍然一段延迟，可能还是会有请求随机访问一个不存在的服务实例上。</p><p>重试机制的原理就是利用Spring Cloud提供的重试机制在请求访问出现错误的时候自动重试当前实例或者其他实例，而不是直接返回错误。</p><p>主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment"># ribbon缓存时间</span></span><br><span class="line"><span class="attr">  ServerListRefreshInterval:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">30000</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">30000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都重试</span></span><br><span class="line">  <span class="comment"># OkToRetryOnAllOperations: true</span></span><br><span class="line">  <span class="comment"># 重试负载均衡其他的实例最大重试次数,不包括首次server</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 同一台实例最大重试次数,不包括首次调用</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  retryable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但是这里要注意一点，<code>OkToRetryOnAllOperations</code>如果设置为true，那么ribbon超时时间最好设置长一点，否则post等请求如果超时会被提交多次，还要注意hystrix的超时时间要大于ribbion的超时时间，否则hystrix会先超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><p>在不同的版本中，Spring Cloud的重试机制是比较混乱的，周立老师对重试机制的详细解释：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/" target="_blank" rel="noopener">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p><p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p><p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。因此，对于Camden以及以后的版本，Feign的重试可使用如下属性进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p><p>结合之前对Eureka配置的优化，我们就可以愉快的进行测试了，开启2个服务访问几次，可以发现随机访问。然后干掉一个服务，再次访问，依然没有问题，不会出现500等情况。Feign自动为我们选择了另外可用的服务发送了重试请求。</p><h2 id="灰度发布方案"><a href="#灰度发布方案" class="headerlink" title="灰度发布方案"></a>灰度发布方案</h2><p>还有一种特别的需求，我们除了想做到不停机发布，可能还需要做到某些用户测试新版本代码，实现降级、限流、滚动、灰度、AB、金丝雀等操作。我在Github上发现了一个开源的代码在一定程度上提供了很好的思路去做这个事情。地址：<a href="https://github.com/JeromeLiuLly/springcloud-gray" target="_blank" rel="noopener">https://github.com/JeromeLiuLly/springcloud-gray</a></p><p>看这个实现方式可以看出来，他的方案是基于<a href="https://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="noopener">spring cloud 实践-降级、限流、滚动、灰度、AB、金丝雀等等等等</a>的方案做的。</p><p>因Spring Cloud都是客户端负载均衡，会从Eureka读取服务列表，然后通过一定的负载均衡规则来选择请求的服务器。这个方案就是重写了Ribbon负载均衡的策略，将一些自定义信息放入了Eureka的metdata-map中，在路由的时候根据这些信息来选择服务。我这里不再多说，大家可以自行去查看他们的文章和代码。</p><p>这个方案灵活性非常大，你可以根据自定义的信息来构建任何你想做的策略，去实现AB Test等等功能，甚至我在开发环境中也能使用。举个例子，因为我们的服务太多了，如果在本机开发的时候，关联的服务较多，要启动比较多的服务才能够进行开发和测试，可能机器会有点吃不消。我基于上述方案让开发的同学们在启动服务的上将本机的IP添加到<code>metadata-map</code>中，这样我在路由的时候判断客户端请求过来的IP是多少，如果跟实例里的信息匹配，那么所有来自这个IP请求就转发到开发同学启动的那台实例上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;项目初期由于BUG和需求改动可能都会比较多，我们会很频繁的发布我们的应用。但是如果不进行处理，在升级的过程中会导致用户服务中断。&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.saily.top/categories/spring/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="灰度发布" scheme="http://www.saily.top/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>(转)eureka缓存细节以及生产环境的最佳配置</title>
    <link href="http://www.saily.top/2018/04/14/spring-cloud-eureka/"/>
    <id>http://www.saily.top/2018/04/14/spring-cloud-eureka/</id>
    <published>2018-04-14T05:29:08.000Z</published>
    <updated>2018-04-16T02:16:03.286Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="http://bhsc881114.github.io/2018/04/01/eureka%E7%BC%93%E5%AD%98%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">eureka缓存细节以及生产环境的最佳配置</a></p><p>作者：<a href="http://bhsc881114.github.io/" target="_blank" rel="noopener">http://bhsc881114.github.io/</a></p><p>eureka作为spring cloud微服务架构里的注册中心，是非常核心的一个组件，它避免了复杂的选主算法，架构比较简单，搭个demo也确实很快，但是如果要用于生产环境，还是得注意很多东西，尤其是下线延迟…<br><a id="more"></a></p><h2 id="服务获取中的缓存问题"><a href="#服务获取中的缓存问题" class="headerlink" title="服务获取中的缓存问题"></a>服务获取中的缓存问题</h2><p>本节的内容都是从这个issue翻译的：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373" target="_blank" rel="noopener">Documentation: changing Eureka renewal frequency WILL break the self-preservation feature of the server</a></p><h3 id="为什么修改client的默认心跳时间，会导致自我保护模式失效？"><a href="#为什么修改client的默认心跳时间，会导致自我保护模式失效？" class="headerlink" title="为什么修改client的默认心跳时间，会导致自我保护模式失效？"></a>为什么修改client的默认心跳时间，会导致自我保护模式失效？</h3><p>Eureka Service会认为客户端是以30s的频率来发送心跳的。服务端期望收到的最大心跳时间是：<br>n instances x 2(60s/30s) x threshold</p><p>如果是2个实例，Eureka会期望每分钟有：2 instances x 2 x 85% =3.4个心跳,也就是说需要3个心跳。<br>如果client的心跳改成15s，挂掉一个，另一个在1min内会发出4个心跳，而这时候的阈值还是3.4个，自我保护模式就失效了。<br>核心原因就是在Eureka Server计算期望心跳数的时候写死了每分钟的心跳间隔，即30秒，所以他永远会是*2(感觉像是新手写的代码啊啊啊 -_-)</p><p><img src="http://7xijc0.com1.z0.glb.clouddn.com/eureka-self.png" alt=""></p><p>还有一个参数可以调整，eureka.server.renewalThresholdUpdateIntervalMs，心跳阈值重新计算的周期，默认15分钟，可以改短一点，2min</p><h3 id="客户端首次注册时间为什么要30s？如何改进？"><a href="#客户端首次注册时间为什么要30s？如何改进？" class="headerlink" title="客户端首次注册时间为什么要30s？如何改进？"></a>客户端首次注册时间为什么要30s？如何改进？</h3><p>首次注册行为是和首次心跳绑定在一起的，首次心跳发送以后会收到not found的响应,client就知道还没注册过，client就会马上注册。首次心跳由参数<br>eureka.instance.leaseRenewalIntervalInSeconds控制的，默认30</p><p>可以通过eureka.client.initialInstanceInfoReplicationIntervalSeconds参数来加快首次注册的速度。他是控制首次改变实例状态（UP/DOWN ）的时间，启动的时候状态肯定是需要改变的，所以他可以用来加快首次注册速度，并且改变这个值不会影响到保护模式</p><p>另外如果你使用的是spring cloud eureka的话没首次注册延迟的问题，他会马上注册</p><h3 id="其他影响快速获取服务信息的因素"><a href="#其他影响快速获取服务信息的因素" class="headerlink" title="其他影响快速获取服务信息的因素"></a>其他影响快速获取服务信息的因素</h3><p><strong>【服务端缓存】</strong></p><p>因为服务端默认会有个read only response cache（下面会细说），每30秒更新一次(eureka.server.response-cache-update-interval-ms),所以可能注册了不是马上能看到（虽然通过rest api不能看到，但是你可以在web ui上看到，因为ui没有缓存）</p><p><strong>【客户端缓存】</strong></p><p>Eureka Client缓存的定期更新周期，他由eureka.client.registryFetchIntervalSeconds控制，默认30秒， 改成5秒</p><p><strong>【Ribbon缓存】</strong></p><p>如果你采用Ribbon来访问服务，那么这里会有个缓存（他的数据来源是本地Eureka Client缓存），他由ribbon. ServerListRefreshInterval控制，默认30秒， 改成2秒</p><h3 id="怎么更快的踢掉没有心跳的机器"><a href="#怎么更快的踢掉没有心跳的机器" class="headerlink" title="怎么更快的踢掉没有心跳的机器"></a>怎么更快的踢掉没有心跳的机器</h3><p>eureka.instance.leaseExpirationDurationInSeconds，这个值用来控制多久踢掉机器，默认是3个心跳周期，有点久，可以考虑改成2个，他不会影响到保护模式（如果开启自我保护模式，心跳间隔因为上面的bug不能改，只能改这个了 -_-）</p><hr><h2 id="服务端缓存细节"><a href="#服务端缓存细节" class="headerlink" title="服务端缓存细节"></a>服务端缓存细节</h2><p>Eureka内部的缓存分很多级，主要有registry、readWriterCacheMap、readOnlyCacheMap；另外还有一个维护最近180s增量的队列recentlyChangedQueue</p><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>包括注册、取消注册等，都直接操作在registry上，同时也会更新recentlyChangedQueue和readWriterCacheMap</p><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读默认是从readOnlyCacheMap读取，读不到的话再从readWriterCacheMap，还没有再从registry</p><h3 id="滥用缓存的读操作"><a href="#滥用缓存的读操作" class="headerlink" title="滥用缓存的读操作"></a>滥用缓存的读操作</h3><p>这个读操作的三级缓存结构，非常让人困惑，registry已经是ConcurrentHashMap，纯内存操作，性能非常高了，为什么前面还要加两级缓存；readWriterCacheMap的数据是在写入以后responseCacheAutoExpirationInSeconds(默认180)秒内失效，readOnlyCacheMap则是一个定时任务，每responseCacheUpdateIntervalMs(默认30)秒从readWriterCacheMap获取最新数据</p><h3 id="去掉readOnlyCacheMap"><a href="#去掉readOnlyCacheMap" class="headerlink" title="去掉readOnlyCacheMap"></a>去掉readOnlyCacheMap</h3><p>从CAP理论上看，Eureka是一个AP系统，但是在C层面这么弱，就是因为各种无谓的缓存造成的，看了下readWriterCacheMap去掉比较难，但是readOnlyCacheMap有一个开关useReadOnlyResponseCache，果断关掉！！</p><hr><h2 id="Time-Lag"><a href="#Time-Lag" class="headerlink" title="Time Lag"></a>Time Lag</h2><p>最后再来看下Eureka wiki中提到的2min time lag问题，其实分多个角度看，不一定是2min</p><h3 id="服务正常上线-修改，最大可能会有120s滞后"><a href="#服务正常上线-修改，最大可能会有120s滞后" class="headerlink" title="服务正常上线/修改，最大可能会有120s滞后"></a>服务正常上线/修改，最大可能会有120s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 30(首次注册 init registe) + 30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)=120</span><br><span class="line">- 如果是在Spring Cloud环境下使用这些组件(Eureka, Ribbon)，不会有首次注册30秒延迟的问题，服务启动后会马上注册,所以从注册到发现，最多可能是90s。</span><br></pre></td></tr></table></figure><h3 id="服务异常下线：最大可能会有270s滞后"><a href="#服务异常下线：最大可能会有270s滞后" class="headerlink" title="服务异常下线：最大可能会有270s滞后"></a>服务异常下线：最大可能会有270s滞后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 定时清理任务每eureka.server. evictionIntervalTimerInMs(默认60)执行一次清理任务</span><br><span class="line">- 每次清理任务会把90秒(3个心跳周期，eureka.instance.leaseExpirationDurationInSeconds)没收到心跳的踢除，但是根据官方的说法 ，因为代码实现的bug，这个时间其实是两倍，即180秒，也就是说如果一个客户端因为网络问题或者主机问题异常下线，可能会在180秒后才剔除</span><br><span class="line">- 读取端，因为readOnlyCacheMap以及客户端缓存的存在，可能会在30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)=90</span><br><span class="line">- 所以极端情况最终可能会是180+90=270</span><br></pre></td></tr></table></figure><h2 id="生产环境最佳配置"><a href="#生产环境最佳配置" class="headerlink" title="生产环境最佳配置"></a>生产环境最佳配置</h2><p>总结前面3点，经过梳理后，推荐的生产环境最佳配置如下：（可用于中小规模环境）：</p><h3 id="Eureka-Server端配置"><a href="#Eureka-Server端配置" class="headerlink" title="Eureka Server端配置"></a>Eureka Server端配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 中小规模下，自我保护模式坑比好处多，所以关闭它</span></span><br><span class="line">eureka.server.enableSelfPreservation=<span class="literal">false</span></span><br><span class="line"><span class="comment">## 心跳阈值计算周期，如果开启自我保护模式，可以改一下这个配置</span></span><br><span class="line"><span class="comment">## eureka.server.renewalThresholdUpdateIntervalMs=120000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 主动失效检测间隔,配置成5秒</span></span><br><span class="line">eureka.server.evictionIntervalTimerInMs=5000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line">eureka.instance.leaseRenewalIntervalInSeconds=5</span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds=10</span><br><span class="line"></span><br><span class="line"><span class="comment">## 禁用readOnlyCacheMap</span></span><br><span class="line">eureka.server. useReadOnlyResponseCache=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="服务提供者和client配置"><a href="#服务提供者和client配置" class="headerlink" title="服务提供者和client配置"></a>服务提供者和client配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line">eureka.instance.leaseRenewalIntervalInSeconds=5</span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds=10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定时刷新本地缓存时间</span></span><br><span class="line">eureka.client.registryFetchIntervalSeconds=5</span><br><span class="line"><span class="comment"># ribbon缓存时间</span></span><br><span class="line">ribbon.ServerListRefreshInterval=2000</span><br></pre></td></tr></table></figure><p>改成上面配置后:</p><ul><li><p>正常上线下线客户端最大感知时间：eureka.client.registryFetchIntervalSeconds+ribbon. ServerListRefreshInterval = 7秒</p></li><li><p>异常下线客户端最大感知时间：<br>2*eureka.instance.leaseExpirationDurationInSeconds+<br>eureka.server.evictionIntervalTimerInMs+<br>eureka.client.registryFetchIntervalSeconds+<br>ribbon. ServerListRefreshInterval = 32</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自 &lt;a href=&quot;http://bhsc881114.github.io/2018/04/01/eureka%E7%BC%93%E5%AD%98%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eureka缓存细节以及生产环境的最佳配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://bhsc881114.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bhsc881114.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;eureka作为spring cloud微服务架构里的注册中心，是非常核心的一个组件，它避免了复杂的选主算法，架构比较简单，搭个demo也确实很快，但是如果要用于生产环境，还是得注意很多东西，尤其是下线延迟…&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.saily.top/categories/spring/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>(转)Spring Cloud 实践-降级、限流、滚动、灰度、AB、金丝雀等等等等</title>
    <link href="http://www.saily.top/2018/04/14/spring-cloud-green-blue/"/>
    <id>http://www.saily.top/2018/04/14/spring-cloud-green-blue/</id>
    <published>2018-04-14T04:18:32.000Z</published>
    <updated>2018-04-16T02:15:51.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-cloud-实践"><a href="#spring-cloud-实践" class="headerlink" title="spring cloud 实践"></a>spring cloud 实践</h1><p>源码地址：<a href="https://github.com/charlesvhe/spring-cloud-practice" target="_blank" rel="noopener">https://github.com/charlesvhe/spring-cloud-practice</a></p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/6144762-b7706923f43d4642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="config-配置中心"><a href="#config-配置中心" class="headerlink" title="config 配置中心"></a>config 配置中心</h2><p>端口：8888，方便起见直接读取配置文件，生产环境可以读取git。application-dev.properties为全局配置。先启动配置中心，所有服务的配置（包括注册中心的地址）均从配置中心读取。</p><h2 id="consumer-服务消费者"><a href="#consumer-服务消费者" class="headerlink" title="consumer 服务消费者"></a>consumer 服务消费者</h2><p>端口：18090，调用服务提供者，为了演示header传递。</p><h2 id="core-框架核心包"><a href="#core-框架核心包" class="headerlink" title="core 框架核心包"></a>core 框架核心包</h2><p>核心jar包，所有微服务均引用该包，使用AutoConfig实现免配置，模拟生产环境下spring-cloud的使用。</p><h2 id="eureka-注册中心"><a href="#eureka-注册中心" class="headerlink" title="eureka 注册中心"></a>eureka 注册中心</h2><p>端口：8761，/metadata端点实现metadata信息配置。</p><h2 id="provider-服务提供者"><a href="#provider-服务提供者" class="headerlink" title="provider 服务提供者"></a>provider 服务提供者</h2><p>端口：18090，服务提供者，无特殊逻辑。</p><h2 id="zuul-网关"><a href="#zuul-网关" class="headerlink" title="zuul 网关"></a>zuul 网关</h2><p>端口：8080，演示解析token获得label并放入header往后传递</p><h1 id="实践：降级、限流、滚动、灰度、AB、金丝雀等等等等"><a href="#实践：降级、限流、滚动、灰度、AB、金丝雀等等等等" class="headerlink" title="实践：降级、限流、滚动、灰度、AB、金丝雀等等等等"></a>实践：降级、限流、滚动、灰度、AB、金丝雀等等等等</h1><p>我本人是从dubbo转过来的，经常看到社区里面拿dubbo和spring-cloud做对比，一对比就提到dubbo所谓的降级、限流功能。spring-cloud默认没有这个能力，让我们来扩展spring-cloud，使她具备比dubbo更牛逼的各种能力。</p><p>所谓的降级、限流、滚动、灰度、AB、金丝雀等等等等，在我看来无非就是扩展了服务路由能力而已。这里说的服务降级，说的是服务A部署多个实例，实例级别的降级限流。如果要做整个服务A的降级，直接采用docker自动扩容缩容即可。</p><p>我们先来看应用场景：</p><p>服务A 发布了1.0版，部署了3个实例A1、A2、A3，现在要对服务A进行升级，由1.0升级到2.0。先将A1服务流量关闭，使A2、A3负担；升级A1代码版本到2.0；将A1流量调整为1%，观察新版本运行情况，如果运行稳定，则逐步提升流量5%、10%直到完全放开流量控制。A2、A3重复上述步骤。</p><p>在上述步骤中，我们想让特别的人使用2.0，其他人还是使用1.0版，稳定后再全员开放。</p><p>我们想不依赖sleuth做链路跟踪，想自己实现一套基于ELK的链路跟踪。</p><p>我们还有各种千奇百怪的想法。。。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现这些想法，我们需要对spring-cloud的各个组件、数据流非常熟悉，这样才能知道该在哪里做扩展。一个典型的调用：外网-》Zuul网关-》服务A-》服务B。。。</p><p>spring-cloud跟dubbo一样都是客户端负载均衡，所有调用均由Ribbon来做负载均衡选择服务器，所有调用前后会套一层hystrix做隔离、熔断。服务间调用均用带LoadBalanced注解的RestTemplate发出。RestTemplate-》Ribbon-》hystrix</p><p>通过上述分析我们可以看到，我们的扩展点就在Ribbon，Ribbon根据我们的规则，选择正确的服务器即可。</p><p>我们先来一个dubbo自带的功能：基于权重的流量控制。dubbo自带的控制台可以设置服务实例粒度的半权，倍权。其实就是在客户端负载均衡时，选择服务器带上权重即可，spring-cloud默认是ZoneAvoidanceRule，优先选择相同Zone下的实例，实例间采用轮询方式做负载均衡。我们的想把基于轮询改为基于权重即可。接下来的问题是，每个实例的权重信息保存在哪里？从哪里取？dubbo放在zookeeper中，spring-cloud放在eureka中。我们只需从eureka拿每个实例的权重信息，然后根据权重来选择服务器即可。具体代码LabelAndWeightMetadataRule（先忽略里面的优先匹配label相关代码）。</p><h2 id="放入核心框架"><a href="#放入核心框架" class="headerlink" title="放入核心框架"></a>放入核心框架</h2><p>LabelAndWeightMetadataRule写好了，那么我们如何使用它，使之生效呢？有3种方式。</p><p>1）写个AutoConfig将LabelAndWeightMetadataRule声明成@Bean，用来替换默认的ZoneAvoidanceRule。这种方式在技术验证、开发测试阶段使用短平快。但是这种方式是强制全局设置，无法个性化。</p><p>2）由于spring-cloud的Ribbon并没有实现netflix Ribbon的所有配置项。netflix配置全局rule方式为：ribbon.NFLoadBalancerRuleClassName=package.YourRule，spring-cloud并不支持，spring-cloud直接到服务粒度，只支持SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.YourRule。我们可以扩展org.springframework.cloud.netflix.ribbon.PropertiesFactory修正spring cloud ribbon未能完全支持netflix ribbon配置的问题。这样我们可以将全局配置写到配置中心的application-dev.properties全局配置中，然后各个微服务还可以根据自身情况做个性化定制。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。</a></p><p>3）使用spring cloud官方建议的@RibbonClient方式。该方式仅存在于spring-cloud单元测试中（在我提问后，现在还存在于spring-cloud issue list）。具体代码参见DefaultRibbonConfiguration、CoreAutoConfiguration。</p><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul</p><p>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="noopener">http://localhost:8761/metadata.html</a> 这是我手写的一个简单的metadata管理界面，分别设置两个provider实例的weight值（设置完需要一段2分钟才能生效），然后访问 <a href="http://localhost:8080/provider/user" target="_blank" rel="noopener">http://localhost:8080/provider/user</a> 多刷几次来测试zuul是否按权重发送请求，也可以访问 <a href="http://localhost:8080/consumer/test" target="_blank" rel="noopener">http://localhost:8080/consumer/test</a> 多刷几次来测试consumer是否按权重来调用provide服务。</p><h2 id="进阶，基于标签"><a href="#进阶，基于标签" class="headerlink" title="进阶，基于标签"></a>进阶，基于标签</h2><p>基于权重的搞定之后，接下来才是重头戏：基于标签的路由。入口请求含有各种标签，然后我们可以根据标签幻化出各种各样的路由规则。例如只有标注为粉丝的用户才使用新版本（灰度、AB、金丝雀），例如标注为中国的用户请求必须发送到中国的服务器（全球部署），例如标注为写的请求必须发送到专门的写服务实例（读写分离），等等等等，唯一限制你的就是你的想象力。</p><h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><p>根据标签的控制，我们当然放到之前写的Ribbon的rule中，每个实例配置的不同规则也是跟之前一样放到注册中心的metadata中，关键是标签数据如何传过来。权重随机的实现思路里面有答案，请求都通过zuul进来，因此我们可以在zuul里面给请求打标签，基于用户，IP或其他看你的需求，然后将标签信息放入ThreadLocal中，然后在Ribbon Rule中从ThreadLocal拿出来使用就可以了。然而，按照这个方式去实验时，发现有问题，拿不到ThreadLocal。原因是有hystrix这个东西，回忆下hystrix的原理，为了做到故障隔离，hystrix启用了自己的线程，不在同一个线程ThreadLocal失效。那么还有什么办法能够将标签信息一传到底呢，想想之前有没有人实现过类似的东西，没错sleuth，他的链路跟踪就能够将spam传递下去，翻翻sleuth源码，找找其他资料，发现可以使用HystrixRequestVariableDefault，这里不建议直接使用HystrixConcurrencyStrategy，会和sleuth的strategy冲突。代码参见CoreHeaderInterceptor。现在可以测试zuul里面的rule，看能否拿到标签内容了。</p><p>这里还不是终点，解决了zuul的路由，服务A调服务B这里的路由怎么处理呢？zuul算出来的标签如何往后面依次传递下去呢，我们还是抄sleuth：把标签放入header，服务A调服务B时，将服务A header里面的标签放到服务B的header里，依次传递下去。这里的关键点就是：内部的微服务在接收到发来的请求时（zuul-》A，A-》B都是这种情况）我们将请求放入ThreadLocal，哦，不对，是HystrixRequestVariableDefault，还记得上面说的原因么：）。这个容易处理，写一个spring mvc拦截器即可，代码参见CoreHeaderInterceptor。然后发送请求时自动带上这个里面保存的标签信息，参见RestTemplate的拦截器CoreHttpRequestInterceptor。到此为止，技术上全部走通实现。</p><p>总结一下：zuul依据用户或IP等计算标签，并将标签放入header里向后传递，后续的微服务通过拦截器，将header里的标签放入RestTemplate请求的header里继续向后接力传递。标签的内容通过放入类似于ThreadLocal的全局变量（HystrixRequestVariableDefault），使Ribbon Rule可以使用。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>参见PreFilter源码，模拟了几个用户的标签，参见LabelAndWeightMetadataRule源码，模拟了OR AND两种标签处理策略。依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul</p><p>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="noopener">http://localhost:8761/metadata.html</a> 设置第一个provide 实例 orLabel为 CN,Test 发送请求头带入Authorization: emt 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="noopener">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第一个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="noopener">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第一个实例。</p><p>设置第二个provide 实例 andLabel为 EN,Male 发送请求头带入Authorization: em 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="noopener">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第二个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="noopener">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第二个实例。</p><p>Authorization头还可以设置为PreFilter里面的模拟token来做测试，至此所有内容讲解完毕，技术路线拉通，剩下的就是根据需求来完善你自己的路由策略啦。</p><p>作者：Charles_He<br>链接：<a href="https://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="noopener">https://www.jianshu.com/p/37ee1e84900a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-cloud-实践&quot;&gt;&lt;a href=&quot;#spring-cloud-实践&quot; class=&quot;headerlink&quot; title=&quot;spring cloud 实践&quot;&gt;&lt;/a&gt;spring cloud 实践&lt;/h1&gt;&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/charlesvhe/spring-cloud-practice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/charlesvhe/spring-cloud-practice&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.saily.top/categories/spring/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="微服务" scheme="http://www.saily.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix流程和原理讲解</title>
    <link href="http://www.saily.top/2018/03/26/hystrix02/"/>
    <id>http://www.saily.top/2018/03/26/hystrix02/</id>
    <published>2018-03-26T14:16:48.000Z</published>
    <updated>2018-09-19T08:06:43.591Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h2 id="Hystrix流程讲解"><a href="#Hystrix流程讲解" class="headerlink" title="Hystrix流程讲解"></a>Hystrix流程讲解</h2><h3 id="创建Command"><a href="#创建Command" class="headerlink" title="创建Command"></a>创建Command</h3><p>一个HystrixCommand或一个HystrixObservableCommand对象，代表了对某个依赖服务发起的一次请求或者调用，构造的时候，可以在构造函数中传入任何需要的参数。<br><a id="more"></a><br>HystrixCommand主要用于仅仅会返回一个结果的调用<br>HystrixObservableCommand主要用于可能会返回多条结果的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommand command = <span class="keyword">new</span> HystrixCommand(arg1, arg2);</span><br><span class="line">HystrixObservableCommand command = <span class="keyword">new</span> HystrixObservableCommand(arg1, arg2);</span><br></pre></td></tr></table></figure><h3 id="执行Command"><a href="#执行Command" class="headerlink" title="执行Command"></a>执行Command</h3><p>执行Command就可以发起一次对依赖服务的调用</p><p>要执行Command，需要在4个方法中选择其中的一个：execute()，queue()，observe()，toObservable()</p><p>其中execute()和queue()仅仅对HystrixCommand适用</p><p>execute()：调用后直接block住，属于同步调用，直到依赖服务返回单条结果，或者抛出异常<br>queue()：返回一个Future，属于异步调用，后面可以通过Future获取单条结果<br>observe()：订阅一个Observable对象，Observable代表的是依赖服务返回的结果，获取到一个那个代表结果的Observable对象的拷贝对象<br>toObservable()：返回一个Observable对象，如果我们订阅这个对象，就会执行command并且获取返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K             value   = command.execute();</span><br><span class="line">Future&lt;K&gt;     fValue  = command.queue();</span><br><span class="line">Observable&lt;K&gt; ohValue = command.observe();         </span><br><span class="line">Observable&lt;K&gt; ocValue = command.toObservable();</span><br></pre></td></tr></table></figure><p>execute()实际上会调用queue().get().queue()，接着会调用toObservable().toBlocking().toFuture()</p><p>也就是说，无论是哪种执行command的方式，最终都是依赖toObservable()去执行的。</p><h3 id="检查是否开启请求缓存"><a href="#检查是否开启请求缓存" class="headerlink" title="检查是否开启请求缓存"></a>检查是否开启请求缓存</h3><p>如果这个command开启了请求缓存，而且这个调用的结果在缓存中存在，那么直接从缓存中返回结果。</p><h3 id="检查是否开启了断路器"><a href="#检查是否开启了断路器" class="headerlink" title="检查是否开启了断路器"></a>检查是否开启了断路器</h3><p>检查这个command对应的依赖服务是否开启了断路器</p><p>如果断路器被打开了，那么hystrix就不会执行这个command，而是直接去执行fallback降级机制。</p><h3 id="检查线程池-队列-semaphore是否已经满了"><a href="#检查线程池-队列-semaphore是否已经满了" class="headerlink" title="检查线程池/队列/semaphore是否已经满了"></a>检查线程池/队列/semaphore是否已经满了</h3><p>如果command对应的线程池/队列/semaphore已经满了，那么也不会执行command，而是直接去调用fallback降级机制。</p><h3 id="执行command"><a href="#执行command" class="headerlink" title="执行command"></a>执行command</h3><p>调用HystrixObservableCommand.construct()或HystrixCommand.run()来实际执行这个command</p><p>HystrixCommand.run()是返回一个单条结果，或者抛出一个异常<br>HystrixObservableCommand.construct()是返回一个Observable对象，可以获取多条结果</p><p>如果HystrixCommand.run()或HystrixObservableCommand.construct()的执行，超过了timeout时长的话，那么command所在的线程就会抛出一个TimeoutException。</p><p>如果timeout了，也会去执行fallback降级机制，而且就不会管run()或construct()返回的值了。</p><h3 id="断路健康检查"><a href="#断路健康检查" class="headerlink" title="断路健康检查"></a>断路健康检查</h3><p>Hystrix会将每一个依赖服务的调用成功，失败，拒绝，超时，等事件，都会发送给circuit breaker断路器。断路器就会对调用成功/失败/拒绝/超时等事件的次数进行统计。断路器会根据这些统计次数来决定，是否要进行断路，如果打开了断路器，那么在一段时间内就会直接断路，然后如果在之后第一次检查发现调用成功了，就关闭断路器。</p><h3 id="调用fallback降级机制"><a href="#调用fallback降级机制" class="headerlink" title="调用fallback降级机制"></a>调用fallback降级机制</h3><p>在以下几种情况中，hystrix会调用fallback降级机制：<strong>run()或construct()抛出一个异常，断路器打开，线程池/队列/semaphore满了，command执行超时了。</strong></p><p>一般在降级机制中，都建议给出一些默认的返回值，比如静态的一些代码逻辑，或者从内存中的缓存中提取一些数据，尽量在这里不要再进行网络请求了</p><p>即使在降级中，一定要进行网络调用，也应该将那个调用放在一个HystrixCommand中，进行隔离</p><p>在HystrixCommand中，上线getFallback()方法，可以提供降级机制</p><p>在HystirxObservableCommand中，实现一个resumeWithFallback()方法，返回一个Observable对象，可以提供降级结果</p><p>如果fallback返回了结果，那么hystrix就会返回这个结果</p><p>对于HystrixCommand，会返回一个Observable对象，其中会发返回对应的结果<br>对于HystrixObservableCommand，会返回一个原始的Observable对象</p><p>如果没有实现fallback，或者是fallback抛出了异常，Hystrix会返回一个Observable，但是不会返回任何数据</p><p>不同的command执行方式，其fallback为空或者异常时的返回结果不同</p><p>对于execute()，直接抛出异常<br>对于queue()，返回一个Future，调用get()时抛出异常<br>对于observe()，返回一个Observable对象，但是调用subscribe()方法订阅它时，立即抛出调用者的onError方法<br>对于toObservable()，返回一个Observable对象，但是调用subscribe()方法订阅它时，立即抛出调用者的onError方法。</p><h3 id="不同执行方式走的流程"><a href="#不同执行方式走的流程" class="headerlink" title="不同执行方式走的流程"></a>不同执行方式走的流程</h3><p>execute()，获取一个Future.get()，然后拿到单个结果<br>queue()，返回一个Future<br>observer()，立即订阅Observable，然后启动8大执行步骤，返回一个拷贝的Observable，订阅时立即回调给你结果<br>toObservable()，返回一个原始的Observable，必须手动订阅才会去执行8大步骤</p><p><img src="/img/hystrix/hystrix执行时的8大流程以及内部原理.png" alt="hystrix执行时的8大流程以及内部原理"></p><h2 id="Request-Cache"><a href="#Request-Cache" class="headerlink" title="Request Cache"></a>Request Cache</h2><p>首先有一个概念，叫做reqeust context–请求上下文，一般来说在一个web应用中，会使用hystrix在一个filter里面，对每一个请求都施加一个请求上下文，在tomcat容器内，每一次请求就是一次请求上下文。</p><p>然后在这次请求上下文中，我们会去执行N多代码，调用N多依赖服务，有的依赖服务可能还会调用好几次，在一次请求上下文中，如果有多个command，参数都是一样的，调用的接口也是一样的，其实结果可以认为也是一样的。</p><p>那么这个时候，我们就可以让第一次command执行返回的结果被缓存在内存中，然后这个请求上下文中后续的其他对这个依赖的调用全部从内存中取用缓存结果就可以了。不用在一次请求上下文中反复多次的执行一样的command，提升整个请求的性能。</p><p>HystrixCommand和HystrixObservableCommand都可以指定一个缓存key，然后hystrix会自动进行缓存，接着在同一个request context内，再次访问的时候，就会直接取用缓存。用请求缓存，可以避免重复执行网络请求，多次调用一个command，那么只会执行一次，后面都是直接取缓存。</p><p>指定缓存key，只需要实现一个<code>getCacheKey</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getCacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"product_info_"</span> + productId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对于请求缓存（request caching），请求合并（request collapsing），请求日志（request log），等等技术，都必须自己管理HystrixReuqestContext的生命周期。</p><p>在一个请求执行之前，都必须先初始化一个request context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br></pre></td></tr></table></figure><p>然后在请求结束之后，需要关闭request context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.shutdown();</span><br></pre></td></tr></table></figure><p>一般在Java Web应用中，都是通过filter过滤器来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRequestContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> HystrixRequestContextFilter());</span><br><span class="line">    registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动清理缓存"><a href="#手动清理缓存" class="headerlink" title="手动清理缓存"></a>手动清理缓存</h3><p>有时候可能需要手动清理缓存，Hystrix提供了方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flushCache</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">    HystrixRequestCache.getInstance(KEY,</span><br><span class="line">            HystrixConcurrencyStrategyDefault.getInstance()).clear(String.valueOf(productId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FallBack降级"><a href="#FallBack降级" class="headerlink" title="FallBack降级"></a>FallBack降级</h2><p>hystrix在3种情况下会调用降级方法。</p><ol><li>运行的程序报错了，error。</li><li>线程池/信号量满了，reject。</li><li>超时了，timeout。</li></ol><p>如果路器发现异常事件的占比达到了一定的比例，直接开启断路，circuit breaker。降级方法可以返回一个自定义的结果，或者一个过期的数据。</p><p>降级是通过实现HystrixCommand.getFallBack()方法来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"从本地缓存获取过期的品牌数据，brandId="</span> + brandId);</span><br><span class="line">    <span class="keyword">return</span> BrandCache.getBrandName(brandId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断路器工作原理"><a href="#断路器工作原理" class="headerlink" title="断路器工作原理"></a>断路器工作原理</h2><ol><li>如果经过短路器的流量超过了一定的阈值，HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</li><li>如果断路器统计到的异常调用的占比超过了一定的阈值，HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</li><li>然后断路器从close状态转换到open状态</li><li>断路器打开的时候，所有经过该断路器的请求全部被短路，不调用后端服务，直接走fallback降级</li><li>经过了一段时间之后，HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()，会half-open，让一条请求经过短路器，看能不能正常调用。如果调用成功了，那么就自动恢复，转到close状态。</li></ol><h3 id="断路器配置"><a href="#断路器配置" class="headerlink" title="断路器配置"></a>断路器配置</h3><ul><li><p>circuitBreaker.enabled</p><p>  控制断路器是否允许工作，包括跟踪依赖服务调用的健康状况，以及对异常情况过多时是否允许触发短路，默认是true。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerEnabled(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure></li><li><p>circuitBreaker.requestVolumeThreshold</p><p>  设置一个rolling window，滑动窗口中，最少要有多少个请求时，才触发开启短路。举例来说，如果设置为20（默认值），那么在一个sleepWindowInMilliseconds秒的滑动窗口内，如果只有19个请求，即使这19个请求都是异常的，也是不会触发开启短路器的。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerRequestVolumeThreshold(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure></li><li><p>circuitBreaker.sleepWindowInMilliseconds</p><p>  设置在断路之后，需要在多长时间内直接reject请求，然后在这段时间之后，再重新到holf-open状态，尝试允许请求通过以及自动恢复，默认值是5000毫秒。这个值也是设置滑动窗口长度的一个值。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerSleepWindowInMilliseconds(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>circuitBreaker.errorThresholdPercentage</p><p>  设置异常请求量的百分比，当异常请求达到这个百分比时，就触发打开短路器，默认是50，也就是50%。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerErrorThresholdPercentage(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure></li><li><p>circuitBreaker.forceOpen</p><p>  如果设置为true的话，直接强迫打开短路器，相当于是手动短路了，手动降级，默认false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerForceOpen(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure></li><li><p>circuitBreaker.forceClosed</p><p>  如果设置为ture的话，直接强迫关闭短路器，相当于是手动停止短路了，手动升级，默认false。</p></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerForceClosed(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置实战"><a href="#配置实战" class="headerlink" title="配置实战"></a>配置实战</h3><p>配置一个断路器，流量要求是20，异常比例是50%，短路时间是5s。在command内加入一个判断，如果是productId=-1，那么就直接报错，触发异常执行。</p><p>写一个client测试程序，写入50个请求，前20个是正常的，但是后30个是productId=-1，然后继续请求，会发现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircuitBreakerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次请求，结果为："</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=-1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次请求，结果为："</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"等待几秒钟，统计到最近30次请求超过40%次，开启断路"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待五秒后，时间窗口统计了（withCircuitBreakerSleepWindowInMilliseconds），发现异常比例太多，这个时候才会去开启断路器。直接走断路器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次请求，结果为："</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器有一个时间窗口，我们必须要等到那个个时间窗口过了以后，hystrix才会看一下最近的时间窗口</span></span><br><span class="line">        <span class="comment">// 比如说最近的10秒内有多少条数据其中一场的数据有没有到一定的比例，如果到了一定的比例，才会去断路</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"尝试等待5秒钟，等待恢复"</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"次请求，结果为："</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断路器设计原则"><a href="#断路器设计原则" class="headerlink" title="断路器设计原则"></a>断路器设计原则</h3><ol><li>每个服务都会调用几十个后端依赖服务，那些后端依赖服务通常是由很多不同的团队开发的</li><li>每个后端依赖服务都会提供它自己的client调用库，比如说用thrift的话，就会提供对应的thrift依赖</li><li>client调用库随时会变更</li><li>client调用库随时可能会增加新的网络请求的逻辑</li><li>client调用库可能会包含诸如自动重试，数据解析，内存中缓存等逻辑</li><li>client调用库一般都对调用者来说是个黑盒，包括实现细节，网络访问，默认配置，等等</li><li>在真实的生产环境中，经常会出现调用者，突然间惊讶的发现，client调用库发生了某些变化</li><li>即使client调用库没有改变，依赖服务本身可能有会发生逻辑上的变化</li><li>有些依赖的client调用库可能还会拉取其他的依赖库，而且可能那些依赖库配置的不正确</li><li>大多数网络请求都是同步调用的</li><li>调用失败和延迟，也有可能会发生在client调用库本身的代码中，不一定就是发生在网络请求中</li></ol><p>线程池机制的优点如下：</p><ol><li>任何一个依赖服务都可以被隔离在自己的线程池内，即使自己的线程池资源填满了，也不会影响任何其他的服务调用</li><li>服务可以随时引入一个新的依赖服务，因为即使这个新的依赖服务有问题，也不会影响其他任何服务的调用</li><li>当一个故障的依赖服务重新变好的时候，可以通过清理掉线程池，瞬间恢复该服务的调用，而如果是tomcat线程池被占满，再恢复就很麻烦</li><li>如果一个client调用库配置有问题，线程池的健康状况随时会报告，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机</li><li>如果一个服务本身发生了修改，需要重新调整配置，此时线程池的健康状况也可以随时发现，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机</li><li>基于线程池的异步本质，可以在同步的调用之上，构建一层异步调用层</li></ol><p>线程池机制的缺点：</p><ol><li>线程池机制最大的缺点就是增加了cpu的开销</li><li>每个command的执行都依托一个独立的线程，会进行排队，调度，还有上下文切换</li><li>Hystrix官方自己做了一个多线程异步带来的额外开销，通过对比多线程异步调用+同步调用得出，Netflix API每天通过hystrix执行10亿次调用，每个服务实例有40个以上的线程池，每个线程池有10个左右的线程</li><li>最后，用hystrix的额外开销，就是给请求带来了3ms左右的延时，最多延时在10ms以内，相比于可用性和稳定性的提升，这是可以接受的</li></ol><h3 id="限流测试"><a href="#限流测试" class="headerlink" title="限流测试"></a>限流测试</h3><p>限流的目的是为了保护过多的请求导致服务并发量过高而宕机。</p><p>withCoreSize：设置你的线程池的大小<br>withMaxQueueSize：设置的是你的等待队列，缓冲队列的大小<br>withQueueSizeRejectionThreshold：如果withMaxQueueSize&lt;withQueueSizeRejectionThreshold，那么取的是withMaxQueueSize，反之，取得是withQueueSizeRejectionThreshold</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                    .withMaxQueueSize(<span class="number">12</span>)</span><br><span class="line">                    .withQueueSizeRejectionThreshold(<span class="number">15</span>))</span><br></pre></td></tr></table></figure><p>基于线程池的限流测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 限流测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/03/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// GetProductInfoCommand配置线程池大小10，队列长度为12，超过8以后会被拒。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先进去线程池的是10个请求，然后有8个请求进入等待队列，线程池里有空闲，等待队列中的请求如果还没有timeout，那么就进去线程池去执行</span></span><br><span class="line">        <span class="comment">// withExecutionTimeoutInMilliseconds(20000)：timeout也设置大一些，否则如果请求放等待队列中时间太长了，直接就会timeout，等不到去线程池里执行了</span></span><br><span class="line">        <span class="comment">// withFallbackIsolationSemaphoreMaxConcurrentRequests(30)：fallback，sempahore限流，30个，避免太多的请求同时调用fallback被拒绝访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                String response = HttpUtil.get(<span class="string">"http://localhost:8081/getProductInfo?productId=-2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + (finalI + <span class="number">1</span>) + <span class="string">"次请求，结果为："</span> + response);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>我们在调用一些第三方服务或者分布式系统的一些其他服务的时候，如果别的服务不稳定，导致大量超时，我们没有处理好，可能会导致我们自己的服务也会出问题，大量的线程卡死。所以我们必须做超时的控制，给我们的服务提供安全保护的措施。</p><ol><li><p>execution.isolation.thread.timeoutInMilliseconds</p><p> 手动设置timeout时长，一个command运行超出这个时间，就被认为是timeout，然后将hystrix command标识为timeout，同时执行fallback降级逻辑</p><p> 默认是1000，也就是1000毫秒</p><pre><code>`HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value)`</code></pre></li><li><p>execution.timeout.enabled</p></li></ol><pre><code>控制是否要打开timeout机制，默认是true`HystrixCommandProperties.Setter().withExecutionTimeoutEnabled(boolean value)`</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hystrix的核心知识</p><ol><li>hystrix内部工作原理：8大执行步骤和流程</li><li>资源隔离：你如果有很多个依赖服务，高可用性，先做资源隔离，任何一个依赖服务的故障不会导致你的服务的资源耗尽，不会崩溃</li><li>请求缓存：对于一个request context内的多个相同command，使用request cache，提升性能</li><li>熔断：基于短路器，采集各种异常事件，报错，超时，reject，短路，熔断，一定时间范围内就不允许访问了，直接降级，自动恢复的机制</li><li>降级：报错，超时，reject，熔断，降级，服务提供容错的机制</li><li>限流：在你的服务里面，通过线程池，或者信号量，限制对某个后端的服务或资源的访问量，避免从你的服务这里过去太多的流量，打死某个资源</li><li>超时：避免某个依赖服务性能过差，导致大量的线程hang住去调用那个服务，会导致你的服务本身性能也比较差</li></ol><p>hystrix的高阶知识</p><ol><li>request collapser，请求合并技术</li><li>fail-fast和fail-slient，高阶容错模式</li><li>static fallback和stubbed fallback，高阶降级模式</li><li>嵌套command实现的发送网络请求的降级模式</li><li>基于facade command的多级降级模式</li><li>request cache的手动清理</li><li>生产环境中的线程池大小以及timeout配置优化经验</li><li>线程池的自动化动态扩容与缩容技术</li><li>hystrix的metric高阶配置</li><li>基于hystrix dashboard的可视化分布式系统监控</li><li>生产环境中的hystrix工程运维经验</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h2 id=&quot;Hystrix流程讲解&quot;&gt;&lt;a href=&quot;#Hystrix流程讲解&quot; class=&quot;headerlink&quot; title=&quot;Hystrix流程讲解&quot;&gt;&lt;/a&gt;Hystrix流程讲解&lt;/h2&gt;&lt;h3 id=&quot;创建Command&quot;&gt;&lt;a href=&quot;#创建Command&quot; class=&quot;headerlink&quot; title=&quot;创建Command&quot;&gt;&lt;/a&gt;创建Command&lt;/h3&gt;&lt;p&gt;一个HystrixCommand或一个HystrixObservableCommand对象，代表了对某个依赖服务发起的一次请求或者调用，构造的时候，可以在构造函数中传入任何需要的参数。&lt;br&gt;
    
    </summary>
    
      <category term="hystrix" scheme="http://www.saily.top/categories/hystrix/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix介绍和简单使用</title>
    <link href="http://www.saily.top/2018/03/11/hystrix01/"/>
    <id>http://www.saily.top/2018/03/11/hystrix01/</id>
    <published>2018-03-11T04:05:39.000Z</published>
    <updated>2018-08-25T08:18:08.275Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p><h1 id="Hystrix是什么？"><a href="#Hystrix是什么？" class="headerlink" title="Hystrix是什么？"></a>Hystrix是什么？</h1><p>在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。</p><p>Hystrix可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。</p><a id="more"></a><p>Hystrix通过将依赖服务进行资源隔离，进而组织某个依赖服务出现故障的时候，这种故障在整个系统所有的依赖服务调用中进行蔓延，同时Hystrix还提供故障时的fallback降级机制</p><p>总而言之，Hystrix通过这些方法帮助我们提升分布式系统的可用性和稳定性。</p><p><img src="/img/hystrix/什么是分布式系统以及其中的故障和hystrix.png" alt="什么是分布式系统以及其中的故障和hystrix"></p><h1 id="Hystrix的历史"><a href="#Hystrix的历史" class="headerlink" title="Hystrix的历史"></a>Hystrix的历史</h1><p>hystrix就是一种高可用保障的一个框架，预先封装好的为了解决某个特定领域的特定问题的一套代码库。用了框架之后，来解决这个领域的特定的问题，就可以大大减少我们的工作量，提升我们的工作质量和工作效率。</p><p>Netflix（可以认为是国外的优酷或者爱奇艺之类的视频网站），API团队从2011年开始做一些提升系统可用性和稳定性的工作，Hystrix就是从那时候开始发展出来的。</p><p>在2012年的时候，Hystrix就变得比较成熟和稳定了，Netflix中，除了API团队以外，很多其他的团队都开始使用Hystrix。</p><p>时至今日，Netflix中每天都有数十亿次的服务间调用，通过Hystrix框架在进行，而Hystrix也帮助Netflix网站提升了整体的可用性和稳定性</p><h1 id="Hystrix的设计原则"><a href="#Hystrix的设计原则" class="headerlink" title="Hystrix的设计原则"></a>Hystrix的设计原则</h1><p>hystrix为了实现高可用性的架构，它的设计原则:</p><ol><li>对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护</li><li>在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延，服务A-&gt;服务B-&gt;服务C，服务C故障了，服务B也故障了，服务A故障了，整套分布式系统全部故障，整体宕机</li><li>提供fail-fast（快速失败）和快速恢复的支持</li><li>提供fallback优雅降级的支持</li><li>支持近实时的监控、报警以及运维操作</li></ol><h1 id="Hystrix要解决的问题"><a href="#Hystrix要解决的问题" class="headerlink" title="Hystrix要解决的问题"></a>Hystrix要解决的问题</h1><p>在复杂的分布式系统架构中，每个服务都有很多的依赖服务，而每个依赖服务都可能会故障。如果服务没有和自己的依赖服务进行隔离，那么可能某一个依赖服务的故障就会拖垮当前这个服务。</p><p>举例来说，某个服务有30个依赖服务，每个依赖服务的可用性非常高，已经达到了99.99%的高可用性，那么该服务的可用性就是99.99%的30次方，也就是99.7%的可用性，99.7%的可用性就意味着0.3%的请求可能会失败，因为0.3%的时间内系统可能出现了故障导致系统不可用。对于1亿次访问来说，0.3%的请求失败，也就意味着30万次请求会失败，也意味着每个月有2个小时的时间系统是不可用的。</p><p>在真实生产环境中，可能更加糟糕，也就是说，即使你每个依赖服务都是99.99%高可用性，但是一旦你有几十个依赖服务，还是会导致你每个月都有几个小时是不可用的。</p><p><img src="/img/hystrix/依赖服务的故障导致服务被拖垮以及故障的蔓延.png" alt="依赖服务的故障导致服务被拖垮以及故障的蔓延"></p><h1 id="Hystrix的更加细节的设计原则"><a href="#Hystrix的更加细节的设计原则" class="headerlink" title="Hystrix的更加细节的设计原则"></a>Hystrix的更加细节的设计原则</h1><ol><li>阻止任何一个依赖服务耗尽所有的资源，比如tomcat中的所有线程资源</li><li>避免请求排队和积压，采用限流和fail fast来控制故障</li><li>提供fallback降级机制来应对故障</li><li>使用资源隔离技术，比如bulkhead（舱壁隔离技术），swimlane（泳道技术），circuit breaker（短路技术），来限制任何一个依赖服务的故障的影响</li><li>通过近实时的统计/监控/报警功能，来提高故障发现的速度</li><li>通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度</li><li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况</li></ol><h1 id="Hystrix的实现"><a href="#Hystrix的实现" class="headerlink" title="Hystrix的实现"></a>Hystrix的实现</h1><ol><li>通过HystrixCommand或者HystrixObservableCommand来封装对外部依赖的访问请求，这个访问请求一般会运行在独立的线程中，资源隔离</li><li>对于超出我们设定阈值的服务调用，直接进行超时，不允许其耗费过长时间阻塞住。这个超时时间默认是99.5%的访问时间，但是一般我们可以自己设置一下</li><li>为每一个依赖服务维护一个独立的线程池，或者是semaphore，当线程池已满时，直接拒绝对这个服务的调用</li><li>对依赖服务的调用的成功次数，失败次数，拒绝次数，超时次数，进行统计</li><li>如果对一个依赖服务的调用失败次数超过了一定的阈值，自动进行熔断，在一定时间内对该服务的调用直接降级，一段时间后再自动尝试恢复</li><li>当一个服务调用出现失败，被拒绝，超时，短路等异常情况时，自动调用fallback降级机制</li><li>对属性和配置的修改提供近实时的支持</li></ol><p><img src="/img/hystrix/资源隔离如何保护依赖服务的故障不要拖垮整个系统.png" alt="资源隔离如何保护依赖服务的故障不要拖垮整个系统"></p><h1 id="Hystrix项目实战"><a href="#Hystrix项目实战" class="headerlink" title="Hystrix项目实战"></a>Hystrix项目实战</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>商品详情页服务和缓存服务，模拟缓存更新时如何使用hystrix。</p><p><strong>缓存服务</strong></p><p><a href="https://github.com/sail-y/eshop-cache-ha" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache-ha</a></p><p><strong>商品服务</strong></p><p><a href="https://github.com/sail-y/eshop-product-ha" target="_blank" rel="noopener">https://github.com/sail-y/eshop-product-ha</a></p><h2 id="商品服务接口导致缓存服务资源耗尽的问题"><a href="#商品服务接口导致缓存服务资源耗尽的问题" class="headerlink" title="商品服务接口导致缓存服务资源耗尽的问题"></a>商品服务接口导致缓存服务资源耗尽的问题</h2><p><img src="/img/hystrix/商品服务接口导致缓存服务资源耗尽的问题.png" alt="商品服务接口导致缓存服务资源耗尽的问题"></p><h2 id="基于线程池的资源隔离"><a href="#基于线程池的资源隔离" class="headerlink" title="基于线程池的资源隔离"></a>基于线程池的资源隔离</h2><p>hystrix进行资源隔离，其实是提供了一个command抽象。把对某一个依赖服务的所有调用请求全部隔离在同一份资源池内，对这个依赖服务的所有调用请求，全部走这个资源池内的资源，不会去用其他的资源了，这个就叫做资源隔离。</p><p>hystrix最最基本的资源隔离的技术，<strong>线程池隔离技术</strong>。对某一个依赖服务，商品服务，所有的调用请求，全部隔离到一个线程池内，对商品服务的每次调用请求都封装在一个command里面。每个command（每次服务调用请求）都是使用线程池内的一个线程去执行的，所以哪怕是对这个依赖服务（商品服务）同时发起的调用量已经到了1000了，但是线程池内就10个线程，最多就只会用这10个线程去执行。</p><p>不会出现对商品服务的请求，因为接口调用延迟将tomcat内部所有的线程资源全部耗尽。目的是为了保护不要因为某一个依赖服务的故障，导致耗尽了缓存服务中的所有的线程资源去执行。</p><h3 id="HystrixCommand：是用来获取一条数据的"><a href="#HystrixCommand：是用来获取一条数据的" class="headerlink" title="HystrixCommand：是用来获取一条数据的"></a>HystrixCommand：是用来获取一条数据的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"GetProductInfoCommandGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://localhost:8082/getProductInfo?productId="</span> + productId;</span><br><span class="line">        String response = HttpUtil.get(url);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test:</p><p><a href="http://localhost:8081/getProductInfo?productId=1" target="_blank" rel="noopener">http://localhost:8081/getProductInfo?productId=1</a></p><h3 id="HystrixObservableCommand：是设计用来获取多条数据的"><a href="#HystrixObservableCommand：是设计用来获取多条数据的" class="headerlink" title="HystrixObservableCommand：是设计用来获取多条数据的"></a>HystrixObservableCommand：是设计用来获取多条数据的</h3><p>controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getProductInfos"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProductInfos</span><span class="params">(String productIds)</span> </span>&#123;</span><br><span class="line">    HystrixObservableCommand&lt;ProductInfo&gt; getProductInfosCommand = <span class="keyword">new</span> GetProductInfosCommand(productIds.split(<span class="string">","</span>));</span><br><span class="line">    Observable&lt;ProductInfo&gt; observable = getProductInfosCommand.observe();</span><br><span class="line">    observable.subscribe(<span class="keyword">new</span> Observer&lt;ProductInfo&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"获取完了所有的商品数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">            log.info(productInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>command:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfosCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] productIds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfosCommand</span><span class="params">(String[] productIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"GetProductInfoCommandGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.productIds = productIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;ProductInfo&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Observable.&lt;ProductInfo&gt;create(observer -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String productId : productIds) &#123;</span><br><span class="line">                        String url = <span class="string">"http://localhost:8082/getProductInfo?productId="</span> + productId;</span><br><span class="line">                        String response = HttpUtil.get(url);</span><br><span class="line">                        ProductInfo productInfo = JSON.parseObject(response, ProductInfo.class);</span><br><span class="line">                        observer.onNext(productInfo);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    observer.onCompleted();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                observer.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test:</p><p><a href="http://localhost:8081/getProductInfos?productId=1,2,3" target="_blank" rel="noopener">http://localhost:8081/getProductInfos?productId=1,2,3</a></p><h3 id="command的四种调用方式"><a href="#command的四种调用方式" class="headerlink" title="command的四种调用方式"></a>command的四种调用方式</h3><p>同步：new CommandHelloWorld(“World”).execute()，new ObservableCommandHelloWorld(“World”).toBlocking().toFuture().get()</p><p>异步：new CommandHelloWorld(“World”).queue()，new ObservableCommandHelloWorld(“World”).toBlocking().toFuture()</p><p>立即执行： observe()：hot，已经执行过了</p><p>订阅： toObservable(): cold，还没执行过</p><h2 id="基于信号量的资源隔离"><a href="#基于信号量的资源隔离" class="headerlink" title="基于信号量的资源隔离"></a>基于信号量的资源隔离</h2><p><img src="/img/hystrix/信号量的资源隔离与限流的说明.png" alt="信号量的资源隔离与限流的说明"></p><p>信号量跟线程池两种资源隔离的技术的区别：</p><p><img src="/img/hystrix/线程池隔离和信号量隔离的原理以及区别.png" alt="线程池隔离和信号量隔离的原理以及区别"></p><h2 id="线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用"><a href="#线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用" class="headerlink" title="线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用?"></a>线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用?</h2><p>线程池：适合99%场景，线程池一般处理对依赖服务的网络请求的调用和访问，timeout这种问题。</p><p>信号量：适合不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，但是像这种访问系统内部的代码，其实不涉及任何的网络请求。那么只要做信号量的普通限流就可以了，因为不需要去捕获timeout类似的问题，如果算法+数据结构的效率不是太高，并发量突然太高，因为这里稍微耗时一些，导致很多线程卡在这里的话是不太好的。所以进行一个基本的资源隔离和访问，避免内部复杂的低效率的代码，导致大量的线程被hang住。</p><p><strong>采用信号量技术进行资源隔离与限流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">               .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));</span><br></pre></td></tr></table></figure><h2 id="资源隔离策略配置"><a href="#资源隔离策略配置" class="headerlink" title="资源隔离策略配置"></a>资源隔离策略配置</h2><p>现在我们知道有线程池（THREAD）和信号量（SEMAPHORE）两种隔离方式。除了选择隔离方式，hystrix还支持对隔离策略进行一些细粒度的配置。</p><p>默认的策略就是线程池</p><p>线程池其实最大的好处就是对于网络访问请求，如果有超时的话，可以避免调用线程阻塞住</p><p>而使用信号量的场景，通常是针对超大并发量的场景下，每个服务实例每秒都几百的QPS，那么此时你用线程池的话，线程一般不会太多，可能撑不住那么高的并发，如果要撑住，可能要耗费大量的线程资源，那么就是用信号量，来进行限流保护</p><p>一般用信号量常见于那种基于纯内存的一些业务逻辑服务，而不涉及到任何网络访问请求</p><p>netflix有100+的command运行在40+的线程池中，只有少数command是不运行在线程池中的，就是从纯内存中获取一些元数据，或者是对多个command包装起来的facacde command，是用信号量限流的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to use thread isolation</span></span><br><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)</span><br><span class="line"><span class="comment">// to use semaphore isolation</span></span><br><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)</span><br></pre></td></tr></table></figure><h3 id="command名称和command组"><a href="#command名称和command组" class="headerlink" title="command名称和command组"></a>command名称和command组</h3><p>每个command都可以设置一个自己的名称，同时可以设置一个自己的组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Setter cachedSetter = </span><br><span class="line">    Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"HelloWorld"</span>));    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(cachedSetter);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>command group，是一个非常重要的概念，默认情况下，因为就是通过command group来定义一个线程池的，而且还会通过command group来聚合一些监控和报警信息。同一个command group中的请求，都会进入同一个线程池中。</p><h3 id="command线程池"><a href="#command线程池" class="headerlink" title="command线程池"></a>command线程池</h3><p>threadpool key代表了一个HystrixThreadPool，用来进行统一监控，统计，缓存。默认的threadpool key就是command group名称。每个command都会跟它的threadpool key对应的thread pool绑定在一起。如果不想直接用command group，也可以手动设置thread pool name。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"HelloWorld"</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"HelloWorldPool"</span>)));</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>command threadpool -&gt; command group -&gt; command key</p><ul><li>command key：代表了一类command，一般来说代表了底层的依赖服务的一个接口。</li><li>command group：代表了某一个底层的依赖服务，一个依赖服务可能会暴露出来多个接口，每个接口就是一个command key。在逻辑上去组织起来一堆command key的调用，统计信息、成功次数、timeout超时次数、失败次数等等，可以看到某一个服务整体的一些访问情况。一般推荐是根据一个服务去划分出一个线程池，command key默认都是属于同一个线程池的。</li></ul><p>比如以一个服务为粒度，估算出来这个服务每秒的所有接口加起来的整体QPS在100左右。调用目标服务的当前服务部署了10个服务实例，每个服务实例上给一个线程池，线程数量大概在10个左右，就可以满足对目标服务的整体的访问QPS大概在每秒100左右需求了。</p><p>还有一种场景，就是command group对应的服务的接口访问量差别很大。然后就希望做一些细粒度的资源隔离，针对同一个服务的不同接口，使用不同的线程池。</p><p>之前的模式是： command key -&gt; command group</p><p>我们可以针对每个command单独设置threadpool key：command key -&gt; 自己的threadpool key</p><p>这样从逻辑上来说多个command key是属于一个command group的，在做统计的时候会放在一起统计。但是每个command key有自己的线程池，每个接口有自己的线程池去做资源隔离和限流。</p><h3 id="设置线程池大小"><a href="#设置线程池大小" class="headerlink" title="设置线程池大小"></a>设置线程池大小</h3><p>Hystrix默认的线程池大小是10，可以通过下面的代码进行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter()</span><br><span class="line">   .withCoreSize(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure><p>一般来说默认的10个已经够了。</p><h3 id="queueSizeRejectionThreshold"><a href="#queueSizeRejectionThreshold" class="headerlink" title="queueSizeRejectionThreshold"></a>queueSizeRejectionThreshold</h3><p>线程池是10个，如果还有请求过来，默认可以排队的线程是5个。超过5个以后多余的请求进来，就会被线程池拒绝掉，抛出异常。</p><p>默认值是5，可以通过下面代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter()</span><br><span class="line">   .withQueueSizeRejectionThreshold(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure><h3 id="execution-isolation-semaphore-maxConcurrentRequests"><a href="#execution-isolation-semaphore-maxConcurrentRequests" class="headerlink" title="execution.isolation.semaphore.maxConcurrentRequests"></a>execution.isolation.semaphore.maxConcurrentRequests</h3><p>设置使用SEMAPHORE隔离策略的时候，允许访问的最大并发量，超过这个最大并发量，请求直接被reject。这个并发量的设置跟线程池大小的设置应该是类似的，但是基于信号量的话性能会好很多，而且hystrix框架本身的开销会小很多。</p><p>默认值是10，不能设置得太大，因为信号量是基于调用线程去执行command的，而且不能从timeout中抽离，因此一旦设置的太大，而且有延时发生，可能瞬间导致tomcat本身的线程资源本占满。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure><p>Hystrix的基本使用已经差不多是这样了，后面再有一篇文章，分析hystrix的流程和原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程学习笔记，记录以后翻看&lt;/p&gt;
&lt;h1 id=&quot;Hystrix是什么？&quot;&gt;&lt;a href=&quot;#Hystrix是什么？&quot; class=&quot;headerlink&quot; title=&quot;Hystrix是什么？&quot;&gt;&lt;/a&gt;Hystrix是什么？&lt;/h1&gt;&lt;p&gt;在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。&lt;/p&gt;
&lt;p&gt;Hystrix可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。&lt;/p&gt;
    
    </summary>
    
      <category term="hystrix" scheme="http://www.saily.top/categories/hystrix/"/>
    
    
      <category term="spring-cloud" scheme="http://www.saily.top/tags/spring-cloud/"/>
    
      <category term="hystrix" scheme="http://www.saily.top/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>高可用缓存架构实战5-缓存预热</title>
    <link href="http://www.saily.top/2018/02/22/cache05/"/>
    <id>http://www.saily.top/2018/02/22/cache05/</id>
    <published>2018-02-22T12:16:59.000Z</published>
    <updated>2018-09-19T01:47:57.572Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>系统刚上线的时候，redis里面是没有数据的，如果这个时候高并发的流量过来全部跑到mysql，那么mysql肯定就挂掉了。所以我们需要缓存预热<br><a id="more"></a></p><ol><li>提前给redis中灌入部分数据，再提供服务</li><li>肯定不可能将所有数据都写入redis，因为数据量太大了，第一耗费的时间太长了，第二根本redis容纳不下所有的数据</li><li>需要根据当天的具体访问情况，实时统计出访问频率较高的热数据</li><li>然后将访问频率较高的热数据写入redis中，肯定是热数据也比较多，我们也得多个服务并行读取数据去写，并行的分布式的缓存预热</li><li>然后将灌入了热数据的redis对外提供服务，这样就不至于冷启动，直接让数据库裸奔了</li></ol><p>缓存预热的方案和流程：</p><p>1、 nginx+lua将访问流量上报到kafka中</p><p>要统计出来当前最新的实时的热数据是哪些，我们就得将商品详情页访问的请求对应的流量，日志，实时上报到kafka中。</p><p>2、 storm从kafka中消费数据，实时统计出每个商品的访问次数，访问次数基于LRU内存数据结构的存储方案</p><p><a href="http://www.saily.top/2018/02/22/cache04-3/">如何使用storm？</a></p><p>优先用内存中的一个LRUMap去存放，这样做性能高，而且没有外部依赖。否则依赖redis的话，我们本就是要防止redis挂掉数据丢失的情况，就不合适了; 用mysql，扛不住高并发读写; 用hbase，hadoop生态系统，维护麻烦，太重了。其实我们只要统计出最近一段时间访问最频繁的商品，然后对它们进行访问计数，同时维护出一个前N个访问最多的商品list即可。计算好每个task大致要存放的商品访问次数的数量，计算出大小。然后构建一个LRUMap，apache commons collections有开源的实现，设定好map的最大大小，就会自动根据LRU算法去剔除多余的数据，保证内存使用限制。即使有部分数据被干掉了，然后下次来重新开始计数，也没关系，因为如果它被LRU算法干掉，那么它就不是热数据，说明最近一段时间都很少访问了。</p><p>3、每个storm task启动的时候，基于zk分布式锁，将自己的id写入zk同一个节点中</p><p>4、每个storm task负责完成自己这里的热数据的统计，每隔一段时间，就遍历一下这个map，然后维护一个前3个商品的list，更新这个list</p><p>5、写一个后台线程，每隔一段时间，比如1分钟，都将排名前3的热数据list，同步到zk中去，存储到这个storm task对应的一个znode中去</p><p>6、我们需要一个服务，比如说，代码可以跟缓存数据生产服务放一起，但是也可以放单独的服务，这个服务可能部署了很多个实例。每次服务启动的时候，就会去拿到一个storm task的列表，然后根据taskid，一个一个的去尝试获取taskid对应的znode的zk分布式锁。如果能获取到分布式锁的话，那么就将那个storm task对应的热数据的list取出来，然后将数据从mysql中查询出来，写入缓存中，进行缓存的预热。因为是多个服务实例，分布式的并行的去做，都基于zk分布式锁做了协调（没有并发冲突问题），分布式并行缓存的预热，效率很高。</p><h2 id="基于nginx-lua完成商品详情页访问流量实时上报kafka的开发"><a href="#基于nginx-lua完成商品详情页访问流量实时上报kafka的开发" class="headerlink" title="基于nginx+lua完成商品详情页访问流量实时上报kafka的开发"></a>基于nginx+lua完成商品详情页访问流量实时上报kafka的开发</h2><p>在nginx这一层，接收到访问请求的时候，就把请求的流量上报发送给kafka。这样的话，storm才能去消费kafka中的实时的访问日志，然后去进行缓存热数据的统计。用的技术方案非常简单，从lua脚本直接创建一个kafka producer，发送数据到kafka。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">wget https://github.com/doujiang24/lua-resty-kafka/archive/master.zip</span><br><span class="line">yum install -y unzip</span><br><span class="line">unzip master.zip</span><br><span class="line">cp -rf /usr/<span class="built_in">local</span>/lua-resty-kafka-master/lib/resty /usr/hello/lualib</span><br></pre></td></tr></table></figure><p>接着修改脚本，开始写记录日志并发送到kafka：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</span><br><span class="line"><span class="keyword">local</span> producer = <span class="built_in">require</span>(<span class="string">"resty.kafka.producer"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> broker_list = &#123;</span><br><span class="line">&#123;host=<span class="string">"192.168.2.201"</span>, port=<span class="number">9092</span>&#125;,</span><br><span class="line">&#123;host=<span class="string">"192.168.2.202"</span>, port=<span class="number">9092</span>&#125;,</span><br><span class="line">&#123;host=<span class="string">"192.168.2.203"</span>, port=<span class="number">9092</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> log_json = &#123;&#125;</span><br><span class="line"><span class="comment">-- 商品详情页</span></span><br><span class="line">log_json[<span class="string">"request_module"</span>] = <span class="string">"product_detail_info"</span></span><br><span class="line">log_json[<span class="string">"headers"</span>] = ngx.req.get_headers()</span><br><span class="line">log_json[<span class="string">"uri_args"</span>] = ngx.req.get_uri_args()</span><br><span class="line">log_json[<span class="string">"body"</span>] = ngx.req.read_body()  </span><br><span class="line">log_json[<span class="string">"http_version"</span>] = ngx.req.http_version()  </span><br><span class="line">log_json[<span class="string">"method"</span>] =ngx.req.get_method() </span><br><span class="line">log_json[<span class="string">"raw_reader"</span>] = ngx.req.raw_header()  </span><br><span class="line">log_json[<span class="string">"body_data"</span>] = ngx.req.get_body_data()  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> message = cjson.encode(log_json);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"><span class="keyword">local</span> shopId = uri_args[<span class="string">"shopId"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向kafka发送请求的记录</span></span><br><span class="line"><span class="keyword">local</span> async_producer = producer:new(broker_list, &#123;producer_type=<span class="string">"async"</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> ok, err = async_producer:send(<span class="string">"access-log"</span>, productId, message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接商品和缓存的key</span></span><br><span class="line"><span class="keyword">local</span> productCacheKey = <span class="string">"product_info_"</span>..productId</span><br><span class="line"><span class="keyword">local</span> shopCacheKey = <span class="string">"shop_info_"</span>..shopId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取cache</span></span><br><span class="line"><span class="keyword">local</span> productCache = cache_ngx:get(productCacheKey)</span><br><span class="line"><span class="keyword">local</span> shopCache = cache_ngx:get(shopCacheKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 没有就从后端查询</span></span><br><span class="line"><span class="keyword">if</span> productCache ==  <span class="string">""</span> <span class="keyword">or</span> productCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">"resty.http"</span>)</span><br><span class="line">    <span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">"http://192.168.2.171:8080"</span>,&#123;</span><br><span class="line">method = <span class="string">"GET"</span>,</span><br><span class="line"><span class="built_in">path</span> = <span class="string">"/getProductInfo?productId="</span>..productId</span><br><span class="line">    &#125;)</span><br><span class="line">    productCache = resp.body</span><br><span class="line">    cache_ngx:set(productCacheKey, productCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shopCache == <span class="string">""</span> <span class="keyword">or</span> shopCache == <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">"resty.http"</span>)</span><br><span class="line">    <span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">"http://192.168.2.171:8080"</span>,&#123;</span><br><span class="line">method = <span class="string">"GET"</span>,</span><br><span class="line"><span class="built_in">path</span> = <span class="string">"/getShopInfo?shopId="</span>..shopId</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    shopCache = resp.body</span><br><span class="line">    cache_ngx:set(shopCacheKey, shopCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCacheJSON = cjson.decode(productCache)</span><br><span class="line"><span class="keyword">local</span> shopCacheJSON = cjson.decode(shopCache)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">productId = productCacheJSON.id,</span><br><span class="line">productName = productCacheJSON.name,</span><br><span class="line">productPrice = productCacheJSON.price,</span><br><span class="line">productPictureList = productCacheJSON.pictureList,</span><br><span class="line">productSpecification = productCacheJSON.specification,</span><br><span class="line">productService = productCacheJSON.service,</span><br><span class="line">productColor = productCacheJSON.color,</span><br><span class="line">productSize = productCacheJSON.size,</span><br><span class="line">shopId = shopCacheJSON.id,</span><br><span class="line">shopName = shopCacheJSON.name,</span><br><span class="line">shopLevel = shopCacheJSON.level,</span><br><span class="line">shopGoodCommentRate = shopCacheJSON.goodCommentRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 渲染模板</span></span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">"resty.template"</span>)</span><br><span class="line">template.render(<span class="string">"product.html"</span>, context)</span><br></pre></td></tr></table></figure><p>两台机器上都这样做，才能统一上报流量到kafka</p><p>修改配置：</p><ol><li>在nginx.conf中，http部分，加入resolver 8.8.8.8;</li><li>在<code>/usr/local/kafka/config/server.properties</code>中加入<code>advertised.host.name = 192.168.2.201</code>(各kafka实例的ip)，杀掉并重启三个kafka进程。<code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></li><li>启动eshop-cache缓存服务，因为nginx中的本地缓存可能不在了</li></ol><p>下面试试消息是否上报成功，先创建kafka topic。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic access-log --replication-factor 1 --partitions 1 --create</span><br></pre></td></tr></table></figure><p>访问：<a href="http://192.168.2.203/product?productId=1&amp;requestPath=product&amp;shopId=1" target="_blank" rel="noopener">http://192.168.2.203/product?productId=1&amp;requestPath=product&amp;shopId=1</a></p><p>启动consumer，订阅access-log主题可以看到消息已经发送过来了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic access-log --from-beginning</span><br></pre></td></tr></table></figure><p><img src="/img/cache/cache05_1.png" alt="cache05_1.png"></p><h2 id="基于Storm统计热数据"><a href="#基于Storm统计热数据" class="headerlink" title="基于Storm统计热数据"></a>基于Storm统计热数据</h2><ol><li>用Spout从kafka读取消息</li><li>Bolt提取productId发射到下一个Bolt</li><li>基于LRUMap统计热点访问的productId</li><li>将热点数据存入zookeeper</li></ol><p><a href="https://github.com/sail-y/eshop-storm" target="_blank" rel="noopener">https://github.com/sail-y/eshop-storm</a></p><p>预热逻辑：</p><ol><li>服务启动的时候，进行缓存预热</li><li>从zk中读取taskid列表</li><li>依次遍历每个taskid，尝试获取分布式锁，如果获取不到，快速报错，不要等待，因为说明已经有其他服务实例在预热了</li><li>直接尝试获取下一个taskid的分布式锁</li><li>即使获取到了分布式锁，也要检查一下这个taskid的预热状态，如果已经被预热过了，就不再预热了</li><li>执行预热操作，遍历productid列表，查询数据，然后写ehcache和redis</li><li>预热完成后，设置taskid对应的预热状态</li></ol><p><a href="https://github.com/sail-y/eshop-cache" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache</a></p><h2 id="基于nginx-lua-storm的热点缓存的流量分发策略自动降级解决方案"><a href="#基于nginx-lua-storm的热点缓存的流量分发策略自动降级解决方案" class="headerlink" title="基于nginx+lua+storm的热点缓存的流量分发策略自动降级解决方案"></a>基于nginx+lua+storm的热点缓存的流量分发策略自动降级解决方案</h2><p>如果因为秒杀等或者抢购等原因，某一个商品访问量瞬间飙升，就算做了流量分发和缓存，因为hash策略所以同一个productId会被分发到同一个nginx服务器中。那么这就可能会导致nginx服务挂掉，这一台挂掉后别的服务上，然后也陆陆续续挂掉，导致整个系统不可用。</p><hr><p><strong>解决办法：</strong></p><p><strong>在storm中实时的计算出瞬间出现的热点</strong></p><p>我们可以基于storm来计算热点数据，比如我们将访问的次数排序，将后面95%的数据访问量取一个平均值。这个时候要设定一个阈值，如果超出95%平均值的n倍，例如5倍，我们就认为是瞬间出现的热点数据，判断其可能在短时间内继续扩大的访问量，甚至达到平均值几十倍，或者几百倍，当发现第一个商品的访问次数，小于平均值的5倍，就安全了，就break掉这个循环。</p><p><strong>流量分发nginx的分发策略降级</strong></p><p>流量分发nginx加一个逻辑：每次访问一个商品详情页的时候，如果发现它是个热点，那么立即做流量分发策略的降级。降级成对这个热点商品，流量分发采取随机负载均衡发送到所有的后端应用nginx服务器上去。瞬间将热点缓存数据的访问从hash分发全部到一台nginx，变成了负载均衡发送到多台nginx上。</p><p><strong>storm还需要保存下来上次识别出来的热点list</strong></p><p>保存上次的热点数据，跟这次计算出的热点数据进行比较，那么就需要对某些数据进行热点取消，删除nginx本地缓存。</p><h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p><a href="https://github.com/sail-y/eshop-storm" target="_blank" rel="noopener">https://github.com/sail-y/eshop-storm</a></p><pre><code>HotProductFindThread.java</code></pre><p>新增的逻辑：</p><ol><li>将LRUMap中的数据按照访问次数进行全局的排序</li><li>计算95%的商品访问次数的平均值</li><li>遍历排序后的商品访问次数，降序</li><li>如果某个商品是平均访问量的10倍以上，就认为是缓存的热点</li><li>将缓存热点数据推送到流量分发的nginx中</li><li>将获取到的换成你数据推送到nginx服务上</li></ol><h3 id="lua接口开发"><a href="#lua接口开发" class="headerlink" title="lua接口开发"></a>lua接口开发</h3><p><strong>将热点数据进行标记接口开发</strong></p><p>之前流量分发的nginx服务是部署在192.168.2.203上面的，所以<code>vi /usr/hello/hello.conf</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  _;</span><br><span class="line"></span><br><span class="line">    location /hello &#123;</span><br><span class="line">        default_type <span class="string">'text/html'</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/hello.lua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /product &#123;</span><br><span class="line">        default_type <span class="string">'text/html'</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/distribute.lua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /hot &#123;</span><br><span class="line">        default_type <span class="string">'text/html'</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/hot.lua;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/hello/lua/hot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> hot_product_cache_key = <span class="string">"hot_product_"</span>..product_id</span><br><span class="line">cache_ngx:<span class="built_in">set</span>(hot_product_cache_key, <span class="string">"true"</span>, 60*60)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><hr><p><strong>设置缓存数据接口开发</strong></p><p><strong>分别在201和201的nginx应用增加一个hot的配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/hello/hello.conf</span><br><span class="line">location /hot &#123;</span><br><span class="line">default_type <span class="string">'text/html'</span>;</span><br><span class="line">content_by_lua_file /usr/hello/lua/hot.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi /usr/hello/lua/hot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"><span class="built_in">local</span> product_info = uri_args[<span class="string">"productInfo"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> product_cache_key = <span class="string">"product_info_"</span>..product_id</span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line">cache_ngx:<span class="built_in">set</span>(product_cache_key, product_info, 60*60)</span><br></pre></td></tr></table></figure><h3 id="自动降级代码开发"><a href="#自动降级代码开发" class="headerlink" title="自动降级代码开发"></a>自动降级代码开发</h3><p>下面在distribute.lua里面开发自动降级的逻辑</p><ol><li>取出之前在hot.lua中缓存的hot_product_cache_key</li><li>如果为<code>true</code>就不走hash算法进行流量分发了，走随机负载均衡算法。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> hosts = &#123;<span class="string">"192.168.2.201"</span>, <span class="string">"192.168.2.202"</span>&#125;</span><br><span class="line"><span class="keyword">local</span> backend = <span class="string">""</span></span><br><span class="line"><span class="keyword">local</span> hot_product_key = <span class="string">"hot_product_"</span>..productId</span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"><span class="keyword">local</span> hot_product_flag = cache_ngx:get(hot_product_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hot_product_flag == <span class="string">"true"</span> <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">tostring</span>(<span class="built_in">os</span>.<span class="built_in">time</span>()):<span class="built_in">reverse</span>():<span class="built_in">sub</span>(<span class="number">1</span>, <span class="number">7</span>))</span><br><span class="line">  <span class="keyword">local</span> index = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  backend = <span class="string">"http://"</span>..hosts[index]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">local</span> hash = ngx.crc32_long(productId)</span><br><span class="line">  <span class="keyword">local</span> index = (hash % <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">  backend = <span class="string">"http://"</span>..hosts[index]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="热点缓存消失自动识别和感知逻辑开发"><a href="#热点缓存消失自动识别和感知逻辑开发" class="headerlink" title="热点缓存消失自动识别和感知逻辑开发"></a>热点缓存消失自动识别和感知逻辑开发</h3><p><a href="https://github.com/sail-y/eshop-cache" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache</a></p><p><strong>HotProductFindThread.java</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 缓存热点消失，发送一个一个http请求到nginx取消热点缓存的标识</span><br><span class="line">String url = &quot;http://192.168.2.203/cancelHot?productId=&quot; + productId;</span><br><span class="line">HttpClientUtils.sendGetRequest(url);</span><br></pre></td></tr></table></figure><p><strong>203上nginx的lua接口开发</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vi hello.conf </span><br><span class="line">location /cancelHot &#123;</span><br><span class="line">    default_type <span class="string">'text/html'</span>;</span><br><span class="line">    content_by_lua_file /usr/hello/lua/cancelHot.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cp lua/hot.lua lua/cancelHot.lua</span><br><span class="line"></span><br><span class="line">vi lua/cancelHot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> hot_product_cache_key = <span class="string">"hot_product_"</span>..product_id</span><br><span class="line"></span><br><span class="line">cache_ngx:<span class="built_in">set</span>(hot_product_cache_key, <span class="string">"false"</span>, 60)</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>手动将某个热点设置为热点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.2.203/hot?productId=1</span><br></pre></td></tr></table></figure><p>然后访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.2.203/product?productId=1&amp;requestPath=product&amp;shopId=1</span><br></pre></td></tr></table></figure><p>可以看到当缓存变成热点以后，访问的服务是随机变化的。</p><p>因为代码里用了缓存，所以记得在203的上面<code>vi conf/nginx.conf</code>，在http模块下新增<code>lua_shared_dict my_cache 128m;</code>。</p><ol><li>多访问几次不同的商品ID</li><li>用storm运行topology，观察日志是否正确</li><li>观察zookeeper里面的数据是否正确</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">get /task-hot-product-list-4</span><br><span class="line">[5,1,3]</span><br></pre></td></tr></table></figure><p>storm日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2018-03-03 21:12:56.627 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread计算出一份排序后的商品访问次数列表】 productCountListJSON=[&#123;1:11&#125;,&#123;3:1&#125;,&#123;5:1&#125;,&#123;9:1&#125;,&#123;7:1&#125;]</span><br><span class="line">2018-03-03 21:12:56.637 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread计算出一份top3热门商品列表】zk path=/task-hot-product-list-4, topnProductListJSON=[1,3,5]</span><br><span class="line">2018-03-03 21:12:56.677 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】计算出后95%访问次数的平均值 avgCount=1.0</span><br><span class="line">2018-03-03 21:12:56.821 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 发现一个新的热点 productId=1</span><br><span class="line">2018-03-03 21:12:58.754 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] http://192.168.2.201/hot?productId=1&amp;productInfo=%7B%22id%22%3A1%2C%22name%22%3A%22iphone7%E6%89%8B%E6%9C%BA%22%2C%22price%22%3A5599.0%2C%22pictureList%22%3A%22a.jpg%2Cb.jpg%22%2C%22specification%22%3A%22iphone7%E7%9A%84%E8%A7%84%E6%A0%BC%22%2C%22service%22%3A%22iphone7%E7%9A%84%E5%94%AE%E5%90%8E%E6%9C%8D%E5%8A%A1%22%2C%22color%22%3A%22%E7%BA%A2%E8%89%B2%2C%E7%99%BD%E8%89%B2%2C%E9%BB%91%E8%89%B2%22%2C%22size%22%3A%225.5%22%2C%22shopId%22%3A1%2C%22modifiedTime%22%3A%222017-01-01+12%3A00%3A00%22%7D%0A</span><br><span class="line">2018-03-03 21:12:58.787 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] http://192.168.2.202/hot?productId=1&amp;productInfo=%7B%22id%22%3A1%2C%22name%22%3A%22iphone7%E6%89%8B%E6%9C%BA%22%2C%22price%22%3A5599.0%2C%22pictureList%22%3A%22a.jpg%2Cb.jpg%22%2C%22specification%22%3A%22iphone7%E7%9A%84%E8%A7%84%E6%A0%BC%22%2C%22service%22%3A%22iphone7%E7%9A%84%E5%94%AE%E5%90%8E%E6%9C%8D%E5%8A%A1%22%2C%22color%22%3A%22%E7%BA%A2%E8%89%B2%2C%E7%99%BD%E8%89%B2%2C%E9%BB%91%E8%89%B2%22%2C%22size%22%3A%225.5%22%2C%22shopId%22%3A1%2C%22modifiedTime%22%3A%222017-01-01+12%3A00%3A00%22%7D%0A</span><br><span class="line">2018-03-03 21:12:58.807 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 保存上次热点数据 lastTimeHotProductList=[1]</span><br><span class="line">2018-03-03 21:13:01.637 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br></pre></td></tr></table></figure><p>然后访问几次别的商品，把平均数提高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2018-03-03 21:15:01.948 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread计算出一份top3热门商品列表】zk path=/task-hot-product-list-4, topnProductListJSON=[1,3,5]</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread计算出一份排序后的商品访问次数列表】 productCountListJSON=[&#123;1:12&#125;,&#123;3:3&#125;,&#123;5:1&#125;,&#123;9:1&#125;,&#123;7:1&#125;]</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】计算出后95%访问次数的平均值 avgCount=1.5</span><br><span class="line">2018-03-03 21:15:03.866 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 发现一个热点消失了 productId=1</span><br><span class="line">2018-03-03 21:15:03.866 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 保存上次热点数据 lastTimeHotProductList=[]</span><br><span class="line">2018-03-03 21:15:06.949 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程笔记，记录以供以后翻看&lt;/p&gt;
&lt;h2 id=&quot;缓存预热&quot;&gt;&lt;a href=&quot;#缓存预热&quot; class=&quot;headerlink&quot; title=&quot;缓存预热&quot;&gt;&lt;/a&gt;缓存预热&lt;/h2&gt;&lt;p&gt;系统刚上线的时候，redis里面是没有数据的，如果这个时候高并发的流量过来全部跑到mysql，那么mysql肯定就挂掉了。所以我们需要缓存预热&lt;br&gt;
    
    </summary>
    
      <category term="高可用缓存架构实战" scheme="http://www.saily.top/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="多级缓存架构" scheme="http://www.saily.top/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Storm介绍和集群部署、WordCount演示</title>
    <link href="http://www.saily.top/2018/02/22/cache04-3/"/>
    <id>http://www.saily.top/2018/02/22/cache04-3/</id>
    <published>2018-02-22T05:34:55.000Z</published>
    <updated>2018-09-15T15:28:13.645Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p><h2 id="java系统跟大数据技术的关系"><a href="#java系统跟大数据技术的关系" class="headerlink" title="java系统跟大数据技术的关系"></a>java系统跟大数据技术的关系</h2><ol><li>大数据不仅仅只是大数据工程师要关注的东西</li><li><p>大数据也是Java程序员在构建各类系统的时候一种全新的思维，以及架构理念，比如Storm，Hive，Spark，ZooKeeper，HBase，Elasticsearch，等等</p><a id="more"></a><p> Storm：实时缓存热点数据统计-&gt;缓存预热-&gt;缓存热点数据自动降级</p><p> Hive：Hadoop生态栈里面，做数据仓库的一个系统，高并发访问下，海量请求日志的批量统计分析，日报周报月报，接口调用情况，业务使用情况，等等</p><p> Spark：离线批量数据处理，比如从DB中一次性批量处理几亿数据，清洗和处理后写入Redis中供后续的系统使用，大型互联网公司的用户相关数据</p><p> ZooKeeper：分布式系统的协调，分布式锁，分布式选举-&gt;高可用HA架构，轻量级元数据存储</p><p> HBase：海量数据的在线存储和简单查询，替代MySQL分库分表，提供更好的伸缩性</p><p> Elasticsearch：海量数据的复杂检索以及搜索引擎的构建，支撑有大量数据的各种企业信息化系统的搜索引擎，电商/新闻等网站的搜索引擎，等等</p></li></ol><h2 id="Apache-Storm简介"><a href="#Apache-Storm简介" class="headerlink" title="Apache Storm简介"></a>Apache Storm简介</h2><p>Storm是一个分布式的，可靠的，容错的数据流处理系统。是非常流行的实时计算框架，也非常成熟。</p><ol><li>支撑各种实时类的项目场景：实时处理消息以及更新数据库，基于最基础的实时计算语义和API（实时数据处理领域）；对实时的数据流持续的进行查询或计算，同时将最新的计算结果持续的推送给客户端展示，同样基于最基础的实时计算语义和API（实时数据分析领域）；对耗时的查询进行并行化，基于DRPC，即分布式RPC调用，单表30天数据，并行化，每个进程查询一天数据，最后组装结果</li><li>高度的可伸缩性：如果要扩容，直接加机器，调整storm计算作业的并行度就可以了，storm会自动部署更多的进程和线程到其他的机器上去，无缝快速扩容</li><li>数据不丢失的保证：storm的消息可靠机制开启后，可以保证一条数据都不丢</li><li>超强的健壮性：从历史经验来看，storm比hadoop、spark等大数据类系统，健壮的多的多，因为元数据全部放zookeeper，不在内存中，随便挂都不要紧</li><li>使用的便捷性：核心语义非常的简单，开发起来效率很高</li></ol><h2 id="Storm的集群架构以及核心概念"><a href="#Storm的集群架构以及核心概念" class="headerlink" title="Storm的集群架构以及核心概念"></a>Storm的集群架构以及核心概念</h2><p>Nimbus，Supervisor，ZooKeeper，Worker，Executor，Task</p><p><img src="/img/cache/storm集群架构.png" alt="storm集群架构"></p><p>Topology，Spout，Bolt，Tuple，Stream</p><p><img src="/img/cache/storm核心概念.png" alt="storm核心概念"></p><p>拓扑：务虚的一个概念</p><p>Spout：数据源的一个代码组件，就是我们可以实现一个spout接口，写一个java类，在这个spout代码中，我们可以自己尝试去数据源获取数据，比如说从kafka中消费数据</p><p>bolt：一个业务处理的代码组件，spout会将数据传送给bolt，各种bolt还可以串联成一个计算链条，java类实现了一个bolt接口</p><p>一堆spout+bolt，就会组成一个topology，就是一个拓扑，实时计算作业，spout+bolt，一个拓扑涵盖数据源获取/生产+数据处理的所有的代码逻辑，topology</p><p>tuple：就是一条数据，每条数据都会被封装在tuple中，在多个spout和bolt之间传递</p><p>stream：就是一个流，务虚的一个概念，抽象的概念，源源不断过来的tuple，就组成了一条数据流</p><p>Spout和bolt组件会向Nimbus请求资源，通过Supervisor分配到不同的worker，然后开启多个task执行任务。</p><p><strong>Storm组件</strong></p><p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。主节点运行Nimbus守护进程，这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。Supervisor守护进程作为拓扑的一部分运行在工作节点上。一个Storm拓扑结构在不同的机器上运行着众多的工作节点。每个工作节点都是topology中一个子集的实现。而Nimbus和Supervisor之间的协调则通过Zookeeper系统或者集群。</p><p><strong>Zookeeper</strong></p><p>Zookeeper是完成Supervisor和Nimbus之间协调的服务。而应用程序实现实时的逻辑则被封装进Storm中的“topology”。topology则是一组由Spouts（数据源）和Bolts（数据操作）通过Stream Groupings进行连接的图。</p><p><strong>Spout</strong></p><p>Spout从来源处读取数据并放入topology。Spout分成可靠和不可靠两种；当Storm接收失败时，可靠的Spout会对tuple（元组，数据项组成的列表）进行重发；而不可靠的Spout不会考虑接收成功与否只发射一次。而Spout中最主要的方法就是nextTuple（），该方法会发射一个新的tuple到topology，如果没有新tuple发射则会简单的返回。</p><p><strong>Bolt</strong></p><p>Topology中所有的处理都由Bolt完成。Bolt从Spout中接收数据并进行处理，如果遇到复杂流的处理也可能将tuple发送给另一个Bolt进行处理。而Bolt中最重要的方法是execute（），以新的tuple作为参数接收。不管是Spout还是Bolt，如果将tuple发射成多个流，这些流都可以通过declareStream（）来声明。</p><h2 id="Storm的并行度以及流分组"><a href="#Storm的并行度以及流分组" class="headerlink" title="Storm的并行度以及流分组"></a>Storm的并行度以及流分组</h2><p>并行度：Worker-&gt;Executor-&gt;Task，没错，是Task</p><p>流分组：Task与Task之间的数据流向关系</p><p><img src="/img/cache/并行度和流分组.png" alt="并行度和流分组"></p><p>Stream Grouping定义了一个流在Bolt任务中如何被切分。</p><ol><li><p>Shuffle grouping：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。</p></li><li><p>Fields grouping：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。</p></li><li><p>Partial Key grouping：根据指定字段分割数据流，并分组。类似Fields grouping。</p></li><li><p>All grouping：tuple被复制到bolt的所有任务。这种类型需要谨慎使用。</p></li><li><p>Global grouping：全部流都分配到bolt的同一个任务。明确地说，是分配给ID最小的那个task。</p></li><li><p>None grouping：无需关心流是如何分组。目前，无分组等效于随机分组。但最终，Storm将把无分组的Bolts放到Bolts或Spouts订阅它们的同一线程去执行（如果可能）。</p></li><li><p>Direct grouping：这是一个特别的分组类型。元组生产者决定tuple由哪个元组处理者任务接收。</p></li><li><p>Local or shuffle grouping：如果目标bolt有一个或多个任务在同一工作进程，tuples 会打乱这些进程内的任务。否则,这就像一个正常的 Shuffle grouping。</p></li></ol><p>一般只用Shuffle grouping和Fields grouping。</p><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p><a href="https://github.com/sail-y/storm-helloworld" target="_blank" rel="noopener">https://github.com/sail-y/storm-helloworld</a></p><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>拷贝apache-storm-1.1.0.tar.gz到/usr/local目录下，解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span></span><br><span class="line">mv apache-storm-1.1.0 storm</span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> STORM_HOME=/usr/<span class="built_in">local</span>/storm</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$STORM_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>修改storm配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/storm</span><br><span class="line">vi /usr/<span class="built_in">local</span>/storm/conf/storm.yaml</span><br><span class="line"></span><br><span class="line">storm.zookeeper.servers:</span><br><span class="line">  - <span class="string">"192.168.2.201"</span></span><br><span class="line">  - <span class="string">"192.168.2.202"</span></span><br><span class="line">  - <span class="string">"192.168.2.203"</span></span><br><span class="line"></span><br><span class="line">nimbus.seeds: [<span class="string">"192.168.2.201"</span>]</span><br><span class="line"></span><br><span class="line">storm.local.dir: <span class="string">"/var/storm"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># slots.ports，指定每个机器上可以启动多少个worker，一个端口号代表一个worker</span></span><br><span class="line"></span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">    - 6700</span><br><span class="line">    - 6701</span><br><span class="line">    - 6702</span><br><span class="line">    - 6703</span><br></pre></td></tr></table></figure><p>把另外两台机器也部署上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.bashrc root@192.168.2.202:~/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/storm root@192.168.2.202:/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>记得source一下和创建/var/storm的目录。</p><p>在201上的nimbus：<code>storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><p>3个节点都启动supervisor ：<code>storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><p>201启动storm ui：<code>storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><p>3个节点都启动logviewer：<code>storm logviewer &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><p>用jps检查是否已经启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">1697 Kafka</span><br><span class="line">1316 QuorumPeerMain</span><br><span class="line">11269 Supervisor</span><br><span class="line">11369 core</span><br><span class="line">11148 nimbus</span><br><span class="line">11486 Jps</span><br></pre></td></tr></table></figure><p>访问Storm UI查看集群状态：<a href="http://192.168.2.201:8080/index.html" target="_blank" rel="noopener">http://192.168.2.201:8080/index.html</a></p><p><img src="/img/cache/storm_ui.png" alt="storm_ui"></p><h2 id="提交作业到storm集群来运行"><a href="#提交作业到storm集群来运行" class="headerlink" title="提交作业到storm集群来运行"></a>提交作业到storm集群来运行</h2><p>先将上面的项目打包</p><pre><code>mvn clean package</code></pre><p>将打包好的<code>storm-helloworld-1.0-SNAPSHOT.jar</code>上传到201的<code>/usr/local</code>目录下。</p><p>然后执行命令提交作业到storm集群。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar /usr/<span class="built_in">local</span>/storm-helloworld-1.0-SNAPSHOT.jar com.roncoo.eshop.storm.WorkCountTopology WorkCountTopology</span><br></pre></td></tr></table></figure><p><img src="/img/cache/storm_ui_wordcount.png" alt="storm_ui_wordcount"></p><p><img src="/img/cache/storm_ui_wordcount_1.png" alt="storm_ui_wordcount"></p><p>如何kill掉一个topology：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm <span class="built_in">kill</span> WorkCountTopology</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程笔记，记录以供以后翻看&lt;/p&gt;
&lt;h2 id=&quot;java系统跟大数据技术的关系&quot;&gt;&lt;a href=&quot;#java系统跟大数据技术的关系&quot; class=&quot;headerlink&quot; title=&quot;java系统跟大数据技术的关系&quot;&gt;&lt;/a&gt;java系统跟大数据技术的关系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;大数据不仅仅只是大数据工程师要关注的东西&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大数据也是Java程序员在构建各类系统的时候一种全新的思维，以及架构理念，比如Storm，Hive，Spark，ZooKeeper，HBase，Elasticsearch，等等&lt;/p&gt;
    
    </summary>
    
      <category term="storm" scheme="http://www.saily.top/categories/storm/"/>
    
    
      <category term="storm" scheme="http://www.saily.top/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper+kafka集群的安装部署</title>
    <link href="http://www.saily.top/2018/02/20/cache04-2/"/>
    <id>http://www.saily.top/2018/02/20/cache04-2/</id>
    <published>2018-02-20T07:09:58.000Z</published>
    <updated>2018-08-25T07:18:22.506Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p><h1 id="zookeeper集群搭建"><a href="#zookeeper集群搭建" class="headerlink" title="zookeeper集群搭建"></a>zookeeper集群搭建</h1><p>将zookeeper-3.4.5.tar.gz拷贝到/usr/local目录下。<br>对zookeeper-3.4.5.tar.gz进行解压缩：</p><pre><code>tar -zxvf zookeeper-3.4.5.tar.gz</code></pre><p>对zookeeper目录进行重命名：</p><pre><code>mv zookeeper-3.4.5 zk</code></pre><a id="more"></a><p>配置zookeeper相关的环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> zk/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line">vi zoo.cfg</span><br><span class="line"><span class="comment">#修改：dataDir=/usr/local/zk/data</span></span><br><span class="line"><span class="comment">#新增：</span></span><br><span class="line">server.0=eshop-cache01:2888:3888</span><br><span class="line">server.1=eshop-cache02:2888:3888</span><br><span class="line">server.2=eshop-cache03:2888:3888</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> zk</span><br><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line"><span class="built_in">echo</span> 0 &gt;&gt; myid</span><br></pre></td></tr></table></figure><p>这是eshop-cache01节点的搭建，另外2个节点，一样的步骤去搭建。</p><p>在另外两个节点上按照上述步骤配置ZooKeeper，使用scp将zk和.bashrc拷贝到eshop-cache02和eshop-cache03上即可。唯一的区别是<code>myid</code>标识号分别设置为1和2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.bashrc root@eshop-cache02:~/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/zk root@eshop-cache02:/usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><p>分别在三台机器上执行：</p><pre><code>zkServer.sh start</code></pre><p>检查ZooKeeper状态：</p><pre><code>zkServer.sh status</code></pre><p>应该是一个leader，两个follower</p><p>jps：检查三个节点是否都有QuromPeerMain进程</p><h1 id="kafka集群搭建"><a href="#kafka集群搭建" class="headerlink" title="kafka集群搭建"></a>kafka集群搭建</h1><p>将<code>kafka_2.11-1.0.0.tgz</code>拷贝到/usr/local目录下。</p><p>对kafka_2.9.2-0.8.1.tgz进行解压缩：</p><pre><code>tar -zxvf kafka_2.11-1.0.0.tgz</code></pre><p>对kafka目录进行改名：</p><pre><code>mv kafka_2.11-1.0.0 kafka</code></pre><p>配置kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br><span class="line"><span class="comment"># broker.id：依次增长的整数，0、1、2，集群中Broker的唯一id</span></span><br><span class="line">zookeeper.connect=192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181</span><br></pre></td></tr></table></figure><p>按照上述步骤在另外两台机器分别安装kafka。用scp把kafka拷贝到其他机器即可。<br>唯一区别的，就是server.properties中的broker.id，要设置为1和2</p><p>在三台机器上的kafka目录下，分别执行以下命令：</p><pre><code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></pre><p>使用jps检查启动是否成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">1697 Kafka</span><br><span class="line">1316 QuorumPeerMain</span><br><span class="line">1997 Jps</span><br></pre></td></tr></table></figure><p>使用基本命令检查kafka是否搭建成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic <span class="built_in">test</span> --replication-factor 1 --partitions 1 --create</span><br><span class="line"></span><br><span class="line">bin/kafka-console-producer.sh --broker-list 192.168.2.201:9092,192.168.2.202:9092,192.168.2.203:9092 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程笔记，记录以供以后翻看&lt;/p&gt;
&lt;h1 id=&quot;zookeeper集群搭建&quot;&gt;&lt;a href=&quot;#zookeeper集群搭建&quot; class=&quot;headerlink&quot; title=&quot;zookeeper集群搭建&quot;&gt;&lt;/a&gt;zookeeper集群搭建&lt;/h1&gt;&lt;p&gt;将zookeeper-3.4.5.tar.gz拷贝到/usr/local目录下。&lt;br&gt;对zookeeper-3.4.5.tar.gz进行解压缩：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf zookeeper-3.4.5.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对zookeeper目录进行重命名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv zookeeper-3.4.5 zk
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://www.saily.top/categories/kafka/"/>
    
    
      <category term="zookeeper" scheme="http://www.saily.top/tags/zookeeper/"/>
    
      <category term="kafka" scheme="http://www.saily.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>高可用缓存架构实战4-多级缓存架构.高并发读写方案.nginx流量分发方案.ZK分布式锁解决并发冲突方案</title>
    <link href="http://www.saily.top/2018/02/18/cache04/"/>
    <id>http://www.saily.top/2018/02/18/cache04/</id>
    <published>2018-02-18T11:45:55.000Z</published>
    <updated>2018-09-15T13:59:58.422Z</updated>
    
    <content type="html"><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p><h2 id="上亿流量的商品详情页系统的多级缓存架构"><a href="#上亿流量的商品详情页系统的多级缓存架构" class="headerlink" title="上亿流量的商品详情页系统的多级缓存架构"></a>上亿流量的商品详情页系统的多级缓存架构</h2><p>很多人以为做个缓存其实就是用一下redis访问一下就可以了，这只是简单的缓存使用方式。做复杂的缓存，支撑电商等复杂的场景下的高并发的缓存，遇到的问题非常非常之多，绝对不是说简单的访问一下redis就可以了。<br><a id="more"></a><br>通常采用三级缓存：<strong>nginx本地缓存+redis分布式缓存+tomcat堆缓存的多级缓存架构</strong></p><p><img src="/img/cache/三级缓存架构图.png" alt=""></p><p>时效性要求非常高的数据：<strong>库存</strong></p><p>一般来说，显示的库存都是时效性要求会相对高一些，因为随着商品的不断的交易，库存会不断的变化。当然，我们就希望当库存变化的时候，尽可能更快将库存显示到页面上去，而不是说等了很长时间，库存才反应到页面上去。</p><p>时效性要求不高的数据：<strong>商品的基本信息（名称. 颜色. 版本. 规格参数，等等）</strong>，时效性要求不高的数据，就还好，比如说你现在改变了商品的名称，稍微晚个几分钟反应到商品页面上，也是可以接受的。</p><p>商品价格/库存等时效性要求高的数据，这种数据不多，相关的服务系统每次发生了变更的时候，直接采取数据库和redis缓存双写的方案，这样缓存的时效性最高。</p><p>商品基本信息等时效性不高的数据，而且种类繁多，来自多种不同的系统，采取MQ异步通知的方式，写一个数据生产服务，监听MQ消息，然后异步拉取服务的数据，更新tomcat jvm缓存+redis缓存。</p><p>流程：<strong>nginx+lua脚本做页面动态生成的工作</strong>，每次请求过来，优先从nginx本地缓存中提取各种数据，结合页面模板，生成需要的页面。如果nginx本地缓存过期了，那么就从nginx到<strong>redis</strong>中去拉取数据，更新到nginx本地。如果redis中也被LRU算法清理掉了，那么就从nginx走http接口到后端的服务中拉取数据，数据生产服务中，先在本地<strong>tomcat里的jvm堆缓存（ehcache）</strong>中找，如果也被LRU清理掉了，那么就重新发送请求到源头的服务中去拉取数据，然后<strong>再次更新tomcat堆内存缓存+redis缓存，并返回数据给nginx，nginx缓存到本地。</strong></p><h3 id="多级缓存架构中每一层的意义"><a href="#多级缓存架构中每一层的意义" class="headerlink" title="多级缓存架构中每一层的意义"></a>多级缓存架构中每一层的意义</h3><p><strong>nginx本地缓存</strong>，抗的是热数据的高并发访问，一般来说，商品的购买总是有热点的，比如每天购买iphone. nike. 海尔等知名品牌的东西的人，总是比较多的。这些热数据，由于经常被访问，利用nginx本地缓存，所以可以被锁定在nginx的本地缓存内。大量的热数据的访问，就会被保留在nginx本地缓存内，那么对这些热数据的大量访问，就直接走nginx就可以了。那么大量的访问，直接就可以走到nginx就行了，不需要走后续的各种网络开销了。</p><p><strong>redis分布式大规模缓存</strong>，抗的是很高的离散访问，支撑海量的数据，高并发的访问，高可用的服务。redis缓存最大量最完整的数据，可能1T+数据; 支撑高并发的访问，QPS最高到几十万; 可用性需要非常好，提供非常稳定的服务。nginx本地内存有限，也就能cache住部分热数据，除了各种iphone. nike等热数据，其他相对不那么热的数据，可能流量会经常走到redis那里。利用redis cluster的多master写入，横向扩容，1T+以上海量数据支持，几十万的读写QPS，99.99%高可用性都没有问题，那么就可以抗住大量的离散访问请求。</p><p><strong>tomcat jvm堆内存缓存</strong>，主要是抗redis大规模灾难的情况，如果redis出现了大规模的宕机，导致nginx大量流量直接涌入数据生产服务，那么最后的tomcat堆内存缓存至少可以再抗一下，不至于让数据库直接裸奔。同时tomcat jvm堆内存缓存，也可以抗住redis没有cache住的最后那少量的部分缓存。</p><h3 id="多级缓存架构项目实例源码"><a href="#多级缓存架构项目实例源码" class="headerlink" title="多级缓存架构项目实例源码"></a>多级缓存架构项目实例源码</h3><p>时效性要求不高的数据，采取的是异步更新缓存的策略。缓存数据生产服务，监听一个消息队列，然后数据源服务（商品信息管理服务）发生了数据变更之后，就将数据变更的消息推送到消息队列中。缓存数据生产服务可以去消费这个数据变更的消息，然后根据消息的指示提取一些参数，然后调用对应的数据源服务的接口拉取数据，这个时候一般是从mysql库中拉取的。</p><p>这里消息中间件，我们使用<code>kafka</code>，<a href="http://www.saily.top/2018/02/20/cache04-2/">zookeeper+kafka集群的安装部署</a></p><p>项目源码地址：<a href="https://github.com/sail-y/eshop-cache" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache</a></p><h3 id="Nginx层缓存"><a href="#Nginx层缓存" class="headerlink" title="Nginx层缓存"></a>Nginx层缓存</h3><p>前面三层缓存架构中的本地堆缓存+redis分布式缓存都做好了，接下来就要来做三级缓存中的nginx那一层的缓存了。一般默认会部署多个nginx，在里面都会放一些缓存，默认情况下，此时缓存命中率是比较低的，因为流量会均分。</p><p><strong>如何提升缓存命中率？</strong></p><p>分发层+应用层，双层nginx。</p><p>分发层nginx，负责流量分发的逻辑和策略，它可以用lua脚本开发一些规则，比如根据productId去进行hash，然后对后端的nginx数量取模，将某一个商品的访问的请求，就固定路由到一个nginx后端服务器上去，保证只会从redis中获取一次缓存数据，再次请求全都是走nginx本地缓存了。</p><p>后端的nginx服务器，就称之为应用服务器; 最前端的nginx服务器，被称之为分发服务器。看似很简单，其实很有用，在实际的生产环境中，可以大幅度提升你的nginx本地缓存这一层的命中率，大幅度减少redis后端的压力，提升性能。</p><p>这里会采用OpenResty的方式去部署nginx，而且会写一个nginx+lua开发的一个hello world。</p><h4 id="部署第一个nginx，作为应用层nginx"><a href="#部署第一个nginx，作为应用层nginx" class="headerlink" title="部署第一个nginx，作为应用层nginx"></a>部署第一个nginx，作为应用层nginx</h4><p>我这里部署到我机器上192.168.2.201，教程参考<a href="http://jinnianshilongnian.iteye.com/blog/2186270" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2186270</a></p><h4 id="部署openresty"><a href="#部署openresty" class="headerlink" title="部署openresty"></a>部署openresty</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">yum install -y readline-devel pcre-devel openssl-devel gcc</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/servers  </span><br><span class="line"><span class="built_in">cd</span> /usr/servers/</span><br><span class="line"></span><br><span class="line">wget http://openresty.org/download/ngx_openresty-1.7.7.2.tar.gz  </span><br><span class="line">tar -xzvf ngx_openresty-1.7.7.2.tar.gz  </span><br><span class="line"><span class="built_in">cd</span> /usr/servers/ngx_openresty-1.7.7.2/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle/LuaJIT-2.1-20150120/  </span><br><span class="line">make clean &amp;&amp; make &amp;&amp; make install  </span><br><span class="line">ln -sf luajit-2.1.0-alpha /usr/<span class="built_in">local</span>/bin/luajit</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle  </span><br><span class="line">wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz  </span><br><span class="line">tar -xvf 2.3.tar.gz  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle  </span><br><span class="line">wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz  </span><br><span class="line">tar -xvf v0.3.0.tar.gz  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/servers/ngx_openresty-1.7.7.2  </span><br><span class="line">./configure --prefix=/usr/servers --with-http_realip_module  --with-pcre  --with-luajit --add-module=./bundle/ngx_cache_purge-2.3/ --add-module=./bundle/nginx_upstream_check_module-0.3.0/ -j2  </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/servers/  </span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">/usr/servers/luajit</span><br><span class="line">/usr/servers/lualib</span><br><span class="line">/usr/servers/nginx</span><br><span class="line">/usr/servers/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure><p>启动nginx: <code>/usr/servers/nginx/sbin/nginx</code></p><h4 id="nginx-lua开发的hello-world"><a href="#nginx-lua开发的hello-world" class="headerlink" title="nginx+lua开发的hello world"></a>nginx+lua开发的hello world</h4><pre><code>vi /usr/servers/nginx/conf/nginx.conf</code></pre><p>在http部分添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua_package_path &quot;/usr/servers/lualib/?.lua;;&quot;;  </span><br><span class="line">lua_package_cpath &quot;/usr/servers/lualib/?.so;;&quot;;</span><br></pre></td></tr></table></figure><p><code>/usr/servers/nginx/conf</code>下，创建一个<code>lua.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nginx.conf的http部分添加：</p><pre><code>include lua.conf;</code></pre><p>验证配置是否正确：</p><pre><code>/usr/servers/nginx/sbin/nginx -t</code></pre><p>在lua.conf的server部分添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /lua &#123;  </span><br><span class="line">    default_type &apos;text/html&apos;;  </span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;hello world&quot;)&apos;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证配置是否正确：</p><pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre><p>重新nginx加载配置</p><pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre><p>访问： <a href="http://192.168.2.201/lua" target="_blank" rel="noopener">http://192.168.2.201/lua</a></p><p>成功输出 hello world</p><hr><p>接下来替换成lua脚本文件执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/servers/nginx/conf/lua/</span><br><span class="line">vi /usr/servers/nginx/conf/lua/test.lua</span><br><span class="line">ngx.say(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>修改lua.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /lua &#123;  </span><br><span class="line">    default_type &apos;text/html&apos;;  </span><br><span class="line">    content_by_lua_file conf/lua/test.lua; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证配置是否正确：</p><pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre><p>重新nginx加载配置</p><pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre><hr><p>查看异常日志</p><pre><code>tail -f /usr/servers/nginx/logs/error.log</code></pre><h4 id="工程化的nginx-lua项目结构"><a href="#工程化的nginx-lua项目结构" class="headerlink" title="工程化的nginx+lua项目结构"></a>工程化的nginx+lua项目结构</h4><p>刚才只是写了一个hello world，在正式的项目中，脚本的目录结构一般是下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    hello.conf     </span><br><span class="line">    lua              </span><br><span class="line">      hello.lua</span><br><span class="line">    lualib            </span><br><span class="line">      *.lua</span><br><span class="line">      *.so</span><br></pre></td></tr></table></figure><p>放在/usr/hello目录下，不会放在nginx所在文件夹里。</p><p>配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/hello/lua</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'ngx.say("hello world");'</span> &gt;&gt; /usr/hello/lua/hello.lua</span><br><span class="line">cp -r /usr/servers/lualib /usr/hello</span><br><span class="line"></span><br><span class="line">vi /usr/hello/hello.conf</span><br><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">  </span><br><span class="line">    location /hello &#123;  </span><br><span class="line">        default_type <span class="string">'text/html'</span>;  </span><br><span class="line">        content_by_lua_file /usr/hello/lua/hello.lua;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>修改<code>nginx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/servers/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  2;  </span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;  </span><br><span class="line"></span><br><span class="line">events &#123;  </span><br><span class="line">    worker_connections  1024;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">http &#123;  </span><br><span class="line">    include       mime.types;  </span><br><span class="line">    default_type  text/html;  </span><br><span class="line">  </span><br><span class="line">    lua_package_path <span class="string">"/usr/hello/lualib/?.lua;;"</span>;  </span><br><span class="line">    lua_package_cpath <span class="string">"/usr/hello/lualib/?.so;;"</span>; </span><br><span class="line">    include /usr/hello/hello.conf;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>验证配置是否正确：</p><pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre><p>重新nginx加载配置</p><pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre><p>如法炮制，在另外一个机器上，也用OpenResty部署一个nginx。</p><h4 id="开发和部署流量分发层"><a href="#开发和部署流量分发层" class="headerlink" title="开发和部署流量分发层"></a>开发和部署流量分发层</h4><p>我在eshop-cache02和eshop-cache03上都部署好了openresty。现在用eshop-cache01和eshop-cache02作为应用层nginx服务器，用eshop-cache03作为分发层nginx。</p><p>现在在eshop-cache03，也就是分发层nginx中，编写lua脚本，完成基于商品id的流量分发策略：</p><ol><li>获取请求参数，比如productId</li><li>对productId进行hash</li><li>hash值对应用服务器数量取模，获取到一个应用服务器</li><li>利用http发送请求到应用层nginx</li><li>获取响应后返回</li></ol><p>这个就是基于商品id的定向流量分发的策略，lua脚本来编写和实现。作为一个流量分发的nginx，会发送http请求到后端的应用nginx上面去，所以要先引入lua http lib包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http_headers.lua  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua</span><br></pre></td></tr></table></figure><p>然后我们编辑流量分发的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> hosts = &#123;<span class="string">"192.168.2.201"</span>, <span class="string">"192.168.2.202"</span>&#125;</span><br><span class="line"><span class="keyword">local</span> hash = ngx.crc32_long(productId)</span><br><span class="line"><span class="keyword">local</span> index = (hash % <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">backend = <span class="string">"http://"</span>..hosts[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> requestPath = uri_args[<span class="string">"requestPath"</span>]</span><br><span class="line">requestPath = <span class="string">"/"</span>..requestPath..<span class="string">"?productId="</span>..productId</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">"resty.http"</span>)</span><br><span class="line"><span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resp, err = httpc:request_uri(backend, &#123;</span><br><span class="line">    method = <span class="string">"GET"</span>,</span><br><span class="line">    <span class="built_in">path</span> = requestPath</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">   ngx.say(<span class="string">"request error :"</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ngx.say(resp.body)</span><br><span class="line"></span><br><span class="line">httpc:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>访问测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br><span class="line">http://192.168.2.203/hello?productId=5&amp;requestPath=hello</span><br><span class="line">hello world. this is eshop-cache01</span><br></pre></td></tr></table></figure><p>基于商品id的定向流量分发策略的lua脚本就开发完了。经过测试可以看到，如果请求的是固定的某一个商品，那么就一定会将流量分到固定的一个应用nginx上面去。</p><h3 id="基于nginx-lua-java完成多级缓存架构的核心业务逻辑"><a href="#基于nginx-lua-java完成多级缓存架构的核心业务逻辑" class="headerlink" title="基于nginx+lua+java完成多级缓存架构的核心业务逻辑"></a>基于nginx+lua+java完成多级缓存架构的核心业务逻辑</h3><p>上面做了流量分发的demo测试，Java层级的缓存开发，接下来把他们对接起来，正式编写分发层和应用层的脚本。</p><p>eshop-cache03机器上修改流量分发层配置和lua脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vi hello.conf</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">location /product &#123;</span><br><span class="line">    default_type <span class="string">'text/html'</span>;</span><br><span class="line">    content_by_lua_file /usr/hello/lua/distribute.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> lua</span><br><span class="line">cp hello.lua distribute.lua</span><br><span class="line">vi distribute.lua</span><br><span class="line"><span class="comment"># 添加shopId</span></span><br><span class="line"><span class="built_in">local</span> shopId = uri_args[<span class="string">"shopId"</span>]</span><br><span class="line">requestPath = <span class="string">"/"</span>..requestPath..<span class="string">"?productId="</span>..productId..<span class="string">"&amp;shopId="</span>..shopId</span><br><span class="line"></span><br><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><hr><p>修改应用层配置和lua脚本：</p><ol><li>应用nginx的lua脚本接收到请求</li><li>获取请求参数中的商品id，以及商品店铺id</li><li>根据商品id和商品店铺id，在nginx本地缓存中尝试获取数据</li><li><p>如果在nginx本地缓存中没有获取到数据，那么就到redis分布式缓存中获取数据，如果获取到了数据，还要设置到nginx本地缓存中</p><p> 这里有个问题，建议不要用nginx+lua直接去获取redis数据。因为openresty没有太好的redis cluster的支持包，所以建议是发送http请求到缓存数据生产服务，由该服务提供一个http接口。缓存数生产服务可以基于redis cluster api从redis中直接获取数据，并返回给nginx。</p></li><li><p>如果缓存数据生产服务没有在redis分布式缓存中没有获取到数据，那么就在自己本地ehcache中获取数据，返回数据给nginx，也要设置到nginx本地缓存中</p></li><li>如果ehcache本地缓存都没有数据，那么就需要去原始的服务中拉去数据，该服务会从mysql中查询，拉去到数据之后，返回给nginx，并重新设置到ehcache和redis中</li><li><p>nginx最终利用获取到的数据，动态渲染网页模板</p><p> 因为应用层也要访问http接口，所以也需要部署http依赖和模板的依赖</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http_headers.lua  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua </span><br><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/</span><br><span class="line">wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template.lua</span><br><span class="line">mkdir /usr/hello/lualib/resty/html</span><br><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/html</span><br><span class="line">wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template/html.lua</span><br></pre></td></tr></table></figure><p> 在hello.conf的server中配置模板位置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="variable">$template_location</span> <span class="string">"/templates"</span>;  </span><br><span class="line"><span class="built_in">set</span> <span class="variable">$template_root</span> <span class="string">"/usr/hello/templates"</span>;</span><br></pre></td></tr></table></figure><p> 编辑要显示的模板：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/hello/templates</span><br><span class="line"><span class="built_in">cd</span> /usr/hello/templates</span><br><span class="line">vi product.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;商品详情页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">商品id: &#123;* productId *&#125;&lt;br/&gt;</span><br><span class="line">商品名称: &#123;* productName *&#125;&lt;br/&gt;</span><br><span class="line">商品图片列表: &#123;* productPictureList *&#125;&lt;br/&gt;</span><br><span class="line">商品规格: &#123;* productSpecification *&#125;&lt;br/&gt;</span><br><span class="line">商品售后服务: &#123;* productService *&#125;&lt;br/&gt;</span><br><span class="line">商品颜色: &#123;* productColor *&#125;&lt;br/&gt;</span><br><span class="line">商品大小: &#123;* productSize *&#125;&lt;br/&gt;</span><br><span class="line">店铺id: &#123;* shopId *&#125;&lt;br/&gt;</span><br><span class="line">店铺名称: &#123;* shopName *&#125;&lt;br/&gt;</span><br><span class="line">店铺评级: &#123;* shopLevel *&#125;&lt;br/&gt;</span><br><span class="line">店铺好评率: &#123;* shopGoodCommentRate *&#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>将渲染后的网页模板作为http响应，返回给分发层nginx</p><p> 在<code>nginx.conf</code>的http模块里添加：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加nginx本地缓存的支持</span><br><span class="line">lua_shared_dict my_cache <span class="number">128</span>m;</span><br></pre></td></tr></table></figure><p> 修改<code>hello.conf</code>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加路由</span><br><span class="line">location /product &#123;</span><br><span class="line">   default_type &apos;text/html&apos;;</span><br><span class="line">   content_by_lua_file /usr/hello/lua/product.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 修改lua/product.lua脚本，注意192.168.2.171是我本机的ip，启动了Java项目：</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">vi lua/product.lua</span><br><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">"productId"</span>]</span><br><span class="line"><span class="keyword">local</span> shopId = uri_args[<span class="string">"shopId"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCacheKey = <span class="string">"product_info_"</span>..productId</span><br><span class="line"><span class="keyword">local</span> shopCacheKey = <span class="string">"shop_info_"</span>..shopId</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCache = cache_ngx:get(productCacheKey)</span><br><span class="line"><span class="keyword">local</span> shopCache = cache_ngx:get(shopCacheKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> productCache == <span class="string">""</span> <span class="keyword">or</span> productCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">"resty.http"</span>)</span><br><span class="line"><span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">"http://192.168.2.171:8080"</span>,&#123;</span><br><span class="line">  method = <span class="string">"GET"</span>,</span><br><span class="line">  <span class="built_in">path</span> = <span class="string">"/getProductInfo?productId="</span>..productId</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">productCache = resp.body</span><br><span class="line">cache_ngx:set(productCacheKey, productCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shopCache == <span class="string">""</span> <span class="keyword">or</span> shopCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">"resty.http"</span>)</span><br><span class="line"><span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">"http://192.168.2.171:8080"</span>,&#123;</span><br><span class="line">  method = <span class="string">"GET"</span>,</span><br><span class="line">  <span class="built_in">path</span> = <span class="string">"/getShopInfo?shopId="</span>..shopId</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">shopCache = resp.body</span><br><span class="line">cache_ngx:set(shopCacheKey, shopCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</span><br><span class="line"><span class="keyword">local</span> productCacheJSON = cjson.decode(productCache)</span><br><span class="line"><span class="keyword">local</span> shopCacheJSON = cjson.decode(shopCache)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">productId = productCacheJSON.id,</span><br><span class="line">productName = productCacheJSON.name,</span><br><span class="line">productPrice = productCacheJSON.price,</span><br><span class="line">productPictureList = productCacheJSON.pictureList,</span><br><span class="line">productSpecification = productCacheJSON.specification,</span><br><span class="line">productService = productCacheJSON.service,</span><br><span class="line">productColor = productCacheJSON.color,</span><br><span class="line">productSize = productCacheJSON.size,</span><br><span class="line">shopId = shopCacheJSON.id,</span><br><span class="line">shopName = shopCacheJSON.name,</span><br><span class="line">shopLevel = shopCacheJSON.level,</span><br><span class="line">shopGoodCommentRate = shopCacheJSON.goodCommentRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">"resty.template"</span>)</span><br><span class="line">template.render(<span class="string">"product.html"</span>, context)</span><br></pre></td></tr></table></figure><p> 写到这里，应该去把java项目里的2个接口给补充一下。还是之前的项目：<a href="https://github.com/sail-y/eshop-cache" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache</a></p></li></ol><h3 id="分布式重建缓存的并发冲突问题"><a href="#分布式重建缓存的并发冲突问题" class="headerlink" title="分布式重建缓存的并发冲突问题"></a>分布式重建缓存的并发冲突问题</h3><p>之前在Java代码里会先去redis里面取数据，如果redis取不到，就会去ehcache里面取，如果还是取不到，就需要重建缓存了。</p><p>但是重建缓存有一个问题，因为我们的服务可能是多实例的，虽然在nginx层我们通过流量分发将请求通过id分发到了不同的nginx应用层上。那么到了接口服务层，可能多次请求访问的是不同的实例，那么可能会导致多个机器去重建读取相同的数据，然后写入缓存中，这就有了<strong>分布式重建缓存的并发冲突问题。</strong></p><p>问题就是可能2个实例获取到的数据快照不一样，但是新数据先写入缓存，如果这个时候另外一个实例的缓存后写入，就有问题了。</p><p><img src="/img/cache/多个缓存服务实例分布式重建的并发冲突问题.png" alt="多个缓存服务实例分布式重建的并发冲突问题"></p><p>这个问题有好几种解决方案：</p><ol><li>一样的在应用层对id进行取模然后固定分发到不同的服务实例上</li><li><p>将更新缓存的请求发送到同一个分区的kafka消息中</p><p> 一般来讲，每个服务实例都会监听kafka一个topic的某一个分区，所以具体去哪一个分区也得取模，保证是同一个实例消费到更新的请求。但问题是在nginx算出来的hash取模可能与kafka生产者的hash策略算出来的分区可能并不一致，还是可能有并发冲突问题。</p></li><li><p>基于zookeeper分布式锁的解决方案</p><p> 分布式锁，如果你有多个机器在访问同一个共享资源，加个锁让多个分布式的机器在访问共享资源的时候串行起来。</p></li></ol><h4 id="zk分布式锁的解决并发冲突的方案"><a href="#zk分布式锁的解决并发冲突的方案" class="headerlink" title="zk分布式锁的解决并发冲突的方案"></a>zk分布式锁的解决并发冲突的方案</h4><p><img src="/img/cache/基于zookeeper分布式锁的冲突解决方案.png" alt=""></p><ol><li>变更缓存重建以及空缓存请求重建，更新redis之前，都需要先获取对应商品id的分布式锁</li><li>拿到分布式锁之后，需要根据时间版本去比较一下，如果自己的版本新于redis中的版本，那么就更新，否则就不更新</li><li>如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获取到分布式的锁</li></ol><p>方案源码实现：<a href="https://github.com/sail-y/eshop-cache" target="_blank" rel="noopener">https://github.com/sail-y/eshop-cache</a></p><p><code>ZooKeeperSession.java</code></p><h2 id="经典的缓存-数据库读写的模式（cache-aside-pattern）"><a href="#经典的缓存-数据库读写的模式（cache-aside-pattern）" class="headerlink" title="经典的缓存+数据库读写的模式（cache aside pattern）"></a>经典的缓存+数据库读写的模式（cache aside pattern）</h2><ol><li><p>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应</p></li><li><p>更新的时候，先删除缓存，然后再更新数据库</p></li></ol><p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p><p>原因很简单，很多时候，复杂点的缓存的场景，因为缓存有的时候，不简单是数据库中直接取出来的值。比如商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要真正把这个影响的最终的库存计算出来，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出现在最新的库存是多少，然后才能将库存更新到缓存中去。</p><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据，并进行运算，才能计算出缓存最新的值的，更新缓存的代价是很高的。还有一个问题就是，是不是每次修改数据库的时候，都一定要将其对应的缓存去跟新一份？也许有的场景是这样的，但是对于比较复杂的缓存数据计算的场景，就不是这样了。举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次，100次; 但是这个缓存在1分钟内就被读取了1次，系统有大量的冷数据，28法则，20%的数据，占用了80%的访问量。实际上，如果你只是删除缓存的话，那么1分钟内，访问的时候再计算，这个缓存不过就重新计算一次而已，开销大幅度降低。每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在1分钟内只是被访问了1次，那么只有那1次，缓存是要被重新计算的，用缓存才去算缓存。其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><h2 id="缓存-数据库双写不一致问题分析"><a href="#缓存-数据库双写不一致问题分析" class="headerlink" title="缓存+数据库双写不一致问题分析"></a>缓存+数据库双写不一致问题分析</h2><h3 id="最初级的缓存不一致问题以及解决方案"><a href="#最初级的缓存不一致问题以及解决方案" class="headerlink" title="最初级的缓存不一致问题以及解决方案"></a>最初级的缓存不一致问题以及解决方案</h3><p>问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致</p><p>解决思路：</p><p>先删除缓存，再修改数据库，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h3 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h3><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中，数据变更的程序完成了数据库的修改，这个时候数据库和缓存中的数据不一样了。</p><p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况，高并发了以后，问题是很多的。</p><p>解决方案：</p><p><img src="/img/cache/复杂的数据库+缓存双写一致保障方案.png" alt=""></p><p><strong>数据库与缓存更新与读取操作进行异步串行化。</strong>更新数据的时候，根据数据的唯一标识（例如hash值取模），将操作路由之后，发送到一个jvm内部的队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中。一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p><p>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p><strong>高并发的场景下，该解决方案要注意的问题</strong></p><ol><li><p>读请求长时阻塞</p><p> 由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。该解决方案，最大的风险点在于可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库，所以务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的。</p><p> 另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压100个商品的库存修改操作，每个库存修改操作要耗费10ms去完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据，这个时候就导致读请求的长时阻塞。</p><p> 一定要做根据实际业务系统的运行情况，去进行一些压力测试和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求会hang多少时间，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以。如果一个内存队列可能积压的更新操作特别多，那么就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p><p> 一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的，针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了。比如500/s的写操作，拆成5份，每200ms就是100个写操作，单机器一般20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成。如果写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列。</p><p> 大部分的情况下，应该是大量的读请求过来，都是直接走缓存取到数据的。少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面，等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据。</p></li><li><p>读请求并发量过高</p><p> 还必须做好压力测试，确保恰巧碰上上述情况的时候，还有另一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值。但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。按1:99的比例计算读和写的请求，每秒5万的读QPS，可能只有500次更新操作，如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条数据在缓存中失效后可能导致多少读请求发送读请求到库存服务来要求更新缓存。一般来说这个比例在1:1，1:2，1:3之内，例如500条缓存数据失效导致每秒钟有1000个读请求会hang在库存服务上，每个读请求最多hang200ms就会返回。在同一时间最多hang住的可能也就是单机200个读请求，单机hang200个读请求，还是ok的。</p></li><li><p>多服务实例部署的请求路由</p><p> 可能这个服务部署了多个实例，那么必须保证，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上。</p></li><li><p>热点商品的路由问题，导致请求的倾斜</p><p> 万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大。因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p></li></ol><h3 id="复杂的数据库-缓存双写一致保障方案项目实例源码"><a href="#复杂的数据库-缓存双写一致保障方案项目实例源码" class="headerlink" title="复杂的数据库+缓存双写一致保障方案项目实例源码"></a>复杂的数据库+缓存双写一致保障方案项目实例源码</h3><p><a href="https://github.com/sail-y/eshop-inventory" target="_blank" rel="noopener">https://github.com/sail-y/eshop-inventory</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此为龙果学院课程笔记，记录以供以后翻看&lt;/p&gt;
&lt;h2 id=&quot;上亿流量的商品详情页系统的多级缓存架构&quot;&gt;&lt;a href=&quot;#上亿流量的商品详情页系统的多级缓存架构&quot; class=&quot;headerlink&quot; title=&quot;上亿流量的商品详情页系统的多级缓存架构&quot;&gt;&lt;/a&gt;上亿流量的商品详情页系统的多级缓存架构&lt;/h2&gt;&lt;p&gt;很多人以为做个缓存其实就是用一下redis访问一下就可以了，这只是简单的缓存使用方式。做复杂的缓存，支撑电商等复杂的场景下的高并发的缓存，遇到的问题非常非常之多，绝对不是说简单的访问一下redis就可以了。&lt;br&gt;
    
    </summary>
    
      <category term="高可用缓存架构实战" scheme="http://www.saily.top/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="多级缓存架构" scheme="http://www.saily.top/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
