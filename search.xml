<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>zookeeper+kafka集群的安装部署</title>
    <url>/2018/02/20/cache/cache04-2/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h1 id="zookeeper集群搭建"><a href="#zookeeper集群搭建" class="headerlink" title="zookeeper集群搭建"></a>zookeeper集群搭建</h1><p>将zookeeper-3.4.5.tar.gz拷贝到/usr/local目录下。<br>对zookeeper-3.4.5.tar.gz进行解压缩：</p>
<pre><code>tar -zxvf zookeeper-3.4.5.tar.gz</code></pre>
<p>对zookeeper目录进行重命名：</p>
<pre><code>mv zookeeper-3.4.5 zk</code></pre>
<a id="more"></a>
<p>配置zookeeper相关的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> zk/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line">vi zoo.cfg</span><br><span class="line"><span class="comment">#修改：dataDir=/usr/local/zk/data</span></span><br><span class="line"><span class="comment">#新增：</span></span><br><span class="line">server.0=eshop-cache01:2888:3888	</span><br><span class="line">server.1=eshop-cache02:2888:3888</span><br><span class="line">server.2=eshop-cache03:2888:3888</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> zk</span><br><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line"><span class="built_in">echo</span> 0 &gt;&gt; myid</span><br></pre></td></tr></table></figure>


<p>这是eshop-cache01节点的搭建，另外2个节点，一样的步骤去搭建。</p>
<p>在另外两个节点上按照上述步骤配置ZooKeeper，使用scp将zk和.bashrc拷贝到eshop-cache02和eshop-cache03上即可。唯一的区别是<code>myid</code>标识号分别设置为1和2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp ~/.bashrc root@eshop-cache02:~/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/zk root@eshop-cache02:/usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>


<p>分别在三台机器上执行：</p>
<pre><code>zkServer.sh start</code></pre>
<p>检查ZooKeeper状态：</p>
<pre><code>zkServer.sh status</code></pre>
<p>应该是一个leader，两个follower</p>
<p>jps：检查三个节点是否都有QuromPeerMain进程</p>
<h1 id="kafka集群搭建"><a href="#kafka集群搭建" class="headerlink" title="kafka集群搭建"></a>kafka集群搭建</h1><p>将<code>kafka_2.11-1.0.0.tgz</code>拷贝到/usr/local目录下。</p>
<p>对kafka_2.9.2-0.8.1.tgz进行解压缩：</p>
<pre><code>tar -zxvf kafka_2.11-1.0.0.tgz</code></pre>
<p>对kafka目录进行改名：</p>
<pre><code>mv kafka_2.11-1.0.0 kafka</code></pre>
<p>配置kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/kafka/config/server.properties</span><br><span class="line"><span class="comment"># broker.id：依次增长的整数，0、1、2，集群中Broker的唯一id</span></span><br><span class="line">zookeeper.connect=192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181</span><br></pre></td></tr></table></figure>

<p>按照上述步骤在另外两台机器分别安装kafka。用scp把kafka拷贝到其他机器即可。<br>唯一区别的，就是server.properties中的broker.id，要设置为1和2</p>
<p>在三台机器上的kafka目录下，分别执行以下命令：</p>
<pre><code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></pre>
<p>使用jps检查启动是否成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line">1697 Kafka</span><br><span class="line">1316 QuorumPeerMain</span><br><span class="line">1997 Jps</span><br></pre></td></tr></table></figure>


<p>使用基本命令检查kafka是否搭建成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic <span class="built_in">test</span> --replication-factor 1 --partitions 1 --create</span><br><span class="line"></span><br><span class="line">bin/kafka-console-producer.sh --broker-list 192.168.2.201:9092,192.168.2.202:9092,192.168.2.203:9092 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Storm介绍和集群部署、WordCount演示</title>
    <url>/2018/02/22/cache/cache04-3/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h2 id="java系统跟大数据技术的关系"><a href="#java系统跟大数据技术的关系" class="headerlink" title="java系统跟大数据技术的关系"></a>java系统跟大数据技术的关系</h2><ol>
<li><p>大数据不仅仅只是大数据工程师要关注的东西</p>
</li>
<li><p>大数据也是Java程序员在构建各类系统的时候一种全新的思维，以及架构理念，比如Storm，Hive，Spark，ZooKeeper，HBase，Elasticsearch，等等</p>
<a id="more"></a>

<p> Storm：实时缓存热点数据统计-&gt;缓存预热-&gt;缓存热点数据自动降级</p>
<p> Hive：Hadoop生态栈里面，做数据仓库的一个系统，高并发访问下，海量请求日志的批量统计分析，日报周报月报，接口调用情况，业务使用情况，等等</p>
<p> Spark：离线批量数据处理，比如从DB中一次性批量处理几亿数据，清洗和处理后写入Redis中供后续的系统使用，大型互联网公司的用户相关数据</p>
<p> ZooKeeper：分布式系统的协调，分布式锁，分布式选举-&gt;高可用HA架构，轻量级元数据存储</p>
<p> HBase：海量数据的在线存储和简单查询，替代MySQL分库分表，提供更好的伸缩性</p>
<p> Elasticsearch：海量数据的复杂检索以及搜索引擎的构建，支撑有大量数据的各种企业信息化系统的搜索引擎，电商/新闻等网站的搜索引擎，等等</p>
</li>
</ol>
<h2 id="Apache-Storm简介"><a href="#Apache-Storm简介" class="headerlink" title="Apache Storm简介"></a>Apache Storm简介</h2><p>Storm是一个分布式的，可靠的，容错的数据流处理系统。是非常流行的实时计算框架，也非常成熟。</p>
<ol>
<li>支撑各种实时类的项目场景：实时处理消息以及更新数据库，基于最基础的实时计算语义和API（实时数据处理领域）；对实时的数据流持续的进行查询或计算，同时将最新的计算结果持续的推送给客户端展示，同样基于最基础的实时计算语义和API（实时数据分析领域）；对耗时的查询进行并行化，基于DRPC，即分布式RPC调用，单表30天数据，并行化，每个进程查询一天数据，最后组装结果</li>
<li>高度的可伸缩性：如果要扩容，直接加机器，调整storm计算作业的并行度就可以了，storm会自动部署更多的进程和线程到其他的机器上去，无缝快速扩容</li>
<li>数据不丢失的保证：storm的消息可靠机制开启后，可以保证一条数据都不丢</li>
<li>超强的健壮性：从历史经验来看，storm比hadoop、spark等大数据类系统，健壮的多的多，因为元数据全部放zookeeper，不在内存中，随便挂都不要紧</li>
<li>使用的便捷性：核心语义非常的简单，开发起来效率很高</li>
</ol>
<h2 id="Storm的集群架构以及核心概念"><a href="#Storm的集群架构以及核心概念" class="headerlink" title="Storm的集群架构以及核心概念"></a>Storm的集群架构以及核心概念</h2><p>Nimbus，Supervisor，ZooKeeper，Worker，Executor，Task</p>
<p><img src="/img/cache/storm%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="storm集群架构"></p>
<p>Topology，Spout，Bolt，Tuple，Stream</p>
<p><img src="/img/cache/storm%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.png" alt="storm核心概念"></p>
<p>拓扑：务虚的一个概念</p>
<p>Spout：数据源的一个代码组件，就是我们可以实现一个spout接口，写一个java类，在这个spout代码中，我们可以自己尝试去数据源获取数据，比如说从kafka中消费数据</p>
<p>bolt：一个业务处理的代码组件，spout会将数据传送给bolt，各种bolt还可以串联成一个计算链条，java类实现了一个bolt接口</p>
<p>一堆spout+bolt，就会组成一个topology，就是一个拓扑，实时计算作业，spout+bolt，一个拓扑涵盖数据源获取/生产+数据处理的所有的代码逻辑，topology</p>
<p>tuple：就是一条数据，每条数据都会被封装在tuple中，在多个spout和bolt之间传递</p>
<p>stream：就是一个流，务虚的一个概念，抽象的概念，源源不断过来的tuple，就组成了一条数据流</p>
<p>Spout和bolt组件会向Nimbus请求资源，通过Supervisor分配到不同的worker，然后开启多个task执行任务。</p>
<p><strong>Storm组件</strong></p>
<p>在Storm集群中，有两类节点：主节点master node和工作节点worker nodes。主节点运行Nimbus守护进程，这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。Supervisor守护进程作为拓扑的一部分运行在工作节点上。一个Storm拓扑结构在不同的机器上运行着众多的工作节点。每个工作节点都是topology中一个子集的实现。而Nimbus和Supervisor之间的协调则通过Zookeeper系统或者集群。</p>
<p><strong>Zookeeper</strong></p>
<p>Zookeeper是完成Supervisor和Nimbus之间协调的服务。而应用程序实现实时的逻辑则被封装进Storm中的“topology”。topology则是一组由Spouts（数据源）和Bolts（数据操作）通过Stream Groupings进行连接的图。</p>
<p><strong>Spout</strong></p>
<p>Spout从来源处读取数据并放入topology。Spout分成可靠和不可靠两种；当Storm接收失败时，可靠的Spout会对tuple（元组，数据项组成的列表）进行重发；而不可靠的Spout不会考虑接收成功与否只发射一次。而Spout中最主要的方法就是nextTuple（），该方法会发射一个新的tuple到topology，如果没有新tuple发射则会简单的返回。</p>
<p><strong>Bolt</strong></p>
<p>Topology中所有的处理都由Bolt完成。Bolt从Spout中接收数据并进行处理，如果遇到复杂流的处理也可能将tuple发送给另一个Bolt进行处理。而Bolt中最重要的方法是execute（），以新的tuple作为参数接收。不管是Spout还是Bolt，如果将tuple发射成多个流，这些流都可以通过declareStream（）来声明。</p>
<h2 id="Storm的并行度以及流分组"><a href="#Storm的并行度以及流分组" class="headerlink" title="Storm的并行度以及流分组"></a>Storm的并行度以及流分组</h2><p>并行度：Worker-&gt;Executor-&gt;Task，没错，是Task</p>
<p>流分组：Task与Task之间的数据流向关系</p>
<p><img src="/img/cache/%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%92%8C%E6%B5%81%E5%88%86%E7%BB%84.png" alt="并行度和流分组"></p>
<p>Stream Grouping定义了一个流在Bolt任务中如何被切分。</p>
<ol>
<li><p>Shuffle grouping：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。</p>
</li>
<li><p>Fields grouping：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。</p>
</li>
<li><p>Partial Key grouping：根据指定字段分割数据流，并分组。类似Fields grouping。</p>
</li>
<li><p>All grouping：tuple被复制到bolt的所有任务。这种类型需要谨慎使用。</p>
</li>
<li><p>Global grouping：全部流都分配到bolt的同一个任务。明确地说，是分配给ID最小的那个task。</p>
</li>
<li><p>None grouping：无需关心流是如何分组。目前，无分组等效于随机分组。但最终，Storm将把无分组的Bolts放到Bolts或Spouts订阅它们的同一线程去执行（如果可能）。</p>
</li>
<li><p>Direct grouping：这是一个特别的分组类型。元组生产者决定tuple由哪个元组处理者任务接收。</p>
</li>
<li><p>Local or shuffle grouping：如果目标bolt有一个或多个任务在同一工作进程，tuples 会打乱这些进程内的任务。否则,这就像一个正常的 Shuffle grouping。</p>
</li>
</ol>
<p>一般只用Shuffle grouping和Fields grouping。</p>
<h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p><a href="https://github.com/sail-y/storm-helloworld">https://github.com/sail-y/storm-helloworld</a></p>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>拷贝apache-storm-1.1.0.tar.gz到/usr/local目录下，解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span></span><br><span class="line">mv apache-storm-1.1.0 storm</span><br></pre></td></tr></table></figure>

<p>配置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> STORM_HOME=/usr/<span class="built_in">local</span>/storm</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$STORM_HOME</span>/bin</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>修改storm配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /var/storm</span><br><span class="line">vi /usr/<span class="built_in">local</span>/storm/conf/storm.yaml</span><br><span class="line"></span><br><span class="line">storm.zookeeper.servers:</span><br><span class="line">  - <span class="string">&quot;192.168.2.201&quot;</span></span><br><span class="line">  - <span class="string">&quot;192.168.2.202&quot;</span></span><br><span class="line">  - <span class="string">&quot;192.168.2.203&quot;</span></span><br><span class="line"></span><br><span class="line">nimbus.seeds: [<span class="string">&quot;192.168.2.201&quot;</span>]</span><br><span class="line"></span><br><span class="line">storm.local.dir: <span class="string">&quot;/var/storm&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># slots.ports，指定每个机器上可以启动多少个worker，一个端口号代表一个worker</span></span><br><span class="line"></span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">    - 6700</span><br><span class="line">    - 6701</span><br><span class="line">    - 6702</span><br><span class="line">    - 6703</span><br></pre></td></tr></table></figure>

<p>把另外两台机器也部署上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp ~/.bashrc root@192.168.2.202:~/</span><br><span class="line">scp -r /usr/<span class="built_in">local</span>/storm root@192.168.2.202:/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>记得source一下和创建/var/storm的目录。</p>
<p>在201上的nimbus：<code>storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
<p>3个节点都启动supervisor ：<code>storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
<p>201启动storm ui：<code>storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
<p>3个节点都启动logviewer：<code>storm logviewer &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
<p>用jps检查是否已经启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line">1697 Kafka</span><br><span class="line">1316 QuorumPeerMain</span><br><span class="line">11269 Supervisor</span><br><span class="line">11369 core</span><br><span class="line">11148 nimbus</span><br><span class="line">11486 Jps</span><br></pre></td></tr></table></figure>

<p>访问Storm UI查看集群状态：<a href="http://192.168.2.201:8080/index.html">http://192.168.2.201:8080/index.html</a></p>
<p><img src="/img/cache/storm_ui.png" alt="storm_ui"></p>
<h2 id="提交作业到storm集群来运行"><a href="#提交作业到storm集群来运行" class="headerlink" title="提交作业到storm集群来运行"></a>提交作业到storm集群来运行</h2><p>先将上面的项目打包</p>
<pre><code>mvn clean package</code></pre>
<p>将打包好的<code>storm-helloworld-1.0-SNAPSHOT.jar</code>上传到201的<code>/usr/local</code>目录下。</p>
<p>然后执行命令提交作业到storm集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storm jar /usr/<span class="built_in">local</span>/storm-helloworld-1.0-SNAPSHOT.jar com.roncoo.eshop.storm.WorkCountTopology WorkCountTopology</span><br></pre></td></tr></table></figure>

<p><img src="/img/cache/storm_ui_wordcount.png" alt="storm_ui_wordcount"></p>
<p><img src="/img/cache/storm_ui_wordcount_1.png" alt="storm_ui_wordcount"></p>
<p>如何kill掉一个topology：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storm <span class="built_in">kill</span> WorkCountTopology</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>storm</category>
      </categories>
      <tags>
        <tag>storm</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins和tomcat的持续集成</title>
    <url>/2015/12/14/ci/jenkins%E5%92%8Ctomcat%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>今天来说一下如何用jenkins做持续集成。<br>jenkins我这里就不介绍了，重点介绍一下如何用jenkins对tomcat进行持续集成。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>流程是这样的：        </p>
<ol>
<li>jenkins从git(or svn)拉取代码，进行构建。        </li>
<li>将打出来的war包用jenkins的插件(Publish over SSH)传到你要部署的服务器。        </li>
<li>执行一个shell脚本，将正在运行的tomcat进程kill掉，把war包拷到tomcat目录的webapps下。然后在运行${TOMCAT_DIR}/bin/startup.sh。<a id="more"></a>

</li>
</ol>
<p><img src="http://7xiqxx.com1.z0.glb.clouddn.com/123123.jpg" alt="如图"></p>
<p>是不是很简单？这样我们在发布应用的时候就再也不需要每次先在本地打包，再手动去删除之前的项目，然后通过ftp工具上传到服务器上，最后再重启tomcat。如果一天要进行几十次类似的操作，其实还是非常耗时的。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="配置jenkins拉取git代码"><a href="#配置jenkins拉取git代码" class="headerlink" title="配置jenkins拉取git代码"></a>配置jenkins拉取git代码</h2><p><img src="http://7xiqxx.com1.z0.glb.clouddn.com/3807ACD4-7799-45F9-89BF-D67BCC4BD2D3.png" alt="jenkins配置"><br>首先配置在jenkins中配置好，然后再去gitlab里面配上hook触发点。<br><img src="http://7xiqxx.com1.z0.glb.clouddn.com/B2859F18-E479-401F-AB0C-8C852F7CA54C.png" alt="gitlab配置"><br>我这里是配置的当gitlab中merge的时候触发构建操作。        </p>
<h2 id="用Maven打包应用"><a href="#用Maven打包应用" class="headerlink" title="用Maven打包应用"></a>用Maven打包应用</h2><p>这个很简单：<br><img src="http://7xiqxx.com1.z0.glb.clouddn.com/4B6A6B6C-9D16-4B2B-BC50-46EAA3563AB8.png" alt="打包"></p>
<h2 id="上传包到服务器并执行脚本"><a href="#上传包到服务器并执行脚本" class="headerlink" title="上传包到服务器并执行脚本"></a>上传包到服务器并执行脚本</h2><p>这里需要在jenkins里安装Publish over SSH插件，并在全局配置中配置一下。<br><img src="http://7xiqxx.com1.z0.glb.clouddn.com/B7FAD378-98CD-480D-906B-3657E4A5FEB8.png"></p>
<p>然后下面是项目中的配置</p>
<p><img src="http://7xiqxx.com1.z0.glb.clouddn.com/F254D9A3-8589-4FE7-9993-BFF799982B7D.png"></p>
<p>上图中的war其实是基于全局配置中的路径，举个例子：</p>
<blockquote>
<p>全局配置中的Remote Directory是 <code>/web</code>，项目配置中的Remote directory是<code>war</code>，那么实际上war传送的路径是/web/war    </p>
</blockquote>
<p>最后就是最重要的脚本        </p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>脚本的目的就是kill掉当前tomcat的进程，复制war包，启动tomcat。<br>脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#defined </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_40/</span><br><span class="line">TOMCAT_HOME=<span class="string">&quot;/mnt/web/apache-tomcat-7.0.54&quot;</span></span><br><span class="line">TOMCAT_PORT=8080</span><br><span class="line">PROJECT=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="comment">#param validate</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;you must use like this : ./deploy.sh &lt;projectname&gt; [tomcat port] [tomcat home dir]&quot;</span>  </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$2</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   TOMCAT_PORT=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$3</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   TOMCAT_HOME=<span class="string">&quot;<span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#shutdown tomcat</span></span><br><span class="line"><span class="comment">#&quot;$TOMCAT_HOME&quot;/bin/shutdown.sh</span></span><br><span class="line"><span class="comment">#echo &quot;tomcat shutdown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#check tomcat process</span></span><br><span class="line">tomcat_pid=`/usr/sbin/lsof -n -P -t -i :<span class="variable">$TOMCAT_PORT</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;current :&quot;</span> <span class="variable">$tomcat_pid</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$tomcat_pid</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> sleep 5</span><br><span class="line"> tomcat_pid=`/usr/sbin/lsof -n -P -t -i :<span class="variable">$TOMCAT_PORT</span>`</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;scan tomcat pid :&quot;</span> <span class="variable">$tomcat_pid</span></span><br><span class="line"> <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$tomcat_pid</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;kill tomcat :&quot;</span> <span class="variable">$tomcat_pid</span></span><br><span class="line">   <span class="built_in">kill</span> -9 <span class="variable">$tomcat_pid</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#publish project</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scan no tomcat pid,<span class="variable">$PROJECT</span> publishing&quot;</span></span><br><span class="line">rm -rf <span class="string">&quot;<span class="variable">$TOMCAT_HOME</span>&quot;</span>/webapps/<span class="variable">$PROJECT</span></span><br><span class="line">cp /yourwarpath/<span class="variable">$PROJECT</span>.war <span class="string">&quot;<span class="variable">$TOMCAT_HOME</span>&quot;</span>/webapps/<span class="variable">$PROJECT</span>.war</span><br><span class="line"><span class="comment">#bak project</span></span><br><span class="line">BAK_DIR=/yourwarpath/bak/<span class="variable">$PROJECT</span>/`date +%Y%m%d`</span><br><span class="line">mkdir -p <span class="string">&quot;<span class="variable">$BAK_DIR</span>&quot;</span></span><br><span class="line">cp <span class="string">&quot;<span class="variable">$TOMCAT_HOME</span>&quot;</span>/webapps/<span class="variable">$PROJECT</span>.war <span class="string">&quot;<span class="variable">$BAK_DIR</span>&quot;</span>/<span class="string">&quot;<span class="variable">$PROJECT</span>&quot;</span>_`date +%H%M%S`.war</span><br><span class="line"><span class="comment">#remove tmp</span></span><br><span class="line">rm -rf /yourwarpath/<span class="variable">$PROJECT</span>.war</span><br><span class="line"><span class="comment">#start tomcat</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$TOMCAT_HOME</span>&quot;</span>/bin/startup.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;tomcat is starting,please try to access <span class="variable">$PROJECT</span> conslone url&quot;</span> </span><br></pre></td></tr></table></figure>

<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>还有一种方式是通过jenkins的deploy plugin来部署应用，我最早的时候用过一段时间这种方式。不知道是什么原因，部署多次之后会导致内存溢出，每部署一次服务器被占用的内存就多一点。最终导致服务器崩溃，ssh都连接不上去，所以最后换了shell脚本的方案。</p>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>发现tomcat的一个bug</title>
    <url>/2015/03/10/ci/%E5%8F%91%E7%8E%B0tomcat%E7%9A%84%E4%B8%80%E4%B8%AAbug/</url>
    <content><![CDATA[<p>在做项目的时候出现一个错误，看了半天没看出来是什么问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root cause</span><br><span class="line">java.util.NoSuchElementException</span><br><span class="line">	java.util.ArrayList$Itr.next(ArrayList.java:834)</span><br><span class="line">	org.apache.jasper.compiler.Validator$ValidateVisitor.getJspAttribute(Validator.java:1385)</span><br><span class="line">	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:772)</span><br><span class="line">	org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251)</span><br><span class="line">	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377)</span><br><span class="line">	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429)</span><br><span class="line">	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:779)</span><br><span class="line">	org.apache.jasper.compiler.Node$UninterpretedTag.accept(Node.java:1251)</span><br><span class="line">	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377)</span><br><span class="line">	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429)</span><br><span class="line">	org.apache.jasper.compiler.Validator$ValidateVisitor.visit(Validator.java:529)</span><br><span class="line">	org.apache.jasper.compiler.Node$JspRoot.accept(Node.java:564)</span><br><span class="line">	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377)</span><br><span class="line">	org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2429)</span><br><span class="line">	org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2435)</span><br><span class="line">	org.apache.jasper.compiler.Node$Root.accept(Node.java:474)</span><br><span class="line">	org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2377)</span><br><span class="line">	org.apache.jasper.compiler.Validator.validateExDirectives(Validator.java:1841)</span><br><span class="line">	org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:217)</span><br><span class="line">	org.apache.jasper.compiler.Compiler.compile(Compiler.java:373)</span><br><span class="line">	org.apache.jasper.compiler.Compiler.compile(Compiler.java:353)</span><br><span class="line">	org.apache.jasper.compiler.Compiler.compile(Compiler.java:340)</span><br><span class="line">	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:657)</span><br><span class="line">	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357)</span><br><span class="line">	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:390)</span><br><span class="line">	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334)</span><br><span class="line">	javax.servlet.http.HttpServlet.service(HttpServlet.java:727)</span><br></pre></td></tr></table></figure>
<p>找了半天才发现是tomcat的一个bug，换了一个tomcat版本就好了<br>导致这个错误的原因如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;jsp:param name&#x3D;&quot;test&quot; value&#x3D;&quot;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>如果是value是空值，在某些tomcat版本下就会出现这个情况，如果你遇见了，不妨换个版本试试。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins配合docker持续集成</title>
    <url>/2015/12/15/ci/jenkins%E9%85%8D%E5%90%88docker%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>我这里用docker来做持续集成的思路和<a href="http://sail-y.github.io/2015/12/14/jenkins%E5%92%8Ctomcat%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">jenkins和tomcat的持续集成</a>是一样的。都是用jenkins拉取git的代码然后打war包，只不过重启tomcat步骤换成了docker的重启。<br>直接展示一下docker的脚本吧。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#defined </span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_40&#x2F;</span><br><span class="line">REGISTRY_URL&#x3D;localhost:5000</span><br><span class="line">WEB_DIR&#x3D;&quot;$WEB_DIR&#x2F;webapps&quot;</span><br><span class="line">PORT&#x3D;&quot;8080&quot;</span><br><span class="line">IMAGE&#x3D;&quot;$1&quot;</span><br><span class="line">PROJECT&#x3D;&quot;$2&quot;</span><br><span class="line"></span><br><span class="line">#param validate</span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">  echo &quot;you must use like this : .&#x2F;deploy_docker.sh &lt;image&gt; &lt;project&gt; [war dir] [port]&quot;  </span><br><span class="line">  exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$3&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">   WEB_DIR&#x3D;&quot;$3&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$4&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">   PORT&#x3D;&quot;$4&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#publish project</span><br><span class="line">echo &quot;delete old $PROJECT.war&quot;</span><br><span class="line">rm -rf &quot;$WEB_DIR&quot;&#x2F;webapps&#x2F;$PROJECT</span><br><span class="line">echo &quot;copy new $PROJECT.war&quot;</span><br><span class="line">cp $WEB_DIR&#x2F;$PROJECT.war &quot;$WEB_DIR&quot;&#x2F;webapps&#x2F;$PROJECT.war</span><br><span class="line">#bak project</span><br><span class="line">BAK_DIR&#x3D;$WEB_DIR&#x2F;bak&#x2F;$PROJECT&#x2F;&#96;date +%Y%m%d&#96;</span><br><span class="line">mkdir -p &quot;$BAK_DIR&quot;</span><br><span class="line">cp &quot;$WEB_DIR&quot;&#x2F;$PROJECT.war &quot;$BAK_DIR&quot;&#x2F;&quot;$PROJECT&quot;_&#96;date +%H%M%S&#96;.war</span><br><span class="line">#remove tmp</span><br><span class="line">rm -rf $WEB_DIR&#x2F;$PROJECT.war</span><br><span class="line"></span><br><span class="line">echo &quot;build image:&quot; $IMAGE</span><br><span class="line">docker build -t $REGISTRY_URL&#x2F;$IMAGE $WEB_DIR</span><br><span class="line">echo &quot;push image:&quot; $IMAGE</span><br><span class="line">docker push $REGISTRY_URL&#x2F;$IMAGE</span><br><span class="line"></span><br><span class="line">echo &#39;&gt;&gt;&gt; Get old container id&#39;</span><br><span class="line">CID&#x3D;&#96;docker ps | grep &quot;dev&quot; | awk &#39;&#123;print $1&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$CID&quot; ]; then</span><br><span class="line">        echo &quot;delete container:&quot; $CID</span><br><span class="line">        docker stop $CID</span><br><span class="line">        docker rm -f $CID</span><br><span class="line">fi</span><br><span class="line">echo &quot;delete local image:&quot; $IMAGE</span><br><span class="line">docker rmi -f $REGISTRY_URL&#x2F;$IMAGE</span><br><span class="line">docker run -d -p $PORT:8080 -v &#x2F;mnt:&#x2F;mnt --name dev $REGISTRY_URL&#x2F;$IMAGE</span><br><span class="line"></span><br><span class="line">echo &quot;finished&quot; </span><br></pre></td></tr></table></figure>

<p>上面是步骤是这样：        </p>
<ol>
<li>jenkins将war包上传到$WEB_DIR目录下，然后执行脚本。        </li>
<li>这个目录下有一个webapps目录，用来存放正在运行的项目war包，是从$WEB_DIR拷贝过去的。        </li>
<li>然后build docker的镜像，并push到私库中。<code>docker build -t $REGISTRY_URL/$IMAGE $WEB_DIR</code>这里最后一个参数是Dockerfile的路径，我在这个目录下还写了一个docker的配置。        </li>
<li>停止之前正在运行的Container。        </li>
<li>删除本地的镜像。        </li>
<li>启动镜像：<code>-v /mnt:/mnt</code>是要映射宿主机的的目录(保存错误日志到宿主机)。<code>--name dev</code>是容器的名字，这个自行修改。<code>docker ps | grep &quot;dev&quot; | awk &#39;&#123;print $1&#125;&#39;</code>这里的<code>dev</code>也需要更换。因为删除了本地的镜像，所以会去私库重新里面下载。</li>
</ol>
<blockquote>
<p>这个脚本有一点问题，local的image有时候删除不掉，不影响运行，但是随着编译的次数，存储空间会越用越多（因为我最终没有采用docker，所以没去深究了）。</p>
</blockquote>
<p>还有Dockerfile如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM tomcat:8.0.30-jre8</span><br><span class="line">ADD webapps &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps</span><br></pre></td></tr></table></figure>

<p>基于官方的tomcat8构建，并且把webapps下的文件拷贝到容器中的tomcat webapps下，这个webapps必须是Dockerfile同级目录下的，也就是<code>$WEB_DIR</code>这个目录下。</p>
<p>还有另外一种方式操作起来更加简单，就是映射宿主机的路径直接写成<code>-v $WEB_DIR/webapps:/usr/local/tomcat/webapps</code>，这样还省去了build时拷贝项目的过程。</p>
<p>但是我觉得都不是很方便，查看日志不太方便，而且docker编译和启动也比较耗时，相比直接kill掉tomcat重启要慢一些。目前没有找到一个更好的实践方式，需要慢慢探索一下，为了不影响开发，我又换回了之前直接kill tomcat的方式。</p>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程1-介绍</title>
    <url>/2016/12/01/concurrency/concurrency1/</url>
    <content><![CDATA[<p>在看完了《深入理解Java虚拟机》之后，继续看《Java并发编程实战一书》。<br>相信在了解虚拟机之后，再来看并发相关知识，能理解得更透彻，书中也讲到，对Java内存模型理解得越深入，就对并发编程掌握得越好。顺道说一下，关于JDK里线程和并发相关类的使用，我主要是通过《Think in Java》学习的，这里就不再介绍基本使用方法了。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程也被称为轻量级进程（这一部分在《深入理解Java虚拟机》中提到过，<a href="http://sail-y.github.io/2016/11/25/JVM11/#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0">点击查看</a>）。在大多数现代操作系统中， 都是以线程为基本的调度单位，而不是进程。</p>
<h2 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h2><p>要想充分发挥多处理器系统的强大计算能力，线程可以有效的降低程序的开发和维护成本，同时提升复杂应用程序的性能。</p>
<a id="more"></a>
<h3 id="发挥多处理器的强大能力"><a href="#发挥多处理器的强大能力" class="headerlink" title="发挥多处理器的强大能力"></a>发挥多处理器的强大能力</h3><p>现在，多处理系统日益普及，个人PC基本上也都是多个处理器了。由于基本的调度单位是线程，因此如果程序中只有一个线程，那么最多只能在一个处理器上运行。在双处理器系统上，单线程的程序只能使用一半的CPU资源，而在拥有100个处理器的系统上将有99%的资源无法使用。多线程程序可以同时在多个处理器上执行，如果设计正确，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率。</p>
<h3 id="建模的简单性"><a href="#建模的简单性" class="headerlink" title="建模的简单性"></a>建模的简单性</h3><p>通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。例如Servlet，框架负责解决请求管理、线程创建、负载平衡等细节，在正确的时刻将请求分发给正确的应用组件。我们开发的时候的就像在开发单线程程序一样，可以简化组件的开发。</p>
<h3 id="异步事件的简化处理"><a href="#异步事件的简化处理" class="headerlink" title="异步事件的简化处理"></a>异步事件的简化处理</h3><p>服务器应用程序在接受来自多个远程客户端的请求时，如果为每个连接都分配其各自的线程并且使用同步I/O，那么就会降低这类程序的开发难度。如果某个应用程序请求数据花费时间较长或者阻塞了，在单线程应用程序在阻塞期间所有的请求都会停顿，为了避免这个问题，单线程服务器应用程序必须使用非阻塞I/O，这种I/O的复杂性太远远高于同步I/O，并且很容易出错。然而，如果每个请求都拥有自己的处理线程，那么在处理某个请求时发生的阻塞将不会影响其他请求的处理。</p>
<h3 id="响应更灵敏的用户界面"><a href="#响应更灵敏的用户界面" class="headerlink" title="响应更灵敏的用户界面"></a>响应更灵敏的用户界面</h3><p>将GUI应用的各种事件放入单独的线程中运行，时间线程能及时地处理界面事件，从而使用户界面具有更高的灵敏度。</p>
<h2 id="线程带来的风险"><a href="#线程带来的风险" class="headerlink" title="线程带来的风险"></a>线程带来的风险</h2><p>Java对线程的支持其实是一把双刃剑。虽然Java提供了相应的语言和库，以及一种明确的跨平台内存模型，这些工具简化了并发应用程序的开发，但同时也提高了对开发人员的技术要求。</p>
<h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>线程的安全性是非常复杂的，在没有充足同步的情况下，多个线程的操作执行顺序是不可预测的。由于多个线程要共享相同的内存地址空间，并且是并发运行，因此它们可能会访问或修改其他线程正在使用的变量，要使多线程程序的行为可以预测，必须对共享变量的访问操作进行协同，在Java中提供了各种同步机制来协同这种访问。</p>
<h3 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h3><p>当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。线程也会带来一些其他活跃性问题，例如死锁，饥饿，以及活锁。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>活跃性意味着某件正确的事情始终会发生，但却不够好。线程带来性能问题就是线程调度带来的开销，还有线程使用共享数据必须使用同步机制，同步机制往往也会抑制编译器做某些优化等问题。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程2-线程安全性</title>
    <url>/2016/12/02/concurrency/concurrency2/</url>
    <content><![CDATA[<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>在构建文件的并发程序时，必须正确地使用线程和锁，但这些终归只是一些机制。要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。一个对象是否是线程安全的，取决于它是否被多个线程同时访问。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但「同步」这个术语还包括volatile类型的变量，显式锁以及原子变量。<br>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：</p>
<ul>
<li>不在线程之间共享该状态变量        </li>
<li>将状态变量改为不可变的变量        </li>
<li>在访问状态变量时使用同步</li>
</ul>
<h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。<br>无状态对象一定是线程安全的。（没有共享数据）</p>
<a id="more"></a>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>像count++这种是属于非原子操作，它包含了三个独立的操作：读取count的值，将值+1，然后将计算结果写入count。所以不同线程在自增的时候，这个值在第一步拿到的可能是过期的数据。<br>在并发编程中，这种由于不恰当的执行时序出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。最常见的竞态条件就是「先检查后执行」，通过一个可能失效的观测结果来决定下一步的动作。</p>
<h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p>要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p>
<p>我们将<code>先检查后执行</code>和<code>读取-修改-写入</code>等操作统称为「复合操作」。我们要以原子方式执行确保线程安全性，Java通过加锁机制来确保原子性。<br>原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作（不可分割的操作）。</p>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>要保持状态的一致性，就需要在某个原子性操作中更新所有相关状态变量。</p>
<h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><p>Java提供了一种内置的锁机制来支持原子性：同步代码快。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的所就是方法调用的所在对象。静态的synchronized方法以Class对象作为锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"> <span class="comment">//访问或修改由锁保护的共享状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。<br>Java的内置锁是互斥锁，意思是最多只有一个线程能持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放这个锁，那么A也将永远地等下去。<br>由于每次只能又一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事务应用程序的原子性有着相同的含义–<strong>一组语句作为一个不可分割的单元被执行</strong>。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>当某线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题。</p>
<blockquote>
<p>synchronized关键字在经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。<br>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
</blockquote>
<h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p>由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。虽然synchronized方法可以确保单个操作的原子性，但如果把多个操作合并为一个复合操作，还是需要额外的加锁机制。</p>
<h2 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h2><p>一般来讲，对整个方法进行同步，每次只有一个线程可以执行，可能会导致性能糟糕。因此我们通常在只需要同步的地方用同步代码块，只对代码块中的共享状态变量进行加锁保护。我们要找到简单性（对整个方法进行同步）与并发性（对尽可能短的代码进行同步）之间的平衡。</p>
<p>通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，已定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。</p>
<p>当执行时间较长的计算或者可能无法快速完成的操作时（例如：网络I/O或控制台I/O），一定不要持有锁。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程3-对象的共享</title>
    <url>/2016/12/05/concurrency/concurrency3/</url>
    <content><![CDATA[<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><p>要编写正确的并发程序，管关键问题在于：在访问共享的可变状态时需要进行正确的管理。本章介绍如何共享和发布对象，从而使它们能够安全地由多个线程同时访问。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>「可见性」是指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p>
<a id="more"></a>
<p>Java内存模型的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。<br>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (!ready) </span><br><span class="line">				Thread.yield();</span><br><span class="line">			System.out.println(number);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">		number = <span class="number">42</span>;</span><br><span class="line">		ready = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子可能是一个死循环，因为ReaderThread线程可能永远看不到ready的值变化（可见性问题）。还有另外一种情况就是输出了0，因为指令重排序优化的原因，<code>ready = true</code>可能会先于<code>number=42</code>执行。</p>
<blockquote>
<p>指令重排序优化是指为了使得处理内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会再计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>
</blockquote>
<h3 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h3><p><code>NoVisibility</code>展示了在缺乏同步的程序中可能产生错误结果中的一种情况：失效数据。除非在每次访问变量的时候使用同步。</p>
<h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>因为double和long是64位数据，内存模型允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。<br>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改的值代表了「半个变量」的数值。不过这很罕见，因为目前的商用虚拟机几乎都还是选择把64位数据的读写作为原子操作来对待，所以我们写代码一般也不需要对long和double变量专门声明为volatile。</p>
<h3 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h3><p><strong>synchronized和final</strong>关键字能实现可见性，synchronized的可见性是由「对一个变量执行unlock操作之前，必须先把此变量同步回主内存中」这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程时操作变量的可见性，而普通变量则不能保证这一点。<br>volatile变量通常用做某个操作完成、发生中断或者状态的标志。</p>
<blockquote>
<p>注意：加锁机制即可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</p>
</blockquote>
<p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>这种访问变量时不需要加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/25 上午10:37.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VThread_0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (VolatileTest.isRunning) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VThread_1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VolatileTest.isRunning = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;stop running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       这个不是必现，得多试几次</span></span><br><span class="line"><span class="comment">       stop running 后死循环</span></span><br><span class="line"><span class="comment">       在第二个线程更改后，第一个线程并没有马上停止，原因从Java内存模型（JMM）说起。</span></span><br><span class="line"><span class="comment">       根据JMM，Java中有一块主内存，不同的线程有自己的工作内存，同一个变量值在主内存中有一份，如果线程用到了这个变量的话，自己的工作内存中有一份一模一样的拷贝。</span></span><br><span class="line"><span class="comment">       每次进入线程从主内存中拿到变量值，每次执行完线程将变量从工作内存同步回主内存中。</span></span><br><span class="line"><span class="comment">       出现打印结果现象的原因就是主内存和工作内存中数据的不同步造成的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全围绕的是可见性和原子性这两个特性展开的，volatile解决的是变量在多个线程之间的可见性，但是无法保证原子性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VThread_0 vThread_0 = <span class="keyword">new</span> VThread_0();</span><br><span class="line">        VThread_1 vThread_1 = <span class="keyword">new</span> VThread_1();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(vThread_0);</span><br><span class="line">        executorService.execute(vThread_1);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><p>「发布」的意思是使对象能够在当前作用于之外的代码中使用，当某个不应该发布的对象被发布时，这种情况就被称为「逸出」。        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	knownSecrets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Secret&gt; <span class="title">getKnownSecrets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> knownSecrets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码发布了HashSet对象，但是却导致knownSecrets里的Secret逸出了，因为任何调用者都能修改knownSecrets里的值。</p>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步，一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据时，就不需要同步，这种技术被称为线程封闭。Java提供了ThreadLocal类来帮助维持线程封闭性。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>不可变对象一定是线程安全的，当满足以下条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改。</li>
<li>对象的所有域都是final类型。</li>
<li>对象是正确创建的（在对象的创建期间，this对象没有逸出）</li>
</ul>
<h2 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h2><p>要安全的地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中。</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<p>如果对象从技术上来看是可变的，但其状态在发布后不会在再改变，那么把这种对象称为「<strong>事实不可变对象</strong>」，在没有额外的同步情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
<p>对象的发布需求取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li>
</ul>
<p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ul>
<li><strong>线程封闭</strong>：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li>
<li><strong>保护对象</strong>：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程4-对象的组合</title>
    <url>/2016/12/06/concurrency/concurrency4/</url>
    <content><![CDATA[<h1 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h1><p>本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意中破坏类的安全性保证。</p>
<h2 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h2><p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略</li>
</ul>
<h3 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h3><p>要确保的类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。        </p>
<a id="more"></a>
<p>不变性条件是指变量的取值范围约束，后验条件是指状态改变的时候值是否合法。<br>如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。</p>
<h3 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h3><p>先验条件是基于前一个状态的操作，例如不能从空队列中移除一个元素，这个被称为依赖状态的操作。<br>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一只等到先验条件为真，然后再执行操作。后面将会介绍JDK提供的BlockingQueue和Semaphore等同步工具类来实现依赖状态的行为。</p>
<h3 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h3><p>许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。</p>
<h2 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h2><p>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护该对象的所有访问。<br>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。<br>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p>
<h3 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h3><p>从线程封闭原则及其逻辑推论可以得出Java监视器模式。遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。意思就是对象的属性全部通过同步的方法来访问或者修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object myLock = <span class="keyword">new</span> Object();</span><br><span class="line">	Widget widget;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(myLock) &#123;</span><br><span class="line">			<span class="comment">// 访问或修改Widget的状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用私有的锁对象而不是对象的内置锁，有许多优点。私有锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过共有方法来访问锁，以便参与到它的同步策略中。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程6-任务执行</title>
    <url>/2016/12/13/concurrency/concurrency6/</url>
    <content><![CDATA[<h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><p>任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构</p>
<h2 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h2><p>在理想情况下，各个任务之间是相互独立的：任务并不依赖其他任务的状态、结果或边界效应。独立性有助于实现并发，例如向web服务器提交一个请求，不会影响正在处理的其他请求。</p>
<h3 id="为任务创建线程"><a href="#为任务创建线程" class="headerlink" title="为任务创建线程"></a>为任务创建线程</h3><p>如果为每一个任务都创建一个线程，那么资源开销是极大的，无限制的创建线程存在一些缺陷：</p>
<ul>
<li>线程生命周期的开销非常高</li>
<li>资源消耗</li>
<li>稳定性<a id="more"></a>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。</p>
<p>每当看到下面这种形式的代码时：</p>
<pre><code>new Thread(runnable).start();</code></pre>
<p>并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池从字面意思来看，是指管理一组同构工作线程的资源池。</p>
<p>在线程池中执行任务比「为每一个任务分配一个线程」优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另外一个额外的好处死，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p>
<p>Executors中的静态工厂方法提供了一些线程池：</p>
<ul>
<li>newFixedThreadPool</li>
<li>newCachedThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newScheduledThreadPool</li>
</ul>
<h3 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h3><p>ExecutorService提供了一些用于生命周期管理的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ExecutorService的生命周期有3种状态：运行、关闭和已终止。ExecutorService在初始创建时处于运行状态。shotdown方法将执行平缓的关闭过程：不再接受新的任务，同事等待已经提交的任务执行完成–包括那些还未开始执行的任务。shotdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<h3 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h3><p>Timer类负责管理延迟任务以及周期任务。然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它。</p>
<h3 id="携带结果的任务Callable与Future"><a href="#携带结果的任务Callable与Future" class="headerlink" title="携带结果的任务Callable与Future"></a>携带结果的任务Callable与Future</h3><p>Callable：它人为主入口点将返回一个值，并可能抛出一个异常。Future表示一个任务的生命周期，并提供相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。</p>
<p>可以通过许多种方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将反悔一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务。</p>
<h3 id="CompletionService与BlockingQueue"><a href="#CompletionService与BlockingQueue" class="headerlink" title="CompletionService与BlockingQueue"></a>CompletionService与BlockingQueue</h3><p>CompletionService将Executor和BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多重不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用Executor。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程7-取消与关闭</title>
    <url>/2016/12/14/concurrency/concurrency7/</url>
    <content><![CDATA[<h1 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h1><p>任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。</p>
<h2 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h2><p>在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>一些特殊的阻塞库的方法支持中断。线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下轻质当前工作，并转而执行其他的工作。</p>
<p>在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难职称起更大的应用。</p>
<p>每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将设置为true。在Thread中包含了中断线程以及查询中断状态的方法。interrupt方法能中断目标线程，isInterrupted方法能返回目标线程的中断状态。静态方法interrupted将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>
<h3 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h3><p>正如任务中应该包含取消策略一样，线程同样应该包含中断策略。中断策略规定线程如何解释某个中断请求-当发现中断请求时，应该做哪些工作。由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
<h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>当调用可中断的阻塞函数时，例如Thread.sleep或BlockingQueue.put等，有两种实用策略可用于处理InterruptedException:</p>
<ul>
<li>传递异常，从而使你的方法也成为可中断的阻塞方法</li>
<li>恢复中断方法，从而使调用栈中的上层代码能够对进行处理。</li>
</ul>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
<h3 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h3><p>并非所有的可阻塞方法或者阻塞机制都能相应中断；如果一个线程由于执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。对于那些由于执行补课中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。</p>
<h2 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h2><p>应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。</p>
<p>除非拥有某个线程，否则不能对该线程进行操控。对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</p>
<p>例如日志服务，为了不给程序带来性能开销，记录日志的操作有一种方法是通过调用log方法将日志消息放入某个队列中，并由其他线程来处理。然后我们要合理的处理这个日志队列，避免因为JVM无法正常关闭时，停止日志线程导致消息丢失。</p>
<h3 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h3><p>ExecutorService提供两种关闭方法：使用shutdown正常关闭，以及使用shutdownNow强行关闭。在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。</p>
<p>这两种关闭方式的差别在于各自的安全性和响应性：强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束；而正常关闭虽然速度慢，但却更安全，因为ExecutorService会一直等到队列中的所有任务都执行完成后才关闭。在其他拥有线程的服务中也应该考虑提供累死的关闭方式以供选择。</p>
<h3 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h3><p>当通过shutdownNow来强行关闭ExecutorService时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。</p>
<p>然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor关闭时哪些任务正在执行。</p>
<h3 id="未捕获的异常"><a href="#未捕获的异常" class="headerlink" title="未捕获的异常"></a>未捕获的异常</h3><p>当线程内代码抛出RuntimeException时，Thread API提供了uncaughtExceptionHanlder，它能检测出某个线程由于未捕获的异常而终结的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureUncaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(<span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;run() by &quot;</span> + t);</span><br><span class="line">        System.out.println(<span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; creating new Thread&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;created &quot;</span> + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(<span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h2><p>JVM既可以正常关闭，也可以强行关闭。</p>
<h3 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h3><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子。关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进行“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃—-既不会执行finally代码块，也不会执行回卷栈，而JVM只是退出。我们应尽可能少地使用守护线程。</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>finalize方法就是终结器，JVM并不保证何时运行甚至是否运行，应该避免使用终结器。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者终结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过FutureTask和Executor框架，可以帮助我们构建可取消的任务和服务。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch01-介绍</title>
    <url>/2018/06/03/elasticsearch/elasticSearch01/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官网：<a href="http://www.elastic.co/products/elasticsearch">http://www.elastic.co/products/elasticsearch</a></p>
<p>系列文章版本基于ElasticSearch5.2</p>
<h2 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch"></a>什么是Elasticsearch</h2><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<a id="more"></a>

<h3 id="什么是搜索？"><a href="#什么是搜索？" class="headerlink" title="什么是搜索？"></a>什么是搜索？</h3><p>百度：我们比如说想找寻任何的信息的时候，就会上百度去搜索一下，比如说找一部自己喜欢的电影，或者说找一本喜欢的书，或者找一条感兴趣的新闻（提到搜索的第一印象）<br>但是百度 != 搜索，这是不对的</p>
<p>还有一种是垂直搜索（站内搜索）：</p>
<p>互联网的搜索：电商网站，招聘网站，新闻网站，各种app<br>IT系统的搜索：OA软件，办公自动化软件，会议管理，日程管理，项目管理，员工管理，搜索“张三”，“张三儿”，“张小三”；有个电商网站，卖家，后台管理系统，搜索“牙膏”，订单，“牙膏相关的订单”</p>
<p>搜索，就是在任何场景下，找寻你想要的信息，输入一段你要搜索的关键字，期望找到这个关键字相关的有些信息</p>
<h3 id="如果用数据库做搜索会怎么样？"><a href="#如果用数据库做搜索会怎么样？" class="headerlink" title="如果用数据库做搜索会怎么样？"></a>如果用数据库做搜索会怎么样？</h3><p>做软件开发或者对IT、计算机有一定的了解的话，都知道数据都是存储在数据库里面的，比如说电商网站的商品信息，招聘网站的职位信息，新闻网站的新闻信息，等等。所以说很自然的一点，如果说从技术的角度去考虑，如何实现如电商网站内部的搜索功能，就可以考虑去使用数据库去进行搜索。</p>
<p><strong>弊端：</strong></p>
<ol>
<li>每条记录的指定字段的文本，可能会很长，比如说“商品描述”字段的长度，有长达数千个，甚至数万个字符，这个时候，每次都要对每条记录的所有文本进行扫描，懒判断，包不包含指定的关键词（比如说“牙膏”）</li>
<li>不能将搜索词拆分开来，尽可能去搜索更多的符合你的期望的结果，比如输入“生化机”，就搜索不出来“生化危机”，也就是没有分词功能。</li>
</ol>
<p>而且用数据库来实现搜索，是不太靠谱的。通常来说，性能会很差。</p>
<h3 id="什么是全文检索和Lucene？"><a href="#什么是全文检索和Lucene？" class="headerlink" title="什么是全文检索和Lucene？"></a>什么是全文检索和Lucene？</h3><ol>
<li><p>全文检索，倒排索引</p>
<p> <img src="/img/es/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2.png"></p>
</li>
<li><p>lucene，就是一个jar包，里面包含了封装好的各种建立倒排索引，以及进行搜索的代码，包括各种算法。我们就用java开发的时候，引入lucene jar，然后基于lucene的api进行去进行开发就可以了。用lucene，我们就可以去将已有的数据建立索引，lucene会在本地磁盘上面，给我们组织索引的数据结构。另外的话，我们也可以用lucene提供的一些功能和api来针对磁盘上额</p>
</li>
</ol>
<h3 id="什么是Elasticsearch？"><a href="#什么是Elasticsearch？" class="headerlink" title="什么是Elasticsearch？"></a>什么是Elasticsearch？</h3><p><img src="/img/es/01/%E4%BB%80%E4%B9%88%E6%98%AFElasticsearch.png"></p>
<h2 id="Elasticsearch功能介绍"><a href="#Elasticsearch功能介绍" class="headerlink" title="Elasticsearch功能介绍"></a>Elasticsearch功能介绍</h2><h3 id="分布式的搜索引擎和数据分析引擎"><a href="#分布式的搜索引擎和数据分析引擎" class="headerlink" title="分布式的搜索引擎和数据分析引擎"></a>分布式的搜索引擎和数据分析引擎</h3><p>搜索：百度，网站的站内搜索，IT系统的检索</p>
<p>数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些</p>
<h3 id="全文检索，结构化检索，数据分析"><a href="#全文检索，结构化检索，数据分析" class="headerlink" title="全文检索，结构化检索，数据分析"></a>全文检索，结构化检索，数据分析</h3><ul>
<li><p>全文检索：我想搜索商品名称包含牙膏的商品，<code>select * from products where product_name like &quot;%牙膏%&quot;</code></p>
</li>
<li><p>结构化检索：我想搜索商品分类为日化用品的商品都有哪些，<code>select * from products where category=&#39;日化用品&#39;</code></p>
<p>  部分匹配、自动完成、搜索纠错、搜索推荐</p>
</li>
<li><p>数据分析：我们分析每一个商品分类下有多少个商品，<code>select category_id,count(*) from products group by category_id</code></p>
</li>
</ul>
<h3 id="对海量数据进行近实时的处理"><a href="#对海量数据进行近实时的处理" class="headerlink" title="对海量数据进行近实时的处理"></a>对海量数据进行近实时的处理</h3><ul>
<li>分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索</li>
<li>海量数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了</li>
<li>近实时：如果检索数据要花费1小时（这就不叫近实时，这叫离线批处理，batch-processing）；近实时是在秒级别对数据进行搜索和分析</li>
</ul>
<p>跟分布式/海量数据相反：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量</p>
<h3 id="Elasticsearch的适用场景"><a href="#Elasticsearch的适用场景" class="headerlink" title="Elasticsearch的适用场景"></a>Elasticsearch的适用场景</h3><ol>
<li>维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐</li>
<li>The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</li>
<li>Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</li>
<li>GitHub（开源代码管理），搜索上千亿行代码</li>
<li>电商网站，检索商品</li>
<li>日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）</li>
<li>商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</li>
<li>BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</li>
<li>国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）</li>
</ol>
<h3 id="Elasticsearch的特点"><a href="#Elasticsearch的特点" class="headerlink" title="Elasticsearch的特点"></a>Elasticsearch的特点</h3><ol>
<li>可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司</li>
<li>Elasticsearch不是什么新技术，主要是将全文检索、数据分析以及分布式技术，合并在了一起，才形成了独一无二的ES；lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat）</li>
<li>对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂</li>
<li>数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不能提供的很多功能</li>
</ol>
<h2 id="ElasticSearch核心概念"><a href="#ElasticSearch核心概念" class="headerlink" title="ElasticSearch核心概念"></a>ElasticSearch核心概念</h2><h3 id="lucene和elasticsearch的前世今生"><a href="#lucene和elasticsearch的前世今生" class="headerlink" title="lucene和elasticsearch的前世今生"></a>lucene和elasticsearch的前世今生</h3><p>elasticsearch，基于lucene，隐藏复杂性，提供简单易用的restful api接口、java api接口（还有其他语言的api接口）</p>
<ol>
<li>分布式的文档存储引擎</li>
<li>分布式的搜索引擎和分析引擎</li>
<li>分布式海量数据，支持PB级数据</li>
</ol>
<p>开箱即用，优秀的默认参数，不需要任何额外设置，完全开源</p>
<p>关于elasticsearch的一个传说，有一个程序员失业了，陪着自己老婆去英国伦敦学习厨师课程。程序员在失业期间想给老婆写一个菜谱搜索引擎，觉得lucene实在太复杂了，就开发了一个封装了lucene的开源项目，compass。后来程序员找到了工作，是做分布式的高性能项目的，觉得compass不够，就写了elasticsearch，让lucene变成分布式的系统。</p>
<h3 id="elasticsearch的核心概念"><a href="#elasticsearch的核心概念" class="headerlink" title="elasticsearch的核心概念"></a>elasticsearch的核心概念</h3><ol>
<li><p>Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级</p>
<p> <img src="/img/es/01/Elasticsearch%E8%BF%91%E5%AE%9E%E6%97%B6%E6%A6%82%E5%BF%B5%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt="Elasticsearch近实时概念的解释"></p>
</li>
</ol>
<ol start="2">
<li><p>Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常</p>
</li>
<li><p>Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群</p>
</li>
<li><p>Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。</p>
</li>
<li><p>Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。</p>
</li>
<li><p>Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">商品index，里面存放了所有的商品数据，商品document</span><br><span class="line"></span><br><span class="line">但是商品分很多种类，每个种类的document的field可能不太一样，比如说电器商品，可能还包含一些诸如售后时间范围这样的特殊field；生鲜商品，还包含一些诸如生鲜保质期之类的特殊field</span><br><span class="line"></span><br><span class="line">type，日化商品type，电器商品type，生鲜商品type</span><br><span class="line"></span><br><span class="line">日化商品type：product_id，product_name，product_desc，category_id，category_name</span><br><span class="line">电器商品type：product_id，product_name，product_desc，category_id，category_name，service_period</span><br><span class="line">生鲜商品type：product_id，product_name，product_desc，category_id，category_name，eat_period</span><br><span class="line"></span><br><span class="line">每一个type里面，都会包含一堆document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;product_id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;product_name&quot;: &quot;长虹电视机&quot;,</span><br><span class="line">  &quot;product_desc&quot;: &quot;4k高清&quot;,</span><br><span class="line">  &quot;category_id&quot;: &quot;3&quot;,</span><br><span class="line">  &quot;category_name&quot;: &quot;电器&quot;,</span><br><span class="line">  &quot;service_period&quot;: &quot;1年&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;product_id&quot;: &quot;3&quot;,</span><br><span class="line">  &quot;product_name&quot;: &quot;基围虾&quot;,</span><br><span class="line">  &quot;product_desc&quot;: &quot;纯天然，冰岛产&quot;,</span><br><span class="line">  &quot;category_id&quot;: &quot;4&quot;,</span><br><span class="line">  &quot;category_name&quot;: &quot;生鲜&quot;,</span><br><span class="line">  &quot;eat_period&quot;: &quot;7天&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。</p>
</li>
<li><p>replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。</p>
<p> <img src="/img/es/01/shard%E5%92%8Creplica%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt="shard和replica的解释"></p>
</li>
</ol>
<h3 id="elasticsearch核心概念-vs-数据库核心概念"><a href="#elasticsearch核心概念-vs-数据库核心概念" class="headerlink" title="elasticsearch核心概念 vs. 数据库核心概念"></a>elasticsearch核心概念 vs. 数据库核心概念</h3><table>
<thead>
<tr>
<th>Elasticsearch</th>
<th align="center">数据库</th>
</tr>
</thead>
<tbody><tr>
<td>Document</td>
<td align="center">行</td>
</tr>
<tr>
<td>Type</td>
<td align="center">表</td>
</tr>
<tr>
<td>Index</td>
<td align="center">库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch02-快速入门</title>
    <url>/2018/06/05/elasticsearch/elasticSearch02/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="环境准备和安装"><a href="#环境准备和安装" class="headerlink" title="环境准备和安装"></a>环境准备和安装</h2><ol>
<li><p>安装JDK，至少1.8.0_73以上版本，java -version</p>
</li>
<li><p>下载和解压缩Elasticsearch安装包（<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0%EF%BC%89">https://www.elastic.co/downloads/past-releases/elasticsearch-5-2-0）</a></p>
<a id="more"></a></li>
<li><p>启动Elasticsearch：bin\elasticsearch，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂的，直接启动就可以用了。</p>
<p> <img src="/img/es/02/es_start.png"></p>
</li>
<li><p>检查ES是否启动成功：<a href="http://localhost:9200/?pretty">http://localhost:9200/?pretty</a></p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">name: node名称</span><br><span class="line">cluster_name: 集群名称（默认的集群名称就是elasticsearch）</span><br><span class="line">version.number: 5.2.0，es版本号</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;4onsTYV&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;nKZ9VK_vQdSQ1J0Dx9gx1Q&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;5.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;24e05b9&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2017-01-24T19:52:35.800Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;6.4.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改集群名称：elasticsearch.yml</p>
<p> 修改<code>elasticsearch.yml</code>里面的<code>cluster.name: my-application</code>即可。</p>
</li>
<li><p>下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口</p>
<p> <a href="https://www.elastic.co/downloads/past-releases/kibana-5-2-0">https://www.elastic.co/downloads/past-releases/kibana-5-2-0</a></p>
<p> <img src="/img/es/02/kibana_start.png"></p>
<p> 访问<a href="http://localhost:5601/%EF%BC%8C%E4%BD%BF%E7%94%A8devtools%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E5%92%8C%E5%BC%80%E5%8F%91">http://localhost:5601/，使用devtools进行测试和开发</a></p>
<p> <img src="/img/es/02/kibana_health.png" alt="GET _cluster/health">    </p>
</li>
</ol>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>学习一门新技术，搭建好环境后第一件事当然是做个helloworld的demo，我们来做个crud</p>
<h3 id="document数据格式"><a href="#document数据格式" class="headerlink" title="document数据格式"></a>document数据格式</h3><ol>
<li>es的数据结构存储模式，熟悉mongodb的人应该知道，他们的数据结构是差不多的，都是面向文档的，一条数据就是一个json。</li>
<li>对象数据存储到数据库中，只能拆解开来，变为扁平的多张表，每次查询的时候还得还原回对象格式，相当麻烦。</li>
<li>ES是面向文档的，文档中存储的数据结构，与面向对象的数据结构是一样的，基于这种文档数据结构，es可以提供复杂的索引，全文检索，分析聚合等功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> EmployeeInfo info;</span><br><span class="line">  <span class="keyword">private</span> Date joinDate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeInfo</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String bio; <span class="comment">// 性格</span></span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> String[] interests; <span class="comment">// 兴趣爱好</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EmployeeInfo info = <span class="keyword">new</span> EmployeeInfo();</span><br><span class="line">info.setBio(<span class="string">&quot;curious and modest&quot;</span>);</span><br><span class="line">info.setAge(<span class="number">30</span>);</span><br><span class="line">info.setInterests(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;bike&quot;</span>, <span class="string">&quot;climb&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.setEmail(<span class="string">&quot;zhangsan@sina.com&quot;</span>);</span><br><span class="line">employee.setFirstName(<span class="string">&quot;san&quot;</span>);</span><br><span class="line">employee.setLastName(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">employee.setInfo(info);</span><br><span class="line">employee.setJoinDate(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>


<p>上述代码，在mysql中，肯定就是两张表：employee表，employee_info表，将employee对象的数据重新拆开来，变成Employee数据和EmployeeInfo数据<br>employee表：email，first_name，last_name，join_date，4个字段<br>employee_info表：bio，age，interests，3个字段；此外还有一个外键字段，比如employee_id，关联着employee表</p>
<h3 id="demo背景"><a href="#demo背景" class="headerlink" title="demo背景"></a>demo背景</h3><p>有一个电商网站，需要为其基于ES构建一个后台系统，提供以下功能：</p>
<ol>
<li>对商品信息进行CRUD（增删改查）操作</li>
<li>执行简单的结构化查询</li>
<li>可以执行简单的全文检索，以及复杂的phrase（短语）检索</li>
<li>对于全文检索的结果，可以进行高亮显示</li>
<li>对数据进行简单的聚合分析</li>
</ol>
<h3 id="简单的集群管理"><a href="#简单的集群管理" class="headerlink" title="简单的集群管理"></a>简单的集群管理</h3><h4 id="快速检查集群的健康状况"><a href="#快速检查集群的健康状况" class="headerlink" title="快速检查集群的健康状况"></a>快速检查集群的健康状况</h4><p>es提供了一套api，叫做cat api，可以查看es中各种各样的数据</p>
<p><code>GET /_cat/health?v</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1528602515 11:48:35  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br></pre></td></tr></table></figure>

<p><strong>如何快速了解集群的健康状况？green、yellow、red？</strong></p>
<ul>
<li>green：每个索引的primary shard和replica shard都是active状态的</li>
<li>yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li>
<li>red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li>
</ul>
<p>为什么现在会处于一个yellow状态？</p>
<p>我们现在就一个笔记本电脑，就启动了一个es进程，相当于就只有一个node。现在es中有一个index，就是kibana自己内置建立的index。由于默认的配置是给每个index分配5个primary shard和5个replica shard，而且primary shard和replica shard不能在同一台机器上（为了容错）。现在kibana自己建立的index是1个primary shard和1个replica shard。当前就一个node，所以只有1个primary shard被分配了和启动了，但是一个replica shard没有第二台机器去启动。</p>
<p>做一个小实验：此时只要启动第二个es进程，就会在es集群中有2个node，然后那1个replica shard就会自动分配过去，然后cluster status就会变成green状态。</p>
<h4 id="快速查看集群中有哪些索引"><a href="#快速查看集群中有哪些索引" class="headerlink" title="快速查看集群中有哪些索引"></a>快速查看集群中有哪些索引</h4><p>GET /_cat/indices?v</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   .kibana T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br></pre></td></tr></table></figure>

<h4 id="简单的索引操作"><a href="#简单的索引操作" class="headerlink" title="简单的索引操作"></a>简单的索引操作</h4><p>创建索引：PUT /test_index?pretty</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">health status index      uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   test_index cyS7pUwcQKmvTFtUCGNgHg   5   1          0            0       650b           650b</span><br><span class="line">yellow open   .kibana    T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">删除索引：DELETE /test_index?pretty</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   .kibana T5J6wa4FSy6ErH1zTOmIEg   1   1          1            0      3.1kb          3.1kb</span><br></pre></td></tr></table></figure>


<h3 id="商品的CRUD操作"><a href="#商品的CRUD操作" class="headerlink" title="商品的CRUD操作"></a>商品的CRUD操作</h3><h4 id="新增商品：新增文档，建立索引"><a href="#新增商品：新增文档，建立索引" class="headerlink" title="新增商品：新增文档，建立索引"></a>新增商品：新增文档，建立索引</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /ecommerce/product/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;gaolujie yagao&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span> :  <span class="string">&quot;gaoxiao meibai&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span> :  <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;producer&quot;</span> :      <span class="string">&quot;gaolujie producer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [ <span class="string">&quot;meibai&quot;</span>, <span class="string">&quot;fangzhu&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /ecommerce/product/2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;jiajieshi yagao&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span> :  <span class="string">&quot;youxiao fangzhu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span> :  <span class="number">25</span>,</span><br><span class="line">    <span class="attr">&quot;producer&quot;</span> :      <span class="string">&quot;jiajieshi producer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [ <span class="string">&quot;fangzhu&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /ecommerce/product/3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;zhonghua yagao&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span> :  <span class="string">&quot;caoben zhiwu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span> :  <span class="number">40</span>,</span><br><span class="line">    <span class="attr">&quot;producer&quot;</span> :      <span class="string">&quot;zhonghua producer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [ <span class="string">&quot;qingxin&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询商品：检索文档"><a href="#查询商品：检索文档" class="headerlink" title="查询商品：检索文档"></a>查询商品：检索文档</h4><p>GET /index/type/id</p>
<p>GET /ecommerce/product/1</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gaolujie yagao&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;gaoxiao meibai&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;producer&quot;</span>: <span class="string">&quot;gaolujie producer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;meibai&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fangzhu&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line">	#### 修改商品：替换文档</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">PUT /ecommerce/product/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;jiaqiangban gaolujie yagao&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span> :  <span class="string">&quot;gaoxiao meibai&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span> :  <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;producer&quot;</span> :      <span class="string">&quot;gaolujie producer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [ <span class="string">&quot;meibai&quot;</span>, <span class="string">&quot;fangzhu&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换方式有一个不好，即使必须带上所有的field，才能去进行信息的修改，否则文档的数据结构会被修改。</p>
<h4 id="修改商品：更新文档"><a href="#修改商品：更新文档" class="headerlink" title="修改商品：更新文档"></a>修改商品：更新文档</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /ecommerce/product/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jiaqiangban gaolujie yagao&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除商品：删除文档"><a href="#删除商品：删除文档" class="headerlink" title="删除商品：删除文档"></a>删除商品：删除文档</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /ecommerce/product/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多种搜索方式"><a href="#多种搜索方式" class="headerlink" title="多种搜索方式"></a>多种搜索方式</h3><p>上面做了CRUD，接下里就是ES里最重要的搜索部分。</p>
<h4 id="query-string-search"><a href="#query-string-search" class="headerlink" title="query string search"></a>query string search</h4><p>搜索全部商品：GET /ecommerce/product/_search</p>
<p><img src="/img/es/02/kibana_search01.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">took：耗费了几毫秒</span><br><span class="line">timed_out：是否超时，这里没有</span><br><span class="line">_shards：数据拆成了5个分片，所以对于搜索请求，会分配所有的primary shard（或者是它的某个replica shard）</span><br><span class="line">hits.total：查询结果的数量，3个document</span><br><span class="line">hits.max_score：score的含义，就是document对于一个search的相关度的匹配分数，越相关，就越匹配，分数也高</span><br><span class="line">hits.hits：包含了匹配搜索的document的详细数据</span><br></pre></td></tr></table></figure>

<p>query string search的由来，因为search参数都是以http请求的query string来附带的(也就是?后面的)</p>
<p>搜索商品名称中包含yagao的商品，而且按照售价降序排序：</p>
<p><code>GET /ecommerce/product/_search?q=name:yagao&amp;sort=price:desc</code></p>
<p>适用于临时的在命令行使用一些工具，比如curl，快速的发出请求，来检索想要的信息；但是如果查询请求很复杂，是很难去构建的。在生产环境中，几乎很少使用query string search</p>
<h4 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h4><p>DSL：Domain Specified Language，特定领域的语言。<br>http request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了</p>
<p><strong>查询所有的商品</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询名称包含yagao的商品，同时按照价格降序排序</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;yagao&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定要查询出来商品的名称和价格就可以</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match_all&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更加适合生产环境的使用，可以构建复杂的查询。</p>
<h4 id="query-filter"><a href="#query-filter" class="headerlink" title="query filter"></a>query filter</h4><p>搜索商品名称包含yagao，而且售价大于25元的商品</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;must&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;yagao&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span> : &#123; <span class="attr">&quot;gt&quot;</span> : <span class="number">25</span> &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="full-text-search（全文检索）"><a href="#full-text-search（全文检索）" class="headerlink" title="full-text search（全文检索）"></a>full-text search（全文检索）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;producer&quot;</span> : <span class="string">&quot;yagao producer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为查询了2个单词，producer这个字段，会先被拆解，建立倒排索引。</p>
<p>在分词以后，只要任意命中其中一个单词，都会被查询出来，如果2个单词都命中会排在前面。</p>
<h4 id="phrase-search（短语搜索）"><a href="#phrase-search（短语搜索）" class="headerlink" title="phrase search（短语搜索）"></a>phrase search（短语搜索）</h4><p>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回。</p>
<p>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match_phrase&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;producer&quot;</span> : <span class="string">&quot;yagao producer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="highlight-search（高亮搜索结果）"><a href="#highlight-search（高亮搜索结果）" class="headerlink" title="highlight search（高亮搜索结果）"></a>highlight search（高亮搜索结果）</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;producer&quot;</span> : <span class="string">&quot;producer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;producer&quot;</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合分析快速入门"><a href="#聚合分析快速入门" class="headerlink" title="聚合分析快速入门"></a>聚合分析快速入门</h3><h4 id="计算每个tag下的商品数量"><a href="#计算每个tag下的商品数量" class="headerlink" title="计算每个tag下的商品数量"></a>计算每个tag下的商品数量</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;group_by_tags&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123; <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;tags&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/es/02/aggs_error.png"></p>
<p>报错了，text类型的字段默认不支持聚合，得做个操作让它支持聚合，将文本field的fielddata属性设置为true。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">PUT /ecommerce/_mapping/product</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fielddata&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再测试一次聚合查询，就好了</p>
<p><img src="/img/es/02/aggs_normal.png"></p>
<h4 id="对名称中包含yagao的商品，计算每个tag下的商品数量"><a href="#对名称中包含yagao的商品，计算每个tag下的商品数量" class="headerlink" title="对名称中包含yagao的商品，计算每个tag下的商品数量"></a>对名称中包含yagao的商品，计算每个tag下的商品数量</h4><p>在聚合分析的基础上加上条件筛选</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;yagao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;all_tags&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先分组，再算每组的平均值，计算每个tag下的商品的平均价格"><a href="#先分组，再算每组的平均值，计算每个tag下的商品的平均价格" class="headerlink" title="先分组，再算每组的平均值，计算每个tag下的商品的平均价格"></a>先分组，再算每组的平均值，计算每个tag下的商品的平均价格</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;group_by_tags&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;tags&quot;</span> &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;avg&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;group_by_tags&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;fangzhu&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">27.5</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;meibai&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;qingxin&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">40</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"><a href="#计算每个tag下的商品的平均价格，并且按照平均价格降序排序" class="headerlink" title="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"></a>计算每个tag下的商品的平均价格，并且按照平均价格降序排序</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;all_tags&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;tags&quot;</span>, <span class="attr">&quot;order&quot;</span>: &#123; <span class="attr">&quot;avg_price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;avg&quot;</span> : &#123; <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"><a href="#按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格" class="headerlink" title="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"></a>按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /ecommerce/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;group_by_price&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ranges&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;to&quot;</span>: <span class="number">20</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="attr">&quot;to&quot;</span>: <span class="number">40</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="attr">&quot;to&quot;</span>: <span class="number">50</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;group_by_tags&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;average_price&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch03-集群和架构讲解</title>
    <url>/2018/06/20/elasticsearch/elasticSearch03/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h2 id="ES基础分布式架构"><a href="#ES基础分布式架构" class="headerlink" title="ES基础分布式架构"></a>ES基础分布式架构</h2><h3 id="Elasticsearch对复杂分布式机制的透明隐藏特性"><a href="#Elasticsearch对复杂分布式机制的透明隐藏特性" class="headerlink" title="Elasticsearch对复杂分布式机制的透明隐藏特性"></a>Elasticsearch对复杂分布式机制的透明隐藏特性</h3><p>Elasticsearch是一套分布式的系统，分布式就是为了应对大数据量。它隐藏了复杂的分布式机制，其中有几个很重要的机制和概念。</p>
<ul>
<li><p>分片机制（之前将一些document插入到es集群中去，不用关心数据怎么进行分片的，数据到哪个shard中去，这是ES自动完成的）</p>
<a id="more"></a></li>
<li><p>cluster discovery（集群发现机制：在第一篇文章中做那个集群status从yellow转green的实验里，直接启动了第二个es进程，那个进程就作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据）</p>
</li>
<li><p>shard负载均衡（举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求）</p>
</li>
</ul>
<p>总结下来就是：分片副本，请求路由，集群扩容，分片重分配</p>
<h3 id="Elasticsearch的垂直扩容与水平扩容"><a href="#Elasticsearch的垂直扩容与水平扩容" class="headerlink" title="Elasticsearch的垂直扩容与水平扩容"></a>Elasticsearch的垂直扩容与水平扩容</h3><ul>
<li><p>垂直扩容：采购更强大的服务器，成本非常高昂，而且会有瓶颈，假设世界上最强大的服务器容量就是10T，但是当你的总数据量达到5000T的时候，你要采购多少台最强大的服务器？</p>
</li>
<li><p>水平扩容：这是业界经常采用的方案，采购越来越多的普通服务器，虽然性能比较一般，但是很多普通服务器组织在一起，就能构成强大的计算和存储能力。</p>
</li>
</ul>
<p>例如：</p>
<p>普通服务器：1T，1万一台，需要100万<br>强大服务器：10T，50万一台，需要500万</p>
<p>一般是采用水平扩容的方式</p>
<h3 id="增减或减少节点时的数据rebalance"><a href="#增减或减少节点时的数据rebalance" class="headerlink" title="增减或减少节点时的数据rebalance"></a>增减或减少节点时的数据rebalance</h3><p>每当增加或者减少节点的时候，ES会自动的负载均衡保持每个节点的shard负载均衡，保证每台服务器的分片数量均衡。</p>
<h3 id="master节点作用"><a href="#master节点作用" class="headerlink" title="master节点作用"></a>master节点作用</h3><p>ES集群都有一个master节点，用来管理ES集群的元数据：比如索引的创建和删除，维护索引的元数据；节点的增加和移除等等。</p>
<p>默认情况下会自动的选出一台节点作为master节点，master不承载请求，所以没有单点瓶颈。</p>
<h3 id="节点对等的分布式架构"><a href="#节点对等的分布式架构" class="headerlink" title="节点对等的分布式架构"></a>节点对等的分布式架构</h3><p>所有的节点都可以接受请求，也可以存储数据，如果数据不在自己的节点上，就去别的节点将数据找到然后返回给客户端。</p>
<ol>
<li>节点对等，每个节点都能接收所有的请求</li>
<li>自动请求路由</li>
<li>响应收集</li>
</ol>
<p><img src="/img/es/03/ES%E7%9A%84%E5%9F%BA%E7%A1%80%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.png" alt="ES的基础分布式架构"></p>
<h2 id="shard-amp-replica机制再次梳理"><a href="#shard-amp-replica机制再次梳理" class="headerlink" title="shard&amp;replica机制再次梳理"></a>shard&amp;replica机制再次梳理</h2><ol>
<li>一个index包含一个或者多个shard</li>
<li>每个shard都是一个最小工作单元，它承载部分数据，每一个都是lucene实例，具有完整的建立索引和处理请求的能力。</li>
<li>增减节点时，shard会自动在nodes中负载均衡</li>
<li>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard。</li>
<li>replica shard是primary shard的副本，负责容错，以及承担读请求负载。</li>
<li>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改。</li>
<li>primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard</li>
<li>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上。</li>
</ol>
<h2 id="单node环境下创建index是什么样子的"><a href="#单node环境下创建index是什么样子的" class="headerlink" title="单node环境下创建index是什么样子的"></a>单node环境下创建index是什么样子的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;test_index</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 3,</span><br><span class="line">      &quot;number_of_replicas&quot; : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>单node环境下，创建一个index，它有3个primary shard，3个replica shard</p>
</li>
<li><p>集群status是yellow</p>
<p> <img src="/img/es/03/%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81.png" alt="单机集群状态"></p>
</li>
<li><p>这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的（primary shard不能和自己的replica shard放在同一个节点上，集群状态是yellow的原因）</p>
</li>
<li><p>集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求</p>
</li>
</ol>
<h2 id="2个node环境下replica-shard是如何分配的"><a href="#2个node环境下replica-shard是如何分配的" class="headerlink" title="2个node环境下replica shard是如何分配的"></a>2个node环境下replica shard是如何分配的</h2><ol>
<li>replica shard分配：5个primary shard，5个replica shard，2个node</li>
<li>primary和replica的数据是同步的</li>
<li>primary/replica都可能会收到读请求</li>
</ol>
<p><img src="/img/es/03/2%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%86%E7%89%87%E5%92%8C%E5%89%AF%E6%9C%AC%E5%88%86%E9%85%8D.png" alt="2个节点的分片和副本分配"></p>
<p>上面有灰色边框的是primary shard</p>
<h2 id="横向扩容的过程，如何超出扩容极限，以及如何提升容错性"><a href="#横向扩容的过程，如何超出扩容极限，以及如何提升容错性" class="headerlink" title="横向扩容的过程，如何超出扩容极限，以及如何提升容错性"></a>横向扩容的过程，如何超出扩容极限，以及如何提升容错性</h2><ol>
<li>如果本身是2个节点，扩容1个节点后primary&amp;replica会自动负载均衡。6个shard，3 primary，3 replica会平均的被分配3个节点中。</li>
<li>扩容后每个node有更少的shard，意味着IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好。</li>
<li>扩容的极限是什么？如果是6个shard（3 primary，3 replica），那么最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，这个时候性能最好。</li>
<li>如果要超出扩容极限，那就动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量。</li>
<li>在3台机器的情况下，9个shard（3 primary，6 replica），虽然资源更少，但是容错性更好，最多容纳2台机器宕机，如果是配置的6个shard那么只能容纳1台机器宕机。</li>
<li>这里的这些知识点综合起来看，一方面是说扩容的原理，怎么扩容，怎么提升系统整体吞吐量；另一方面要考虑到系统的容错性，怎么保证提高容错性，让尽可能多的服务器宕机，保证数据不丢失。</li>
</ol>
<h2 id="Elasticsearch容错机制：master选举，replica容错，数据恢复"><a href="#Elasticsearch容错机制：master选举，replica容错，数据恢复" class="headerlink" title="Elasticsearch容错机制：master选举，replica容错，数据恢复"></a>Elasticsearch容错机制：master选举，replica容错，数据恢复</h2><p>假设我们一共有9 shard，3个node。</p>
<ol>
<li>如果master node宕机了，那么ES集群会自动进行master选举，自动选举另外一个node成为新的master，这个时候集群状态会变成red。</li>
<li>replica容错：新的master将replica shard提升为primary shard，集群状态变成yellow。</li>
<li>然后我们再重启宕机的node，master会将确实的副本复制到该node，会使用原有的shard并同步宕机后的修改，然后集群变成green。</li>
</ol>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch08-内核原理</title>
    <url>/2018/09/28/elasticsearch/elasticSearch08/</url>
    <content><![CDATA[<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>如何使文本被搜索到是搜索引擎很重要的一部分，倒排索引是很适合搜索的。</p>
<p>因为它的结构：</p>
<ol>
<li>包含这个关键词的document list</li>
<li>包含这个关键词的所有document的数量：IDFinverse document frequency. </li>
<li>这个关键词在每个document中出现的次数：TFterm frequency. <a id="more"></a></li>
<li>这个关键词在这个document中的次序</li>
<li>每个document的长度：length norm</li>
<li>包含这个关键词的所有document的平均长度</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Term  | Doc 1 | Doc 2 | Doc 3 | ...</span><br><span class="line">------------------------------------</span><br><span class="line">brown |   X   |       |  X    | ...</span><br><span class="line">fox   |   X   |   X   |  X    | ...</span><br><span class="line">quick |   X   |   X   |       | ...</span><br><span class="line">the   |   X   |       |  X    | ...</span><br></pre></td></tr></table></figure>

<p>倒排索引是不可变的，它的好处如下：</p>
<ul>
<li>不需要锁，提升并发能力，避免锁的问题</li>
<li>数据不变，一直保存在os cache中，只要cache内存足够</li>
<li>filter cache一直驻留在内存，因为数据不变</li>
<li>可以压缩，节省cpu和io开销</li>
</ul>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h1 id="文档写入原理"><a href="#文档写入原理" class="headerlink" title="文档写入原理"></a>文档写入原理</h1><p>文档在写入的时候，ES的流程如下：</p>
<ol>
<li>新文档写入buffer</li>
<li>commit point</li>
<li>buffer中的数据写入新的index segment</li>
<li>等待在os cache中的index segment被fsync强制刷到磁盘上</li>
<li>新的index sgement被打开，供search使用</li>
<li>buffer被清空</li>
</ol>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1102.png"></p>
<p><strong>删除和更新</strong></p>
<p>每次commit point时，会有一个.del文件，标记了哪些segment中的哪些document被标记为deleted了。<br>搜索的时候，会依次查询所有的segment，从旧的到新的，比如被修改过的document，在旧的segment中，会标记为deleted，在新的segment中会有其新的数据。</p>
<h1 id="优化写入流程"><a href="#优化写入流程" class="headerlink" title="优化写入流程"></a>优化写入流程</h1><p>现有流程的问题，每次都必须等待fsync将segment刷入磁盘，才能将segment打开供search使用，这样的话从一个document写入，到它可以被搜索，可能会超过1分钟！这就不是近实时的搜索了！主要瓶颈在于fsync实际发生磁盘IO写数据进磁盘，是很耗时的。</p>
<p>写入流程被改进如下：</p>
<ol>
<li>数据写入buffer</li>
<li>每隔一定时间，buffer中的数据被写入segment文件，但是先写入os cache</li>
<li>只要segment写入os cache，那就直接打开供search使用，不立即执行commit</li>
</ol>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1105.png"></p>
<p>数据写入os cache，并被打开供搜索的过程，叫做refresh，默认是每隔1秒refresh一次。也就是说，每隔一秒就会将buffer中的数据写入一个新的index segment file，先写入os cache中。所以es是近实时的，数据写入到可以被搜索，默认是1秒。</p>
<p>POST /my_index/_refresh，可以手动refresh，一般不需要手动执行，没必要这样，让es自己搞就可以了。</p>
<p>比如说，我们现在的时效性要求比较低，只要求一条数据写入es，一分钟以后才让我们搜索到就可以了，那么就可以调整refresh interval。如果写的并发量和数据量比较大的话，refresh设置长一点可以优化写入速度，因为频繁的写入index segment file会比较占用资源。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;refresh_interval&quot;</span>: <span class="string">&quot;60s&quot;</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="可靠存储实现"><a href="#可靠存储实现" class="headerlink" title="可靠存储实现"></a>可靠存储实现</h1><p>再次优化的写入流程</p>
<ol>
<li>数据写入buffer缓冲和translog日志文件</li>
<li>每隔一秒钟，buffer中的数据被写入新的segment file，并进入os cache，此时segment被打开并供search使用</li>
<li>buffer被清空</li>
<li>重复1~3，新的segment不断添加，buffer不断被清空，而translog中的数据不断累加</li>
<li>当translog长度达到一定程度的时候，commit操作发生<ol>
<li>buffer中的所有数据写入一个新的segment，并写入os cache，打开供使用</li>
<li>buffer被清空</li>
<li>一个commit ponit被写入磁盘，标明了所有的index segment</li>
<li>filesystem cache中的所有index segment file缓存数据，被fsync强行刷到磁盘上</li>
<li>现有的translog被清空，创建一个新的translog</li>
</ol>
</li>
</ol>
<p><strong>新的文档被添加到内存缓冲区并且被追加到了事务日志</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1106.png" alt="新的文档被添加到内存缓冲区并且被追加到了事务日志"></p>
<p><strong>刷新（refresh）完成后, 缓存被清空但是事务日志不会</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1107.png"></p>
<p><strong>事务日志不断积累文档</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1108.png"></p>
<p><strong>在刷新（flush）之后，段被全量提交，并且事务日志被清空</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1109.png"></p>
<h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>OS cache中积累了不少数据，这个时候如果机器宕机了，虽然os cache的数据丢失了，但是translog的数据是存在的，可以基于translog和commit point进行数据恢复。</p>
<p>fsync+清空translog，就是flush，默认每隔30分钟flush一次，或者当translog过大的时候，也会flush。</p>
<p>POST /my_index/_flush，一般来说别手动flush，让它自动执行就可以了。</p>
<p><strong>translog</strong></p>
<p>translog本身，每隔5秒被fsync一次到磁盘上。在一次增删改操作之后，当fsync在primary shard和replica shard都成功之后，那次增删改操作才会成功。</p>
<p>但是这种在一次增删改时强行fsync translog可能会导致部分操作比较耗时，也可以允许部分数据丢失，设置异步fsync translog。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;index.translog.durability&quot;</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index.translog.sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不确定这个行为的后果，最好是使用默认的参数（ “index.translog.durability”: “request” ）来避免数据丢失。</p>
<h1 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h1><p>前面说了，refresh操作默认是每秒一次，每秒生成一个新的segment file，这样文件太多了，而且每次search都要搜索所有的segment，很耗时。</p>
<p>ES默认会在后台执行segment merge操作，在merge的时候，被标记为deleted的document也会被彻底物理删除。</p>
<p>每次merge操作的执行流程：</p>
<ol>
<li>选择一些有相似大小的segment，merge成一个大的segment</li>
<li>将新的segment flush到磁盘上去</li>
<li>写一个新的commit point，包括了新的segment，并且排除旧的那些segment</li>
<li>将新的segment打开供搜索</li>
<li>将旧的segment删除</li>
</ol>
<p><strong>两个提交了的段和一个未提交的段正在被合并到一个更大的段</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1110.png"></p>
<p><strong>一旦合并结束，老的段被删除</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1111.png"></p>
<h2 id="optimize-API"><a href="#optimize-API" class="headerlink" title="optimize API"></a>optimize API</h2><p>optimize API大可看做是 强制合并 API 。它会将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
<p>POST /my_index/_optimize?max_num_segments=1，尽量不要手动执行，让它自动默认执行就可以了。</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-简介基本操作</title>
    <url>/2017/08/28/git/git1/</url>
    <content><![CDATA[<p>用git已经差不多3年了，回顾一下。</p>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>这个是Git的官网，Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git的读音为/gɪt/。</p>
<p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了 Git 上。</p>
<a id="more"></a>


<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>github是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名github。<br>github于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。</p>
<h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><p>GitLab是一个利用Ruby on Rails开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。<br>它拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序（Wall）进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。<br>GitLab要求服务器端采用Gitolite搭建（为了方便安装，现已经用gitlab-shell代替Gitolite）</p>
<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><ul>
<li><p>获得版本库</p>
<ul>
<li>git init</li>
<li>git clone</li>
</ul>
</li>
<li><p>版本管理    </p>
<ul>
<li>git add</li>
<li>git commit</li>
<li>git rm</li>
</ul>
</li>
<li><p>查看信息</p>
<ul>
<li>git help</li>
<li>git log</li>
<li>git diff</li>
</ul>
</li>
<li><p>远程协作</p>
<ul>
<li>git pull</li>
<li>git push</li>
</ul>
</li>
</ul>
<p>执行<code>git init</code>，初始化一个空的git仓库，目录下会生成一个**<em>.git**</em>目录，用<code>ls -al</code>可查看。</p>
<p>创建一个文件：<code>touch test.txt</code></p>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>执行<code>git status</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>表示当前处于master分支上，并且还没有提交过，test.txt没有被追踪（意思test.txt没有纳入到git的版本控制系统中），然后执行<code>git add test.txt</code>加入到暂存区中。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git add test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status </span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   test.txt</span><br></pre></td></tr></table></figure>

<h2 id="git-rm-–cached"><a href="#git-rm-–cached" class="headerlink" title="git rm –cached"></a>git rm –cached</h2><p>现在test.txt文件就已经被添加到git暂存区了，可以被提交。根据上面的输出提示，我们可以执行<code>git rm --cached &lt;file&gt;</code>将文件还原到被修改的状态，现在来试一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git rm --cached test.txt </span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line">➜  mygit git:(master) ✗ git status </span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>
<p>现在文件又从暂存区恢复到了被修改的状态，接下来我们添加后来测试一下git的提交,git的commit是要求提交必须填写注释的。</p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mygit git:(master) ✗ git commit</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line">#</span><br><span class="line"># Initial commit</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       new file:   test.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>这里出来一个vi的界面填写注释，如果直接保存退出会终止提交并提示以下内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git commit</span><br><span class="line">Aborting commit due to empty commit message.</span><br></pre></td></tr></table></figure>
<p>现在输入注释后进行提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git commit</span><br><span class="line">[master (root-commit) db19d2d] initial commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">➜  mygit git:(master) git status </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>还有一种更加简便的方式：将当前目录下有修改的文件进行<code>add</code>操作并提交：<br><code>git commit -am &#39;add another line&#39;</code></p>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>如果要查看之前的提交，可以用<code>git log</code>命令进行查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git <span class="built_in">log</span></span><br><span class="line">commit db19d2de7917bc55dc8a7d05545e12f7e00c8325 (HEAD -&gt; master)</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 15 10:58:10 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>Git的提交id（commit id）是一个摘要值，这个摘要值实际上是个sha1计算出来的。</p>
<p>对于user.name和user.email来说，有3个地方可以设置</p>
<ol>
<li>/etc/gitconfig (几乎不会使用) <code>git config --system</code></li>
<li>~/.gitconfig (很常用) <code>git config --global</code></li>
<li>针对于特定项目的，.git/config文件中 <code>git config --local</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git config</span><br><span class="line">usage: git config [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Config file location</span><br><span class="line">    --global              use global config file</span><br><span class="line">    --system              use system config file</span><br><span class="line">    --<span class="built_in">local</span>               use repository config file</span><br></pre></td></tr></table></figure>

<p>设置一下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  .git git:(master) git config --<span class="built_in">local</span> user.name <span class="string">&#x27;帆&#x27;</span></span><br><span class="line">➜  .git git:(master) git config --<span class="built_in">local</span> user.email <span class="string">&#x27;test@test.com&#x27;</span></span><br><span class="line">➜  .git git:(master) git config --list</span><br><span class="line">user.name=yangfan</span><br><span class="line">user.email=hyyangfan@gmail.com</span><br><span class="line">commit.template=/Users/xiaomai/.stCommitMsg</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br><span class="line">core.precomposeunicode=<span class="literal">true</span></span><br><span class="line">user.name=帆</span><br><span class="line">user.email=<span class="built_in">test</span>@test.com</span><br></pre></td></tr></table></figure>

<p><code>git config --list</code>展示了设置的属性，现在再来看**.git/config**文件，就发生了变化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  .git git:(master) cat config</span><br><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = <span class="literal">true</span></span><br><span class="line">	bare = <span class="literal">false</span></span><br><span class="line">	logallrefupdates = <span class="literal">true</span></span><br><span class="line">	ignorecase = <span class="literal">true</span></span><br><span class="line">	precomposeunicode = <span class="literal">true</span></span><br><span class="line">[user]</span><br><span class="line">	name = 帆</span><br><span class="line">	email = <span class="built_in">test</span>@test.com</span><br></pre></td></tr></table></figure>

<p>现在再改一下test.txt文件：</p>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) vi test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status </span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(master) ✗ git checkout -- test.txt </span><br><span class="line">➜  mygit git:(master) git status </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p><code>git checkout -- test.txt</code>可以恢复文件的修改，这个命令要慎用，没有提交的话用了这个命令修改的找不回来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) vi test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git add test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&quot;second commit&quot;</span></span><br><span class="line">[master 112c95f] second commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p><code>git commit -m</code> 后面的**-m**是填写注释的简便方式。</p>
<p>现在多提交了一次，查看一下提交日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git <span class="built_in">log</span></span><br><span class="line">commit 112c95fdbf9e8361e68b99d8bc9f658923461dc1 (HEAD -&gt; master)</span><br><span class="line">Author: 帆 &lt;<span class="built_in">test</span>@test.com&gt;</span><br><span class="line">Date:   Fri Sep 15 11:30:05 2017 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit db19d2de7917bc55dc8a7d05545e12f7e00c8325</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 15 10:58:10 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>现在新创建一个<strong>test2.txt</strong>并提交，那我们将这个文件从已经提交的库里删除应该怎么做呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git rm test2.txt </span><br><span class="line">rm <span class="string">&#x27;test2.txt&#x27;</span></span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    test2.txt</span><br><span class="line"></span><br><span class="line">➜  mygit git:(master) ✗ ls</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，我们可以看到，不光是<code>git status</code>显示文件已经被删除，<code>ls</code>命令也看不到了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git reset HEAD test2.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">D	test2.txt</span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test2.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(master) ✗ ls</span><br><span class="line">test.txt</span><br><span class="line">➜  mygit git:(master) ✗ git checkout -- test2.txt</span><br><span class="line">➜  mygit git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(master) ls</span><br><span class="line">test.txt  test2.txt</span><br></pre></td></tr></table></figure>

<p>上面又测试一系列命令，用reset和checkout命令恢复了删除的文件。</p>
<p>下面进行真正的删除，并提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git rm test2.txt </span><br><span class="line">rm <span class="string">&#x27;test2.txt&#x27;</span></span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	deleted:    test2.txt</span><br><span class="line"></span><br><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&quot;delete test2.txt&quot;</span></span><br><span class="line">[master 5f69c8b] delete test2.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test2.txt</span><br><span class="line">➜  mygit git:(master) ls        </span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>

<p>再演示系统使用系统命令rm删除文件的情况，不再需要调用reset就可以用checkout恢复。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) <span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span> &gt; test2.txt</span><br><span class="line">➜  mygit git:(master) ✗ ls</span><br><span class="line">test.txt  test2.txt</span><br><span class="line">➜  mygit git:(master) ✗ git add test2.txt </span><br><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&#x27;create a file&#x27;</span></span><br><span class="line">[master 1a7fc91] create a file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br><span class="line">➜  mygit git:(master) rm test2.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test2.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(master) ✗ git checkout -- test2.txt</span><br><span class="line">➜  mygit git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(master) ls</span><br><span class="line">test.txt  test2.txt</span><br></pre></td></tr></table></figure>

<p>不过也可以由此看出，使用<code>git rm</code>，可以直接提交删除文件。而使用系统命令<code>rm</code>，需要调用<code>git add</code>将删除文件的动作纳入到暂存区才能提交。</p>
<ul>
<li><p>git rm：</p>
<ol>
<li><p>删除了一个文件</p>
</li>
<li><p>将被删除的文件纳入到暂存区（stage，index）</p>
<p>若想恢复被删除的文件，需要进行两个动作：</p>
</li>
<li><p><code>git reset HEAD test2.txt</code>，将待删除的问价你从暂存区恢复到工作区</p>
</li>
<li><p><code>git checkout -- test2.txt</code>，将工作区中的修改丢弃掉</p>
</li>
</ol>
</li>
<li><p>rm：<br>  将test2.txt删除，这时被删除的文件并未纳入暂存区中。</p>
</li>
</ul>
<h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master)  git mv test.txt test2.txt</span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	renamed:    test.txt -&gt; test2.txt</span><br><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&#x27;rename a file&#x27;</span></span><br><span class="line">[master 7030bca] rename a file</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> rename test.txt =&gt; test2.txt (100%)</span><br></pre></td></tr></table></figure>

<h2 id="git-add-1"><a href="#git-add-1" class="headerlink" title="git add ."></a>git add .</h2><p>如果一次修改了多个文件，可以使用<code>git add .</code>命令将所有修改纳入到暂存区。</p>
<h2 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h2><p>如果不小心写错了提交消息怎么办？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&quot;不小心写错了这条消息&quot;</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">	modified:   test2.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit</span><br><span class="line">➜  mygit git:(master) ✗ git commit --amend -m <span class="string">&#x27;再次修正&#x27;</span></span><br><span class="line">[master 021a9de] 再次修正</span><br><span class="line"> Date: Wed Sep 20 16:48:51 2017 +0800</span><br><span class="line"> 2 files changed, 1 insertion(+), 2 deletions(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">➜  mygit git:(master) ✗ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-分支</title>
    <url>/2017/09/21/git/git2/</url>
    <content><![CDATA[<p>先介绍一下**.gitignore**</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>项目里面经常有一些文件是不需要纳入版本控制的，例如我编译后的class文件，或者idea产生的一些配置文件等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gradle</span><br><span class="line">&#x2F;build&#x2F;</span><br><span class="line">!gradle&#x2F;wrapper&#x2F;gradle-wrapper.jar</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">nbproject&#x2F;private&#x2F;</span><br><span class="line">build&#x2F;</span><br><span class="line">nbbuild&#x2F;</span><br><span class="line">dist&#x2F;</span><br><span class="line">nbdist&#x2F;</span><br><span class="line">.nb-gradle&#x2F;</span><br><span class="line"></span><br><span class="line">rebel.xml</span><br><span class="line"></span><br><span class="line">&#x2F;out</span><br></pre></td></tr></table></figure>

<p>上面是我的一个项目的配置，看得出来是有一些规则的，使用起来很简单，将这些规则保存到一个<code>.gitignore</code>中后，在项目里面这些文件或者文件夹里面的所有修改操作都不会被纳入到git版本控制中，也不会提交。</p>
<a id="more"></a>

<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>*<strong>.a</strong> 忽略所有.a结尾的文件</li>
<li><strong>!lib.a</strong> 但lib.a除外</li>
<li><strong>/TODO</strong> 仅仅忽略项目根目录下的TODO文件，但不包括subdir/TODO</li>
<li><strong>build/</strong> 忽略build/目录下的所有文件</li>
<li>*<em>doc/</em>.txt** 会忽略doc/notes.txt但不包括doc/server/arch.txt</li>
</ul>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支就是当你正在开发的时候，你可以基于当前的工作副本新开一条开发线，2边都可以进行单独的开发，当开发到某一个阶段的时候，可以合并到一起，这样2个分支的修改内容都能保留。</p>
<p>————— master<br>————— new_branch</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>这个命令可以显示当前所在分支，当使用<code>git init</code>创建仓库的时候，git默认会为我们创建一个master分支。</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建一个新的分支并切换到新的分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch new_branch</span><br><span class="line">➜  mygit git:(master) git branch</span><br><span class="line">* master</span><br><span class="line">  new_branch</span><br><span class="line">➜  mygit git:(master) git checkout new_branch</span><br><span class="line">Switched to branch <span class="string">&#x27;new_branch&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个时候2个分支上的文件还是一模一样的。</p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>在<strong>new_branch</strong>分支上创建一个文件并提交，切换到master上查看，是没有这个文件的，这也说明2个不同分支上的文件是独立的，修改是互不影响的。</p>
<p>切换分支的命令：<code>git checkout</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(new_branch) <span class="built_in">echo</span> <span class="string">&#x27;test new branch&#x27;</span> &gt; test4.txt</span><br><span class="line">➜  mygit git:(new_branch) ✗ git add test4.txt </span><br><span class="line">➜  mygit git:(new_branch) ✗ git commit -m <span class="string">&#x27;add a new file&#x27;</span></span><br><span class="line">[new_branch 8013cc2] add a new file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test4.txt</span><br><span class="line">➜  mygit git:(new_branch) git status</span><br><span class="line">On branch new_branch</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(new_branch) ls</span><br><span class="line">mydir               settings.properties test.txt            test4.txt</span><br><span class="line">➜  mygit git:(new_branch) git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) ls</span><br><span class="line">mydir               settings.properties test.txt</span><br></pre></td></tr></table></figure>

<p>如果想在2个分支之间来回切换，可以使用<code>git checkout -</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(new_branch) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;new_branch&#x27;</span></span><br><span class="line">➜  mygit git:(new_branch) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;new_branch&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>分支一样可以删除，命令：<code>git branch -d new_branch</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(new_branch) git branch -d new_branch</span><br><span class="line">error: Cannot delete branch <span class="string">&#x27;new_branch&#x27;</span> checked out at <span class="string">&#x27;/Users/xiaomai/code/zhanglong/git/mygit</span></span><br></pre></td></tr></table></figure>
<p>报错了，为什么呢？因为你当前本来就在<strong>new_branch</strong>上，就好比你坐到一个凳子上怎么能把凳子挪走呢。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(new_branch) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) git branch -d new_branch</span><br><span class="line">error: The branch <span class="string">&#x27;new_branch&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D new_branch&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>又出错了，说<strong>new_branch</strong>并没有合并过，不能删除，如果要删除要使用<code>git branch -D new_branch</code>。</p>
<p>因为我们之前创建了test4.txt这个文件，它是存在于new_branch分支上的，如果直接删除这个分支，那么在这个分支上所做的修改就会丢失了，也就是test4.txt这个文件就没了。</p>
<p>现在来测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch -D new_branch</span><br><span class="line">Deleted branch new_branch (was 8013cc2).</span><br></pre></td></tr></table></figure>

<p>下面的新创建了一个new_branch2分支，但是这次却可以直接删除，因为这2个分支是一样的，没有区别，不需要合并。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch new_branch2</span><br><span class="line">➜  mygit git:(master) git checkout new_branch2  </span><br><span class="line">Switched to branch &#39;new_branch2&#39;</span><br><span class="line">➜  mygit git:(new_branch2) git checkout -</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">➜  mygit git:(master) git branch -d new_branch2  </span><br><span class="line">Deleted branch new_branch2 (was c7a801e).</span><br></pre></td></tr></table></figure>

<h4 id="创建并切换"><a href="#创建并切换" class="headerlink" title="创建并切换"></a>创建并切换</h4><p>创建分支并切换，我们之前是用了2个命令，Git也提供了简便的方式，用一条命令来完成这个操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git checkout -b new_branch4</span><br><span class="line">Switched to a new branch <span class="string">&#x27;new_branch4&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>刚才创建分支后删除，有提示到说没有合并，我们再创建一个分支，并对文件做一些修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(new_branch4) vi test.txt </span><br><span class="line">➜  mygit git:(new_branch4) ✗ git status</span><br><span class="line">On branch new_branch4</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(new_branch4) ✗ git add .</span><br><span class="line">➜  mygit git:(new_branch4) ✗ git commit -m <span class="string">&#x27;add a new line in test&#x27;</span></span><br><span class="line">[new_branch4 41c3327] add a new line <span class="keyword">in</span> <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  mygit git:(new_branch4) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) git branch</span><br><span class="line">* master</span><br><span class="line">  new_branch4</span><br></pre></td></tr></table></figure>

<p>Git里合并的命令是<code>git merge</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git merge new_branch4  </span><br><span class="line">Updating c7a801e..41c3327</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>这个命令的意思是，将<strong>new_branch4</strong>分支上的修改合并到<strong>master</strong>上。</p>
<p>现在查看test.txt的文件内容，和我们在<strong>new_branch4</strong>上修改的内容一样了。</p>
<p>再验证一下合并之后能不能成功删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch -d new_branch4  </span><br><span class="line">Deleted branch new_branch4 (was 41c3327).</span><br></pre></td></tr></table></figure>

<p>因为<strong>new_branch4</strong>分支上的修改已经合并（merge）到master上了，所以可以正常删除。</p>
<h3 id="分支的原理"><a href="#分支的原理" class="headerlink" title="分支的原理"></a>分支的原理</h3><p><img src="/img/git/git2-1.png"></p>
<p>分支到底是什么呢，分支指的是一个commit对象链，它就像是一条**<em>工作记录线**</em>（或者时间线），这张图有4个commit，这4个commit共同组成了一个branch。</p>
<p>每一次提交都会记录上一次的commit id，我们看第一个提交的commit id是10dc7…，而第二次提交的parent属性正好是10dc7。而这也就把所有的commit连接起来了，在版本库只有一个分支的情况下，这些连接起来的线也就组成了分支的信息。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>之前我们在使用<code>git rest HEAD</code>的时候，这个HEAD到底是什么意思呢？</p>
<p>HEAD指向的是当前分支，master指向提交，什么意思呢，如下图所示，master是指向第3个提交，而HEAD是指向的master分支。</p>
<p><img src="/img/git/git2-2.png"></p>
<p>下图就相当于在master分支上执行<code>git checkout -b dev</code>，创建并切换到dev分支：创建了一个叫dev的指针，它和master一样也指向同一个提交，并且HEAD指向当前分支上，也就是dev。</p>
<p><img src="/img/git/git2-3.png"></p>
<p>这个我们可以通过命令来实战验证一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">➜  mygit git:(dev) cat .git/HEAD </span><br><span class="line">ref: refs/heads/dev</span><br></pre></td></tr></table></figure>

<p>这张图又什么意思呢，相信很容易猜到了，就是在dev分支上产生了一次提交。</p>
<p><img src="/img/git/git2-4.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(dev) vi test.txt </span><br><span class="line">➜  mygit git:(dev) ✗ git add .</span><br><span class="line">➜  mygit git:(dev) ✗ git commit -m &#39;add a new line in test.txt&#39;</span><br><span class="line">[dev bd1bf5d] add a new line in test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>下面的图意思是将dev合并到master分支上，因为master没有修改，所以这里不会产生冲突，直接将master的指针指向了第4个提交（这种没有冲突的提交也叫Fast-Forward）</p>
<p><img src="/img/git/git2-5.png"></p>
<p><code>git log -3</code></p>
<p>先看一下dev分支的提交日志：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit bd1bf5d33911594452c43f990904f393f6037607 (HEAD -&gt; dev)</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 15:14:45 2017 +0800</span><br><span class="line"></span><br><span class="line">    add a new line in test.txt</span><br><span class="line"></span><br><span class="line">commit 41c3327a9cf94bcb85799f0253fba0707036292c (master)</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 14:29:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    add a new line in test</span><br></pre></td></tr></table></figure>
<hr>
<p>再看一下master分支的提交日志：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit 41c3327a9cf94bcb85799f0253fba0707036292c (HEAD -&gt; master)</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 14:29:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    add a new line in test</span><br><span class="line"></span><br><span class="line">commit c7a801e2d02195a49d6741d61f1e6b471664b3f6</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 11:06:54 2017 +0800</span><br></pre></td></tr></table></figure>

<p>可以看到dev的第二个提交正好是master分支的第一个提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git merge dev</span><br><span class="line">Updating 41c3327..bd1bf5d</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在执行merge操作，可以看到update 41c3327，也就是dev的第一条提交，正好是master没有的，结合刚才的图来看，也就是把master指向了41c3327。</p>
<hr>
<p>看一下merge之后master分支上的<code>git log -3</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">commit bd1bf5d33911594452c43f990904f393f6037607 (HEAD -&gt; master, dev)</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 15:14:45 2017 +0800</span><br><span class="line"></span><br><span class="line">    add a new line in test.txt</span><br><span class="line"></span><br><span class="line">commit 41c3327a9cf94bcb85799f0253fba0707036292c</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 14:29:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    add a new line in test</span><br><span class="line"></span><br><span class="line">commit c7a801e2d02195a49d6741d61f1e6b471664b3f6</span><br><span class="line">Author: 帆 &lt;test@test.com&gt;</span><br><span class="line">Date:   Thu Sep 21 11:06:54 2017 +0800</span><br><span class="line"></span><br><span class="line">    gitignore</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<hr>
<p>下面再看看我们在master和dev分支上都作一些修改，然后合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) <span class="built_in">echo</span> <span class="string">&#x27;hello java&#x27;</span> &gt; test2.txt </span><br><span class="line">➜  mygit git:(master) ✗ git add .</span><br><span class="line">➜  mygit git:(master) ✗ git commit -m <span class="string">&#x27;create a file test2.txxt&#x27;</span></span><br><span class="line">[master bc84a7f] create a file test2.txxt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br><span class="line">➜  mygit git:(master) git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">➜  mygit git:(dev) ✗ <span class="built_in">echo</span> <span class="string">&#x27;hello kotlin&#x27;</span> &gt; test2.txt </span><br><span class="line">➜  mygit git:(dev) ✗ git add .</span><br><span class="line">➜  mygit git:(dev) ✗ git commit -m <span class="string">&#x27;create file test2.txt&#x27;</span></span><br><span class="line">[dev def3afc] create file test2.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br></pre></td></tr></table></figure>
<p>现在我们在master和dev上都创建了一个<code>test2.txt</code>，并且内容不一样。</p>
<p>现在master和dev指向的commit都不一样，现在合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git merge dev</span><br><span class="line">Auto-merging test2.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> test2.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>出现了冲突，git不知道如何处理这种冲突，需要我们自己解决，我们现在看一下<strong>test2.txt</strong>的内容是什么<br><code>vi test2.txt</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello java</span><br><span class="line">=======</span><br><span class="line">hello kotlin</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>

<p>上面是HEAD（当前分支master）的内容，下面的dev分支的内容，现在我们手动处理一下冲突，编辑保留我们需要留下的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ vi test2.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both added:      test2.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在执行<code>git add test2.txt</code>表示冲突已经解决，可以提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git add test2.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">&quot;git commit&quot;</span> to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">	modified:   test2.txt</span><br><span class="line"></span><br><span class="line">➜  mygit git:(master) ✗ git commit</span><br><span class="line">[master b4bd64b] Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">➜  mygit git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(master) cat test2.txt </span><br><span class="line">hello java</span><br><span class="line">hello kotlin</span><br></pre></td></tr></table></figure>

<p>现在再回过头来看看dev分支下test2.txt的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">➜  mygit git:(dev) cat test2.txt </span><br><span class="line">hello kotlin</span><br></pre></td></tr></table></figure>

<p>内容还是跟之前的一样，如果这个时候我们执行<code>git merge master</code>，还会产生冲突吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(dev) git merge master</span><br><span class="line">Updating def3afc..b4bd64b</span><br><span class="line">Fast-forward</span><br><span class="line"> test2.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  mygit git:(dev) cat test2.txt </span><br><span class="line">hello java</span><br><span class="line">hello kotlin</span><br></pre></td></tr></table></figure>

<p>没有冲突，fast-forward直接成功，为什么呢？</p>
<p>因为在master上合并后，指针移动了2次，一次是dev的提交，一次是合并的提交。</p>
<p>现在在dev上再将master合并过来的时候，master的提交里已经包含了dev这次的提交，git检测到没有冲突，直接将指针指向了master的提交就可以了。</p>
<h2 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h2><ul>
<li>如果可能，合并分支时Git会使用fast-forward模式</li>
<li>在这种模式下，删除分支时会丢掉分支信息</li>
<li>合并时加上–no-ff参数会禁用fast-forward，这样会多出一个commit id （Merge branch ‘dev’）<ul>
<li><code>git merge --no-ff dev</code></li>
</ul>
</li>
<li>查看log<ul>
<li><code>git log --graph</code></li>
</ul>
</li>
</ul>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>刚才已经讲解了分支的原理，那么现在再来理解一下版本回退，应该就很容易想到了，无非就是移动分支的指针某到一个提交上。</p>
<ul>
<li>回退到上一版本<ul>
<li><code>git reset --hard HEAD^</code>这个命令表示回退到<code>HEAD</code>的上一个版本，多一个<code>^</code>就多回退一个版本。</li>
<li><code>git reset --hard HEAD~2</code>表示回退到<code>HEAD</code>的某一个版本之前，后面的数字就是回退的数量。</li>
<li><code>git reset --hard commit id</code></li>
</ul>
</li>
<li>返回到某一个版本<ul>
<li><code>git reflog</code></li>
</ul>
</li>
</ul>
<p>如果现在已经在历史的某一个提交上，用<code>git log</code>是看不到之后的commit id的。那么就可以使用<code>git reflog</code>查看，<code>git reflog</code>显示的是操作日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ca07f7b (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to ca07f7b</span><br><span class="line">0d2246f HEAD@&#123;1&#125;: reset: moving to HEAD</span><br><span class="line">0d2246f HEAD@&#123;2&#125;: reset: moving to HEAD</span><br><span class="line">0d2246f HEAD@&#123;3&#125;: reset: moving to HEAD^^</span><br><span class="line">3240097 HEAD@&#123;4&#125;: reset: moving to HEAD^</span><br><span class="line">ca07f7b (HEAD -&gt; master) HEAD@&#123;5&#125;: commit: add another line</span><br><span class="line">3240097 HEAD@&#123;6&#125;: commit: add another line</span><br><span class="line">d8f57a9 HEAD@&#123;7&#125;: commit: add a new line</span><br><span class="line">0d2246f HEAD@&#123;8&#125;: commit (initial): initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-checkout、stash等命令</title>
    <url>/2017/09/28/git/git3/</url>
    <content><![CDATA[<p>前面的文章讲解了分支的操作和原理，接下来接着看一下git的<strong>checkout、stash、blame、diff</strong>等命令的一些使用方法。</p>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>修改一下文件，看看<code>git status</code>会提示什么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) vim test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Git提示到：修改没有暂存，请用<code>git add</code>或者<code>git checkout --</code>，我们试一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>文件就已经恢复了，之前我们一直用checkout来切换分支。那么这个命令到底是什么意思呢？</p>
<p><code>git checkout -- test.txt</code>：丢弃掉相对于<strong>暂存区</strong>中最后一次添加的文件内容所做的变更。</p>
<p>意思是第一次修改，然后用<code>git add test.txt</code>，将文件添加到暂存区，然后再修改，这个时候执行<code>git checkout -- test.txt</code>，文件就会恢复到暂存区的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) vim test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git add test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">➜  mygit git:(master) ✗ git reset HEAD test.txt </span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	test.txt</span><br></pre></td></tr></table></figure>

<p>这次编辑完后将文件添加到暂存区，<code>git status</code>其实我们可以执行<code>git reset HEAD &lt;file&gt;</code>将文件从暂存区移除。</p>
<p>那么<code>git reset HEAD test.txt</code>的作用是：</p>
<blockquote>
<p>将之前添加到暂存区（stage,index)的内容从暂存区移除到工作区。</p>
</blockquote>
<p>我们要注意这2个命令的区别，一个是从工作区恢复到暂存区，一个是从暂存区移除到工作区。</p>
<h3 id="切换到某一个提交"><a href="#切换到某一个提交" class="headerlink" title="切换到某一个提交"></a>切换到某一个提交</h3><p>我们都知道分支其实就是指向了某一个提交，那么实际上切换分支，也就是切换到某一个提交上，所以我们也可以直接<code>git checkout commit id</code>来切换提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git checkout ca07f7b</span><br><span class="line">Note: checking out <span class="string">&#x27;ca07f7b&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by using -b with the checkout <span class="built_in">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at ca07f7b... add another line</span><br></pre></td></tr></table></figure>

<p>切换成功了，但是给了一串提示：你当前在一个游离的状态，你可以随便看看，改一些东西并提交，也切换到其他分支丢弃刚才的修改。如果想保留刚才的提交，就必须基于当前提交新创建一个分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(ca07f7b) vi test.txt </span><br><span class="line">➜  mygit git:(ca07f7b) ✗ git status</span><br><span class="line">HEAD detached at ca07f7b</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(ca07f7b) ✗ git checkout master</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">	test.txt</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>切换到<strong>ca07f7b</strong>提交后，对文件进行修改，然后在切换到master分支，被拒绝了，说我们的修改没有提交或者暂存，如果这样做，那么修改就丢失了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(ca07f7b) ✗ git add .</span><br><span class="line">➜  mygit git:(ca07f7b) ✗ git commit -m <span class="string">&#x27;my commit&#x27;</span></span><br><span class="line">[detached HEAD 7d01a11] my commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  mygit git:(7d01a11) git checkout master</span><br><span class="line">Warning: you are leaving 1 commit behind, not connected to</span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line">  7d01a11 my commit</span><br><span class="line"></span><br><span class="line">If you want to keep it by creating a new branch, this may be a good time</span><br><span class="line">to <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line"> git branch &lt;new-branch-name&gt; 7d01a11</span><br><span class="line"></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们提交以后再切换到master，成功了，但是又给了提示，说我们有一个提交被落下了，这个提交没有在任何的分支上面。如果你想要创建一个分支来保存提交，那么现在就是一个好的时机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git branch mycommit 7d01a11</span><br><span class="line">➜  mygit git:(master) git branch</span><br><span class="line">* master</span><br><span class="line">  mycommit</span><br><span class="line">➜  mygit git:(master) git checkout mycommit  </span><br><span class="line">Switched to branch <span class="string">&#x27;mycommit&#x27;</span></span><br></pre></td></tr></table></figure>
<p>用<code>git log</code>也查看到了<strong>7d01a11</strong>是最新一次的提交。</p>
<p>顺道提一下分支改名的命令：<code>git branch -m master master2</code>，把master改名为master2。</p>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>现在模拟一种情况，新建了一个分支<strong>test</strong>，<strong>master</strong>分支上的提交比<strong>test</strong>要领先一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) vi test.txt </span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git status</span><br><span class="line">On branch <span class="built_in">test</span></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git checkout master</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">	test.txt</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>现在在两个分支上的文件不一样，然后在test分支上修改<strong>test.txt</strong>的内容，随后执行切换分支的操作，git报错了不允许提交：当前的修改会被丢弃，请提交或者暂存。</p>
<p>那这个时候我们工作只是进行了一点，又不想提交怎么办呢，git提供了一个<code>stash</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git stash</span><br><span class="line">Saved working directory and index state WIP on <span class="built_in">test</span>: c96bc8f commit</span><br></pre></td></tr></table></figure>

<p>将当前的工作区保存，现在再切换分支，就没有问题了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git stash</span><br><span class="line">Saved working directory and index state WIP on <span class="built_in">test</span>: c96bc8f commit</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git status</span><br><span class="line">On branch <span class="built_in">test</span></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">➜  mygit git:(master) git checkout -</span><br><span class="line">Switched to branch <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们要恢复之前的修改，可以用<code>git stash list</code>查看已经保存的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on <span class="built_in">test</span>: c96bc8f commit</span><br><span class="line">(END)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多保存一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) vi test.txt </span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git stash save <span class="string">&#x27;hello&#x27;</span>      </span><br><span class="line">Saved working directory and index state On <span class="built_in">test</span>: hello</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git stash list</span><br><span class="line">stash@&#123;0&#125;: On <span class="built_in">test</span>: hello</span><br><span class="line">stash@&#123;1&#125;: WIP on <span class="built_in">test</span>: c96bc8f commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git stash pop</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git stash apply</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> test.txt</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ vi test.txt  </span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git stash drop stash@&#123;1&#125;</span><br><span class="line">stash@&#123;1&#125; is not a valid reference</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) ✗ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (62dec20aca499f2e2660eb106fae481607d3662f)</span><br></pre></td></tr></table></figure>

<h3 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h3><ul>
<li>git stash</li>
<li>git stash list </li>
</ul>
<h3 id="恢复现场"><a href="#恢复现场" class="headerlink" title="恢复现场"></a>恢复现场</h3><ul>
<li>git statsh apply (stash内容并不删除，需要通过git statsh drop stash@{0}手动删除）</li>
<li>git stash pop（恢复的同时也将stashn内容删除）</li>
<li>git stash apply stash@{0}</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是版本库的一个快照，一般我们在发版的时候会用到。</p>
<h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>标签有两种：</p>
<ol>
<li>轻量级标签（lightweight）<code>git tag v1.0.1</code></li>
<li>带有附注标签（annotated）<code>git tag -a v1.0.2 0m &#39;release version&#39;</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git tag v1.0</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git tag -a v2.0 -m <span class="string">&#x27;2.0 released&#x27;</span></span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git tag</span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>git tag -l &#39;pattern&#39;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git tag -l <span class="string">&#x27;v1.0&#x27;</span></span><br><span class="line">v1.0</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git tag -l <span class="string">&#x27;v*&#x27;</span>  </span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p><code>git tag -d v1.0</code></p>
<h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p>这个命令可以查看某一个文件上一次是被谁以及什么时间修改的，非常有用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git blame test.txt </span><br><span class="line">^0d2246f (yangfan 2017-09-27 17:19:28 +0800 1) hello</span><br><span class="line">ca07f7b3 (sail    2017-09-27 17:21:57 +0800 2) world</span><br><span class="line">d8f57a90 (sail    2017-09-27 17:20:27 +0800 3) hello world</span><br><span class="line">3240097a (sail    2017-09-27 17:20:59 +0800 4) hello java</span><br><span class="line">c96bc8fc (sail    2017-09-28 17:31:51 +0800 5) hello perl</span><br><span class="line">e7fb783f (sail    2017-09-28 17:02:47 +0800 6) hello python</span><br><span class="line">a5a26e15 (sail    2017-09-28 17:34:41 +0800 7) hello c<span class="comment">#</span></span><br><span class="line">a5a26e15 (sail    2017-09-28 17:34:41 +0800 8) hello scala</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>


<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><h3 id="系统自带diff"><a href="#系统自带diff" class="headerlink" title="系统自带diff"></a>系统自带diff</h3><p>diff是Git提供比较文件不同的一个命令，实际上linux或者osx系统本身也提供了一个这样的命令。</p>
<p>先测试一下系统自带的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ vi test1.txt </span><br><span class="line">➜  mygit git:(master) ✗ diff -u test.txt test1.txt </span><br><span class="line">--- test.txt	2017-09-29 10:57:13.000000000 +0800</span><br><span class="line">+++ test1.txt	2017-09-29 11:02:54.000000000 +0800</span><br><span class="line">@@ -1,8 +1,3 @@</span><br><span class="line"> hello</span><br><span class="line"> world</span><br><span class="line"> hello world</span><br><span class="line">-hello java</span><br><span class="line">+hello perl</span><br><span class="line">+hello python</span><br><span class="line">-hello c<span class="comment">#</span></span><br><span class="line">-hello scala</span><br></pre></td></tr></table></figure>

<p><code>---</code>表示源文件，<code>+++</code>表示要比较的目标文件。</p>
<p><code>-1,3</code>源文件1到3行，<code>+1,8</code>目标文件1到8行。</p>
<p>再下面的表示源文件<code>-</code>去这一行，就等于目标文件。<br>目标文件<code>+</code>上这一行，就等于源文件。</p>
<h3 id="git-diff命令"><a href="#git-diff命令" class="headerlink" title="git diff命令"></a>git diff命令</h3><p><code>git diff</code>比较的是暂存区与工作区文件的差别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) <span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span> &gt;&gt; aa</span><br><span class="line">➜  mygit git:(master) ✗ git add aa</span><br><span class="line">➜  mygit git:(master) ✗ git diff aa</span><br></pre></td></tr></table></figure>
<p>因为<code>git add aa</code>添加到暂存区后，工作区和暂存区的文件是一样的，所以这个命令输出空白，表示没有区别。</p>
<p>接着修改一下工作区的<strong>aa</strong>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ vi aa</span><br><span class="line">➜  mygit git:(master) ✗ git diff aa</span><br><span class="line">diff --git a/aa b/aa</span><br><span class="line">index 3b18e51..585558d 100644</span><br><span class="line">--- a/aa</span><br><span class="line">+++ b/aa</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> hello world</span><br><span class="line">+hello java</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<p>这个输出跟系统自带的命令比较像，文件名都一样，表示原始文件是暂存区文件，目标文件是工作区文件，暂存区文件<code>+hello java</code>就等于工作区的<strong>aa</strong>文件。</p>
<h4 id="git-diff-commit-id"><a href="#git-diff-commit-id" class="headerlink" title="git diff commit id"></a>git diff commit id</h4><p>这个命令可以比较工作区和某一次提交的差别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git commit -am <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">[master f6ae6e2] aa</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 aa</span><br><span class="line">➜  mygit git:(master) vi aa </span><br><span class="line">➜  mygit git:(master) ✗ git diff HEAD </span><br><span class="line">diff --git a/aa b/aa</span><br><span class="line">index 585558d..1274e4d 100644</span><br><span class="line">--- a/aa</span><br><span class="line">+++ b/aa</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> hello world</span><br><span class="line"> hello java</span><br><span class="line">+hello spring</span><br></pre></td></tr></table></figure>
<p><code>git diff HEAD</code>比较的是最新的提交与工作区之间的差别。</p>
<p><code>git diff --cached</code>比较的是最新的提交与暂存区之间的差别。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-远程仓库</title>
    <url>/2017/09/29/git/git4/</url>
    <content><![CDATA[<h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><p>Git本身是一个分布式的版本控制系统，每个用户的机器上都会有一个完整的版本库。之前我们的操作都是在本地机器上操作的，最终别人需要获取我们的修改，需要我们将本地的修改<strong>推送(push)**到远程机器上，然后别人再</strong>拉取(pull)**合并我们的代码。</p>
<p>说到远程仓库呢，就不得不提一下<strong>Github</strong>，全球最大的同性交友社区（😄开个玩笑）。</p>
<p><a href="https://github.com/">https://github.com/</a></p>
<p><strong>Github</strong>是免费使用的条件就是你在上面创建的代码都是开源的，开源被查看的，如果要想创建私有的仓库，就是需要收费的。那么应运而生的产生了一个叫<strong>Gitlab</strong>的开源产品可以让我们在公司的服务器搭建私有的仓库，让我们可以享受到免费的，私有的，内网的服务。</p>
<a id="more"></a>

<p>先注册一个<strong>Github</strong>的帐号吧，欢迎大家关注我<a href="https://github.com/sail-y%E3%80%82">https://github.com/sail-y。</a></p>
<p>接下来就是要把本地的仓库要推送到远程，<strong>Github</strong>有一个叫<strong>README.md</strong>的文件用来描述项目，它是采用<strong>MarkDown</strong>语法编写的，跟我这篇文章的编写方式是一样的，可以去了解一下，很方便。</p>
<p>现在新建一个仓库，创建几个文件多进行几次提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ls</span><br><span class="line">README.md test.txt</span><br><span class="line">➜  mygit git:(master) cat test.txt </span><br><span class="line">hello world</span><br><span class="line">add second line</span><br><span class="line">add a thrid line</span><br><span class="line">➜  mygit git:(master) cat README.md </span><br><span class="line"><span class="comment">## Git示例项目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 开发者</span></span><br><span class="line"></span><br><span class="line">* 七七</span><br><span class="line">* 灰灰</span><br><span class="line">➜  mygit git:(master) git <span class="built_in">log</span></span><br><span class="line">commit ec41fdfefd806965a088cd160d1fe755c263c5a9 (HEAD -&gt; master)</span><br><span class="line">Author: 七七 &lt;qiqi@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 29 16:07:15 2017 +0800</span><br><span class="line"></span><br><span class="line">    add readme</span><br><span class="line"></span><br><span class="line">commit ef71fd488241a5276e89dce67681ae923072202e</span><br><span class="line">Author: 七七 &lt;qiqi@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 29 16:04:36 2017 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line">commit fee1876da354c9bb45d317ae3a9d00d8ffb50fa0</span><br><span class="line">Author: 七七 &lt;qiqi@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 29 16:04:08 2017 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit e54c3751489948d4c0e3d81d71c9e5c2f02cf11a</span><br><span class="line">Author: 七七 &lt;qiqi@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 29 16:02:04 2017 +0800</span><br></pre></td></tr></table></figure>

<p>接着我们在<strong>Github</strong>上创建一个远程仓库</p>
<p><img src="/img/git/git4-1.png"></p>
<p>创建完成后<strong>Github</strong>就提示我们可以推送一个现有的仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:sail-y/git_demo.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>执行完命令后，发现<strong>Github</strong>上已经出现了我们推送的仓库内容：<strong><a href="https://github.com/sail-y/git_demo">https://github.com/sail-y/git_demo</a></strong></p>
<p><img src="/img/git/git4-2.png"></p>
<p>第一次关联远程仓库并推送后，以后只需要执行<code>git push</code>就可以将当前分支推送到远程仓库了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) vi test.txt </span><br><span class="line">➜  mygit git:(master) ✗ git commit -am <span class="string">&#x27;forth commit&#x27;</span> </span><br><span class="line">[master c3b0d8b] forth commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  mygit git:(master) git push</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 316 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line">   ec41fdf..c3b0d8b  master -&gt; master</span><br></pre></td></tr></table></figure>






<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>前面我们在<strong>github</strong>上创建了一个远程仓库，并且跟本地仓库进行了关联，实际上git本地仓库是可以关联很多个远程仓库的。</p>
<p>可以用<code>git remote show</code>查看所有的远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git remote show</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>还可以查看详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:sail-y/git_demo.git</span><br><span class="line">  Push  URL: git@github.com:sail-y/git_demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>


<p>上面命令输出表示当前fetch（拉取）的地址是<strong><a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:sail-y/git_demo.git</strong>，推送的地址是<strong><a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:sail-y/git_demo.git</strong>，当前分支是master，远程关联的分支是master。<code>git pull</code>默认拉取的是master分支，<code>git push</code>默认推送的是master分支，并且已经是最新的了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git branch -av</span><br><span class="line">* master                460b082 add fifth line</span><br><span class="line">  remotes/origin/master 460b082 add fifth line</span><br></pre></td></tr></table></figure>

<p>加上<code>-a</code>参数可以看到远程分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) ✗ git commit -am <span class="string">&#x27;update test.txt&#x27;</span></span><br><span class="line">[master d04325a] update test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  mygit git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">➜  mygit git:(master) git branch -av</span><br><span class="line">* master                d04325a [ahead 1] update test.txt</span><br><span class="line">  remotes/origin/master 460b082 add fifth line</span><br></pre></td></tr></table></figure>

<p>接着进行一次提交，<code>git status</code>提示本地的分支是超前了远程master分支的1个提交。<code>git branch -av</code>显示的结果也是2个分支最后一次提交的id，现在也不一样了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git push</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 323 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line">   460b082..d04325a  master -&gt; master</span><br><span class="line">➜  mygit git:(master) git branch -av</span><br><span class="line">* master                d04325a update test.txt</span><br><span class="line">  remotes/origin/master d04325a update test.txt</span><br></pre></td></tr></table></figure>

<p>执行<code>git push</code>，将本地的推送到远程，再执行<code>git branch -av</code>,origin/master显示的最后一次提交发生了一次改变，我们可以理解为origin/master就是保存了一份远程分支的提交信息，是只读的。</p>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>当另外两个用户同时修改了一个文件，一个人先push，另一个也再push的时候，会被远程拒绝，此时需要处理冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(master) git push</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;git@github.com:sail-y/git_demo.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br><span class="line">➜  mygit2 git:(master) git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_demo</span><br><span class="line">   bb880c1..f162a21  master     -&gt; origin/master</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p><code>bb880c1..f162a21  master     -&gt; origin/master</code></p>
<p>这个输出的意思是远程的master的commit同步到本地的origin/master。<br>然后发现有冲突，需要自己编辑文件来解决冲突，调用<code>git add</code>来标记冲突已解决，最后提交并push。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(master) ✗ vi hello.txt</span><br><span class="line">➜  mygit2 git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch and <span class="string">&#x27;origin/master&#x27;</span> have diverged,</span><br><span class="line">and have 1 and 1 different commits each, respectively.</span><br><span class="line">  (use <span class="string">&quot;git pull&quot;</span> to merge the remote branch into yours)</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  mygit2 git:(master) ✗ git add hello.txt </span><br><span class="line">➜  mygit2 git:(master) git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch and <span class="string">&#x27;origin/master&#x27;</span> have diverged,</span><br><span class="line">and have 1 and 1 different commits each, respectively.</span><br><span class="line">  (use <span class="string">&quot;git pull&quot;</span> to merge the remote branch into yours)</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">&quot;git commit&quot;</span> to conclude merge)</span><br><span class="line"></span><br><span class="line">➜  mygit2 git:(master) git commit</span><br><span class="line">[master 02b63a9] Merge branch <span class="string">&#x27;master&#x27;</span> of github.com:sail-y/git_demo</span><br></pre></td></tr></table></figure>


<p>git pull == git fetch + git merge</p>
<p>git fetch表示把远程最新的修改拉回到本地，git merge表示将远程的修改合并到代码库里。</p>
<p>我们可以分别测试一下这2个命令，也就是刚才说的先同步远程master信息到本地的origin/master。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(master) git branch -av</span><br><span class="line">* master                7660696 [ahead 1] hello23</span><br><span class="line">  remotes/origin/HEAD   -&gt; origin/master</span><br><span class="line">  remotes/origin/master 02b63a9 Merge branch <span class="string">&#x27;master&#x27;</span> of github.com:sail-y/git_demo</span><br><span class="line">➜  mygit2 git:(master) git fetch</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_demo</span><br><span class="line">   02b63a9..4ba6b0d  master     -&gt; origin/master</span><br><span class="line">➜  mygit2 git:(master) git branch -av</span><br><span class="line">* master                7660696 [ahead 1, behind 1] hello23</span><br><span class="line">  remotes/origin/HEAD   -&gt; origin/master</span><br><span class="line">  remotes/origin/master 4ba6b0d change hello.txt   </span><br></pre></td></tr></table></figure>


<p>可以看到在执行<code>git fetch</code>之前，remotes/origin/master 的最新commit id是02b63a9，执行以后就变成了4ba6b0d。</p>
<p>接着我们来合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(master) git merge origin/master</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>就跟之前一样，解决冲突并提交。</p>
<h3 id="分支设计技巧"><a href="#分支设计技巧" class="headerlink" title="分支设计技巧"></a>分支设计技巧</h3><ol>
<li>Gitflow</li>
<li>基于Git分支的开发模型：<br> develop分支（频繁变化的一个分支）<br> test分支（供测试与产品等人员使用的一个分支，变化不是特别频繁）<br> master分支（生产发布分支，变化非常不频繁的一个分支）<br> bugfix（hotfix）分支（生产系统中出现了紧急Bug，用于紧急修复的分支）</li>
</ol>
<h3 id="Git命令别名"><a href="#Git命令别名" class="headerlink" title="Git命令别名"></a>Git命令别名</h3><p>git可以配置简短的字符串来替代长一些的命令，来方便用户。</p>
<p>这里我们配置几个别名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git config --global alias.br branch</span><br><span class="line">➜  mygit git:(master) git config --global alias.st status</span><br><span class="line">➜  mygit git:(master) git config --global alias.co checkout</span><br><span class="line">➜  mygit git:(master) git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个命令的结果是保存在了<code>~/.gitconfig</code>文件中，可以查看到。</p>
<p>执行外部命令需要，也就是非git命令，需要在前面加感叹号。</p>
<p><code>➜  mygit git:(master) git config --global alias.ui &#39;!gitk&#39;</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-远程仓库2</title>
    <url>/2017/11/12/git/git5/</url>
    <content><![CDATA[<h3 id="refspec"><a href="#refspec" class="headerlink" title="refspec"></a>refspec</h3><p>Reference Specification简称refspec。<br>在执行push或fetch操作时，refspec用以给出本地Ref和远程Ref之间的映射关系，通常是本地分支或本地tag与远程库中的分支或tag之间的映射关系。</p>
<p>refspec格式：<br>+<src_ref>:<dst_refs><br>其中的+是可选的，表示强制更新<br>典型的push refspec为HEAD:refs/heads/master<br>典型的fetch refspec为refs/heads/<em>:refs/remotes/origin/</em></p>
<a id="more"></a>

<ol>
<li><p>在缺省情况下，refspec会被git remote add命令所自动生成，Git会获取远端上refs/heads下的所有引用，并将它们写到本地的refs/remotes/origin目录下，这些信息我们都可以在**.git/config**文件里面可以看到。所以，如果远端上有一个master分支，你在本地就可以通过下面几种方式来访问它们的历史记录：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git <span class="built_in">log</span> origin/master</span><br><span class="line">➜  mygit2 git:(develop) git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">➜  mygit2 git:(develop) git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="推送新的分支"><a href="#推送新的分支" class="headerlink" title="推送新的分支"></a>推送新的分支</h4><p>表示本地分支和远程分支的关联，我们在创建好分支以后直接执行push是无法推送的，因为git并不知道你要推送到远程的哪一个分支上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(master) git co -b develop</span><br><span class="line">Switched to a new branch <span class="string">&#x27;develop&#x27;</span></span><br><span class="line">➜  mygit git:(develop) git br <span class="built_in">test</span></span><br><span class="line">➜  mygit git:(develop) git br -av</span><br><span class="line">* develop               93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  master                93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  <span class="built_in">test</span>                  93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/master 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">➜  mygit git:(develop) git push</span><br><span class="line">fatal: The current branch develop has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin develop</span><br></pre></td></tr></table></figure>

<p><code>git push --set-upstream origin develop</code> 就表示推送到远程，并在远程创建一个叫develop的分支，和本地develop分支关联。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git push --set-upstream origin develop</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> * [new branch]      develop -&gt; develop</span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop from origin.</span><br></pre></td></tr></table></figure>


<p>这个时候如果我们在另外一台机器想拉取这个远程分支怎么办呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(master) git checkout -b develop origin/develop </span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;develop&#x27;</span></span><br><span class="line">➜  mygit2 git:(develop) git br -av </span><br><span class="line">* develop                93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  master                 f7b8c54 [ahead 2] Merge branch <span class="string">&#x27;master&#x27;</span> of github.com:sail-y/git_demo</span><br><span class="line">  remotes/origin/HEAD    -&gt; origin/master</span><br><span class="line">  remotes/origin/develop 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/master  93cd003 git gui <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>只需在checkout的时候最后面跟上远程分支的名称<strong>origin/develop</strong>。</p>
<h4 id="另一种推送分支的方式"><a href="#另一种推送分支的方式" class="headerlink" title="另一种推送分支的方式"></a>另一种推送分支的方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git co <span class="built_in">test</span></span><br><span class="line">Switched to branch <span class="string">&#x27;test&#x27;</span></span><br><span class="line">➜  mygit2 git:(<span class="built_in">test</span>) git push -u origin <span class="built_in">test</span></span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> * [new branch]      <span class="built_in">test</span> -&gt; <span class="built_in">test</span></span><br><span class="line">Branch <span class="built_in">test</span> <span class="built_in">set</span> up to track remote branch <span class="built_in">test</span> from origin.</span><br></pre></td></tr></table></figure>

<p>注意<code>git push -u</code>和<code>git push --set-upstream</code>的作用，是一样的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git fetch</span><br><span class="line">From github.com:sail-y/git_demo</span><br><span class="line"> * [new branch]      <span class="built_in">test</span>       -&gt; origin/<span class="built_in">test</span></span><br><span class="line">➜  mygit git:(develop) git br -av                </span><br><span class="line">* develop                93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  master                 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/develop 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/master  93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/<span class="built_in">test</span>    93cd003 git gui <span class="built_in">test</span></span><br><span class="line">➜  mygit git:(develop) git checkout --track origin/<span class="built_in">test</span></span><br><span class="line">Branch <span class="built_in">test</span> <span class="built_in">set</span> up to track remote branch <span class="built_in">test</span> from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;test&#x27;</span></span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) git br -av</span><br><span class="line">  develop                93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  master                 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">* <span class="built_in">test</span>                   93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/develop 93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/master  93cd003 git gui <span class="built_in">test</span></span><br><span class="line">  remotes/origin/<span class="built_in">test</span>    93cd003 git gui <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>这里用另外一种方式拉取远程分支，<code>git checkout --track origin/test</code>实际上就是<code>git checkout -b test origin/test</code>的一种特殊简写，为什么说特殊呢，因为它并没有指定本地分支的名称，而是直接使用了远程分支的名称。</p>
<h4 id="如何删除远程分支"><a href="#如何删除远程分支" class="headerlink" title="如何删除远程分支"></a>如何删除远程分支</h4><h5 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h5><p>git push的完整写法：git push origin src:dest</p>
<p>将本地的分支推送到远程分支，名称可以不一样，那么删除远程分支，就是传递一个空分支到远程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git push origin :develop</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> - [deleted]         develop</span><br></pre></td></tr></table></figure>

<h5 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git push --delete origin develop</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> - [deleted]         develop</span><br></pre></td></tr></table></figure>


<p>推送的时候可以设置远程分支不同的名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git push --set-upstream origin develop:develop2</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> * [new branch]      develop -&gt; develop2</span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop2 from origin.</span><br></pre></td></tr></table></figure>

<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ol>
<li><p>push操作的完整命令是：git push origin srcBrnach:destBranch</p>
</li>
<li><p>pull操作的完整命令是：git poll origin srcBranch:destBranch</p>
</li>
<li><p>HEAD标记：HEAD文件是一个指向你当前所在分支的引用标识符，该文件内部并不包含SHA-1值，而是一个指向另外一个引用的指针。(可以在**.git/HEAD**中查看)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git co <span class="built_in">test</span></span><br><span class="line">Switched to branch <span class="string">&#x27;test&#x27;</span></span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/test&#x27;</span>.</span><br><span class="line">➜  mygit git:(<span class="built_in">test</span>) cat .git/HEAD</span><br><span class="line">ref: refs/heads/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当执行<code>git commit</code>命令时，git会创建一个commit对象，并且将这个commit对象的parent指针设置为HEAD所指向的引用的SHA-1值。</p>
</li>
<li><p>我们对于HEAD修改的任何操作，都会被<code>git reflog</code>完整记录下来。</p>
</li>
<li><p>实际上我们可以通过git底层命令symbolic-ref来实现对HEAD文件内容的修改。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git symbolic-ref HEAD                   </span><br><span class="line">refs/heads/develop</span><br><span class="line">➜  mygit2 git:(develop) git symbolic-ref HEAD refs/heads/<span class="built_in">test</span>   </span><br><span class="line">➜  mygit2 git:(<span class="built_in">test</span>) </span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p>先回顾一下创建标签的知识。</p>
<p><code>git tag v1.0</code>创建了一个轻量级标签，只包含了对commit的引用。</p>
<p><code>git tag -a v2.0 -m &#39;v2.0 released&#39;</code>创建了一个重量级标签，他不光包含了引用，还包含了自身的注释信息。可以用<code>git show v2.0</code>查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tag v2.0</span><br><span class="line">Tagger: 七七 &lt;qiqi@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 20:47:55 2017 +0800</span><br><span class="line"></span><br><span class="line">v2.0 released</span><br></pre></td></tr></table></figure>


<p>推送标签也是用push命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git push origin v2.0</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> * [new tag]         v2.0 -&gt; v2.0</span><br></pre></td></tr></table></figure>


<p>如果标签比较多的话，可以一次性推送所有标签。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git push origin --tags</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 159 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class="line"> * [new tag]         v3.0 -&gt; v3.0</span><br></pre></td></tr></table></figure>

<h4 id="完整命令"><a href="#完整命令" class="headerlink" title="完整命令"></a>完整命令</h4><p><code>git push origin refs/tags/v4.0:refs/tags/v4.0</code></p>
<h4 id="拉取标签"><a href="#拉取标签" class="headerlink" title="拉取标签"></a>拉取标签</h4><p><code>git fetch origin tag v4.0</code></p>
<h3 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h3><p>跟删除分支是类似的，是将一个空的标签推送到远程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(develop) git push origin :refs/tags/v3.0</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> - [deleted]         v3.0</span><br></pre></td></tr></table></figure>

<p>另一种方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git push origin --delete tag v2.0</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> - [deleted]         v2.0</span><br></pre></td></tr></table></figure>


<h3 id="git-prune"><a href="#git-prune" class="headerlink" title="git prune"></a>git prune</h3><p>当我们有一边删除了远程分支后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit git:(<span class="built_in">test</span>) git push --delete origin develop</span><br><span class="line">To github.com:sail-y/git_demo.git</span><br><span class="line"> - [deleted]         develop</span><br></pre></td></tr></table></figure>

<p>如何在另外一个仓库同步这个信息呢，先查看远程分支的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:sail-y/git_demo.git</span><br><span class="line">  Push  URL: git@github.com:sail-y/git_demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                      tracked</span><br><span class="line">    refs/remotes/origin/develop stale (use <span class="string">&#x27;git remote prune&#x27;</span> to remove)</span><br><span class="line">    <span class="built_in">test</span>                        tracked</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    develop merges with remote develop</span><br><span class="line">    master  merges with remote master</span><br><span class="line">    <span class="built_in">test</span>    merges with remote <span class="built_in">test</span></span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (fast-forwardable)</span><br><span class="line">    <span class="built_in">test</span>   pushes to <span class="built_in">test</span>   (up to date)</span><br></pre></td></tr></table></figure>

<p>注意这里是另外一个用户，这里git给了提示：<strong>refs/remotes/origin/develop stale (use ‘git remote prune’ to remove)</strong></p>
<p>如果我们pull，会得到一个错误，因为远程的develop已经被删除了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git pull origin develop:develop</span><br><span class="line">fatal: Couldn<span class="string">&#x27;t find remote ref develop</span></span><br></pre></td></tr></table></figure>

<p>我们试试<code>git remote prune</code>的命令，本地和远程分支develop之间的关联，就已经没有了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mygit2 git:(develop) git remote prune origin</span><br><span class="line">Pruning origin</span><br><span class="line">URL: git@github.com:sail-y/git_demo.git</span><br><span class="line"> * [pruned] origin/develop</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-裸库和submodule、substree</title>
    <url>/2017/11/21/git/git6/</url>
    <content><![CDATA[<h2 id="裸库"><a href="#裸库" class="headerlink" title="裸库"></a>裸库</h2><p>通常我们在本地初始化仓库的时候，都是用<code>git init</code>。如果我们不借助github，如何自己建立一个中心仓库呢，这个就是裸库的概念。</p>
<p><code>git init --bare &lt;repo&gt;</code></p>
<p>这个命令执行后，将在本地创建一个名为 repo 的文件夹， 里面包含着 Git 的基本目录， 我们一般会将这个文件夹命名为后面加 .git 的形式，如 repo.git （这也是为什么我们从 GitHub clone 仓库的时候，地址都是 xxx.git 这样的形式的原因）.使用 –bare 参数初始化的仓库，我们一般称之为裸仓库， 因为这样创建的仓库并不包含 工作区 ， 也就是说，我们并不能在这个目录下执行我们一般使用的 Git 命令。</p>
<a id="more"></a>

<h2 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h2><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p>
<p>一般在Java中，我们会打包成jar包放入nexus中，可是如果是频繁更新的库，这样做会比较麻烦。那么如果我们将代码直接包含在项目中呢，这里就可以使用submodule。Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<p>先在github上创建2个仓库：</p>
<p><a href="https://github.com/sail-y/git_parent.git">https://github.com/sail-y/git_parent.git</a><br><a href="https://github.com/sail-y/git/_child.git">https://github.com/sail-y/git\_child.git</a>        </p>
<p>在本地也分别创建2个仓库并与之关联。</p>
<p>那么我们如何在一个仓库中包含另外一个仓库呢？</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) git submodule add git@github.com:sail-y/git_child.git mymodule</span><br><span class="line">Cloning into <span class="string">&#x27;/Users/xiaomai/code/zhanglong/git/git_parent/mymodule&#x27;</span>...</span><br><span class="line">remote: Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (6/6), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>我们在git_parent仓库中执行这个命令，表示将git_child作为submodule拉取到mymodule目录中，注意这里mymodule是不能事先存在的，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) ✗ git st</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   mymodule</span><br></pre></td></tr></table></figure>

<p>多出来一个文件和一个目录，目录里面就包含了另一个仓库里的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) ✗ <span class="built_in">cd</span> mymodule </span><br><span class="line">➜  mymodule git:(master) ls</span><br><span class="line">hello.txt     submodule.txt</span><br></pre></td></tr></table></figure>

<p>如果子仓库更新了，只需要在mymodule中执行<code>git pull</code>就可以拉取变更。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) <span class="built_in">cd</span> mymodule </span><br><span class="line">➜  mymodule git:(master) git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_child</span><br><span class="line">   5fc54e6..5adf3e0  master     -&gt; origin/master</span><br><span class="line">Updating 5fc54e6..5adf3e0</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>如果包含的submodule比较多的话，也可以使用命令将仓库包含的所有submodule都进行更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) ✗ git submodule foreach git pull</span><br><span class="line">Entering <span class="string">&#x27;mymodule&#x27;</span></span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_child</span><br><span class="line">   5adf3e0..19a2793  master     -&gt; origin/master</span><br><span class="line">Updating 5adf3e0..19a2793</span><br><span class="line">Fast-forward</span><br><span class="line"> welcome.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 welcome.txt</span><br></pre></td></tr></table></figure>

<p>当子模块发生变更的时候，父模块也会检测到，需要重新提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_parent git:(master) ✗ git st</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   mymodule (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">➜  git_parent git:(master) ✗ git add .</span><br><span class="line">➜  git_parent git:(master) ✗ git cm <span class="string">&#x27;update submodule&#x27;</span> </span><br><span class="line">[master a5cec07] update submodule</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">➜  git_parent git:(master) git push</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 311 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_parent.git</span><br><span class="line">   d0bc606..a5cec07  master -&gt; master</span><br></pre></td></tr></table></figure>

<h3 id="拉取submodule"><a href="#拉取submodule" class="headerlink" title="拉取submodule"></a>拉取submodule</h3><p>如果我们拉取了一个新的项目，它包含了submodule，直接clone仓库的时候，submodule里面是没有内容的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git git <span class="built_in">clone</span> git@github.com:sail-y/git_parent.git git_parent2</span><br><span class="line">Cloning into <span class="string">&#x27;git_parent2&#x27;</span>...</span><br><span class="line">remote: Counting objects: 8, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 8 (delta 0), reused 8 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">➜  git <span class="built_in">cd</span> git_parent2/mymodule </span><br><span class="line">➜  mymodule git:(master) ls</span><br><span class="line">➜  mymodule git:(master) </span><br></pre></td></tr></table></figure>

<p>我们需要执行2个命令来更新submodule的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mymodule git:(master) git submodule init</span><br><span class="line">Submodule <span class="string">&#x27;mymodule&#x27;</span> (git@github.com:sail-y/git_child.git) registered <span class="keyword">for</span> path <span class="string">&#x27;./&#x27;</span></span><br><span class="line">➜  mymodule git:(master) git submodule update --recursive </span><br><span class="line">Cloning into <span class="string">&#x27;/Users/xiaomai/code/zhanglong/git/git_parent2/mymodule&#x27;</span>...</span><br><span class="line">Submodule path <span class="string">&#x27;./&#x27;</span>: checked out <span class="string">&#x27;19a2793acc723c501f7422a9fdd810e46a528381&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样做有3步操作，稍微麻烦了一点，实际上clone有一个参数可以一键完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git git <span class="built_in">clone</span> git@github.com:sail-y/git_parent.git git_parent3 --recursive          </span><br><span class="line">Cloning into <span class="string">&#x27;git_parent3&#x27;</span>...</span><br><span class="line">remote: Counting objects: 8, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Receiving objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 8 (delta 0), reused 8 (delta 0), pack-reused 0</span><br><span class="line">Submodule <span class="string">&#x27;mymodule&#x27;</span> (git@github.com:sail-y/git_child.git) registered <span class="keyword">for</span> path <span class="string">&#x27;mymodule&#x27;</span></span><br><span class="line">Cloning into <span class="string">&#x27;/Users/xiaomai/code/zhanglong/git/git_parent3/mymodule&#x27;</span>...</span><br><span class="line">remote: Counting objects: 12, <span class="keyword">done</span>.        </span><br><span class="line">remote: Compressing objects: 100% (7/7), <span class="keyword">done</span>.        </span><br><span class="line">remote: Total 12 (delta 1), reused 11 (delta 0), pack-reused 0        </span><br><span class="line">Receiving objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">&#x27;mymodule&#x27;</span>: checked out <span class="string">&#x27;19a2793acc723c501f7422a9fdd810e46a528381&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="subtree"><a href="#subtree" class="headerlink" title="subtree"></a>subtree</h2><p>因为submodule在使用过程存在一些弊端，比如在父工程中修改了被依赖的项目的代码（因为代码就在项目中），然后推送后，在子模块本身的项目再拉取，实际上这样是有很多问题的。所以就出现了subtree这么一个开源功能，被git团队纳入了git中，它更加优秀，使用起来也很简单。</p>
<p>官方也是建议用substree来替代submodule。</p>
<p>下面开始演示，在github新建两个仓库。</p>
<p><a href="https://github.com/sail-y/git/_substree/_parent.git">https://github.com/sail-y/git\_substree\_parent.git</a>    </p>
<p><a href="https://github.com/sail-y/git/_substree/_child.git">https://github.com/sail-y/git\_substree\_child.git</a></p>
<p>准备工作需要在父项目里先添加一个远程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git remote add subtree-origin git@github.com:sail-y/git_substree_child.git</span><br><span class="line">➜  git_substree_parent git:(master) git remote show </span><br><span class="line">origin</span><br><span class="line">subtree-origin</span><br></pre></td></tr></table></figure>

<p>然后再添加subtree</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git subtree add --prefix=substree subtree-origin master --squash</span><br><span class="line">git fetch subtree-origin master</span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_substree_child</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; subtree-origin/master</span><br><span class="line">Added dir <span class="string">&#x27;substree&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git subtree add</code>这个命令将subtree-origin的master分支拉取到了substree这个目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) ls</span><br><span class="line">parent.txt substree</span><br></pre></td></tr></table></figure>

<p>实际上这个命令会将child的commit合并过来，并将作者改了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 8f08b4edbb537806f4a34feb8f773b97aa898d10 (HEAD -&gt; master, origin/master)</span><br><span class="line">Merge: 3c75631 5090ac2</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:16:59 2017 +0800</span><br><span class="line"></span><br><span class="line">    Merge commit <span class="string">&#x27;5090ac20e7c71524697e762276f924343c0bed54&#x27;</span> as <span class="string">&#x27;substree&#x27;</span></span><br><span class="line"></span><br><span class="line">commit 5090ac20e7c71524697e762276f924343c0bed54</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:16:59 2017 +0800</span><br><span class="line"></span><br><span class="line">    Squashed <span class="string">&#x27;substree/&#x27;</span> content from commit 1112351</span><br><span class="line">    </span><br><span class="line">    git-subtree-dir: substree</span><br><span class="line">    git-subtree-split: 1112351e504917e6fed1c6decee6bb81e931d647</span><br><span class="line"></span><br><span class="line">commit 3c75631cda4535d854e9ff7629aab2c9afcdebe6</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:01:28 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>它与submodule最显著的区别就是，submodule是保存的对子模块的一个引用，一个指针，而subtree是直接保存的文件。</p>
<p>在子模块新增一次提交，添加一个<strong>world.txt</strong>文件。</p>
<p>在父模块更新的命令是：<br><code>git subtree pull --prefix=substree subtree-origin master --squash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git subtree pull --prefix=substree subtree-origin master --squash</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_substree_child</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   1112351..844d9fd  master     -&gt; subtree-origin/master</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> substree/world.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 substree/world.txt</span><br></pre></td></tr></table></figure>

<p>看一下<code>git log</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit d7fbb7665c6d1af3cbdd4f5cf1977d682d6aa054 (HEAD -&gt; master)</span><br><span class="line">Merge: 8f08b4e 64dcef5</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:29:03 2017 +0800</span><br><span class="line"></span><br><span class="line">    Merge commit <span class="string">&#x27;64dcef57bc7eea0fda072d53628b9464040a6072&#x27;</span></span><br><span class="line"></span><br><span class="line">commit 64dcef57bc7eea0fda072d53628b9464040a6072</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:29:03 2017 +0800</span><br><span class="line"></span><br><span class="line">    Squashed <span class="string">&#x27;substree/&#x27;</span> changes from 1112351..844d9fd</span><br><span class="line">    </span><br><span class="line">    844d9fd add world</span><br><span class="line">    </span><br><span class="line">    git-subtree-dir: substree</span><br><span class="line">    git-subtree-split: 844d9fdb772f8e2c57218176b40b064f618523a4</span><br></pre></td></tr></table></figure>

<p>并没有出现李四的提交，844d9fd add world，被修改成了张三。</p>
<p>再child里再提交一个<strong>hellworld.txt</strong>文件，然后更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git subtree pull --prefix=substree subtree-origin master         </span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:sail-y/git_substree_child</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   844d9fd..a940bda  master     -&gt; subtree-origin/master</span><br><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>

<p>注意这次没有**–squash**参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit a940bdaf1c8dd5048782c7179c62d93b1bc03d80 (subtree-origin/master)</span><br><span class="line">Author: 李四 &lt;lisi@git.com&gt;</span><br><span class="line">Date:   Thu Nov 23 09:31:47 2017 +0800</span><br><span class="line"></span><br><span class="line">    add helloworld</span><br></pre></td></tr></table></figure>

<p>这次就出现了李四的提交信息，**–squash**会将要合并的分支所有的提交全部合并成一个提交信息。</p>
<p>接下来我们在parent的项目里修改child.txt，并push。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) <span class="built_in">cd</span> subtree </span><br><span class="line">➜  subtree git:(master) vi child.txt </span><br></pre></td></tr></table></figure>

<p>可以看到github上parent项目中的child.txt是有新增的内容的，但是child项目里面却没有。</p>
<p><img src="/img/git/git6-1.png"></p>
<p><img src="/img/git/git6-2.png"></p>
<p>实际上在父项目中，还需要单独执行一次push。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_substree_parent git:(master) git subtree push --prefix=subtree subtree-origin master</span><br><span class="line">git push using:  subtree-origin master</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 347 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:sail-y/git_substree_child.git</span><br><span class="line">   a940bda..0c887fa  0c887fa4eb23fe282551d1368e72d31a177182e6 -&gt; master</span><br></pre></td></tr></table></figure>

<p><img src="/img/git/git6-3.png"></p>
<h3 id="–squash"><a href="#–squash" class="headerlink" title="–squash"></a>–squash</h3><p><code>--squash</code>会将subtree的所有提交信息合并成parent的一个提交，然后会将这一次合并的提交和parent再次合并，那么就产生了2次合并。<code>--squash</code>是为了防止主仓库的提交历史被污染，但是它的使用也有一些问题。</p>
<p>所以在使用<code>--squash</code>的时候，我们需要保证要么一直使用，要么一直不使用。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-cherry-pick、rebase</title>
    <url>/2017/11/30/git/git7/</url>
    <content><![CDATA[<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>cherry-pick可以将你对某个分支的修改信息应用到另外一个分支上。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在现有一个文件在master分支上，但是却不小心在develop分支上做了修改并新增了两次提交，也就是提交错了分支。</p>
<p>传统方式是我们备份好已经修改的文件然后切换分支再复制过去，这样做太低效了，而且容易出错。</p>
<p>我们可以用cherry-pick来解决这个问题。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_cherry_pick git:(develop) git <span class="built_in">log</span></span><br><span class="line">commit 9b7651337815b3697283c38a2cde43a17edf622b (HEAD -&gt; develop)</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:19:01 2017 +0800</span><br><span class="line"></span><br><span class="line">    hello2</span><br><span class="line"></span><br><span class="line">commit 0947abad01c529e1b14d0a364df55c295ae21896</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:18:50 2017 +0800</span><br><span class="line"></span><br><span class="line">    hello1</span><br><span class="line"></span><br><span class="line">commit aa53a19826d28c9f795efd901c386e4c6267594d</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:18:23 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br><span class="line">(END)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_cherry_pick git:(master) git cherry-pick 0947ab</span><br><span class="line">[master 264078d] hello1</span><br><span class="line"> Date: Thu Nov 30 09:18:50 2017 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">➜  git_cherry_pick git:(master) </span><br></pre></td></tr></table></figure>

<p>git自动的将commit应用到了另外一个分支上。现在在develop上再新增一次提交，如果我们直接在master上应用跨越2次的提交会怎么样呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 0318ff6fd8b6f7696701227ba6f260cbf4633524 (HEAD -&gt; develop)</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:24:12 2017 +0800</span><br><span class="line"></span><br><span class="line">    hello4</span><br><span class="line"></span><br><span class="line">commit d071b32aaabcd1ea0f5551b66605c5ac5ee6d464</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:22:32 2017 +0800</span><br><span class="line"></span><br><span class="line">    hello3</span><br><span class="line"></span><br><span class="line">commit 9b7651337815b3697283c38a2cde43a17edf622b</span><br><span class="line">Author: yangfan &lt;hyyangfan@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 30 09:19:01 2017 +0800</span><br><span class="line"></span><br><span class="line">    hello2</span><br></pre></td></tr></table></figure>

<p>执行命令后，出现了冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_cherry_pick git:(master) git cherry-pick 0318ff6fd8b6f76</span><br><span class="line">error: could not apply 0318ff6... hello4</span><br><span class="line">hint: after resolving the conflicts, mark the corrected paths</span><br><span class="line">hint: with <span class="string">&#x27;git add &lt;paths&gt;&#x27;</span> or <span class="string">&#x27;git rm &lt;paths&gt;&#x27;</span></span><br><span class="line">hint: and commit the result with <span class="string">&#x27;git commit&#x27;</span></span><br><span class="line">➜  git_cherry_pick git:(master) ✗ cat test.txt </span><br><span class="line">hello</span><br><span class="line">hello1</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">=======</span><br><span class="line">hello2</span><br><span class="line">hello3</span><br><span class="line">hello4</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0318ff6... hello4</span><br></pre></td></tr></table></figure>

<p>我们把冲突处理掉就可以了。</p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>rebase我们可以翻译成变基或者是衍合，它的功能是类似于merge的。不同的是merge在合并后是两条线合并，rebase是把另外一个分支的新的提交直接嫁接过来，我觉得有点像cherry-pick。</p>
<ul>
<li>rebase过程中也会出现冲突，解决冲突后，使用git add添加，然后执行<code>git rebase --continue</code></li>
<li>接下来Git会继续应用余下的补丁</li>
<li>任何时候都可以通过如下命令终止rebase，分支会恢复到rebase开始前的状态。<code>git rebase --abort</code></li>
<li>不要对master分支执行reabase，否则会引起很多问题</li>
<li>一般来说，执行reabse的分支都是自己的本地分支，没有推送到远程版本库。</li>
</ul>
<p>因为rebase会修改分支的提交历史，所以不要在与其他人共享的分支上执行这个命令，否则会造成非常麻烦的结果。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>要演示rebase的命令，首先遵从最佳实践，不要在master上做操作，所以创建两个分支，分别进行两次提交。</p>
<p>develop分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit f1e1d6ab0397578a06100772e6e89fffa6f274dc (HEAD -&gt; develop)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:21:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    add develop1</span><br><span class="line"></span><br><span class="line">commit 88e11d005f5fd66157d165e99be8aca2d6078fff</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:21:39 2017 +0800</span><br><span class="line"></span><br><span class="line">    add world</span><br><span class="line"></span><br><span class="line">commit 31dec318f7cf42e0289228535a89efe0b6c5bb8e (<span class="built_in">test</span>, master)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:20:26 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>test分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit ca7495957b750285fb6ad32bf0aaff2d3d89b44f (HEAD -&gt; <span class="built_in">test</span>)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:23:43 2017 +0800</span><br><span class="line"></span><br><span class="line">    add test2</span><br><span class="line"></span><br><span class="line">commit 6ca36bae9ff45bfd0df6a5f05b26c08d4ac94a52</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:23:32 2017 +0800</span><br><span class="line"></span><br><span class="line">    add test1</span><br><span class="line"></span><br><span class="line">commit 31dec318f7cf42e0289228535a89efe0b6c5bb8e (master)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:20:26 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br></pre></td></tr></table></figure>

<p>这两个分支都有共同的祖先，也就是31dec318f7cf42e028922这次提交。</p>
<p>下图显示了merge和rebase操作对分支历史的不同区别。</p>
<p><img src="/img/git/git7-1.png"></p>
<p>因为我们对文件修改的不一样，那么一定会产生冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_rebase git:(<span class="built_in">test</span>) git rebase develop  </span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add test1</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> test.txt</span><br><span class="line">error: Failed to merge <span class="keyword">in</span> the changes.</span><br><span class="line">Patch failed at 0001 add test1</span><br><span class="line">The copy of the patch that failed is found <span class="keyword">in</span>: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run <span class="string">&quot;git rebase --continue&quot;</span>.</span><br><span class="line">If you prefer to skip this patch, run <span class="string">&quot;git rebase --skip&quot;</span> instead.</span><br><span class="line">To check out the original branch and stop rebasing, run <span class="string">&quot;git rebase --abort&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>如果执行<code>git rebase --skip</code>，就会丢弃掉test分支上提交的修改，直接使用develop上的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_rebase git:(f1e1d6a) ✗ git rebase --skip</span><br><span class="line">Applying: add test2</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> test.txt</span><br><span class="line">error: Failed to merge <span class="keyword">in</span> the changes.</span><br><span class="line">Patch failed at 0002 add test2</span><br><span class="line">The copy of the patch that failed is found <span class="keyword">in</span>: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run <span class="string">&quot;git rebase --continue&quot;</span>.</span><br><span class="line">If you prefer to skip this patch, run <span class="string">&quot;git rebase --skip&quot;</span> instead.</span><br><span class="line">To check out the original branch and stop rebasing, run <span class="string">&quot;git rebase --abort&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>因为有2次提交，所以忽略第一次后，还有第二次的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">➜  git_rebase git:(f1e1d6a) ✗ cat test.txt </span><br><span class="line">hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">world</span><br><span class="line">develop1</span><br><span class="line">=======</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; add test2</span><br></pre></td></tr></table></figure>

<p>现在把冲突解决一下，手工编辑一下文件，保留下自己想保留的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_rebase git:(f1e1d6a) ✗ git add .</span><br><span class="line">➜  git_rebase git:(f1e1d6a) ✗ git rebase --<span class="built_in">continue</span></span><br><span class="line">Applying: add test2</span><br><span class="line">➜  git_rebase git:(<span class="built_in">test</span>) </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  git_rebase git:(<span class="built_in">test</span>) git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 1b18ea5189f30c5a725b586297a747e46572962a (HEAD -&gt; <span class="built_in">test</span>)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:23:43 2017 +0800</span><br><span class="line"></span><br><span class="line">    add test2</span><br><span class="line"></span><br><span class="line">commit f1e1d6ab0397578a06100772e6e89fffa6f274dc (develop)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:21:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    add develop1</span><br><span class="line"></span><br><span class="line">commit 88e11d005f5fd66157d165e99be8aca2d6078fff</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:21:39 2017 +0800</span><br><span class="line"></span><br><span class="line">    add world</span><br><span class="line"></span><br><span class="line">commit 31dec318f7cf42e0289228535a89efe0b6c5bb8e (master)</span><br><span class="line">Author: 张三 &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Tue Dec 5 09:20:26 2017 +0800</span><br><span class="line"></span><br><span class="line">    initial commit</span><br></pre></td></tr></table></figure>

<p>因为丢弃了一次test的提交，所以很明显的看到，master第一次提交后，是develop的两次提交，然后是<code>add test2</code>的一次提交，test分支变基操作执行完毕。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab替换nginx服务</title>
    <url>/2015/10/29/git/gitlab%E6%9B%BF%E6%8D%A2nginx%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>之前在自己服务器上搭建服务器，这是之前的文章<br><a href="http://sail-y.github.io/2015/02/06/centos-6-5-%E5%AE%89%E8%A3%85gitlab%E5%AE%89%E8%A3%85%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/">gitlab安装需要注意的问题</a></p>
<p>后来在按照官网上替换自带服务器上的nginx的时候出现了一点问题。也是找了很久才找到这么一篇帖子，我在这里把nginx的部分转载过来一下。</p>
<a id="more"></a>
<p><a href="https://www.owent.net/2014/10/gitlab%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%A1.html">原文地址</a></p>
<blockquote>
<p>其次，我替换自己的nginx服务器的时候，nginx官方提供的包并不带gitlab要求的passenger模块，所以不能直接用官方提供的方法。我是用gitlab-ctl reconfigure生成了nginx的配置以后复制到自己的nginx里去的。生成的配置在 /var/opt/gitlab/nginx/conf/gitlab-http.conf</p>
</blockquote>
<blockquote>
<p>还是nginx，我的nginx的启动账户不是gitlab的（默认是gitlab-www），所以会出现502错误。日志里内容是访问fastcgi权限不足。所以还要chmod 755 /var/opt/gitlab/gitlab-rails/sockets</p>
</blockquote>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]Twitter的分布式自增ID算法Snowflake实现分析及其Java、Php和Python版</title>
    <url>/2015/04/22/java/-%E8%BD%AC-Twitter%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%87%AA%E5%A2%9EID%E7%AE%97%E6%B3%95Snowflake%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6Java%E3%80%81Php%E5%92%8CPython%E7%89%88/</url>
    <content><![CDATA[<p>转载：<a href="http://www.dengchuanhua.com/132.html">http://www.dengchuanhua.com/132.html</a></p>
<p>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位+机器ID 10位+毫秒内序列12位。</p>
<p>该项目地址为：<a href="https://github.com/twitter/snowflake%E6%98%AF%E7%94%A8Scala%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82">https://github.com/twitter/snowflake是用Scala实现的。</a></p>
<p>python版详见开源项目<a href="https://github.com/erans/pysnowflake%E3%80%82">https://github.com/erans/pysnowflake。</a></p>
<p>核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---0000000000 00</span><br></pre></td></tr></table></figure>
<p>在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</p>
<p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p>
<a id="more"></a>
<p>且看其核心代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;/pre&gt;</span><br><span class="line"><span class="comment">/** Copyright 2010-2012 Twitter, Inc.*/</span></span><br><span class="line"><span class="keyword">package</span> com.twitter.service.snowflake</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.twitter.ostrich.stats.<span class="type">Stats</span></span><br><span class="line"><span class="keyword">import</span> com.twitter.service.snowflake.gen._</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Random</span></span><br><span class="line"><span class="keyword">import</span> com.twitter.logging.<span class="type">Logger</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object that generates IDs.</span></span><br><span class="line"><span class="comment"> * This is broken into a separate class in case</span></span><br><span class="line"><span class="comment"> * we ever want to support multiple worker threads</span></span><br><span class="line"><span class="comment"> * per process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span>(<span class="params">val workerId: <span class="type">Long</span>, val datacenterId: <span class="type">Long</span>, private val reporter: <span class="type">Reporter</span>, var sequence: <span class="type">Long</span> = 0L</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Snowflake</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">genCounter</span></span>(agent: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="type">Stats</span>.incr(<span class="string">&quot;ids_generated&quot;</span>)</span><br><span class="line">    <span class="type">Stats</span>.incr(<span class="string">&quot;ids_generated_%s&quot;</span>.format(agent))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> exceptionCounter = <span class="type">Stats</span>.getCounter(<span class="string">&quot;exceptions&quot;</span>)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> log = <span class="type">Logger</span>.get</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> twepoch = <span class="number">1288834974657</span>L</span><br><span class="line"></span><br><span class="line"> <span class="comment">//机器标识位数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> workerIdBits = <span class="number">5</span>L</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心标识位数</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> datacenterIdBits = <span class="number">5</span>L</span><br><span class="line"></span><br><span class="line"><span class="comment">//机器ID最大值</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> maxWorkerId = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; workerIdBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心ID最大值</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> maxDatacenterId = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; datacenterIdBits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//毫秒内自增位</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> sequenceBits = <span class="number">12</span>L</span><br><span class="line"></span><br><span class="line"><span class="comment">//机器ID偏左移12位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> workerIdShift = sequenceBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据中心ID左移17位</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间毫秒左移22位</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> sequenceMask = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> lastTimestamp = <span class="number">-1</span>L</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check for workerId</span></span><br><span class="line">  <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>.format(maxWorkerId))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>.format(maxDatacenterId))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">    timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_id</span></span>(useragent: <span class="type">String</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validUseragent(useragent)) &#123;</span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidUserAgentError</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id = nextId()</span><br><span class="line">    genCounter(useragent)</span><br><span class="line"></span><br><span class="line">    reporter.report(<span class="keyword">new</span> <span class="type">AuditLogEntry</span>(id, useragent, rand.nextLong))</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_worker_id</span></span>(): <span class="type">Long</span> = workerId</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_datacenter_id</span></span>(): <span class="type">Long</span> = datacenterId</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_timestamp</span></span>() = <span class="type">System</span>.currentTimeMillis</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[snowflake] <span class="function"><span class="keyword">def</span> <span class="title">nextId</span></span>(): <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//时间错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">      log.error(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidSystemClock</span>(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>.format(</span><br><span class="line">        lastTimestamp - timestamp))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line"><span class="comment">//当前毫秒内，则+1</span></span><br><span class="line">      sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">      <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当前毫秒内计数满了，则等待下一秒</span></span><br><span class="line">        timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastTimestamp = timestamp</span><br><span class="line"><span class="comment">//ID偏移组合生成最终的ID，并返回ID   </span></span><br><span class="line"></span><br><span class="line">((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">      (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">      (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">      sequence</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待下一个毫秒的到来 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">tilNextMillis</span></span>(lastTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line">    <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">      timestamp = timeGen()</span><br><span class="line">    &#125;</span><br><span class="line">    timestamp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">timeGen</span></span>(): <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">AgentParser</span> = <span class="string">&quot;&quot;</span><span class="string">&quot;([a-zA-Z][a-zA-Z\-0-9]*)&quot;</span><span class="string">&quot;&quot;</span>.r</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validUseragent</span></span>(useragent: <span class="type">String</span>): <span class="type">Boolean</span> = useragent <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AgentParser</span>(_) =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;pre&gt;</span><br></pre></td></tr></table></figure>
<p>上述为twitter的实现，下面且看一个Java实现，貌似为淘宝的朋友写的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> twepoch = <span class="number">1361753741828L</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdBits = <span class="number">4L</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ -<span class="number">1L</span> &lt;&lt; workerIdBits;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceBits = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ -<span class="number">1L</span> &lt;&lt; sequenceBits;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">if</span> (workerId &gt; <span class="keyword">this</span>.maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">     <span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>,</span><br><span class="line">     <span class="keyword">this</span>.maxWorkerId));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> timestamp = <span class="keyword">this</span>.timeGen();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lastTimestamp == timestamp) &#123;</span><br><span class="line">   <span class="keyword">this</span>.sequence = (<span class="keyword">this</span>.sequence + <span class="number">1</span>) &amp; <span class="keyword">this</span>.sequenceMask;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.sequence == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;###########&quot;</span> + sequenceMask);</span><br><span class="line">    timestamp = <span class="keyword">this</span>.tilNextMillis(<span class="keyword">this</span>.lastTimestamp);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.sequence = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (timestamp &lt; <span class="keyword">this</span>.lastTimestamp) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(</span><br><span class="line">      String.format(</span><br><span class="line">        <span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>.lastTimestamp - timestamp));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.lastTimestamp = timestamp;</span><br><span class="line">  <span class="keyword">long</span> nextId = ((timestamp - twepoch &lt;&lt; timestampLeftShift))</span><br><span class="line">    | (<span class="keyword">this</span>.workerId &lt;&lt; <span class="keyword">this</span>.workerIdShift) | (<span class="keyword">this</span>.sequence);</span><br><span class="line"><span class="comment">//  System.out.println(&quot;timestamp:&quot; + timestamp + &quot;,timestampLeftShift:&quot;</span></span><br><span class="line"><span class="comment">//    + timestampLeftShift + &quot;,nextId:&quot; + nextId + &quot;,workerId:&quot;</span></span><br><span class="line"><span class="comment">//    + workerId + &quot;,sequence:&quot; + sequence);</span></span><br><span class="line">  <span class="keyword">return</span> nextId;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> timestamp = <span class="keyword">this</span>.timeGen();</span><br><span class="line">  <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">   timestamp = <span class="keyword">this</span>.timeGen();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> timestamp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  IdWorker worker2 = <span class="keyword">new</span> IdWorker(<span class="number">2</span>);</span><br><span class="line">  System.out.println(worker2.nextId());</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一个php的实现    </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Idwork</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> debug = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">static</span> $workerId;</span><br><span class="line"><span class="built_in">static</span> $twepoch = <span class="number">1361775855078</span>;</span><br><span class="line"><span class="built_in">static</span> $sequence = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> workerIdBits = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">static</span> $maxWorkerId = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> sequenceBits = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">static</span> $workerIdShift = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">static</span> $timestampLeftShift = <span class="number">14</span>;</span><br><span class="line"><span class="built_in">static</span> $sequenceMask = <span class="number">1023</span>;</span><br><span class="line"><span class="keyword">private</span>  <span class="built_in">static</span> $lastTimestamp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$workId</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>($workId &gt; <span class="built_in">self</span>::$maxWorkerId || $workId&lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;worker Id can&#x27;t be greater than 15 or less than 0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">self</span>::$workerId=$workId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;__construct()-&gt;self::$workerId:&#x27;</span>.<span class="built_in">self</span>::$workerId;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//获得当前时间戳</span></span><br><span class="line">$time = explode(<span class="string">&#x27; &#x27;</span>, microtime());</span><br><span class="line">$time2= substr($time[<span class="number">0</span>], <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">$timestramp = $time[<span class="number">1</span>].$time2;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;timeGen()-&gt;$timestramp:&#x27;</span>.$time[<span class="number">1</span>].$time2;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>  $time[<span class="number">1</span>].$time2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">tilNextMillis</span>(<span class="params">$lastTimestamp</span>) </span>&#123;</span><br><span class="line">$timestamp = <span class="keyword">$this</span>-&gt;timeGen();</span><br><span class="line"><span class="keyword">while</span> ($timestamp &lt;= $lastTimestamp) &#123;</span><br><span class="line">$timestamp = <span class="keyword">$this</span>-&gt;timeGen();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;tilNextMillis()-&gt;$timestamp:&#x27;</span>.$timestamp;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> $timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">nextId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$timestamp=<span class="keyword">$this</span>-&gt;timeGen();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;nextId()-&gt;self::$lastTimestamp1:&#x27;</span>.<span class="built_in">self</span>::$lastTimestamp;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">self</span>::$lastTimestamp == $timestamp) &#123;</span><br><span class="line"><span class="built_in">self</span>::$sequence = (<span class="built_in">self</span>::$sequence + <span class="number">1</span>) &amp; <span class="built_in">self</span>::$sequenceMask;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">self</span>::$sequence == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;###########&quot;</span>.<span class="built_in">self</span>::$sequenceMask;</span><br><span class="line">    $timestamp = <span class="keyword">$this</span>-&gt;tilNextMillis(<span class="built_in">self</span>::$lastTimestamp);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;nextId()-&gt;self::$lastTimestamp2:&#x27;</span>.<span class="built_in">self</span>::$lastTimestamp;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">self</span>::$sequence  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;nextId()-&gt;self::$sequence:&#x27;</span>.<span class="built_in">self</span>::$sequence;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($timestamp &lt; <span class="built_in">self</span>::$lastTimestamp) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> Excwption(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for &quot;</span>.(<span class="built_in">self</span>::$lastTimestamp-$timestamp).<span class="string">&quot; milliseconds&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">self</span>::$lastTimestamp  = $timestamp;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;nextId()-&gt;self::$lastTimestamp3:&#x27;</span>.<span class="built_in">self</span>::$lastTimestamp;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;logdebug-&gt;nextId()-&gt;(($timestamp - self::$twepoch &lt;&lt; self::$timestampLeftShift )):&#x27;</span>.((sprintf(<span class="string">&#x27;%.0f&#x27;</span>, $timestamp) - sprintf(<span class="string">&#x27;%.0f&#x27;</span>, <span class="built_in">self</span>::$twepoch) ));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">$nextId = ((sprintf(<span class="string">&#x27;%.0f&#x27;</span>, $timestamp) - sprintf(<span class="string">&#x27;%.0f&#x27;</span>, <span class="built_in">self</span>::$twepoch)  )) | ( <span class="built_in">self</span>::$workerId &lt;&lt; <span class="built_in">self</span>::$workerIdShift ) | <span class="built_in">self</span>::$sequence;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;timestamp:&#x27;</span>.$timestamp.<span class="string">&#x27;-----&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;twepoch:&#x27;</span>.sprintf(<span class="string">&#x27;%.0f&#x27;</span>, <span class="built_in">self</span>::$twepoch).<span class="string">&#x27;-----&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;timestampLeftShift =&#x27;</span>.<span class="built_in">self</span>::$timestampLeftShift.<span class="string">&#x27;-----&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;nextId:&#x27;</span>.$nextId.<span class="string">&#x27;----&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;workId:&#x27;</span>.<span class="built_in">self</span>::$workerId.<span class="string">&#x27;-----&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;workerIdShift:&#x27;</span>.<span class="built_in">self</span>::$workerIdShift.<span class="string">&#x27;-----&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> $nextId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$Idwork = <span class="keyword">new</span> Idwork(<span class="number">1</span>);</span><br><span class="line">$a= $Idwork-&gt;nextId();</span><br><span class="line">$Idwork = <span class="keyword">new</span> Idwork(<span class="number">2</span>);</span><br><span class="line">$a= $Idwork-&gt;nextId();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式自增ID算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java获取URL上的参数</title>
    <url>/2016/07/21/java/Java%E8%8E%B7%E5%8F%96URL%E4%B8%8A%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>最近遇到一个需求需要在获取URL字符串上的kv键值对，我们都知道Java Web在请求是直接用request来获取值的。如果是字符串呢，就需要正则表达式来自己截取了。<br>自己写代码是比较麻烦的，下面推荐用Guava工具包，2行代码就可以解决这个需求了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String getPara(String url, String name) &#123;</span><br><span class="line">    String params &#x3D; url.substring(url.indexOf(&quot;?&quot;) + 1, url.length());</span><br><span class="line">    Map&lt;String, String&gt; split &#x3D; Splitter.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;&#x3D;&quot;).split(params);</span><br><span class="line">    return split.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先截取到?后面的字符串，然后再用<code>Splitter.on(&quot;&amp;&quot;).withKeyValueSeparator(&quot;=&quot;).split(params);</code>就轻松的解决了~</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 枚举存储</title>
    <url>/2015/12/11/java/Mybatis-%E6%9E%9A%E4%B8%BE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>我们在写程序的时候会遇到这种需求。就是我的对象里面有一个属性是一个枚举值，但是mybatis默认是不支持的，官方提供了一个typeHandler可以用枚举的ordinal()来进行存和取的自动转换。把它配置在<br><code>mybatis-configuration.xml</code>里。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">        &lt;typeHandler handler&#x3D;&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType&#x3D;&quot;com.xxx.user.UserType&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;typeHandlers&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是这里有一些问题，必须如果数据库里面存在了别的数字，举个例，有以下枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum UserType&#123;</span><br><span class="line">    ADMIN, EDITOR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个枚举在数据库中对应的数字应该是0和1，问题如下</p>
<ol>
<li>枚举写的顺序不能变，否则数据库数据会错乱</li>
<li>枚举序数中间不能中断(0，2)</li>
<li>数据库里有除了0和1之外的数字，在查询数据的时候程序会得到一个异常(<code>ArrayIndexOutOfBoundsException</code>)</li>
</ol>
<p>最怕的就是程序出异常了，这里<code>ArrayIndexOutOfBoundsException</code>的原因是因为EnumOrdinalTypeHandler的代码大致是下面这个的意思。</p>
<pre><code>UserType.values()[i]</code></pre>
<p>所以就出现了我们写代码其实并不经常会遇到的<code>ArrayIndexOutOfBoundsException</code></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了避免出现这些情况，有个简单的办法就是重写一个<code>EnumOrdinalTypeHandler</code>，<br>我这里贴一下我的解决方案。<br>首先要为所有枚举写一个接口，为了获取枚举对应的intValue,代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonEnum</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取枚举值对应的枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumClass 枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumValue 枚举值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends CommonEnum&lt;E&gt;&gt; <span class="function">E <span class="title">getEnum</span><span class="params">(<span class="keyword">final</span> Class&lt;E&gt; enumClass, <span class="keyword">final</span> Integer enumValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enumValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(enumClass, enumValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取枚举值对应的枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumClass 枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumValue 枚举值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends CommonEnum&gt; <span class="function">E <span class="title">valueOf</span><span class="params">(Class&lt;E&gt; enumClass, Integer enumValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enumValue == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;EnumValue is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> getEnumMap(enumClass).get(enumValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取枚举键值对</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumClass 枚举类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends CommonEnum&gt; <span class="function">Map&lt;Integer, E&gt; <span class="title">getEnumMap</span><span class="params">(Class&lt;E&gt; enumClass)</span> </span>&#123;</span><br><span class="line">        E[] enums = enumClass.getEnumConstants();</span><br><span class="line">        <span class="keyword">if</span> (enums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(enumClass.getSimpleName() + <span class="string">&quot; does not represent an enum type.&quot;</span>);</span><br><span class="line">        Map&lt;Integer, E&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * enums.length);</span><br><span class="line">        <span class="keyword">for</span> (E t : enums)&#123;</span><br><span class="line">            map.put(t.getValue(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面3个静态方法也可以提取到工具类中，我这里偷了一下懒，也因为我是用的JDK8。<br>枚举实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserType</span> <span class="keyword">implements</span> <span class="title">CommonEnum</span>&lt;<span class="title">UserType</span>&gt; </span>&#123;</span><br><span class="line">    ADMIN(<span class="number">0</span>), EDITOR(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    UserType(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是一个很常见的枚举，重点在下面的typeHandler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEnumTypeHandler</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">CommonEnum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;E&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomEnumTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Type argument cannot be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        E[] enums = type.getEnumConstants();</span><br><span class="line">        <span class="keyword">if</span> (enums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(type.getSimpleName() + <span class="string">&quot; does not represent an enum type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, E parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setInt(i, parameter.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rs.getInt(columnName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CommonEnum.getEnum(type, i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot convert &quot;</span> + i + <span class="string">&quot; to &quot;</span> + type.getSimpleName() + <span class="string">&quot; by int value.&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CommonEnum.getEnum(type, i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot convert &quot;</span> + i + <span class="string">&quot; to &quot;</span> + type.getSimpleName() + <span class="string">&quot; by int value.&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">if</span> (cs.wasNull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CommonEnum.getEnum(type, i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot convert &quot;</span> + i + <span class="string">&quot; to &quot;</span> + type.getSimpleName() + <span class="string">&quot; by int value.&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类基本上也是拷的<code>EnumOrdinalTypeHandler</code>。重要的改动的代码如下：</p>
<pre><code>ps.setInt(i, parameter.getValue());
return CommonEnum.getEnum(type, i);</code></pre>
<p>第一句是插入和更新的时候用到的，第二句是查询的时候用到的，最后把<code>mybatis-configuration.xml</code>里的改一下。    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">        &lt;typeHandler handler=<span class="string">&quot;xxx.CustomEnumTypeHandler&quot;</span> javaType=<span class="string">&quot;com.xxx.user.UserType&quot;</span>/&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 接口版本管理</title>
    <url>/2015/03/31/java/Spring-MVC-%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>随着我们的应用后台不断的发版，因为改动导致了数据结构的变化，这个时候就需要对HTTP API进行版本控制了。对原有的客户端进行兼容，搜索一番后找到一个方法。<br>先看这个文章，提供了一个解决方案。<br><a href="http://www.cnblogs.com/jcli/p/springmvc_restful_version.html">http://www.cnblogs.com/jcli/p/springmvc_restful_version.html</a></p>
<p>Spring MVC通过在方法上使用<code>RequestMapping</code>来确认应该使用哪个方法来响应相应的请求，而RequestMapping又通过各种RequestCondition的实现来完成各种过滤（比如：consumes，headers，methods，params，produces以及value等）。在Spring MVC框架中使用RequestConditionHolder和RequestMappingInfo这两个实现。</p>
<h6 id="自定义RequestCondition"><a href="#自定义RequestCondition" class="headerlink" title="自定义RequestCondition"></a>自定义RequestCondition</h6><ul>
<li>实现RequestCondition接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.mvc.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestCondition</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">combine</span><span class="params">(T other)</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other, HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>继承RequestMappingHandlerMapping<ul>
<li>getCustomTypeCondition方法根据对应的Handler类返回类级别的condition</li>
<li>getCustomMethodCondition方法根据对应的Handler方法返回方法级别的condition</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>基本上我是照着他做的，不过我这里也是遇到不少的问题，因为数据是直接post的json，需要转换为实体对象，所以还需要一些额外的配置。文中提到：</p>
<blockquote>
<p>最后，得让SpringMVC加载我们定义的CustomRequestMappingHandlerMapping以覆盖原先的RequestMappingHandlerMapping, 所以要去掉前面说的<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>这个配置，我们通过JavaConfig的方式注入</p>
</blockquote>
<p>我是不太愿意去掉<code>&lt;mvc:annotation-driven/&gt;</code>的，不过试了半天也没有好的效果，因为<br><code>&lt;mvc:annotation-driven/&gt;</code>注册的东西太多了。<br>我尝试直接写一个<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code> 一样包名的类来覆盖掉spring的类，来改掉getCustomTypeCondition和getCustomMethodCondition的方法实现。现在来看应该是可行的，但我没有这样干是因为中途遇见一个问题一直没调试好，最终又换成了自定义的类。这个问题就是因为客户端目前的版本号全部是在post的json中传过来的，就不考虑在路径上做改动。<br>所以我出现了这样的操作，在没找到问题之前我一直以为我重写的类这一种方式有问题，看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiVersionCondition <span class="title">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String device = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        device = JSONUtil.parse(request.getInputStream()).getString(<span class="string">&quot;device&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> version = VersionUtil.getVersion(JSON.parseObject(device).getString(<span class="string">&quot;app_ver&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (version &gt;= <span class="keyword">this</span>.apiVersion) <span class="comment">// 如果请求的版本号大于配置版本号， 则满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是把post过来的json数据取出来，然后取出里面的version进行判断，不过我得到这样一个错误，看了很久也没看懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.http.converter.HttpMessageNotReadableException: Required request body content is missing: org.springframework.web.method.HandlerMethod$HandlerMethodParameter@bee0537e</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleEmptyBody(RequestResponseBodyMethodProcessor.java:189) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:170) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:105) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:77) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:162) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:129) ~[spring-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) ~[spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) [spring-webmvc-4.1.3.RELEASE.jar:4.1.3.RELEASE]</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>然后才发现我在这里把inputStream读了以后，到controller那一层已经没有任何数据了。基本上是算得上自己作死加犯傻了。结果还是采取的在Http Header里面放一个版本号来进行判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ApiVersionCondition getMatchingCondition(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    int version &#x3D; VersionUtil.getVersion(request.getHeader(&quot;App-Version&quot;));</span><br><span class="line"></span><br><span class="line">    if (version &gt;&#x3D; this.apiVersion) &#x2F;&#x2F; 如果请求的版本号大于配置版本号， 则满足</span><br><span class="line">        return this;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说一下配置的地方，我没有用WebConfig的配置方式，但还是去掉了<code>&lt;mvc:annotation-driven&gt;</code><br>换成了几个bean。<br>下面贴上我的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--RequestMapping解析器--&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;com.xiaomaihd.xueshaqu.version.CustomRequestMappingHandlerMapping&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;order&quot; value&#x3D;&quot;0&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;interceptors&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;conversionServiceExposingInterceptor&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;webBindingInitializer&quot;&gt;</span><br><span class="line">        &lt;bean</span><br><span class="line">                class&#x3D;&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;conversionService&quot; ref&#x3D;&quot;conversionService&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;validator&quot; ref&#x3D;&quot;validator&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageConverters&quot; ref&#x3D;&quot;messageConverters&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;conversionService&quot; class&#x3D;&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;conversionServiceExposingInterceptor&quot;</span><br><span class="line">      class&#x3D;&quot;org.springframework.web.servlet.handler.ConversionServiceExposingInterceptor&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;conversionService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>大功告成，目前还没发现其他的问题</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Rest</tag>
        <tag>Spring Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Mvc 3.1 之后如何配置messageConverters</title>
    <url>/2015/03/06/java/Spring-Mvc-3-1-%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEmessageConverters/</url>
    <content><![CDATA[<p><code>&lt;mvc:annotation-driven /&gt;</code> 是一种简写形式，完全可以手动配置替代这种简写形式，简写形式可以让初学都快速应用默认配置方案。<code>&lt;mvc:annotation-driven /&gt;</code> 会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code> 两个bean,是spring MVC为@Controllers分发请求所必须的。</p>
<p>这句话我在很多帖子都看到过，我自己的项目本身使用的Spring MVC 3.2，实际上在3.1之后，&lt;mvc:annotation-driven /&gt;注册的类发生了变化</p>
<blockquote>
<p>Spring Framework 3.1 introduces a new set of support classes for processing requests with annotated controllers:</p>
</blockquote>
<blockquote>
<p>RequestMappingHandlerMapping<br>RequestMappingHandlerAdapter<br>ExceptionHandlerExceptionResolver<br>These classes are a replacement for the existing:</p>
</blockquote>
<blockquote>
<p>DefaultAnnotationHandlerMapping<br>AnnotationMethodHandlerAdapter<br>AnnotationMethodHandlerExceptionResolver</p>
</blockquote>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The above registers a RequestMappingHandlerMapping, a RequestMappingHandlerAdapter, and an ExceptionHandlerExceptionResolver (among others) in support of processing requests with annotated controller methods using annotations such as @RequestMapping , @ExceptionHandler, and others.</p>
</blockquote>
<blockquote>
<p>It also enables the following:</p>
</blockquote>
<blockquote>
<ol>
<li>Spring 3 style type conversion through a ConversionService instance in addition to the JavaBeans PropertyEditors used for Data Binding.</li>
<li>Support for formatting Number fields using the @NumberFormat annotation through the ConversionService.</li>
<li>Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation.</li>
<li>Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath.</li>
<li>HttpMessageConverter support for @RequestBody method parameters and @ResponseBody method return values from @RequestMapping or @ExceptionHandler methods.<br>This is the complete list of HttpMessageConverters set up by mvc:annotation-driven:</li>
</ol>
</blockquote>
<ul>
<li>ByteArrayHttpMessageConverter converts byte arrays.</li>
<li>StringHttpMessageConverter converts strings.</li>
<li>ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.</li>
<li>SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.</li>
<li>FormHttpMessageConverter converts form data to/from a MultiValueMap&lt;String, String&gt;.</li>
<li>Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if   JAXB2 is present on the classpath.</li>
<li>MappingJackson2HttpMessageConverter (or MappingJacksonHttpMessageConverter) converts to/from JSON — added if Jackson 2 (or Jackson) is present on the classpath.</li>
<li>AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath.</li>
<li>RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath.</li>
</ul>
<p>这是摘取的官方文档，可以看出，注册的类已经变成了RequestMappingHandlerMapping和 RequestMappingHandlerAdapter。<br>我之前在不知道的时候，使用AnnotationMethodHandlerAdapter 进行配置，结果在有&lt;mvc:annotation-driven /&gt;存在的情况下，我自己配置的AnnotationMethodHandlerAdapter 怎么都不起作用，于是去掉了&lt;mvc:annotation-driven /&gt;标签，手动注册了AnnotationMethodHandlerAdapter ，和DefaultAnnotationHandlerMapping。结果引发了其他问题，比如文件无法上传的问题。</p>
<p>阅读文档发现Spring提供了基于&lt;mvc:annotation-driven /&gt;自定义messageConverters的方法，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.example.MyOtherHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面展示我自己的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/jdbc</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/util      </span></span></span><br><span class="line"><span class="tag"><span class="string">          			 http://www.springframework.org/schema/util/spring-util-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">  					 http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- spring自动扫描注解的组件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xx.xx&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;stringHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;fastJsonHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;marshallingHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stringHttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			避免出现乱码 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fastJsonHttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 避免IE出现下载JSON文件的情况 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;features&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">util:list</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- &lt;value&gt;WriteMapNullValue&lt;/value&gt; --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>QuoteFieldNames<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteDateUseDateFormat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;marshallingHttpMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;marshaller&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;castorMarshaller&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;unmarshaller&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;castorMarshaller&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>text/xml;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>application/xml;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 返回类型定义 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;stringHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;fastJsonHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;marshallingHttpMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;castorMarshaller&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.oxm.castor.CastorMarshaller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- AOP自动注解功能 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 不进行拦截的 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/**/*.html&quot;</span> <span class="attr">order</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/download/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/download/**&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/plugin/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/plugin/**&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/pages/**&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;messages&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 支持上传文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- restTemplate --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;restTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.client.RestTemplate&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>messageConverters</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring mvc @ResponseBody 返回枚举类型</title>
    <url>/2015/01/31/java/Spring-mvc-ResponseBody-%E8%BF%94%E5%9B%9E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>我们在用<code>@ResponseBody</code>返回实体对象可以用<code>spring mvc</code>自动帮我们转化成json串<br>但是当实体中包含了枚举类型的属性的时候怎么办，我这里使用的是<code>fastjson</code>，他默认是转换成了字符串。<br>根据我上一篇博文的解决方案，我们这里自定义一个<code>FastJsonHttpMessageConverter</code></p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractHttpMessageConverter</span>&lt;<span class="title">Object</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Charset UTF8     = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Charset             charset  = UTF8;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> SerializerFeature[] features = <span class="keyword">new</span> SerializerFeature[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonHttpMessageConverter</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> MediaType(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;json&quot;</span>, UTF8), <span class="keyword">new</span> MediaType(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;*+json&quot;</span>, UTF8));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Charset <span class="title">getCharset</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.charset;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharset</span><span class="params">(Charset charset)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.charset = charset;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> SerializerFeature[] getFeatures() &#123;  </span><br><span class="line">        <span class="keyword">return</span> features;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFeatures</span><span class="params">(SerializerFeature... features)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.features = features;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readInternal</span><span class="params">(Class&lt;? extends Object&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException,  </span></span><br><span class="line"><span class="function">            HttpMessageNotReadableException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">  </span><br><span class="line">        InputStream in = inputMessage.getBody();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> len = in.read(buf);  </span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();  </span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(bytes, <span class="number">0</span>, bytes.length, charset.newDecoder(), clazz);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Object obj, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException,  </span></span><br><span class="line"><span class="function">            HttpMessageNotWritableException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        OutputStream out = outputMessage.getBody();  </span><br><span class="line">        String text = JSONUtil.toJSONString(obj, features);  </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = text.getBytes(charset);  </span><br><span class="line">        out.write(bytes);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>其实我就改了一句代码，如下所示，这样我们就可以返回想要的索引数字了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = JSONUtil.toJSONString(obj, features);  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring mvc</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson序列化枚举属性</title>
    <url>/2015/01/30/java/fastjson%E5%BA%8F%E5%88%97%E5%8C%96%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>我的实体类里面有一个属性是枚举类型的，但是我在转换的时候我不希望取它的name，而是它的索引值0,1,2,3,搜索一番后发现这个回答</p>
<blockquote>
<p><a href="http://zhidao.baidu.com/link?url=5_N_6oaQaN6s-JLAZzwy-Fdbt93qC7VmzIfLvifZk463bKCwh7xBweUgBlJLczgHF9y7kjqNktsJmEVUuPlNkCw4sjfLaXq9ITfz9ieQH5u">fastjson enum 枚举 反序列化</a><br>为了方便大家查看，我把内容贴过来<br>看fastjson源码，SerializeWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">( Enum &lt; ?&gt;value, <span class="keyword">char</span> c )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( value == <span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line">	writeNull(); 　</span><br><span class="line">	write( <span class="string">&#x27;,&#x27;</span> ); 　</span><br><span class="line">	<span class="keyword">return</span>; 　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( isEnabled( SerializerFeature.WriteEnumUsingToString ) )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( isEnabled( SerializerFeature.UseSingleQuotes ) )</span><br><span class="line">	&#123;</span><br><span class="line">		write( <span class="string">&#x27;\&#x27;&#x27;</span> ); 　</span><br><span class="line">		write( value.name() ); 　</span><br><span class="line">		write( <span class="string">&#x27;\&#x27;&#x27;</span> ); 　</span><br><span class="line">		write( c );</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		write( <span class="string">&#x27;\&quot;&#x27;</span> ); 　</span><br><span class="line">		write( value.name() ); 　</span><br><span class="line">		write( <span class="string">&#x27;\&quot;&#x27;</span> ); 　</span><br><span class="line">		write( c ); 　</span><br><span class="line">	&#125; 　</span><br><span class="line">	<span class="keyword">return</span>; 　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writeIntAndChar( value.ordinal(), c ); 　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>
<blockquote>
<p>可以看出SerializeWriter在初始化的时候，features不要设置SerializerFeature.WriteEnumUsingToString<br>因为JSON.DEFAULT_PARSER_FEATURE是enable了SerializerFeature.WriteEnumUsingToString，也就是说是读枚举的value值而不是int值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_GENERATE_FEATURE;　　</span><br><span class="line"><span class="keyword">static</span> &#123;　　</span><br><span class="line"><span class="keyword">int</span> features = <span class="number">0</span>;　　</span><br><span class="line">features |= com.alibaba.fastjson.serializer.SerializerFeature.QuoteFieldNames.getMask();　　</span><br><span class="line">features |= com.alibaba.fastjson.serializer.SerializerFeature.SkipTransientField.getMask();　　</span><br><span class="line">features |= com.alibaba.fastjson.serializer.SerializerFeature.WriteEnumUsingToString.getMask();　　</span><br><span class="line">features |= com.alibaba.fastjson.serializer.SerializerFeature.SortField.getMask();　　 </span><br><span class="line"><span class="comment">// features |= com.alibaba.fastjson.serializer.SerializerFeature.WriteSlashAsSpecial.getMask();</span></span><br><span class="line">DEFAULT_GENERATE_FEATURE = features;　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，解决你这个问题的方法就是之前调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONSerializer.config(SerializerFeature.WriteEnumUsingToString,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是<code>JSONSerializer.config</code>不是一个<strong>静态方法</strong>，不能直接调用<br>而且如果直接调用<code>JSON.toJSON</code>把实体类转为<code>json</code>，这里还有另外一句代码    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz.isEnum()) &#123;  </span><br><span class="line">    <span class="keyword">return</span> ((Enum&lt;?&gt;) javaObject).name();  </span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">如果是枚举类型，不管你怎么改配置都不会给你转成索引值的情况，所以我们这里就先想把实体转成`jsonString`，再把`jsonString`转成`JSONObject`。</span><br><span class="line">再继续看`fastjson`的源码</span><br><span class="line">在`JOSN.toJSONString`中</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">toJSONString</span><span class="params">(Object object, SerializerFeature... features)</span> </span>&#123;  </span><br><span class="line">    SerializeWriter out = <span class="keyword">new</span> SerializeWriter();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        JSONSerializer serializer = <span class="keyword">new</span> JSONSerializer(out);  </span><br><span class="line">        <span class="keyword">for</span> (com.alibaba.fastjson.serializer.SerializerFeature feature : features) &#123;  </span><br><span class="line">            serializer.config(feature, <span class="keyword">true</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        serializer.write(object);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.toString();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        out.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>他这里也是用的<code>serializer.config</code>来配置的，干脆我们自己写个工具方法吧，同时把<code>WriteEnumUsingToString</code>禁用掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializerFeature[] CONFIG = <span class="keyword">new</span> SerializerFeature[]&#123;  </span><br><span class="line">        SerializerFeature.WriteNullBooleanAsFalse,<span class="comment">//boolean为null时输出false  </span></span><br><span class="line">        SerializerFeature.WriteMapNullValue, <span class="comment">//输出空置的字段  </span></span><br><span class="line">        SerializerFeature.WriteNonStringKeyAsString,<span class="comment">//如果key不为String 则转换为String 比如Map的key为Integer  </span></span><br><span class="line">        SerializerFeature.WriteNullListAsEmpty,<span class="comment">//list为null时输出[]  </span></span><br><span class="line">        SerializerFeature.WriteNullNumberAsZero,<span class="comment">//number为null时输出0  </span></span><br><span class="line">        SerializerFeature.WriteNullStringAsEmpty<span class="comment">//String为null时输出&quot;&quot;  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">toJSON</span><span class="params">(Object javaObject)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    SerializeWriter out = <span class="keyword">new</span> SerializeWriter();  </span><br><span class="line">    String jsonStr;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        JSONSerializer serializer = <span class="keyword">new</span> JSONSerializer(out);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (com.alibaba.fastjson.serializer.SerializerFeature feature : CONFIG) &#123;  </span><br><span class="line">            serializer.config(feature, <span class="keyword">true</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        serializer.config(SerializerFeature.WriteEnumUsingToString, <span class="keyword">false</span>);  </span><br><span class="line">        serializer.write(javaObject);  </span><br><span class="line"></span><br><span class="line">        jsonStr =  out.toString();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        out.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">    JSONObject jsonObject = JSON.parseObject(jsonStr);  </span><br><span class="line">    <span class="keyword">return</span> jsonObject;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这样调用我们的工具类方法转换出来的结果，就是我们想要的数字了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Lambda表达式初步与函数式接口</title>
    <url>/2016/12/19/java/jdk8-1/</url>
    <content><![CDATA[<h1 id="Lambda表达式初步与函数式接口"><a href="#Lambda表达式初步与函数式接口" class="headerlink" title="Lambda表达式初步与函数式接口"></a>Lambda表达式初步与函数式接口</h1><p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。</p>
<a id="more"></a>
<h2 id="为何需要Lambda表达式"><a href="#为何需要Lambda表达式" class="headerlink" title="为何需要Lambda表达式"></a>为何需要Lambda表达式</h2><ul>
<li>在Java中，我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。</li>
<li>在JavaScript中，函数参数一个函数，返回值是另一个函数的情况是非常常见的；JavaScript是一门非常典型的函数式语言。</li>
</ul>
<p>Java匿名内部类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样写是有点繁琐的，在Java8中可以直接下面这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">   <span class="comment">// do something     </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在Java8的循环中，我们也可以很方便的使用Lambda表达式。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// foreach语法</span></span><br><span class="line"><span class="keyword">for</span>(Integer i : list) &#123;</span><br><span class="line">	System.out.println(i);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8新增的forEach方法</span></span><br><span class="line">list.forEach(i -&gt; System.out.println(i));</span><br><span class="line"><span class="comment">// 这种只有一行代码，一个参数的调用，我们甚至还可以再简化一点</span></span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看forEach的方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接受了一个Consumer参数，这个接口是JDK8新增的一个函数式接口。            </p>
<h2 id="什么是函数式接口？"><a href="#什么是函数式接口？" class="headerlink" title="什么是函数式接口？"></a>什么是函数式接口？</h2><ol>
<li>一个接口，有且只有一个抽象方法，这个接口就称为函数式接口。</li>
<li>如果我们在某个接口上声明了@FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口。</li>
<li>如果某个接口只有抽象方法，但我们并没有给该接口声明@FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试自己写一个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个不算抽象方法，因为MyInterface的实现类必然是Object的子类，他会直接继承Object类的实现，实现类依然只需要实现test()方法。</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        myInterface.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        test.myTest(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 这里就是MyInterface.test()方法的实现</span></span><br><span class="line">            System.out.println(<span class="string">&quot;mytest&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式的作用"><a href="#Lambda表达式的作用" class="headerlink" title="Lambda表达式的作用"></a>Lambda表达式的作用</h2><p>Lambda表达式为Java添加了缺失的函数式编程特性，使我们能将函数当作一等公民看待。<br>在将函数作为一等公民的语言中，Lambda表达式的类型是函数。但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型—-函数式接口（functional interface）。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面是用lambda表达式和stream来对一个列表的字符串进行大写字母转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面看到有2个冒号的地方，这个叫做方法引用，方法引用有四种方式，这是其中一种，通过类的方式引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, String&gt; function = String::toUpperCase;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>那么对象会被当做lambda表达式的第一个参数传入，上面的代码就相当于”hello”.toUpperCase();</p>
<p>下面演示一个Comparator的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">Collections.sort(names, (o1, o2) -&gt; o2.compareTo(o1));</span><br><span class="line"></span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure>

<p>这就是一个倒序排序，Collections.sort()的第二个参数就是一个Comparator对象，我们用lambda表示来写的，看一下Comparator是声明为函数式接口。所以可以用lambda来写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure>

<h2 id="Java-Lambda基本语法"><a href="#Java-Lambda基本语法" class="headerlink" title="Java Lambda基本语法"></a>Java Lambda基本语法</h2><ul>
<li>Java中的Lambda表达式基本语法<ul>
<li>(arg) -&gt; (body)</li>
</ul>
</li>
<li>比如<ul>
<li>(arg1, arg2) -&gt; {bodu}</li>
<li>(type1 arg1, type2 arg2…) -&gt; {body}</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>(int a, int b) -&gt; { return a + b; }</li>
<li>() -&gt; System.out.println(“Hello World”);</li>
<li>(String s) -&gt; {System.out.println(s);}</li>
<li>() -&gt; 42</li>
</ul>
<h2 id="Java-Lambda结构"><a href="#Java-Lambda结构" class="headerlink" title="Java Lambda结构"></a>Java Lambda结构</h2><ul>
<li>一个Lambda表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同。</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a,b)或(int a,int b)或(String a,int b, float c)</li>
<li>空圆括号代表参数集为空。例如：() -&gt; 42</li>
<li>当只有一个参数，且其类型可推导时，圆括号()可省略。例如：a -&gt; return a * a;</li>
<li>Lambda表达式的主体可包含零条或多条语句。</li>
<li>如果Lambda表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致。</li>
<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中(形成代码块)。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空。</li>
</ul>
<h2 id="主要接口详解"><a href="#主要接口详解" class="headerlink" title="主要接口详解"></a>主要接口详解</h2><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest test = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(test.compute(<span class="number">1</span>, value -&gt; <span class="number">2</span> * value));</span><br><span class="line">        System.out.println(test.compute(<span class="number">2</span>, value -&gt; <span class="number">5</span> + value));</span><br><span class="line">        System.out.println(test.compute(<span class="number">3</span>, value -&gt; value * value));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Function&lt;Integer, String&gt; function = String::valueOf;</span><br><span class="line">        System.out.println(test.convert(<span class="number">5</span>, function.compose((Integer i) -&gt; i + <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = function.apply(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, String&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compose和andThen"><a href="#compose和andThen" class="headerlink" title="compose和andThen"></a>compose和andThen</h4><p>compose()方法，它接受一个Function，也返回一个Function，结果就是执行参数里的apply，再执行本对象的apply。<br>andThen()方法则相反，是先执行本对象的apply，再执行参数Function的apply。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest2 test2 = <span class="keyword">new</span> FunctionTest2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出12</span></span><br><span class="line">        System.out.println(test2.compute(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">        <span class="comment">// 输出36</span></span><br><span class="line">        System.out.println(test2.compute2(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态+-操作</span></span><br><span class="line">        System.out.println(test2.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2));</span><br><span class="line">        System.out.println(test2.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 - value2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// BIFunction实例</span></span><br><span class="line">        System.out.println(test2.compute4(<span class="number">2</span>, <span class="number">3</span>, (value1, value2) -&gt; value1 + value2, value -&gt; value * value));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><p>接受2个参数，返回一个值的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people = Arrays.asList(person1, person2, person3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        PersonTest test = <span class="keyword">new</span> PersonTest();</span><br><span class="line"><span class="comment">//        List&lt;Person&gt; personResult = test.getPeopleByUsername(&quot;zhangsan&quot;, people);</span></span><br><span class="line"><span class="comment">//        personResult.forEach(person -&gt; System.out.println(person.getUsername()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;Person&gt; personResult = test.getPeopleByAge(20, people);</span></span><br><span class="line"><span class="comment">//        personResult.forEach(person -&gt; System.out.println(person.getAge()));</span></span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personResult = test.getPeopleByAge2(<span class="number">20</span>, people, (ageOfPerson, personList) -&gt; personList.stream().filter(person -&gt; person.getAge() &gt; ageOfPerson).collect(Collectors.toList()));</span><br><span class="line">        personResult.forEach(person -&gt; System.out.println(person.getAge()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPeopleByUsername</span><span class="params">(String username, List&lt;Person&gt; people)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> people.stream().filter(person -&gt; person.getUsername().equals(username)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPeopleByAge</span><span class="params">(<span class="keyword">int</span> age, List&lt;Person&gt; people)</span> </span>&#123;</span><br><span class="line">        BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction = (ageOfPerson, personList) -&gt; personList.stream().filter(person -&gt; person.getAge() &gt; ageOfPerson).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(age, people);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPeopleByAge2</span><span class="params">(<span class="keyword">int</span> age, List&lt;Person&gt; people, BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(age, people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>判断用的函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = p -&gt; p.length() &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        PredicateTest2 predicateTest2 = <span class="keyword">new</span> PredicateTest2();</span><br><span class="line">        predicateTest2.conditionFilter(list, i -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        predicateTest2.conditionFilter2(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以前我们在对数据进行筛选或者处理的时候，一般是单独定义一个方法来进行处理，现在我们只需要把筛选条件当作参数传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate的其他方法测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter2</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate, Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.or(predicate2).test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>简单测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java.util.function包下面还有很多函数式接口，无非就是0参数，1个参数，2个参数的接口，用法都是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOperatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryOperatorTest binaryOperatorTest = <span class="keyword">new</span> BinaryOperatorTest();</span><br><span class="line">        System.out.println(binaryOperatorTest.compute(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">        System.out.println(binaryOperatorTest.compute(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a - b));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        System.out.println(binaryOperatorTest.getShort(<span class="string">&quot;hello123&quot;</span>, <span class="string">&quot;world&quot;</span>, (a, b) -&gt; a.length() - b.length()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BinaryOperator&lt;Integer&gt; binaryOperator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binaryOperator.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShort</span><span class="params">(String a, String b, Comparator&lt;String&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BinaryOperator.minBy(comparator).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-JODA实战</title>
    <url>/2017/04/08/java/jdk8-10/</url>
    <content><![CDATA[<p>Java 8日期/时间（ Date/Time）API是开发人员最受追捧的变化之一，Java从一开始就没有对日期时间处理的一致性方法，因此日期/时间API也是除Java核心API以外另一项倍受欢迎的内容。</p>
<p>为什么我们需要新的Java日期/时间API？</p>
<p>在开始研究Java 8日期/时间API之前，让我们先来看一下为什么我们需要这样一个新的API。在Java中，现有的与日期和时间相关的类存在诸多问题，其中有：</p>
<ol>
<li>Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。</li>
<li>java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li>对于时间、时间戳、格式化以及解析，并没有一些明确定义的类。对于格式化和解析的需求，我们有java.text.DateFormat抽象类，但通常情况下，SimpleDateFormat类被用于此类需求。</li>
<li>所有的日期类都是可变的，因此他们都不是线程安全的，这是Java日期类最大的问题之一。</li>
<li>日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。<a id="more"></a>

</li>
</ol>
<p>在现有的日期和日历类中定义的方法还存在一些其他的问题，但以上问题已经很清晰地表明：Java需要一个健壮的日期/时间类。这也是为什么Joda Time在Java日期/时间需求中扮演了高质量替换的重要角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line">System.out.println(localDate.getYear() + <span class="string">&quot;, &quot;</span> + localDate.getMonthValue() + <span class="string">&quot;, &quot;</span> + localDate.getDayOfMonth());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成日期</span></span><br><span class="line">LocalDate localDate2 = LocalDate.of(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(localDate2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只关注月份和日期</span></span><br><span class="line">LocalDate localDate3 = LocalDate.of(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line">MonthDay monthDay = MonthDay.of(localDate3.getMonth(), localDate3.getDayOfMonth());</span><br><span class="line">MonthDay monthDay2 = MonthDay.from(LocalDate.of(<span class="number">2011</span>, <span class="number">3</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(monthDay.equals(monthDay2));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时分秒</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line">LocalTime time2 = time.plusHours(<span class="number">3</span>).plusMinutes(<span class="number">20</span>);</span><br><span class="line">System.out.println(time2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate1 = localDate.plus(<span class="number">2</span>, ChronoUnit.WEEKS);</span><br><span class="line"></span><br><span class="line">System.out.println(localDate1);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate4 = localDate.minus(<span class="number">2</span>, ChronoUnit.MONTHS);</span><br><span class="line">System.out.println(localDate4);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">System.out.println(clock.millis());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate5 = LocalDate.now();</span><br><span class="line">LocalDate localDate6 = LocalDate.of(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(localDate5.isAfter(localDate6));</span><br><span class="line">System.out.println(localDate5.isBefore(localDate6));</span><br><span class="line">System.out.println(localDate5.equals(localDate6));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">System.out.println(availableZoneIds);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);</span><br><span class="line"></span><br><span class="line">System.out.println(zonedDateTime);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">YearMonth yearMonth = YearMonth.now();</span><br><span class="line">System.out.println(yearMonth);</span><br><span class="line">System.out.println(yearMonth.lengthOfMonth());</span><br><span class="line">System.out.println(yearMonth.isLeapYear());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">YearMonth yearMonth1 = YearMonth.of(<span class="number">2016</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(yearMonth1);</span><br><span class="line">System.out.println(yearMonth1.lengthOfMonth());</span><br><span class="line">System.out.println(yearMonth1.lengthOfYear());</span><br><span class="line">System.out.println(yearMonth1.isLeapYear());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate7 = LocalDate.now();</span><br><span class="line">LocalDate localDate8 = LocalDate.of(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line">Period period = Period.between(localDate7, localDate8);</span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Instant.now());</span><br></pre></td></tr></table></figure>


<h2 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2014-03-18</span></span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> year = date.getYear();</span><br><span class="line">Month month = date.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = date.getDayOfMonth();</span><br><span class="line">DayOfWeek dow = date.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> len = date.lengthOfMonth();</span><br><span class="line"><span class="comment">// 闰年</span></span><br><span class="line"><span class="keyword">boolean</span> leap = date.isLeapYear();</span><br><span class="line">System.out.println(leap);</span><br><span class="line"></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TemporalField方式获取</span></span><br><span class="line">year = date.get(ChronoField.YEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间</span></span><br><span class="line"><span class="comment">// 13:45:20</span></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> hour = time.getHour();</span><br><span class="line"><span class="keyword">int</span> minute = time.getMinute();</span><br><span class="line"><span class="keyword">int</span> second = time.getSecond();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串转换</span></span><br><span class="line">date = LocalDate.parse(<span class="string">&quot;2014-03-18&quot;</span>);</span><br><span class="line">time = LocalTime.parse(<span class="string">&quot;13:45:20&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime</span></span><br><span class="line"><span class="comment">// 2014-03-18T13:45:20</span></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">LocalDateTime dt3 = date.atTime(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line">LocalDateTime dt4 = date.atTime(time);</span><br><span class="line">LocalDateTime dt5 = time.atDate(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 机器嗦理解的时间类Instant</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2秒后加上一千秒</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>, <span class="number">1_000</span>);</span><br><span class="line">Instant.now().toEpochMilli();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有类都实现了Temporal接口，  Temporal接口定义了如何读取和操纵为时间建模的对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Duration类主要用于以秒和纳秒恒衡量的时间的长短</span></span><br><span class="line">Duration d1 = Duration.between(time, time.plusHours(<span class="number">1</span>));</span><br><span class="line">System.out.println(d1.getSeconds());</span><br><span class="line"><span class="comment">// Period则以年、月或日的方式对多个时间单位建模</span></span><br><span class="line">Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>), LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</span><br><span class="line">System.out.println(tenDays.getDays());</span><br><span class="line"><span class="comment">// Duration和Period还有一些工厂类</span></span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br><span class="line">threeMinutes = Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Period nineDays = Period.ofDays(<span class="number">9</span>);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(dt1.plus(twoYearsSixMonthsOneDay));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取今天的0点</span></span><br><span class="line">LocalDateTime localDateTime = LocalDate.now().atTime(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">long</span> beginOfDay = localDateTime.toEpochSecond(ZoneOffset.of(<span class="string">&quot;+08:00&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(beginOfDay);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计算-amp-格式化"><a href="#计算-amp-格式化" class="headerlink" title="计算&amp;格式化"></a>计算&amp;格式化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// with是直接修改对应的属性</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 2011-03-18</span></span><br><span class="line">LocalDate date2 = date1.withYear(<span class="number">2011</span>);</span><br><span class="line"><span class="comment">// 2011-03-25</span></span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(<span class="number">25</span>);</span><br><span class="line"><span class="comment">// 2011-09-25</span></span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus和minus是相对方式修改属性</span></span><br><span class="line"><span class="comment">// 2014-03-18</span></span><br><span class="line">date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 2014-03-25</span></span><br><span class="line">date2 = date1.plusWeeks(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2011-03-25</span></span><br><span class="line">date3 = date2.minusYears(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 2011-09-25</span></span><br><span class="line">date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用TemporalAdjuster进行复杂处理</span></span><br><span class="line">date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 下一个星期天 2014-03-23</span></span><br><span class="line">date2 = date1.with(nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line"><span class="comment">// 这个月最后一天 2014-03-31</span></span><br><span class="line">date3 = date2.with(lastDayOfMonth());</span><br><span class="line"><span class="comment">// 只取工作日</span></span><br><span class="line">date3 = date2.with(temporal -&gt; &#123;</span><br><span class="line">    DayOfWeek dow = DayOfWeek.of(temporal.get(DAY_OF_WEEK));</span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dow == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dow == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, DAYS);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">TemporalAdjuster nextWorkingDay = ofDateAdjuster(temporal -&gt; &#123;</span><br><span class="line">    DayOfWeek dow = DayOfWeek.of(temporal.get(DAY_OF_WEEK));</span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dow == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dow == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, DAYS);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">date2.with(nextWorkingDay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化操作</span></span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line">date1 = LocalDate.parse(<span class="string">&quot;20140318&quot;</span>, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">date2 = LocalDate.parse(<span class="string">&quot;2014-03-18&quot;</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter italianFormatter =</span><br><span class="line">        DateTimeFormatter.ofPattern(<span class="string">&quot;d. MMMM yyyy&quot;</span>, Locale.ITALIAN);</span><br><span class="line"></span><br><span class="line">date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 18. marzo 2014</span></span><br><span class="line">String formattedDate = date.format(italianFormatter);</span><br><span class="line">date2 = LocalDate.parse(formattedDate, italianFormatter);</span><br><span class="line"></span><br><span class="line">italianFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder().appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">        .appendLiteral(<span class="string">&quot;. &quot;</span>)</span><br><span class="line">        .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">        .appendLiteral(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        .appendText(ChronoField.YEAR)</span><br><span class="line">        .parseCaseInsensitive()</span><br><span class="line">        .toFormatter(Locale.ITALIAN);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId romeZone = ZoneId.of(<span class="string">&quot;Europe/Rome&quot;</span>);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(romeZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>, <span class="number">13</span>, <span class="number">45</span>);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(romeZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(romeZone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Instant instantFromDateTime = dateTime.toInstant(romeZone);</span></span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant, romeZone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时区偏差</span></span><br><span class="line">ZoneOffset newYourkOffset = ZoneOffset.of(<span class="string">&quot;-05:00&quot;</span>);</span><br><span class="line">OffsetDateTime dateTimeInNewYork = OffsetDateTime.of(dateTime, newYourkOffset);</span><br><span class="line"></span><br><span class="line">MinguoDate minguoDate = MinguoDate.now();</span><br><span class="line">System.out.println(minguoDate);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Optional详解</title>
    <url>/2017/01/17/java/jdk8-2/</url>
    <content><![CDATA[<p>在Java中我们会经常遇到NullPointerException异常，代码里就少不了很多这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != obj) &#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8中的Optional<T>是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。<br>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>我们应该怎么使用Optional这个类呢。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是传统方式的代码书写方式</span></span><br><span class="line"><span class="comment">//        if (optional.isPresent()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(optional.get());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们应该用函数式风格来使用Optional</span></span><br><span class="line">        optional.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        System.out.println(optional.orElse(<span class="string">&quot;world&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        System.out.println(optional.orElseGet(() -&gt; <span class="string">&quot;nihao&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面再展示一个具体的应用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmployeeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmployeeList</span><span class="params">(List&lt;Employee&gt; employeeList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.employeeList = employeeList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Employee employee2 = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee2.setName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Company company = <span class="keyword">new</span> Company();</span><br><span class="line">        company.setName(<span class="string">&quot;company1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employeeList = Arrays.asList(employee, employee2);</span><br><span class="line"></span><br><span class="line">        company.setEmployeeList(employeeList);</span><br><span class="line">	    <span class="comment">// 下面的代码使用函数式的风格开发，避免了null判断以及条件分支等等代码</span></span><br><span class="line">        Optional&lt;Company&gt; optional = Optional.ofNullable(company);</span><br><span class="line">        System.out.println(optional.map(theCompany -&gt; theCompany.getEmployeeList()).orElse(Collections.emptyList()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-方法引用</title>
    <url>/2017/02/05/java/jdk8-3/</url>
    <content><![CDATA[<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用：method reference<br>方法引用实际上是个Lambda表达式的一种语法糖。</p>
<p>我们可以将方法引用看作是一个<code>函数指针</code>，function pointer。</p>
<p>方法引用共分为4类：</p>
<a id="more"></a>

<ol>
<li><p>类名::静态方法名</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是常规的lambda表达式写法</span></span><br><span class="line">        students.sort((o1, o2) -&gt; Student.compareStudentByScore(o1, o2));</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面展示方法引用的写法，这就是上面的代码的语法糖，更简洁</span></span><br><span class="line">        students.sort(Student::compareStudentByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引用名::实例方法名</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getScore() - student2.getScore();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里演示了如何使用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</span><br><span class="line">  students.sort((o1, o2) -&gt; studentComparator.compareStudentByScore(o1, o2));</span><br><span class="line">  students.sort(studentComparator::compareStudentByScore);</span><br></pre></td></tr></table></figure></li>
<li><p>类名::实例方法名<br> 新增2个方法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getScore() - student.getScore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comparByeName</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareToIgnoreCase(student.getName());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> 然后演示</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式和类型对象的实例方法</span></span><br><span class="line">  students.sort((o1, o2) -&gt; o1.compareByScore(o2));</span><br><span class="line">  <span class="comment">// 使用方法引用</span></span><br><span class="line"><span class="comment">// 引用的是类型对象的实例方法</span></span><br><span class="line"><span class="comment">// 这种方式的调用，lambda表达式的第一个参数是作为调用方，然后其他的lambda表达式参数都作为实例方法的参数传入</span></span><br><span class="line">  students.sort(Student::compareByScore);</span><br></pre></td></tr></table></figure></li>
<li><p>构造方法引用：类名::new</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Student&gt; supplier = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">  <span class="comment">// 构造方法引用</span></span><br><span class="line">  Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Stream详解</title>
    <url>/2017/02/05/java/jdk8-4/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>
<a id="more"></a>

<ul>
<li>Collection提供了新的stream()方法</li>
<li>流不存储值，通过管道的方式获取值</li>
<li>本质是函数式的，对流的操作会产生一个结果，不过并不会修改底层的数据源，集合可以作为流底层数据源</li>
<li>延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现</li>
</ul>
<p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。<br>流由3部分构成：</p>
<ol>
<li>源</li>
<li>零个或多个中间操作</li>
<li>终止操作<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png"></li>
</ol>
<p>流操作的分类：</p>
<ol>
<li>惰性求值（中间操作）</li>
<li>及早求值（终止操作）</li>
</ol>
<h2 id="创建流的几种方式"><a href="#创建流的几种方式" class="headerlink" title="创建流的几种方式"></a>创建流的几种方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line">        Stream stream1 = Stream.of(strArray);</span><br><span class="line">        Stream stream2 = Arrays.stream(strArray);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">        Stream stream3 = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流的简单使用"><a href="#流的简单使用" class="headerlink" title="流的简单使用"></a>流的简单使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">// 不包含8</span></span><br><span class="line">        IntStream.range(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        <span class="comment">// 包含8</span></span><br><span class="line">        IntStream.rangeClosed(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进一步应用"><a href="#进一步应用" class="headerlink" title="进一步应用"></a>进一步应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.stream().map(i -&gt; <span class="number">2</span> * i).reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Stream转换为数组和集合"><a href="#Stream转换为数组和集合" class="headerlink" title="Stream转换为数组和集合"></a>Stream转换为数组和集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String[] strArray = stream.toArray(i -&gt; new String[i]);</span></span><br><span class="line"><span class="comment">//        Arrays.asList(strArray).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        String[] strArray = stream.toArray(String[]::new);</span></span><br><span class="line"><span class="comment">//        Arrays.asList(strArray).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = stream.collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//        list.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个参数是要返回的容器，第二个参数是对每一个结果进行处理，第三个参数是把所有处理过的结果组装进要返回的list</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = stream.collect(() -&gt; new ArrayList(), (theList, item) -&gt; theList.add(item), (theList1, theList2) -&gt; theList1.addAll(theList2));</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</span></span><br><span class="line"><span class="comment">//        list.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一个重载的collect方法</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = stream.collect(Collectors.toCollection(ArrayList::new));</span></span><br><span class="line"><span class="comment">//        list.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为Set</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = stream.collect(Collectors.toCollection(TreeSet::new));</span></span><br><span class="line"><span class="comment">//        set.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接字符串</span></span><br><span class="line">        String str = stream.collect(Collectors.joining());</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        list.stream().map(String::toUpperCase).collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        list2.stream().map(item -&gt; item * item).collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flapMap是把流里的List也打开成一整个流</span></span><br><span class="line">        Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>), Arrays.asList(<span class="number">2</span>, <span class="number">3</span>), Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        stream.flatMap(theList -&gt; theList.stream()).map(item -&gt; item).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stream&lt;String&gt; stream = Stream.generate(UUID.randomUUID()::toString);</span></span><br><span class="line"><span class="comment">//        stream.findFirst().ifPresent(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate会产生一个无限流，所以要配合limit使用</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//        stream.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出该流中大于2的元素，然后将每个月元素乘以2，然后过滤掉流中的前两个元素，然后再取流中的前两个元素，最后求出流中元素的总和。</span></span><br><span class="line">        <span class="comment">// 1,3,5,7,9,11 结果是32</span></span><br><span class="line"><span class="comment">//        Integer integer = stream.filter(item -&gt; item &gt; 2).mapToInt(item -&gt; item * 2)</span></span><br><span class="line"><span class="comment">//                .skip(2).limit(2).sum();</span></span><br><span class="line"><span class="comment">//        System.out.println(integer);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        IntSummaryStatistics intSummaryStatistics = stream.filter(item -&gt; item &gt; 2).mapToInt(item -&gt; item * 2)</span></span><br><span class="line"><span class="comment">//                .skip(2).limit(2).summaryStatistics();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(intSummaryStatistics.getCount());</span></span><br><span class="line"><span class="comment">//        System.out.println(intSummaryStatistics.getMax());</span></span><br><span class="line"><span class="comment">//        System.out.println(intSummaryStatistics.getMin());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(stream);</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.filter(item -&gt; item &gt; 2));</span></span><br><span class="line">        <span class="comment">// 这句代码会抛异常: stream has already been operated upon or closed</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.distinct());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确的调用方式如下</span></span><br><span class="line">        System.out.println(stream);</span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.filter(item -&gt; item &gt; <span class="number">2</span>);</span><br><span class="line">        System.out.println(stream2);</span><br><span class="line">        Stream&lt;Integer&gt; stream3 = stream2.distinct();</span><br><span class="line">        System.out.println(stream3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中间操作和终止操作本质上的区别"><a href="#中间操作和终止操作本质上的区别" class="headerlink" title="中间操作和终止操作本质上的区别"></a>中间操作和终止操作本质上的区别</h3><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>中间操作都会返回一个Stream对象，比如说返回Stream<Integer>。<br>终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map是一个中间操作，是惰性的，在没有遇到终止操作的时候，中间操作是不会执行的</span></span><br><span class="line">        Stream&lt;String&gt; test = list.stream().map(item -&gt; &#123;</span><br><span class="line">            String result = item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这句代码才会输入map方法中的test</span></span><br><span class="line">        test.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这段代码虽然输出了正确的结果，但是程序不会终止，因为distinct一直在为无限流不停的去重</span></span><br><span class="line">        IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span> ) % <span class="number">2</span>).distinct().limit(<span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 下面才是正确的方式</span></span><br><span class="line">        IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span> ) % <span class="number">2</span>).limit(<span class="number">6</span>).distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="串行流和并行流的区别"><a href="#串行流和并行流的区别" class="headerlink" title="串行流和并行流的区别"></a>串行流和并行流的区别</h3><p>Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备500w个uuid来用不同的流进行排序</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始排序&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        list.stream().sorted().count();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序耗时：&quot;</span> + millis);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        list.parallelStream().sorted().count();</span><br><span class="line">        endTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序耗时：&quot;</span> + millis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始排序</span></span><br><span class="line"><span class="comment">         * 排序耗时：6500</span></span><br><span class="line"><span class="comment">         * 排序耗时：3394</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流的短路"><a href="#流的短路" class="headerlink" title="流的短路"></a>流的短路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印长度为5的第一个单词</span></span><br><span class="line"><span class="comment">//        list.stream().mapToInt(String::length).filter(length -&gt; length == 5).findFirst().ifPresent(System.out::println);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面只会输入出hello和5，因为流针对每一个元素的统一应用所有操作，所以直接找到了第一个hello</span></span><br><span class="line">        list.stream().mapToInt(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> length = item.length();</span><br><span class="line">            System.out.println(item);</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;).filter(length -&gt; length == <span class="number">5</span>).findFirst().ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatMap的应用场景"><a href="#flatMap的应用场景" class="headerlink" title="flatMap的应用场景"></a>flatMap的应用场景</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello welcome&quot;</span>, <span class="string">&quot;world hello&quot;</span>, <span class="string">&quot;hello world hello&quot;</span>, <span class="string">&quot;hello welcome&quot;</span>);</span><br><span class="line">        <span class="comment">// 找出所有单词并且去重</span></span><br><span class="line">        list.stream().flatMap(item -&gt; Arrays.stream(item.split(<span class="string">&quot; &quot;</span>))).distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">&quot; &quot;</span> + item2)).collect(Collectors.toList());</span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组：group-by操作"><a href="#分组：group-by操作" class="headerlink" title="分组：group by操作"></a>分组：group by操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>, <span class="number">20</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">90</span>, <span class="number">30</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select * from student group by name;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 传统方式：</span></span><br><span class="line"><span class="comment">         * 1. 循环列表</span></span><br><span class="line"><span class="comment">         * 2. 取出学生名字</span></span><br><span class="line"><span class="comment">         * 3. 检查map中是否存在该名字，不存在则直接添加到该map中；存在则将map中的List对象取出来，然后将该Student对象添加到List中</span></span><br><span class="line"><span class="comment">         * 4. 返回map对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流方式，一行代码</span></span><br><span class="line">        Map&lt;String, List&lt;Student&gt;&gt; map = students.stream().collect(Collectors.groupingBy(Student::getName));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  select count(*) from student group by name;</span></span><br><span class="line">        Map&lt;String, Long&gt; map1 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting()));</span><br><span class="line">        System.out.println(map1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个人的平均分</span></span><br><span class="line">        Map&lt;String, Double&gt; map2 = students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore)));</span><br><span class="line">        System.out.println(map2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分区是分组的一种特例，就是用条件来分为两组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; map3 = students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= <span class="number">90</span>));</span><br><span class="line">        System.out.println(map3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Stream源码解析</title>
    <url>/2017/02/10/java/jdk8-5/</url>
    <content><![CDATA[<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>我们看一下Stream API里很重要的collect函数。</p>
<ol>
<li>collect是一个收集器。</li>
<li>Collector作为collect方法的参数</li>
<li>Collector是一个接口，它是一个可变的汇聚操作，将输入元素累积到一个可变的结果容器中；它会在所有元素都处理完毕之后，将累积的结果转换为一个最终的表示（这是一个可选操作）；它支持串行与并行两种方式执行。</li>
<li>Collectors提供了关于Collector的常见汇聚实现，Collectors本身实际上是一个工厂。</li>
<li>为了确保串行与并行操作结果的等价性，Collector函数需要满足两个条件：identity（同一性）与associativity（结合性）</li>
<li>a == combiner.apply(a, supplier.get())</li>
<li>函数式编程最大的特点：表示做什么，而不是如何做。<a id="more"></a>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student5 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4, student5);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().collect(toList());</span><br><span class="line">        students1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + students.stream().collect(counting()));</span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + students.stream().count());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        students.stream().collect(minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br><span class="line">        students.stream().collect(maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br><span class="line">        System.out.println(students.stream().collect(averagingInt(Student::getScore)));</span><br><span class="line">        System.out.println(students.stream().collect(summingInt(Student::getScore)));</span><br><span class="line">        System.out.println(students.stream().collect(summarizingInt(Student::getScore)));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(students.stream().map(Student::getName).collect(joining(<span class="string">&quot;, &quot;</span>)));</span><br><span class="line">        System.out.println(students.stream().map(Student::getName).collect(joining(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;&lt;being&gt;&quot;</span>, <span class="string">&quot;&lt;end&gt;&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = students.stream()</span><br><span class="line">                .collect(groupingBy(Student::getScore, groupingBy(Student::getName)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; map2 = students.stream().collect(partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>));</span><br><span class="line">        System.out.println(map2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; map3 = students.stream()</span><br><span class="line">                .collect(partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>, partitioningBy(student -&gt; student.getScore() &gt; <span class="number">90</span>)));</span><br><span class="line">        System.out.println(map3);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, Long&gt; map4 = students.stream().collect(partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>, counting()));</span><br><span class="line">        System.out.println(map4);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Student&gt; map5 = students.stream().collect(groupingBy(Student::getName, collectingAndThen(minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));</span><br><span class="line">        System.out.println(map5);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用Collectors.toList举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                   (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CollectorImpl就是Collector的一个实现类，这个构造方法的参数我理解如下：</p>
<ol>
<li>第一个参数Supplier，就是生成一个容器用来装需要收集的元素，这里是一个ArrayList</li>
<li>第二个参数是一个BiConsumer，这里叫做累加器，操作内容就是把流里的元素放进容器里</li>
<li>第三个参数combiner是一个BinaryOperator类型，只有在并发流的时候才会用到，意思就是并发的时候会有多个Supplier各自进行收集，最后combiner会把这些结果集合并在一起。</li>
</ol>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-比较器Comparator</title>
    <url>/2017/02/26/java/jdk8-6/</url>
    <content><![CDATA[<h3 id="比较器详解"><a href="#比较器详解" class="headerlink" title="比较器详解"></a>比较器详解</h3><p>关于比较器我们经常在排序的时候用到，按照某个属性排序。比如我们按照学生的成绩排序，如果成绩相等呢，我们再按照姓名排序。</p>
<p>在Java 8中，Comparator新增了不少默认方法以及静态方法，我们要把这些东西用起来。</p>
<a id="more"></a>
<p>看看示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串长度升序</span></span><br><span class="line">        list.sort((item1, item2) -&gt; item1.length() - item2.length());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        list.sort(Comparator.comparingInt(String::length));</span><br><span class="line">        <span class="comment">//这行代码会报错</span></span><br><span class="line">        list.sort(Comparator.comparingInt(o -&gt; o.length()).reversed());</span><br><span class="line">        <span class="comment">// 字符串长度降序</span></span><br><span class="line">        list.sort(Comparator.comparingInt(String::length).reversed());</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看一下为什么list.sort(Comparator.comparingInt(o -&gt; o.length()).reversed());<br>会报错呢？其实改成list.sort(Comparator.comparingInt((String o) -&gt; o.length()).reversed());，我们主动加上lambda表达式的类型声明，也是可以的，这是因为Java的类型推断，只能推断一层，我们看comparingInt的参数泛型是&lt;? super T&gt;，而reversed()方法才是最后调用的一个方法，所以Java就只能推断出reversed()方法泛型是什么。而推断不出Comparator.comparingInt的参数泛型应该是什么了。<br>所以这个例子如果我们去掉reversed方法，list.sort(Comparator.comparingInt(o -&gt; o.length());这样写也是可以正常运行的。</p>
<p>接着看thenComparing方法，解读一下文档，说的就是只在第一个比较器比较的结果是相等的时候，才会执行第二个执行比较器，如果不相等的话，那么第二个比较器是不会执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-自定义收集器和注意事项</title>
    <url>/2017/02/26/java/jdk8-7/</url>
    <content><![CDATA[<h3 id="自定义收集器"><a href="#自定义收集器" class="headerlink" title="自定义收集器"></a>自定义收集器</h3><p>之前我们简单说过了Collector接口，以及他的简单使用，现在我们来尝试自定义一个收集器，来进行更加深刻的理解。</p>
<p>Collector的5个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;    </span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 收集器特性，只有3个值，CONCURRENT，UNORDERED，IDENTITY_FINISH</span></span><br><span class="line"><span class="comment">// CONCURRENT标识同一个结果容器可以由多个线程多次调用。</span></span><br><span class="line"><span class="comment">// UNORDERED标识收集器并不承诺保证流的顺序。</span></span><br><span class="line"><span class="comment">// IDENTITY_FINISH标识finisher函数就是identity函数。</span></span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>了解以上接口方法后，我们来自己实现一个收集器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生结果容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累加器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accumulator invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Set&lt;T&gt;::add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于并行流，将多个部分的执行结果合并起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并后返回最终的结果类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finisher invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = list.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked</span><br><span class="line">characteristics invoked</span><br><span class="line">[world, hello, welcome]</span><br></pre></td></tr></table></figure>

<p>首先说明一点，因为这些返回都是函数式接口，所以方法被调用了，也不意味着行为被执行了。</p>
<p>我们来看一下collect方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;</span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的不是并行流，就直接看evaluate(ReduceOps.makeRef(collector));这一行代码，我们再进ReduceOps.makeRef看一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, I&gt; TerminalOp&lt;T, I&gt;</span><br><span class="line">makeRef(Collector&lt;? <span class="keyword">super</span> T, I, ?&gt; collector) &#123;</span><br><span class="line">    Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span><br><span class="line">    BiConsumer&lt;I, ? <span class="keyword">super</span> T&gt; accumulator = collector.accumulator();</span><br><span class="line">    BinaryOperator&lt;I&gt; combiner = collector.combiner();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReducingSink</span> <span class="keyword">extends</span> <span class="title">Box</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">AccumulatingSink</span>&lt;<span class="title">T</span>, <span class="title">I</span>, <span class="title">ReducingSink</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">            state = supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            accumulator.accept(state, t);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(ReducingSink other)</span> </span>&#123;</span><br><span class="line">            state = combiner.apply(state, other.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReduceOp&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReducingSink <span class="title">makeSink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReducingSink();</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span><br><span class="line">                   ? StreamOpFlag.NOT_ORDERED</span><br><span class="line">                   : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到下面的代码就已经执行了这3个方法，来获取3个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span><br><span class="line">BiConsumer&lt;I, ? <span class="keyword">super</span> T&gt; accumulator = collector.accumulator();</span><br><span class="line">BinaryOperator&lt;I&gt; combiner = collector.combiner();</span><br></pre></td></tr></table></figure>

<p>那么为什么characteristics()方法调用了2次呢，看看上面的源码就知道，一处是在getOpFlags方法调用的，一处是在collect的最后一行代码里调用的。</p>
<p>如果Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, UNORDERED));把IDENTITY_FINISH去掉，那么就会调用finisher方法。</p>
<h3 id="自定义收集器深度剖析和并行流陷阱"><a href="#自定义收集器深度剖析和并行流陷阱" class="headerlink" title="自定义收集器深度剖析和并行流陷阱"></a>自定义收集器深度剖析和并行流陷阱</h3><p>接下里我们自定义的一个Collector目的是要把一个list转换成一个map，不过要求Supplier返回是一个Set。意思就是Collector&lt;T,A,R&gt;3个泛型参数，A和R的类型是不一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生结果容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累加器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accumulator invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;accumulator: &quot;</span> + set +  Thread.currentThread().getName());</span><br><span class="line">            set.add(item);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于并行流，将多个部分的执行结果合并起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并后返回最终的结果类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set -&gt; &#123;</span><br><span class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            set.forEach(item -&gt; map.put(item, item));</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就不能再写IDENTITY_FINISH了，因为A和R的类型不一样，如果写了会报一个强制转换的异常。</span></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = list.stream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked</span><br><span class="line">characteristics invoked</span><br><span class="line">finisher invoked</span><br><span class="line">&#123;a&#x3D;a, b&#x3D;b, world&#x3D;world, c&#x3D;c, d&#x3D;d, e&#x3D;e, f&#x3D;f, g&#x3D;g, hello&#x3D;hello, welcome&#x3D;welcome&#125;</span><br></pre></td></tr></table></figure>
<p>上面写到不能再添加IDENTITY_FINISH，否则会出错，原因就在于之前我们解释的过的源码中的一行代码，就是collect的源码中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">               ? (R) container</span><br><span class="line">               : collector.finisher().apply(container);</span><br></pre></td></tr></table></figure>
<p>很明显，如果包含了IDENTITY_FINISH枚举，那么会执行(R) container。直接进行强制转换，在我们这里的container的e类型是Set,R是Map，那么这行代码就是把Set强制转换成一个Map，当然我们就会得到一个强制类型转换的异常。这也说明一个问题，characteristics并不能乱写，所以我们要理解这个函数的每一个枚举的含义，才能在开发中很好的运用。</p>
<p>接下来我们进行一个改造，把stream换成parallelStream。<br>运行一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">characteristics invoked</span><br><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: []main</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-1</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-2</span><br><span class="line">characteristics invoked</span><br><span class="line">finisher invoked</span><br><span class="line">&#123;a&#x3D;a, b&#x3D;b, world&#x3D;world, c&#x3D;c, d&#x3D;d, e&#x3D;e, f&#x3D;f, g&#x3D;g, hello&#x3D;hello, welcome&#x3D;welcome&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到有多个线程进行了累加器的调用。<br>我们再改一行代码</p>
<pre><code>return Collections.unmodifiableSet(EnumSet.of(UNORDERED, CONCURRENT);</code></pre>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">characteristics invoked</span><br><span class="line">characteristics invoked</span><br><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, f, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, f, g, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, e, f, g, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, b, e, f, g, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">accumulator: [a, hello, welcome]main</span><br><span class="line">accumulator: [a, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">2</span></span><br><span class="line">accumulator: [a, hello, welcome]ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">characteristics invoked</span><br><span class="line">finisher invoked</span><br><span class="line">&#123;a=a, b=b, c=c, world=world, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>

<p>这有个很明显的差别，就是累加器输出的时候，打印set的值[]差别很大，这个不是偶然的，我们看CONCURRENT的api解释：<strong>允许有多个线程操作同一个结果容器，并且只能被用于无序(UNORDERED)的流</strong>。反过来想一下，如果没有加CONCURRENT特性，那么并行流就是有几个线程，就有几个结果容器被操作了，</p>
<p>我们多执行几次代码，可能会得到一个<code>ConcurrentModificationException</code>的异常，可是，如果我们把测试代码中打印set值的代码去掉，无论你执行多少次，也不会出现这个异常。<br>我们看一下<code>ConcurrentModificationException </code>的说明： This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible. For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it.<br>意思很明确了，不允许一个线程在修改的时候，另一个线程同时又在迭代它。所以我们要在实际开发中，避免在累加器中对中间结果容器进行额外的操作。</p>
<p>那么如何证明加了CONCURRENT之后就只有一个中间结果容器，不加就就有多个中间结果容器呢(多个线程多个容器，所以不会有ConcurrentModificationException)，用combiner就能测试了，因为只有一个中间结果容器的话，combiner根本不会执行。</p>
<p>我们把代码改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set1: &quot;</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">&quot;set1: &quot;</span> + set2);</span><br><span class="line">        set1.addAll(set2);</span><br><span class="line">        <span class="keyword">return</span> set1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加CONCURRENT:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">characteristics invoked</span><br><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-1 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-2 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-1 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-1 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-2 hashcode: 0</span><br><span class="line">set1: [hello]</span><br><span class="line">set1: [hello]</span><br><span class="line">set1: [world]</span><br><span class="line">set1: [f]</span><br><span class="line">set1: [g]</span><br><span class="line">set1: [a]</span><br><span class="line">set1: [welcome]</span><br><span class="line">set1: [e]</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">set1: [f, g]</span><br><span class="line">set1: [a, hello]</span><br><span class="line">set1: [world, hello]</span><br><span class="line">set1: [a, hello, welcome]</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">accumulator: []main hashcode: 0</span><br><span class="line">set1: [c]</span><br><span class="line">set1: [d]</span><br><span class="line">set1: [b]</span><br><span class="line">set1: [c, d]</span><br><span class="line">set1: [b, c, d]</span><br><span class="line">set1: [e, f, g]</span><br><span class="line">set1: [a, world, hello, welcome]</span><br><span class="line">set1: [b, c, d, e, f, g]</span><br><span class="line">characteristics invoked</span><br><span class="line">finisher invoked</span><br><span class="line">&#123;a&#x3D;a, b&#x3D;b, world&#x3D;world, c&#x3D;c, d&#x3D;d, e&#x3D;e, f&#x3D;f, g&#x3D;g, hello&#x3D;hello, welcome&#x3D;welcome&#125;</span><br></pre></td></tr></table></figure>

<p>加了CONCURRENT之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">characteristics invoked</span><br><span class="line">characteristics invoked</span><br><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-1 hashcode: 0</span><br><span class="line">accumulator: [welcome]ForkJoinPool.commonPool-worker-1 hashcode: 1233099618</span><br><span class="line">accumulator: [a, welcome]ForkJoinPool.commonPool-worker-1 hashcode: 1233099715</span><br><span class="line">accumulator: []main hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-2 hashcode: 0</span><br><span class="line">accumulator: []ForkJoinPool.commonPool-worker-3 hashcode: 0</span><br><span class="line">accumulator: [a, world, hello, welcome]ForkJoinPool.commonPool-worker-2 hashcode: 1445580839</span><br><span class="line">accumulator: [a, hello, welcome]ForkJoinPool.commonPool-worker-1 hashcode: 1332262037</span><br><span class="line">accumulator: [a, world, e, hello, welcome]ForkJoinPool.commonPool-worker-2 hashcode: 1445580940</span><br><span class="line">accumulator: [a, world, hello, welcome]ForkJoinPool.commonPool-worker-3 hashcode: 1445580839</span><br><span class="line">accumulator: [a, world, e, f, hello, welcome]ForkJoinPool.commonPool-worker-1 hashcode: 1445581042</span><br><span class="line">characteristics invoked</span><br><span class="line">finisher invoked</span><br><span class="line">&#123;a&#x3D;a, b&#x3D;b, world&#x3D;world, c&#x3D;c, d&#x3D;d, e&#x3D;e, f&#x3D;f, g&#x3D;g, hello&#x3D;hello, welcome&#x3D;welcome&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到的，加了CONCURRENT之后根本就没有执行combiner方法。<br>所以我们可以再总结一下combiner的使用说明，就是在并行流，并且收集器的特性没有CONCURRENT特性的时候，combiner才会被调用。</p>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Collectors工厂类源码探索</title>
    <url>/2017/02/26/java/jdk8-8/</url>
    <content><![CDATA[<h3 id="Collectors静态工厂类"><a href="#Collectors静态工厂类" class="headerlink" title="Collectors静态工厂类"></a>Collectors静态工厂类</h3><p>对于Collectors静态工厂类来说，其实现一共分为两种情况：</p>
<ol>
<li>通过CollectorImpl来实现。</li>
<li>通过reducing方法来实现, reducing方法本身又是通过CollectorImpl实现的。<a id="more"></a>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法现在来看也很简单了，3个参数，supplier，accumulator，combiner，然后characteristics是CH_ID，就是IDENTITY_FINISH，那么也就不需要finisher方法了。</p>
<p>toList是实现是ArrayList，如果我们需要LinkedList怎么办呢。我们需要用toCollection方法，接收一个Supplier，指定为<code>LinkedList:new</code>就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                               (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的joining就是用了finisher，因为A和R类型不一样(StringBuilder和String)，需要用finishder来转换一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>collectingAndThen的实现就是把FINISH_IDENTITY的特性给移除了，然后再给finisher()加一个andThen操作，对结果再次进行一个转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="title">collectingAndThen</span><span class="params">(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</span> </span>&#123;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = downstream.characteristics();</span><br><span class="line">    <span class="keyword">if</span> (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (characteristics.size() == <span class="number">1</span>)</span><br><span class="line">            characteristics = Collectors.CH_NOID;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            characteristics = EnumSet.copyOf(characteristics);</span><br><span class="line">            characteristics.remove(Collector.Characteristics.IDENTITY_FINISH);</span><br><span class="line">            characteristics = Collections.unmodifiableSet(characteristics);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               downstream.accumulator(),</span><br><span class="line">                               downstream.combiner(),</span><br><span class="line">                               downstream.finisher().andThen(finisher),</span><br><span class="line">                               characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapping函数，就是在累加器执行之前，对参数进行一个类型转换，这也会导致返回类型改变。举例如下，首先根据人的城市分组，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity = people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet())));</span><br></pre></td></tr></table></figure>
<p>源码如下,结合上面的例子来看，就是toSet()本来应该是Set<Person>，但是因为mapping把累加器的类型由Person改成了String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                           Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream) &#123;</span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> U&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               (r, t) -&gt; downstreamAccumulator.accept(r, mapper.apply(t)),</span><br><span class="line">                               downstream.combiner(), downstream.finisher(),</span><br><span class="line">                               downstream.characteristics());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>counting方法，就是初始值为0，每个元素映射成1，然后再加起来。后面的minBy,maxBy也都是通过reducing来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting() &#123;</span><br><span class="line">	<span class="keyword">return</span> reducing(<span class="number">0L</span>, e -&gt; <span class="number">1L</span>, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>summarizingInt方法，为什么第一个参数是一个数组呢，而不是直接一个值，因为累加器accumulator是BiConsumer，接受2个参数，不返回值，如果要进行累加的话，只能通过容器来累加，如果直接是一个值的话，没办法传递，也没有办法累加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>],</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] += mapper.applyAsInt(t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] += b[<span class="number">0</span>]; <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-memcached框架配置</title>
    <url>/2015/02/06/java/mybatis-memcached%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>官方放出了mybatis和memcached的整合包，先附上官方文档地址<br><a href="http://mybatis.github.io/memcached-cache/">http://mybatis.github.io/memcached-cache/</a><br>文档很简洁，事实证明使用起来也很简单<br>memcached的安装我这里就不再讲了，网上很容易找到<br>在项目中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-memcached<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后在想使用的mapper中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.acme.FooMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.memcached.MemcachedCache&quot;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就可以用了</p>
<p>再建一个memcached.properties，对他进行配置<br>我简单测试了一下发现它可以配置多个服务器，用逗号分隔，经测试如果某一台挂掉，他会选择正常的那台<br>如果2台都挂掉，就会报错,估计我们还是希望在memcached服务器挂掉后从数据库读取数据，不知道大家有什么好的实现方式或者思路吗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.mybatis.caches.memcached.servers&#x3D;172.29.33.201:11211,localhost:11211</span><br><span class="line">org.mybatis.caches.memcached.expiration&#x3D;30 </span><br><span class="line">org.mybatis.caches.memcached.asyncget&#x3D;false </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security配置cors跨域访问</title>
    <url>/2016/12/29/java/spring-security-cors/</url>
    <content><![CDATA[<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cors.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cors.html</a></p>
<p>文档看似很清晰的描述了如何在Spring 4.2之后启用cors跨域访问，网上搜索介绍这样的帖子也不少。也提到了说什么如果用了Spring Security的话要采用filter的方式来配置。下面这段话就是官方文档</p>
<blockquote>
<p>In order to support CORS with filter-based security frameworks like Spring Security, or with other libraries that do not support natively CORS, Spring Framework also provides a CorsFilter. Instead of using @CrossOrigin or WebMvcConfigurer#addCorsMappings(CorsRegistry), you need to register a custom filter defined like bellow:</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCorsFilter</span> <span class="keyword">extends</span> <span class="title">CorsFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyCorsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(configurationSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UrlBasedCorsConfigurationSource <span class="title">configurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">		config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">		config.addAllowedOrigin(<span class="string">&quot;http://domain1.com&quot;</span>);</span><br><span class="line">		config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">		config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">		UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">		source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">		<span class="keyword">return</span> source;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过测试之后，实在是无论采用哪一种方式都不行，实在是太费解了，debug了半天跨域的时候GET方法根本连DispatchServlet都不进去，POST方法倒是可以跨域，发现POST请求是根据header的origin来判断是否跨域。</p>
<p>还是想着从Spring Security这边来入手，结果就发现HttpSecurity类提供了这么一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a &#123;<span class="doctag">@link</span> CorsFilter&#125; to be used. If a bean by the name of corsFilter is</span></span><br><span class="line"><span class="comment"> * provided, that &#123;<span class="doctag">@link</span> CorsFilter&#125; is used. Else if corsConfigurationSource is</span></span><br><span class="line"><span class="comment"> * defined, then that &#123;<span class="doctag">@link</span> CorsConfiguration&#125; is used. Otherwise, if Spring MVC is</span></span><br><span class="line"><span class="comment"> * on the classpath a &#123;<span class="doctag">@link</span> HandlerMappingIntrospector&#125; is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the &#123;<span class="doctag">@link</span> CorsConfigurer&#125; for customizations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CorsConfigurer&lt;HttpSecurity&gt; <span class="title">cors</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getOrApply(<span class="keyword">new</span> CorsConfigurer&lt;HttpSecurity&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我抱着试一试的心态，加上了这句话代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.headers()</span><br><span class="line">            .frameOptions()</span><br><span class="line">            .sameOrigin()</span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">// disable CSRF, http basic, form login</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">// 跨域支持</span></span><br><span class="line">            .cors().and()</span><br><span class="line"></span><br><span class="line">            .httpBasic().disable() <span class="comment">//</span></span><br><span class="line">            .formLogin().disable()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ReST is stateless, no sessions</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            .and()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return 403 when not authenticated</span></span><br><span class="line">            .exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> NoAuthenticationEntryPoint());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let child classes set up authorization paths</span></span><br><span class="line">    setupAuthorization(http);</span><br><span class="line"></span><br><span class="line">    http.addFilterBefore(jsonWebTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是<code>.cors().and()</code>这句了，然后还是采用<code>addCorsMappings</code>方法来配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">			.allowedOrigins(<span class="string">&quot;http://domain2.com&quot;</span>)</span><br><span class="line">			.allowedMethods(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">			.allowedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>, <span class="string">&quot;header3&quot;</span>)</span><br><span class="line">			.exposedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>)</span><br><span class="line">			.allowCredentials(<span class="keyword">false</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果当然是成功了，Spring的文档也老是跟不上节奏，还是需要自己多探索和思考。希望能帮到遇到这个问题的朋友们。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Security OAuth2 定制错误消息</title>
    <url>/2019/01/09/java/spring-security-oauth2-custom-exception-response/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在搭建一个Spring Cloud的项目，在搭建途中，遇到了一些问题，这里记录一下。<br>在搭建AuthorizationServer的时候，就遇到了问题，我的授权模式是用的password模式，然后是集成了JWT生成access_token。</p>
<p>基本上我是参照这个项目搭建的，<a href="https://gitee.com/log4j/pig">https://gitee.com/log4j/pig</a> 。不过因为只是参考，所以我还做了一些改动，而且我们Spring Cloud的版本也不一样，我是F版的。</p>
<a id="more"></a>

<h2 id="问题1-oauth-token-401问题"><a href="#问题1-oauth-token-401问题" class="headerlink" title="问题1 /oauth/token 401问题"></a>问题1 /oauth/token 401问题</h2><p>在AuthorizationServer搭建完成以后，启动访问/oauth/token接口获取access_token。传入用户名和密码，然后一直得到一个401错误，日志也没有，我最开始还以为是Spring Security把这个接口给拦截了，后来DEBUG了一下源码，发现在BasicAuthenticationFilter.doFilterInternal()里有这么一句判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String header = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (header == <span class="keyword">null</span> || !header.toLowerCase().startsWith(<span class="string">&quot;basic &quot;</span>)) &#123;</span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是如果你的header里面没有Authorization(BasicAuthenticationFilter.doFilterInternal)，或者Authorization不是以basic 开头的，直接就返回401了。虽然我忘记了传这个参数，但是日志里没有任何提示，这个错误真是让我好一顿找才给解决。</p>
<p>这里面是<code>client_id:client_secret</code>的base64编码。到这还没完，因为Spring Cloud F版会有那个PasswordEncoder，所以他在校验secret的时候会和服务器配置的时候会进行加密，如果存储的密钥不是相应的加密方式，他也会报错，这个错误在网上都搜得到了。</p>
<p><a href="http://springcloud.cn/view/13">Spring Security 4.x -&gt; 5.x 踩坑记录</a></p>
<p>DaoAuthenticationProvider.additionalAuthenticationChecks()方法里，就是检查密码的地方。</p>
<h2 id="问题2-Unsupported-grant-type-password"><a href="#问题2-Unsupported-grant-type-password" class="headerlink" title="问题2 Unsupported grant type: password"></a>问题2 Unsupported grant type: password</h2><p>接着我又开始遇到这个错误，搜了一下说是AuthenticationManager无法注入。</p>
<p>在AuthorizationServerEndpointsConfigurer.getDefaultTokenGranters里面，如果AuthenticationManager类的实例的话，那么就不支持password的授权模式，也就是ResourceOwnerPasswordTokenGranter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TokenGranter&gt; <span class="title">getDefaultTokenGranters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ClientDetailsService clientDetails = clientDetailsService();</span><br><span class="line">	AuthorizationServerTokenServices tokenServices = tokenServices();</span><br><span class="line">	AuthorizationCodeServices authorizationCodeServices = authorizationCodeServices();</span><br><span class="line">	OAuth2RequestFactory requestFactory = requestFactory();</span><br><span class="line"></span><br><span class="line">	List&lt;TokenGranter&gt; tokenGranters = <span class="keyword">new</span> ArrayList&lt;TokenGranter&gt;();</span><br><span class="line">	tokenGranters.add(<span class="keyword">new</span> AuthorizationCodeTokenGranter(tokenServices, authorizationCodeServices, clientDetails,</span><br><span class="line">			requestFactory));</span><br><span class="line">	tokenGranters.add(<span class="keyword">new</span> RefreshTokenGranter(tokenServices, clientDetails, requestFactory));</span><br><span class="line">	ImplicitTokenGranter implicit = <span class="keyword">new</span> ImplicitTokenGranter(tokenServices, clientDetails, requestFactory);</span><br><span class="line">	tokenGranters.add(implicit);</span><br><span class="line">	tokenGranters.add(<span class="keyword">new</span> ClientCredentialsTokenGranter(tokenServices, clientDetails, requestFactory));</span><br><span class="line">	<span class="keyword">if</span> (authenticationManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">		tokenGranters.add(<span class="keyword">new</span> ResourceOwnerPasswordTokenGranter(authenticationManager, tokenServices,</span><br><span class="line">				clientDetails, requestFactory));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tokenGranters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://springcloud.cn/view/13">Spring Security 4.x -&gt; 5.x 踩坑记录</a>的也提到了这个问题，不过我这里遇到了更奇怪的现象，在WebSecurityConfigurerAdapter加上下面的配置后，并没有解决我的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果我发现在我的项目中，AuthorizationServerConfig竟然比WebSecurityConfigurer先加载，所以在<code>public void configure(AuthorizationServerEndpointsConfigurer endpoints)</code>注入并设置endpoints.authenticationManager(authenticationManager)的时候，放的是一个null进去。</p>
<p>我还觉得蛮奇怪的，下面的代码也会注入一个null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br></pre></td></tr></table></figure>

<p>然后我把这个参数改到构造方法里面去启动，结果就告诉我循环依赖，后来想了想，可能是因为Spring在处理循环依赖的时候，把一些注入类自动处理成null了。</p>
<p>在我解决了循环依赖以后，我就能登录成功了。</p>
<h2 id="问题3-如何定制BadCredentialsException-UserNameNotFound的异常消息"><a href="#问题3-如何定制BadCredentialsException-UserNameNotFound的异常消息" class="headerlink" title="问题3 如何定制BadCredentialsException,UserNameNotFound的异常消息"></a>问题3 如何定制BadCredentialsException,UserNameNotFound的异常消息</h2><p>接下来就是输入错误密码的时候得到的错误了，如果用户名或者密码错误了，Spring Security会返回一个</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;error&quot;</span>: <span class="string">&quot;invalid_grant&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;error_ description&quot;</span>: <span class="string">&quot;坏的凭证&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个错误信息太不友好了，我们一般给客户端返回的消息都是统一标准的格式，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;code&quot;</span>:<span class="string">&quot;401&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;msg&quot;</span>:<span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样另类的消息格式是绝对不允许的。所以我就想定制化这个消息格式，是相信Spring Security肯定提供了相应的机制来供我们实现这个消息的定制，我先是在网上搜了很久，都没有找到解决方案，只是找到了一些哥们跟我有同样的问题，但是却没有人给出解决方案。</p>
<p>比如这个stackoverflow.com上的这个<a href="https://stackoverflow.com/questions/38109842/how-to-change-the-badcredentialsexception-usernamenotfound-exception-messages-in">哥们</a>。</p>
<p>没办法了，找不到方案就自己想办法吧，我就从抛出异常的地方开始一行一行的debug，接着发现这个异常被TokenEndpoint类里的一个ExceptionHandler给拦截然后输出的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(OAuth2Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;OAuth2Exception&gt; <span class="title">handleException</span><span class="params">(OAuth2Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">		logger.warn(<span class="string">&quot;Handling error: &quot;</span> + e.getClass().getSimpleName() + <span class="string">&quot;, &quot;</span> + e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getExceptionTranslator().translate(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么这个getExceptionTranslator到底是个什么东西，最后翻了一下到底是在哪里设置的这个属性，最终发现是AuthorizationServerEndpointsConfigurer的一个字段，是不是很眼熟？</p>
<p>和设置AuthenticationManager的是同一个类，所以定制一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebResponseExceptionTranslator</span> <span class="keyword">implements</span> <span class="title">WebResponseExceptionTranslator</span>&lt;<span class="title">OAuth2Exception</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(RestResp.error(CommonErrorCode.AUTHORIZED_ERROR), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在AuthorizationServerConfig里加上配置，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    endpoints</span><br><span class="line">            <span class="comment">//......其他配置</span></span><br><span class="line">            .exceptionTranslator(customWebResponseExceptionTranslator)</span><br><span class="line">            .authenticationManager(authenticationManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>最后得到了我们想要的输出结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;401&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题4-invalid-token-错误消息定制"><a href="#问题4-invalid-token-错误消息定制" class="headerlink" title="问题4 invalid_token 错误消息定制"></a>问题4 invalid_token 错误消息定制</h2><p>如果传入的token是错误的，那么会得到这样格式的一个错误消息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;invalid_token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;error_description&quot;</span>: <span class="string">&quot;Cannot convert access token to JSON&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上有可能是这个token在redis里没有等好几种错误</p>
<p>DefaultTokenServices.loadAuthentication(String accessTokenValue)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;Invalid access token: &quot;</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (accessToken.isExpired()) &#123;</span><br><span class="line">	tokenStore.removeAccessToken(accessToken);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;Access token expired: &quot;</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OAuth2Authentication result = tokenStore.readAuthentication(accessToken);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// in case of race condition</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;Invalid access token: &quot;</span> + accessTokenValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要定制化这个错误消息，需要制定一个AuthExceptionEntryPoint.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthExceptionEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Token失效，禁止访问 &#123;&#125;&quot;</span>, request.getRequestURI());</span><br><span class="line">        response.setCharacterEncoding(StandardCharsets.UTF_8.displayName());</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">        RestResp result = RestResp.error(CommonErrorCode.UNAUTHORIZED, <span class="string">&quot;Token错误&quot;</span>);</span><br><span class="line">        response.setStatus(HttpStatus.SC_OK);</span><br><span class="line">        PrintWriter printWriter = response.getWriter();</span><br><span class="line">        printWriter.append(objectMapper.writeValueAsString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后ResourceServerConfiguration里增加配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;</span><br><span class="line">    resources.expressionHandler(expressionHandler);</span><br><span class="line">    resources.authenticationEntryPoint(authExceptionEntryPoint);</span><br><span class="line">    resources.accessDeniedHandler(iuMiaoAccessDeniedHandler);</span><br><span class="line">    resources.tokenStore(redisTokenStore());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就能得到自定义的错误。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;10000401&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;未授权: Token错误&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK集合源码-List</title>
    <url>/2020/10/13/jdk/jdk01/</url>
    <content><![CDATA[<h1 id="JDK集合源码"><a href="#JDK集合源码" class="headerlink" title="JDK集合源码"></a>JDK集合源码</h1><p>准备写一些文章，把集合、并发、网络相关的JDK工具的使用和源码都在这里记录一下。首先从简单的集合源码开始。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>基于数组的集合，默认的构造函数，给了一个空数组，Object[]， {}，默认的初始化大小为10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在构造ArrayList，建议指定一个大小，避免频繁扩容带来的开销。</p>
</blockquote>
<p>每次往ArrayList中插入数据的时候，都会判断当前数组的元素是否塞满了，如果塞满的话，此时就会扩容这个数组，然后将老数组中的元素拷贝到新数组中去，确保说数组一定是可以承受足够多的元素的。</p>
<a id="more"></a>

<h4 id="add-方法的源码"><a href="#add-方法的源码" class="headerlink" title="add()方法的源码"></a>add()方法的源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经满了，会扩容大约1.5倍</span></span><br><span class="line">    <span class="comment">// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span><br><span class="line">    <span class="comment">// 然后利用Arrays.copyOf，将老数据复制到新数组中</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// 大约是1.5倍</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  <span class="comment">// 将老数据的数据复制到新的数组里</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="set-方法的源码"><a href="#set-方法的源码" class="headerlink" title="set()方法的源码"></a>set()方法的源码</h4><p>set源码比较简单，就是检查索引是否超出边界，然后做一个值的替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-index-element-方法的源码"><a href="#add-index-element-方法的源码" class="headerlink" title="add(index, element)方法的源码"></a>add(index, element)方法的源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查索引是否越界</span></span><br><span class="line">  rangeCheckForAdd(index);</span><br><span class="line">  <span class="comment">// 检查容量是否够了</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">// 关键代码，将某个索引后的数据往数组后面复制，也就是相当于数据往后移动一位</span></span><br><span class="line">  System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                   size - index);</span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-方法的源码"><a href="#get-方法的源码" class="headerlink" title="get()方法的源码"></a>get()方法的源码</h4><p>这个简单，就是直接根据索引返回数组里的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-方法的源码"><a href="#remove-方法的源码" class="headerlink" title="remove()方法的源码"></a>remove()方法的源码</h4><p>删除某一个元素，就是从某一个元素开始往前移动一位，然后将最后一位重置为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 往前移动</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>remove()<br>add(index, element)</p>
<p>这个两个方法，都会导致数组的拷贝，大量元素的挪动，性能都不是太高，基于数组来做这种随机位置的插入和删除，其实性能真的不是太高</p>
<p>add()、add(index, element)，这两个方法，都可能会导致数组需要扩容，数组长度是固定的，默认初始大小是10个元素，如果不停的往数组里塞入数据，可能会导致瞬间数组不停的扩容，影响系统的性能</p>
<p>set()、get()，定位到随机的位置，替换那个元素，或者是获取那个元素，这个其实还是比较靠谱的，基于数组来实现随机位置的定位，性能是很高的</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList，是一个双向链表。</p>
<p>![image-20201013184959422](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013184959422.png)</p>
<p>add()，默认就是在队列的尾部插入一个元素，在那个双向链表的尾部插入一个元素<br>add(index, element)，是在队列的中间插入一个元素<br>addFirst()，在队列的头部插入一个元素<br>addLast()，跟add()方法是一样的，也是在尾部插入一个元素</p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>在往中间插入数据的时候，会根据传入的索引，找到对应的节点，然后设置到节点的before变量中，那么在查找这个节点的过程中，实际上是一个遍历的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果索引在列表的前半部分，则从前往后开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则从后往前遍历查找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过一些指针的变换操作，来完成插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert succ != null;</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">  succ.prev = newNode;</span><br><span class="line">  <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20201013185212959](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185212959.png)</p>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>**getFirst() == peek()**：获取头部的元素，直接返回first指针指向的那个Node里面的数据，他们都是返回头部的元素。getFirst()如果是对空list调用，会抛异常；peek()对空list调用，会返回null</p>
<p>**getLast()**：获取尾部的元素</p>
<p>get(int index)，需要用到node(index)方法来定位元素，也就是先判断索引在前半部分还是在后半部分，然后遍历来获得元素，性能较低。</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>removeLast()</strong><br><strong>removeFirst() == poll()</strong><br><strong>remove(int index)</strong></p>
<p>删除，也是通过一些指针的替换，将节点脱离出来，item设置为null，然后等待被回收掉。</p>
<p>![image-20201013185444906](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201013185444906.png)</p>
<h3 id="Vector和Stack"><a href="#Vector和Stack" class="headerlink" title="Vector和Stack"></a>Vector和Stack</h3><p>Stack是基于数组的栈结构，而Vector是基于数组的有序集合，Stack是继承于Vector。</p>
<p>栈：先进后出</p>
<p>Stack的push方法，几乎和ArrayList的add一样，顺序设置数组的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elementData[elementCount++] = obj;</span><br></pre></td></tr></table></figure>

<p>但是，ArrayList每次扩容是1.5倍，<code>capacity + (capacity &gt;&gt; 1) = 1.5</code>，Vector每次扩容默认是2倍。</p>
<p>pop()方法，从栈顶弹出一个元素，就是返回最后一个元素，然后删除最后一个元数据，这里会涉及到利用System.arraycopy拷贝数组元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>一个最常见的场景，就是在迭代这个集合的时候，对集合进行remove操作，就一定会遇到这个错误。</p>
<p>这个是集合迭代器的fail-fast机制，每一种集合的数据结构，都有一个modCount的字段，新增和删除元素的时候，会对这个字段进行modCount++操作。</p>
<p>然后在初始化迭代器的时候，会记录初始化的会记录modCount的值到expectedModCount中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 初始化的时候记录modCount的值</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>

<p>然后在后面迭代的的回收，会判断值是否发生改变，如果改变了，就直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK集合源码-Map</title>
    <url>/2020/10/16/jdk/jdk02/</url>
    <content><![CDATA[<h1 id="Map源码"><a href="#Map源码" class="headerlink" title="Map源码"></a>Map源码</h1><p>Map是集合里一个非常重要的数据结构，面试也是会经常问到源码的。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>简单描述一下HashMap的原理，它的结构就是数组+链表+红黑树。</p>
<p>put的时候，对key进行hash，找到对应的数组位置放在里面，然后hash冲突了就组成链表往后追加。查询的时候也是一样，对key进行hash，然后用equals去比较链表上key的值。</p>
<p>JDK1.8优化了hashmap的数据结构，如果链表过长，达到8以后，就会转变成红黑树。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这个数组的初始化长度，是16，和ArrayList不一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组变量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16	</span></span><br><span class="line"><span class="comment">// 初始数组大小，默认是16</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后他有个，负载因子是0.75，意思就是默认情况下，如果数组占用达到了<code>16 * 0.75 = 12</code>，就会开始执行扩容操作了。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 这个就是负载因子值了，默认就是上边这个0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// next指针，就形成了链表</span></span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>看这个put方法的源码，就是有一个hash(key)的方法，用来做key做hash计算，然后定位数组索引用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h4><p>这个hash(key)，并不是简单对hashCode取模得到的一个值，它这里是一个非常高性能的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，key.hashCode()，直接获取到了key的hash值，然后和 h &gt;&gt;&gt; 16做了一个异或的运算。</p>
<p>h &gt;&gt;&gt; 16，就是二进制右移16位，举例，下面是一个hash值的2进制</p>
<p><code>1111 1111 1111 1111 1111 1010 0111 1100</code></p>
<p>右移16位后，高位补0，他就变成了</p>
<p><code>0000 0000 0000 0000 1111 1111 1111 1111</code></p>
<p>然后再做异或操作，也就是<code>h ^ (h &gt;&gt;&gt; 16)</code></p>
<blockquote>
<p>异或：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p>
</blockquote>
<p>所以异或之后的结果是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1010 0111 1100</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line">1111 1111 1111 1111 0000 0101 1000 0011</span><br></pre></td></tr></table></figure>

<p>发现没有，这么做，就实现了int值的，高16位和低16位异或运算，为什么要这么做呢，是跟后面的代码有关系。</p>
<p>在定位数组索引的时候，也用到了一个位运算，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>n就是数组的长度，这个值一般情况下，是比较小的，比如n=16的二进制</p>
<p><code>0000 0000 0000 0000 0000 0000 0001 0000</code></p>
<p>这个值如果去和原始的hash值做位运算，肯定始终都是只会在低16位做运算，高16位，就用不上了。所以提前用hash()方法将高16位和低16位做了位运算后，就能保证在定位数组索引的时候，无论这个n值的大小，也能让hash的高低16位都参与到运算中。</p>
<p>为什么要这样做呢？因为这样做可以<strong>降低hash冲突的概率</strong>，如果说老是用低16位去做运算定位数组索引的话，就会导致一定的hash冲突。</p>
<p>继续看put的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 刚开始，数组都是空的，这里就分配一个默认的大小，也就是16</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// (n - 1) &amp; hash 通过位运算，来实现了一个取模的效果，而且每次扩容，都是2的n次方，只要保证数组的大小是2的n次方，就能保证(n - 1) &amp; hash和 hash % 数组.length取模是一样的效果</span></span><br><span class="line"><span class="comment">// 比直接取模，效率高很多</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>这个取模的优化，是hashmap非常重要的优化点</p>
<h4 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h4><p>接着看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 这个 (n - 1) &amp; hash 很重要</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 满足这个条件，说明是相同的key，覆盖旧的值就好</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 处理红黑树的情况</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的总长度达到了8，那么链表就要转变成红黑树了</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相同的key，替换新的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>这个红黑树的具体算法，非常复杂，有什么翻转，变色什么的，就当成黑盒来看吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环的方式，先转成双向链表，然后转成成一棵树</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合前面的源码看，如果put的时候发现一家是一个红黑树了，那么就是直接往红黑树上挂节点了。</p>
<p><code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code></p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>HashMap基于数组的数据结构，那么必然会有扩容的问题，它的原理就是，达到负载因子的的数量后，就进行2倍扩容，然后rehash，每一个key-value对，都会基于key的hash值重新寻址找到新数组的新的位置。</p>
<p>比如他之前的长度是16，新的数组长度是32</p>
<p>之前那些key的hash可能之前对16取模的位置是5，那么对32取模后，他的位置就变成了11，位置发生了变化。</p>
<p>这是1.7之前的原理，1.8以后，他就不是直接取模了，用的是与运算的位操作来实现高性能的取模操作，但是这个就要求数组的长度必须是2的n次方。</p>
<p>举一个扩容的例子。</p>
<p>还记得寻址的算法么：<code>tab[i = (n - 1) &amp; hash]</code></p>
<p>此时，n=16</p>
<p>第一个key</p>
<p>n - 1    0000 0000 0000 0000 0000 0000 0000 1111</p>
<p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p>
<p>&amp;结果  0000 0000 0000 0000 0000 0000 0000 0101  = 5（index = 5的位置）</p>
<p>第二个key</p>
<p>n - 1 0000 0000 0000 0000 0000 0000 0000 1111</p>
<p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p>
<p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p>
<p>他们就是在同一个位置，然后数组扩容，变成了32</p>
<p>此时，n=32</p>
<p>第一个key</p>
<p>n-1 0000 0000 0000 0000 0000 0000 0001 1111</p>
<p>hash1 1111 1111 1111 1111 0000 1111 0000 0101</p>
<p>&amp;结果 0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）</p>
<p> 第二个key</p>
<p>n-1      0000 0000 0000 0000 0000 0000 0001 1111</p>
<p>hash2 1111 1111 1111 1111 0000 1111 0001 0101</p>
<p>&amp;结果 0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 21的位置）</p>
<p>第一个位置没有变，但是第二个就变成了21。</p>
<p>所以规律是什么？</p>
<ol>
<li>首先，数组的长度肯定是2的倍数，16-&gt;32-&gt;64-&gt;128</li>
<li>扩容之后，key要么在之前的index位置，要么就变成了之前的index（5） + oldCap（16） = 21的位置</li>
</ol>
<p>贴下扩容的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 这就是数组2倍扩容了</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// e.next是null，说明就是一个单节点，直接重新计算一下hash放过去就好了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，就基于红黑树的算法讲每一个节点都重新hash寻址，找到各自的新数组位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 这里就是链表了</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 还是在之前的位置</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 如果是链表，它在新数组的位置就是之前的index+oldCap </span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>HashMap看完了，LinkedHashMap也就简单了，它就是多了一个功能，它会记录你插入的顺序，如果你去遍历LinkedHashMap，是按照你插入的顺序来遍历的。</p>
<p>如果面试官问，LinkedHashMap和TreeMap，都可以维持key顺序，那区别是什么？LinkedHashMap是基于链表实现的，它的顺序是key的插入顺序，TreeMap的基于红黑树实现的，它的顺序是基于key的某个排序算法来排序的。</p>
<p>LinkedHashMap和HashMap的原理，大致是一样的，区别就是在插入、更新、删除的时候，他会记录一下key的顺序。他的put方法，其实也还是调用的HashMap的put方法，但是在执行结束之后，有一个<code>afterNodeInsertion(evict);</code>方法，这个方法在HashMap的实现中是空实现。但是在LinkedHashMap中，他就覆盖了这个方法，其实一共有3个方法在不同的地方会被回调到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>他用了一个链表的结构，来存储了key插入的顺序，这个数据结构就是，直接继承了HashMap的Node，然后增加了before和after参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后每次都会调用linkNodeLast方法， 将这个节点挂在链表的后面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么覆盖，会不会改变他的顺序呢，默认是不会的，</p>
<p>LInkedHashMap有一个字段，accessOrder，可在构造方法的时候传入，如果为true，则访问后也会刷新位置，否则只是插入才会记录位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>为true，get和put方法，都会导致这个key对应的Entry移动到链表的尾部去，删除元素的时候，也会从链表里删除。</p>
<p>迭代的时候，就会从链表的头部，也就是head节点开始按顺序迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>![image-20201020131704780](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201020131704780.png)</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap是用红黑树做的数据结构，用红黑树维护了key的顺序，可以按照指定顺序进行迭代。</p>
<p>它有自己的Entry结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，TreeMap是按照自然排序，也就是字典序来对key进行排序的。如果想定制排序规则的话，可以在构造方法中参数排序比较器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet、LinkedHashSet、TreeSet"><a href="#HashSet、LinkedHashSet、TreeSet" class="headerlink" title="HashSet、LinkedHashSet、TreeSet"></a>HashSet、LinkedHashSet、TreeSet</h2><p>Set的源码，没什么好说的，他其实就是继承自HashMap，然后只用了key的结构，value都是空值。</p>
<p>比如HashSet，LinkedHashSet，TreeSet都是。</p>
<p>HashSet，就是无序的，LinkedHashSet就是插入顺序，TreeSet就是可排序的，都是不可重复的。</p>
]]></content>
      <categories>
        <category>JDK源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>并发源码-线程</title>
    <url>/2020/10/19/jdk/%E5%B9%B6%E5%8F%9101/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程篇知识，主要包括并发编程方面，JUC并发包下的类的源码学习。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>执行main方法后，就会开启一个jvm进程了，进程里，又有很多线程，main线程就是执行程序的第一个线程，然后我们又创建了一个子线程，来执行另外的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>多个线程的执行，是没有先后顺序的，他们会争夺和抢占的CPU的时间，谁先抢到，谁就先执行。</p>
<p>并发编程，无非就是在多线程的情况下去操作同一份数据，或者不同的线程之间需要通信。</p>
<h3 id="Thread-Group"><a href="#Thread-Group" class="headerlink" title="Thread Group"></a>Thread Group</h3><p>ThreadGroup就是线程组，可以把一堆线程放入一个组里，作为一个整体统一管理和设置，这个一般不怎么用。</p>
<p>每一个线程都是会属于一个线程组的，如果在创建线程的时候没有设置，默认就是父线程的线程组。</p>
<p>比如main线程创建的子线程，子线程的线程组就是main ThreadGroup。</p>
<p>默认线程会加入父线程的ThreadGroup，也可以手动创建ThreadGroup，ThreadGroup也有父ThreadGroup，ThreadGroup可以包裹一大堆的线程，然后统一做一些操作，比如统一复制、停止、销毁，等等。</p>
<p>enumerate()：复制线程组里的线程</p>
<p>activeCount()：获取线程组里活跃的线程</p>
<p>getName()、getParent()、list()，等等</p>
<p>interrupt()：打断所有的线程</p>
<p>destroy()：一次性destroy所有的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程的线程组</span></span><br><span class="line">        <span class="comment">// 输出：main</span></span><br><span class="line">        System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 子线程默认加入父线程的group</span></span><br><span class="line">            <span class="comment">// 输出：main</span></span><br><span class="line">            System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        ThreadGroup custom = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;custom&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造方法可以指定线程组</span></span><br><span class="line">        <span class="keyword">new</span> Thread(custom, () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 加入了指定的custom线程组</span></span><br><span class="line">            <span class="comment">// 输出：custom</span></span><br><span class="line">            System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>优先级一般是在1~10之间，默认优先级是5，一般不设置，默认就是5，因为设置了，CPU也不一定按照这个来执行。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>看源码，一般就先扫一眼变量，或者从构造方法开始看起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们经常会看到日志打印里，线程名字都是Thread-0，Thread-1这样的，来源的代码就在这里了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="comment">// 因为线程还没有被创建，所以这里获取到的是父线程的对象，也就是main Thread</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="comment">// 如果没有传ThreadGroup，就用父线程的ThreadGroup</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）创建你的线程，就是你的父线程</p>
<p>（2）如果你没有指定ThreadGroup，你的ThreadGroup就是父线程的ThreadGroup</p>
<p>（3）你的daemon状态默认是父线程的daemon状态</p>
<p>（4）你的优先级默认是父线程的优先级</p>
<p>（5）如果你没有指定线程的名称，那么默认就是Thread-0格式的名称</p>
<p>（6）你的线程id是全局递增的，从1开始</p>
<p>这是初始化的代码，接着看下start</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动后状态会发生变化，一个线程不能被启动2次</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 初始化的时候分配的group</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Native方法来启动线程，然后执行run方法()</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>Thread.sleep(500),可以让线程停顿一段时间，然后恢复运行，在很多场景都可能会用到，比如在死循环中，通过sleep方法来达到一个定时执行的效果。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>这也是一个Native的方法，很少看到有人会用到，它的意思就是让出CPU执行时间，让别的线程先去执行一下。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>mian线程里创建线程start后，就会并发执行了，如果要实现等待的效果，可以调用线程的join方法，会阻塞等待子线程的逻辑执行完成，main线程继续往下走</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程会阻塞等待，等待thread1执行完成后，继续执行main线程后面的内容</span></span><br><span class="line">    thread1.join();</span><br><span class="line">  </span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>这个方法，叫打断，实际上他并不会中断线程的执行，只是给线程设置一个标志位，然后isInterrupted就能返回true了。一个最常见的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种情况，就是一个正在sleep的线程，如果调用interrupt的话，也会中断睡眠，抛出一个java.lang.InterruptedException: sleep interrupted的异常。</p>
<p>线程的使用，基本上就是这些了，后面就是基于线程的并发编程。</p>
<h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>在并发编程中，有三类问题，分别是可见性、原子性、有序性。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>就是一个线程修改了变量值，另外一个线程读取到的还是原来的值的问题，在Java中一般用volatile关键字来解决，或者加锁。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>比如i++的操作，他就是不保证原子性的，因为i++在底层是拆分成了多个指令，包含了读取，计算，写入，不同的线程在对同一个变量执行i++的时候，可能拿到的值是相同的，然后i++完成后都写入，导致最后的结果就不对了，比如i=1，2个线程i++开始读到的都是1，然后++完了，你以为最后应该是3了，其实都是2。</p>
<p>有人在会在网上说什么volatile是轻量级的锁，这是不对的，他并不能保证原子性，原子性只能通过加锁去解决，比如synchronize、lock，锁住变量，只能自己访问，操作串行化，保证多个操作之间的原子性。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性，就是指令重排序的问题，编译器和指令器，有时候会对代码进行优化，在前后逻辑不影响的情况下，他可能会优化代码的执行顺序，比如下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">prepare();<span class="comment">//准备资源</span></span><br><span class="line">flag=<span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">execute();<span class="comment">// 基于线程1准备的资源进行操作</span></span><br></pre></td></tr></table></figure>

<p>那么重排序之后，有可能flag=true，就先执行了，可能就会导致线程2的代码， 执行异常。</p>
<p><strong>基于happens-before保证有序性</strong></p>
<p>指令重排序，不是乱排的，有个happens-before原则，只要符合happens-before原则的情况，就不能乱排。</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>满足这8个原则的情况下，才能对指令进行重排序。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM1-Java介绍</title>
    <url>/2016/10/28/jvm/JVM1/</url>
    <content><![CDATA[<p>今天开写JVM系列的学习笔记，书籍为周志明的《深入理解Java虚拟机》</p>
<p>走进Java</p>
<h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>Sun官方所定义的技术体系包括以下几个组成部分</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机</li>
<li>Class文件格式</li>
<li>Java API类库</li>
<li>来自商业机构和开源社区的第三方Java类库        </li>
</ul>
<p>我们把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为<code>JDK</code>，JDK是用于支持Java程序开发的最小环境。Java API类库中的Java SE API子集和Java虚拟机这两部分统称为<code>JRE</code>，JRE是支持Java程序运行的标准环境。下图展示了Java技术体系所包含的内容，以及JDK和JRE所覆盖的范围。</p>
<a id="more"></a>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/801753-20150921165309834-1573432020.png"></p>
<h3 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h3><p>1999年HotSpot虚拟机作为JDK1.2附加程序发布，成为JDK1.3及之后版本的Sun JDK默认虚拟机。<br>2002年5月8日，JDK1.4发布，新特性包括，正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等。<br>2004年2月13日，JDK1.5发布，JDK1.5在Java语法易用性上做出了非常大的改进。例如，自动装箱、泛型、动态注解、枚举、可变长参数、循环遍历(foreach循环)等语法特性，在虚拟机和API层面上，这个版本改进了<strong>Java的内存模型</strong>(Java Memory Model, JMM)，提供了java.util.concurent并发包等。<br>2006年12月11日，JDk1.6发布，JDK1.6的改进包括：提供动态语言支持，提供编译API和微型HTTP服务器API等。这个版本对Java虚拟机内部做了大量改进，包括<strong>锁与同步、垃圾收集、类加载</strong>等方面的算法。<br>2011年7月，JDK7发布，由于Sun公司被Oracle收购等各种原因，原计划在JDK7发布的Lambda，Jigsaw和Coin延迟，JDK7的主要改进包括：提供新的G1收集器，加强对非Jaa语言的调用支持，升级类加载架构等。<br>2014年3月19日，JDK8发布，JDK8改进比较多，最大的改进是Lambda表达式（以及因之带来的函数式接口，很多原有类都做了变更，但能够与以往版本兼容，堪称奇功！），还有Stream API流式处理，joda-time等等一些新特性。但有一些本来计划发布的大变更，比如模块化等推迟到了JDK9中。        </p>
<h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>在JDK1.3之后，HotSpot VM成了Sun JDK和OpenJDK中所带的默认虚拟机。HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法单位进行编译。如果<strong>一个方法被频繁调用</strong>，或方法中<strong>有效循环次数很多</strong>，将会分别触发标准编译和OSR(栈上替换)编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术没输出质量更高的本地代码。<br>我们可以在命令行里执行<code>java -version</code>看看本机上的虚拟机。<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/QQ20161028-0.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM10-运行期优化</title>
    <url>/2016/11/17/jvm/JVM10/</url>
    <content><![CDATA[<p>Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为『热点代码』。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器。</p>
<h2 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>HotSpot虚拟机是采用解释器与编译器并存的架构。解释器和编译器各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>在运行过程中被即时编译器编译的『热点代码』有两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<a id="more"></a>

<p>前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，他成为”热点代码”也是理所当然。而后者则是为了解决一个方法只被调用过一次或者少量的几次，但是方法体内部存在循环次数较多的循环体问题，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是”热点代码”。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测，目前主要有两种方式：</p>
<ul>
<li>基于采样的热点探测</li>
<li>基于计数器的热点探测</li>
</ul>
<p>HotSpot是使用的第二种，基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，超过这个阀值，就会触发JIT编译。</p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就是统计方法被调用的次数，默认阀值在Client模式下是1500次，在Server模式下是10000次，这个阀值可以通过虚拟机参数-XX:CompileThreshold来设置。<br>当一个方法被调用时，会检查方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器和回边计数器值之和是否超过方法调用计数器的阈值。如果已经超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p>如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是直接进入解释器按照解释方法执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会少一半，这个过程称为方法的调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。进行热度衰减的动作是在虚拟机进行垃圾回收时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边”。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p>关于回边计数器的阈值，虽然HotSpot也提供了一个类似于方法调用计数器阈值-XX:CompileThreshold的参数-XX:BackEdgeThreshold供用户设置，但是当前虚拟机实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式如下：</p>
<ol>
<li><p>Client模式<br> 方法调用计数器阈值 × OSR比率 / 1000，其中OSR比率默认值933，如果都取默认值，Client模式下回边计数器的阈值应该是13995</p>
</li>
<li><p>Server模式<br> 方法调用计数器阈值 × (OSR比率 - 解释器监控比率) / 100，其中OSR比率默认140，解释器监控比率默认33，如果都取默认值，Server模式下回边计数器阈值应该是10700</p>
</li>
</ol>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段中是否有已经编译好的版本，如果有，它将会优先执行已编译好的代码，否则就把回边计时器的值加1，然后判断方法调用计数器与回边计数器值之和是否已经超过回边计数器的阈值。当超过阈值之后，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</p>
<p>与方法计数器不同，回边计数器没有热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成的时候，都仍然按照解释方式继续执行，而编译动作则在后台的编译线程中进行。用户可以通过-XX:-BackgroundCompilation来禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p>
<p>对于Client Compiler（C1编译器）来说，它是一个简单快速的三段式编译，主要关注点在于局部性的优化，而放弃了许多耗时间长的全局优化手段。</p>
<p>对于Sever Compiler（C2编译器）来说，它则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除、循环展开、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除等，另外，还有可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分支频率预测等，下一部分将讲解上述的一部分优化手段。</p>
<p>Server Compiler从即时编译的标准来看，无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</p>
<h3 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h3><p>在Sun官方的Wiki上，HotSpot虚拟机设计团队列出了一个相对比较全面、在即时编译器中采用的优化技术列表，其中有不少经典编译器的优化手段，也有许多针对Java语言（准确地说是运行在Java虚拟机上得所有语言）本身进行的优化技术，下面主要看几项最有代表性的优化技术：</p>
<ul>
<li>语言无关的经典优化技术之一：公共子表达式消除</li>
<li>语言无关的经典优化技术之一：数组范围检查消除</li>
<li>最重要的优化技术之一：方法内联</li>
<li>最前沿的优化技术之一：逃逸分析</li>
</ul>
<h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><p>公共子表达式消除的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面的计算结果代替E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。下面举例说明：</p>
<pre><code>int d = (c * b) * 12 + a + (a + b * c);</code></pre>
<p>如果这段代码交给javac编译器则不会进行任何优化，但进入虚拟机即时编译器后，它将会进行如下优化：<strong>编译器检测到“c*b”与“b*c”是一样的表达式，而且在计算期间b与c的值是不会变的。</strong>因此这条表达式就可能被视为：</p>
<pre><code>int d = E * 12 + a + (a + E)</code></pre>
<p>还有可能进行代数简化：</p>
<pre><code>int d = E * 13 + a * 2</code></pre>
<p>表达式进行交换之后，再计算起来就可以节省一些时间了。</p>
<h4 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h4><p>我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样在本质上是裸指针操作。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即检查i必须满足i&gt;=0&amp;&amp;i&lt;foo.length这个条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。这对软件开发者来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的判定条件，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。</p>
<p>无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是在运行时每次都做则不一定。例如：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下表“3”没有越界，执行的时候就无须判断了。更加常见的情况是数组访问发生在循环之中，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0,foo.length])内，那在整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(obj!=<span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Object = <span class="keyword">null</span>;</span><br><span class="line">	foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用方法内联后大致成这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Object = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(obj!=<span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为有了方法内联的基础，这段代码还能被继续优化，删除不可能被执行的dead code。<br>只有<a href="http://sail-y.github.io/2016/11/15/JVM9/#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">非虚方法</a>才能直接内联，虚方法需要运行时确定调用目标，所以虚拟机还有一套“类型继承关系分析”的技术来确定目前已加载的类中，某个接口是否有多余一种的实现，某个类是否存在子类、子类是否为抽象类等信息。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析是目前Java虚拟机中比较前沿的优化技术，他与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象动态作用域。</p>
<blockquote>
<p>当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
</blockquote>
<p>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高校的优化。如下：</p>
<ul>
<li>栈上分配：Java虚拟机中，对象在堆上分配，Java堆中的对象对于各个线程都是共享可见的。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象还是回收和整理内存都要耗费时间。如果确定一个对象不会逃逸出方法之外，那么让这个对象在栈上分配将会是一个不错的主意，对象所占用的内存空间就可以随着栈帧出栈而销毁，这样垃圾收集系统的压力将会小很多。</li>
<li>同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li>
<li>标量替换：标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等)都不能进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解那它就称作聚合量，Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。</li>
</ul>
<p>关于逃逸分析的论文在1999年就已经发表，但直到Sun SDK1.6才实现了逃逸分析，而且直到现在这项优化尚未足够成熟，仍有很大的改进余地。不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。虽然在实际测试结果中，实施逃逸分析后的程序往往能运行出不错的成绩，但是在实际的应用程序，尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况，或因分析过程耗时但却无法有效判别出非逃逸对象而导致性能有所下降。</p>
<p>如果有需要，并且确认对程序运行有益，可以使用参数-XX:+DoEscapeAnalysis来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析结果。有了逃逸分析支持之后，就可以使用参数-XX:+EliminateAllocations来开启标量替换，使用参数-XX:+EliminatLocks来开启同步消除，使用参数-XX:+PrintEliminateAllocations查看标量的替换情况。</p>
<p>尽管目前逃逸分析技术仍不是十分成熟，但是在今后的虚拟机中，逃逸分析技术肯定会支撑起一系列实用有效的优化技术。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM12-线程安全与锁优化</title>
    <url>/2016/11/25/jvm/JVM12/</url>
    <content><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>
<h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>讨论线程安全，就限定于<strong>多个线程之间存在共享数据访问</strong>这个前提，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。我们将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程独立。</p>
<a id="more"></a>
<ol>
<li>不可变<br> 在Java语言中，不可变的对象一定是线程安全的。基本数据类型采用final关键字修饰，如果是对象则需要保证自己的行为不会影响状态，例如String的replace()等方法都是产生新的对象。</li>
<li>绝对线程安全<br> 绝对的线程安全就是前面的提到的定义，这个定义很严格，一个类要达到「不管运行时环境如何，调用者都不需要任何额外的同步措施」通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</li>
<li>相对线程安全<br> 相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外保障措施。在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable等。</li>
<li>线程兼容<br> 线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
<li>线程对立<br> 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。一个线程对立的例子是Thread类的suspend()和resume()方法，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那肯定就要产生死锁了。</li>
</ol>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ol>
<li><p>互斥同步<br> 互斥同步（Mutual Exclusion &amp; Synchronization）是常见的一种并发正确性保证手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critial Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br> 在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字在经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。<br> 根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。<br> 关于monitorenter和monitorexit，有两点是要特别注意的：</p>
<ul>
<li><p>synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题</p>
</li>
<li><p>同步块在已进入的线程执行完之前，会阻塞后面其它线程的进入</p>
<p>因为Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还长，所以synchronized是Java语言中一个重量级（Heavyweight）锁，有经验的程序员都会在确实必要的情况下才使用这种操作。<br>除了synchronized，还有java.util.concurrent包中的ReentrantLock来实现同步。</p>
</li>
</ul>
</li>
<li><p>非阻塞同步<br> 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。互斥同步属于一种悲观的并发策略。随着硬件指令集（CAS指令）的发展，我们还可以采用基于冲突检测的乐观并发策略：先操作，没有其他线程竞争，就成功了；如果有其他线程争用，产生了冲突，就再采取补偿措施。<br> AtomicInteger的incrementAndGet方法就是无限循环自增直到成功。</p>
</li>
</ol>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>互斥同步，对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核状态完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机开发团队也注意到很多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机上有一个以上的处理器，能让两个或两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
<p>JDK1.4.2就已经引入了自旋锁，只不过默认是关闭的，在JDK1.6中就已经改为默认开启了。自旋不能代替阻塞，且先不说处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但是它是要占据处理器时间的，因此如果锁被占用的时间很短，自旋等待的效果就非常好；反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此自旋等待必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了，自旋次数的默认值是10，可以使用参数-XX:PreBlockSpin来更改。</p>
<p>在JDK1.6之后引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外如果对于某一个锁，自旋很少成功获得过，那么在以后要获得这个锁时将可能忽略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于<strong>逃逸分析</strong>的支持，如果判断在一段代码中，堆上所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然无需进行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小—-只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM2-Java内存区域</title>
    <url>/2016/10/28/jvm/JVM2/</url>
    <content><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>下面从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，包含以下几个运行时数据区域。</p>
<a id="more"></a>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/WechatIMG1.jpeg"></p>
<p>注意看图上分为<strong>线程共享数据区域</strong>和<strong>线程私有数据区域</strong>。</p>
<h3 id="线程私有数据区"><a href="#线程私有数据区" class="headerlink" title="线程私有数据区"></a>线程私有数据区</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器(Program Counter Register)是比较小的一块内存空间,在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。    </p>
<p>一个处理器一时间只会执行一条线程的指令，因此线程切换后为了能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<code>线程私有</code>的内存。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是<code>Java方法</code>执行的内存模型：<em>每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈入栈到出栈的过程。</em><br>在这个区域中，如果我们写一个回调的死循环可能会抛出StackOverFlow异常，或者是在区域大小动态扩展的时候申请不到足够的内存，也会抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈类似，不过是为Native方法服务的。虚拟机规范中没有强制的规定，HotSpot VM直接把本地方法栈和虚拟机栈合二为一了。</p>
<h3 id="线程共享数据区"><a href="#线程共享数据区" class="headerlink" title="线程共享数据区"></a>线程共享数据区</h3><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块，<strong>此内存区域的唯一目的就是存放对象实例</strong>。由于现代GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点还有Eden空间、From Survivor空间、To Survivor空间等。这个区域如果满了，会抛出<em>OutOfMemoryError</em>异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区(Method Area)用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。在Hotspot VM中，这个区域被称为“永久代”(Permanent Generation)，其他虚拟机则不存在永久代。并且使用永久代来实现方法区，容易遇到内存溢出问题(-XX:MaxPermSize)，所以JDK8的HotSpot VM去掉“永久代”，以“元数据区”（Metaspace）替代之。在JDK7的HotSpot中，原本放在永久代的字符串常量池也被移除。这个区域如果满了，会抛出<em>OutOfMemoryError</em>异常。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，图上面没有。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放<strong>编译器生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。那么运行时常量池相对Class文件常量池另外一个重要特征是动态性，并非Class文件中常量池的内容才能进入方法区运行时常量池，例如String的<code>intern()</code>方法就能将新的常量放入池中。常量池如果满了，会抛出<em>OutOfMemoryError</em>异常。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>JDK1.4加入的NIO，引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配<strong>堆外内存</strong>，然后通过一个存储在Java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。这个<strong>堆外内存</strong>虽不会受堆大小的限制，但是受本机总内存（RAM+SWAP）大小以及处理器寻址空间的限制，所以可能会出现OutOfMemoryError异常。</p>
<h1 id="对象探秘"><a href="#对象探秘" class="headerlink" title="对象探秘"></a>对象探秘</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在语言层面上，创建对象只是一个new关键字而已，而在虚拟机中创建一个对象的过程呢？</p>
<ol>
<li>当虚拟机遇到一条new指令，先检查指令参数能否在<strong>常量池</strong>中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，就先执行相应的类加载过程。</li>
<li>在类加载检查通过后，虚拟机为新生类分配内存(对象所需内存大小在类加载完成后已经确定)，为对象分配空间就是把一块确定大小的内存从Java堆中划分出来。<ul>
<li>如果Java堆内存是规整的，使用<strong>指针碰撞</strong>方式。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。</li>
<li>如果Java堆内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<strong>空闲列表法</strong>来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。<br>  除了可用空间外，还有个问题是在虚拟机中创建并发创建对象也不是线程安全的，有两个方案解决这个问题：<ul>
<li>对分配内存空间的动作进行同步处理</li>
<li>使用本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，即每个线程在Java堆中预先分配一小块内存。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB,可以通过-XX:+/-UseTLAB参数来设定。</li>
</ul>
</li>
</ul>
</li>
<li>内存分配完成，虚拟机需要将分配到的内存空间都初始化为零值。这一步保证了对象的实例字段不被赋值就可以使用对应字段的零值。</li>
<li>虚拟机进行必要设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息。这些信息放在对象的对象头中。</li>
<li>从虚拟机角度来看一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始—-<code>&lt;init&gt;</code>方法没有执行，所有的字段都还为零。接下来执行<code>&lt;init&gt;</code>方法，按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在Hotspot虚拟机中，对象在内存中存储的布局可用分为3块区域：对象头，实例数据，和对齐填充。</p>
<ol>
<li>对象头包含2部分数据，第一部分用于存储对象自身的运行时数据(如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等)。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，不过这跟<a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">对象访问定位</a>的实现方式有关系，下面介绍。</li>
<li>实例数据就是对象真正存储的有效信息，包括从父类继承下来的。</li>
<li>对齐填充起占位符的作用，因为HotSpot VM的自动内存管理系统要求对象的起始地址必须的8字节的整倍数。</li>
</ol>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象，目前主流的访问方式有使用句柄和直接指针两种。</p>
<ol>
<li>如果使用句柄访问，Java堆中会划分一块内存来做句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。如图所示<img src="http://7xs4nh.com1.z0.glb.clouddn.com/WechatIMG2.jpeg?imageMogr2/rotate/270"></li>
<li>如果使用直接指针访问，那么Java堆的对象布局中就包含了类型指针，而reference中存储的直接就是对象地址。(<em>这种方式类型指针就在对象数据中</em>)。HotSpot就是使用的这种方式，如图所示<img src="http://7xs4nh.com1.z0.glb.clouddn.com/jvm2.2.1.jpeg?imageMogr2/rotate/270"></li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM3-内存溢出异常实战</title>
    <url>/2016/10/31/jvm/JVM3/</url>
    <content><![CDATA[<p>在Java虚拟机规范的描述中，除了程序计数器，其他几个运行时区域都有发生OutOfMemoryError异常的可能。本文有两个目的：</p>
<ol>
<li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容。</li>
<li>希望我们在工作中遇到问题的时候能迅速判断是哪个区域的内存溢出，知道什么样的代码会导致这些区域溢出，以及出现这些异常后该如何处理。</li>
</ol>
<p>这个图展示了如何在Idea中设置VM参数。</p>
<a id="more"></a>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/jvm2-2-1.png"></p>
<h3 id="Java堆异常"><a href="#Java堆异常" class="headerlink" title="Java堆异常"></a>Java堆异常</h3><p>Java堆用于储存对象实例，只要不断地创建对象且对象不被回收，那么在对象数量到达最大堆的容量限制后就会产生OOM。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午1:34.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  设置堆大小为20m，不可扩展(堆的最小值-Xms参数和最大值-Xmx参数设置为一样可避免堆自动扩展)</span></span><br><span class="line"><span class="comment"> *  VM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid56046.hprof ...</span><br><span class="line">Heap dump file created [27956110 bytes in 0.186 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>这个问题很常见，根据错误提示可以定位到代码，分清楚是内存泄露还是内存溢出。如果是内存泄露，找出GC无法回收的对象代码位置。如果不存在泄露，就是说内存中的对象确实都还必须存活着，应当检查一下虚拟机的堆参数(-Xms和-Xmx)，代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说<code>-Xoss</code>(设置本地方法栈大小)是无效的，栈容量只由<code>-Xss</code>参数设置。关于虚拟机栈和本地方法栈，在虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午2:06.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  不断地递归调用导致栈深度增加</span></span><br><span class="line"><span class="comment"> *  VM参数：-Xss128k</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JavaVMStackSOF javaVMStackSOF = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaVMStackSOF.stackLength();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + javaVMStackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack length:29460</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">	at oom.JavaVMStackSOF.stackLength(JavaVMStackSOF.java:19)</span><br></pre></td></tr></table></figure>
<p>在单线程下，无论是栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是<em>StackOverFlow</em>异常。<br>可以通过不断创建线程的方式产生内存溢出异常，不过这个异常与栈容量大小没有什么关系，因为不断创建线程，每个线程分配的容量越大，那么总共可产生线程数量就越小，就越容易出现OOM。这个只能通过减少最大堆内存(留给栈分配的内存变大)和减少栈容量来换取更多的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午2:18.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 不断创建线程导致内存溢出</span></span><br><span class="line"><span class="comment"> * VM参数：-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要在Windows下运行这段代码，可能会假死</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM javaVMStackOOM = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaVMStackOOM.stackLeakByThread();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread count: &quot;</span> + javaVMStackOOM.count);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread count: 2028</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">	at java.lang.Thread.start0(Native Method)</span><br></pre></td></tr></table></figure>

<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>前面提到过，运行时常量池也是方法区的一部分，并且在JDK8 HotSpot中去掉了永久代。<code>String.intern()</code>是一个Native方法，它的作用是：如果常量池中有一个String对象的字符串就返回池中的这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中去，并且返回此String对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午3:01.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * VM参数-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于JDK 1.6 HotSpot而言，方法区=永久代，这里看到OutOfMemoryError的区域是“PermGen space”，即永久代，那其实也就是方法区溢出了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * JDK7这个例子会一直循环，因为JDK 7里String.intern生成的String不再是在perm gen分配,而是在Java Heap中分配</span></span><br><span class="line"><span class="comment"> * JDK8移除了永久代（Permanent Generation ），替换成了元空间（Metaspace）内存分配模型</span></span><br><span class="line"><span class="comment"> * 设置虚拟机参数-XX:MaxMetaspaceSize=1m，可出现OutOfMemoryError: Metaspace 溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>这个地方的溢出，特征是发现OOM后Dump文件很小，而程序中间接或直接使用了NIO，那就考虑检查一下是不是这个原因。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM4-垃圾收集器</title>
    <url>/2016/10/31/jvm/JVM4/</url>
    <content><![CDATA[<h2 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，方法或者线程结束的时候内存自然就跟着回收了，所以不需要考虑过多回收的问题。而<strong>Java堆</strong>和<strong>方法区</strong>就不一样了，这部分内存的<strong>分配</strong>和<strong>回收</strong>都是动态的。</p>
<h3 id="Java堆内存回收"><a href="#Java堆内存回收" class="headerlink" title="Java堆内存回收"></a>Java堆内存回收</h3><p>因为堆就是放对象的地方，要回收内存，首先要知道哪些对象是不可能再被任何途径使用的</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>这个算法的实现是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1，当引用失效时，计数器-1。Object-C就是使用的这种方式，Java没有选用引用计数算法来管理内存，因为它很难解决对象之间相互循环引用的问题。例子如下</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午3:48.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 虚拟机参数：-verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (System.gc())  7440K-&gt;632K(125952K), 0.0012069 secs]</span><br><span class="line">[Full GC (System.gc())  632K-&gt;520K(125952K), 0.0058047 secs]</span><br></pre></td></tr></table></figure>
<p>看到<code>632K-&gt;520K</code>，意味着两个对象相互引用也被回收了，侧面说明虚拟机不是通过引用计数法来判断对象是否存活的。</p>
<h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>这个算法的基本思路是通过一系列的称为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链相连(从GC Roots到这个对象不可达)时，则证明此对象是不可用的。下图中object5、object6、object7虽然相互关联，但是到GC Roots是不可达的，所以他们会被回收。<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/jvm3-1.jpeg"></p>
<p>在Java语言中，可用作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的本地方法）引用的对象</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。</p>
<ul>
<li>强引用在代码中普遍存在，类似<code>Object obj = new Object()</code>这类的引用，只要引用还在，垃圾收集器就不会回收</li>
<li>软引用是用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference来实现软引用。</li>
<li>弱引用也是用来描述非必需对象，被弱引用关联的对象只能生存到下一次GC之前。无论当前内存是够足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用的存在不会对一个对象的生存时间构成影响，它的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现。</li>
</ul>
<h4 id="对象自我拯救"><a href="#对象自我拯救" class="headerlink" title="对象自我拯救"></a>对象自我拯救</h4><p>用可达性分析算法，对象也需要标记2次后才会被回收，第一次是发现没有与GC Roots相连的引用链接会标记一次，然后看他覆盖finalize()方法或者finalize()被调用过没有，如果finalize()不需要执行，就直接被回收了，如果需要执行，稍后GC会进行第二轮标记，对象有可能被移出回收队列(例如在finalize()中重新给自己赋值)。上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/31 下午4:54.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  此代码演示两点：</span></span><br><span class="line"><span class="comment"> *     1. 对象可以在GC时自我拯救</span></span><br><span class="line"><span class="comment"> *     2. 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为finalize方法的优先级很低，所以暂停了0.5秒等待它执行</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :( &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面代码一样，但是这次失败了，因为finalize只执行一次</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为finalize方法的优先级很低，所以暂停了0.5秒等待它执行</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :( &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :( </span><br></pre></td></tr></table></figure>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>Java虚拟机规范中说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集性价比一般比较低。HotSpot VM永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。<br>判断一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证方法区不会溢出。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>下面介绍几种垃圾回收算法的思想及发展过程。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的收集算法是标记-清除(Mark-Sweep)算法，，如同它的名字一样，算法分为<code>标记</code>和<code>清除</code>两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。（<a href="#%E5%AF%B9%E8%B1%A1%E8%87%AA%E6%88%91%E6%8B%AF%E6%95%91">标记过程</a>已经介绍过了）。这种算法主要有两个不足：</p>
<ul>
<li>一个是效率问题，标记和清除两个过程的效率都不高</li>
<li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时<a href="http://sail-y.github.io/2016/10/28/JVM2/#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA">对象的创建</a>，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。标记-清除算法的执行过程如图：<br><img src="/img/jvm/04/%E6%A0%87%E8%AE%B0%E6%B8%85%E6%A5%9A%E7%AE%97%E6%B3%95.png">。</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法是为了解决效率问题而出现的，<strong>它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉</strong>。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图：<br><img src="/img/jvm/04/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p>
<p>只是这个算法代价太高，内存缩小为原来的一半，现在商用虚拟机都采用这种算法来回收“新生代”，IBM研究表明新生代98%的对象“朝生夕死”，所以不需要按1:1来划分内存空间，而是将内存分为一块较大的<strong>Eden</strong>空间和两块较小的<strong>Survivor</strong>空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。我们没有办法保证每次回收都只有不多余10%的对象存活，所以如果Survivor空间不够用的时候，这些对象将直接通过分配担保机制进入老年代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率会变低，如果对象存活率太高，还需要额外的空间进行分配担保，所以老年代一般不能直接用这种算法。<br>标记-整理算法是先标记对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。如图：<img src="/img/jvm/04/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>概括一下Java内存的布局：<img src="/img/jvm/04/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png"><br>当前的商业虚拟机垃圾收集都采用“分代收集”算法，把Java堆分为新生代和老年代。在新生代中，垃圾收集时都有大批对象死去，只有少量存活，只需复制少量存活的对象成本低。老年代对象存活率高、没有额外的空间进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器是内存回收的具体实现，JDK1.7之后的HotSpot虚拟机包含的收集器如下图所示：<br><img src="/img/jvm/04/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png"></p>
<p>上图展示了7种不作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是一个单线程的收集器，在进行垃圾收集的时候，会暂停其他所有的工作线程，直到它收集结束。新生代采用<em>复制</em>算法，老年代采取<em>标记-整理</em>算法。虽然它会暂停用户的工作线程似乎显得很不能接受，<strong>不过它仍然是Client模式下虚拟机的默认新生代收集器</strong>，因为它简单而高效，收集几十兆内存停顿时间可以控制在几十毫秒，这是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>ParNew收集器是Serial收集器的多线程版本，它是运行在Server模式下虚拟机中首选的新生代收集器</strong>。有个重要的原因是，除了Serial收集器，目前只有它能与CMS收集器配合工作。(CMS是HotSpot在JDK1.5推出的第一款真正意义上的<strong>老年代</strong>并发收集器，第一次实现了垃圾收集线程基本上与用户线程同时工作–意思就是几乎不会暂停用户的工作线程)。ParNew收集器默认开启的收集线程数与CPU数量相同，与Serial相比，CPU数量越多，它的效果才越好。在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个使用复制算法的新生代收集器。它的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的<strong>吞吐量</strong>。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，假如虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。高吞吐量可以高效率的运用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。Parallel Scavenge收集器还有个参数-XX:+UseAdaptiveSizePolicy值得关注，这个参数打开后虚拟机会根据当前系统的运行情况动态调整新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄，以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为<em>GC自适应调节策略</em>。如果我们不太了解手工优化，交给虚拟机区去优化是个不错的选择。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它是单线程收集器，使用<strong>标记-整理</strong>算法。这个收集器主要也是在Client模式下的虚拟机使用。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>标记-整理</strong>算法。由于Parallel Scavenge无法与CMS配合工作，Serial Old在服务端应用上又不给力，JDK1.6后Parallel Old的发布才有了Parallel Scavenge+Parallel Old的应用组合，适合注重吞吐量以及CPU资源敏感的场合。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器是基于<strong>标记-清除</strong>算法实现的。CMS非常优秀但是有3个缺点：</p>
<ul>
<li>占用CPU资源</li>
<li>并发收集会产生浮动垃圾(收集的同时产生的新垃圾)</li>
<li>内存空间碎片问题</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一，随JDK1.7 HotSpot发布。G1的目标是替换掉CMS收集器，特点如下：</p>
<ul>
<li>并行(多线程)+并发(与用户线程同时工作)</li>
<li>分代收集</li>
<li>空间整合(不会产生空间碎片)</li>
<li>可预测的停顿</li>
</ul>
<p>在G1收集器之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1收集器不再是这样，使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。</p>
<p>G1收集器跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM5-内存分配与回收策略</title>
    <url>/2016/11/01/jvm/JVM5/</url>
    <content><![CDATA[<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>之前讲了垃圾回收器体系以及运作原理，现在来看看对象内存分配那点事儿。对象的内存分配，往大方向讲就是在堆上分配，对象主要分配在新生代的Eden区上，也可能直接分配在老年代中，并不固定，取决于使用的哪一种垃圾收集器以及虚拟机参数设置。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机会发一起一次Minor GC。        </p>
<a id="more"></a>
<p>不同的垃圾收集器组合对于对象的分配是有影响的，我们这里都是测试在<code>Serial+SerialOld</code>的收集器组合下测试的代码。<br>下面的代码，<code>-Xms20M -Xmx20M -Xmn10M</code>三个参数限制了Java堆大小为20M，不可扩展，分给新生代10M，剩下10M分给老年代，<code>-XX:SurvivorRatio=8</code>定义了Eden区与一个Survivor区的空间比例是8:1,<code>-XX:+UseSerialGC</code>参数指定Serial垃圾收集器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/1 下午3:34.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  VM 参数: -verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">// 发生一次MinorGC</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GC输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 7643K-&gt;517K(9216K), 0.0078067 secs] 7643K-&gt;6661K(19456K), 0.0078482 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4750K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000007bec00000, 0x00000007bf0223b8, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000007bf500000, 0x00000007bf581668, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3062K, capacity 4494K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>eden space</code>是8M，前面3个对象都分配到了eden区，在分配<code>allocation4</code>的时候，eden区已经不够了，于是发生了一次Minor GC，但是3个对象都是存活的，并且无法放进Survivor(from space)区，所以通过分配担保机制转移到了老年代去。然后4M的<code>allocation4</code>分配进了Eden区。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的复制（新生代采用复制算法）。</p>
<pre><code>-XX:PretenureSizeThreshold只在Serial和ParNew两款收集器有效。</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/1 下午3:34.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  VM 参数: -verbose:gc -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3M -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">// 发生一次MinorGC</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 6357K-&gt;554K(9216K), 0.0055719 secs] 6357K-&gt;4650K(19456K), 0.0056074 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 6991K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  78% used [0x00000007bec00000, 0x00000007bf2490f0, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  54% used [0x00000007bf500000, 0x00000007bf58ab68, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00020, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3201K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>看到对象超过了3M，直接进入了tenured generation(老年代)。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>对象在Eden区每gc留下来一次(大小可复制到Survivor区中)，年龄+1，默认是15岁后移到老年代。这个阀值可以通过-XX:MaxTenuringThreshold设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/2 下午13:58.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 1岁后直接进入老年代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenuringThresholdTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">// Eden区放不下了，发起第一次GC，allocation1年龄+1，allocation2因为无法放入Survivor区通过分配担保机制提前进入老年代，allocation3进入新生代Eden区</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 发起第二次GC，allocation3被回收，allocation1年龄过大进入老年代，allocation4进入Eden区</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 5843K-&gt;783K(9216K), 0.0062294 secs] 5843K-&gt;4879K(19456K), 0.0062786 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 4961K-&gt;0K(9216K), 0.0018562 secs] 9057K-&gt;4867K(19456K), 0.0018840 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4178K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000007bec00000, 0x00000007bf014930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400228, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> tenured generation   total 10240K, used 4866K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  47% used [0x00000007bf600000, 0x00000007bfac0ae8, 0x00000007bfac0c00, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3103K, capacity 4494K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 338K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>为了适应不同程序的内存状况，Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到“-XX:MaxTenuringThreshold”设置要求的年龄。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM6-虚拟机性能监控与故障处理工具</title>
    <url>/2016/11/02/jvm/JVM6/</url>
    <content><![CDATA[<p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照(threaddump/javacore文件)、堆转储快照(heapdump/hprof文件)等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位问题的速度。</p>
<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p>JDK的安装目录bin下提供了很多工具，这些工具其实是jdk/lib/tools.jar的包装而已。</p>
<h3 id="jps：虚拟机进城状况工具"><a href="#jps：虚拟机进城状况工具" class="headerlink" title="jps：虚拟机进城状况工具"></a>jps：虚拟机进城状况工具</h3><p>jps(JVM Process Status Tool):可以列出正在运行的虚拟机进程，并显示虚拟机执行主类以及这些进程的本地虚拟机唯一ID(Local Virtual Machine IIdentifier, LVMID)，这个LVMID跟系统里的PID是一致的。</p>
<a id="more"></a>
<p>jps命令格式：</p>
<pre><code>jsp [ options ] [ hostid ]</code></pre>
<p>jps执行样例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jps -l</span><br><span class="line">772 </span><br><span class="line">15944 sun.tools.jps.Jps</span><br><span class="line">15547 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td align="left">只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="left">输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="left">输出主类的全名，如果进城执行的是Jar包，输出Jar包路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="left">输出虚拟机进城启动时JVM参数</td>
</tr>
</tbody></table>
<h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>jstat命令格式为：</p>
<pre><code>jstat [ option vmid [ interval [ s | ms ] [ count ] ] ]</code></pre>
<p>对本机来说<code>vmid</code>就是<code>LVMID</code>。interval和count表示间隔和次数，省略表示只查询1次。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-class</td>
<td align="left">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td align="center">-gc</td>
<td align="left">监视Java堆状况，包括Eden区、两个Survivor区、、老年代、永久带等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td align="center">-gccapacity</td>
<td align="left">监视内容基本与-gc相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gccause</td>
<td align="left">与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td align="center">-gcnew</td>
<td align="left">监视新生代GC状况</td>
</tr>
<tr>
<td align="center">-gcnewcapacity</td>
<td align="left">监视内容基本与-gcnew相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcold</td>
<td align="left">监视老年代GC状况</td>
</tr>
<tr>
<td align="center">-gcoldcapacity</td>
<td align="left">监视内容基本与-gcold相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcpermcapacity</td>
<td align="left">输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-compiler</td>
<td align="left">输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">-printcompilation</td>
<td align="left">输出已经被JIT编译的方法</td>
</tr>
</tbody></table>
<p>jstat执行样例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jstat -gcutil 15547 1000 3</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"> 74.83   0.00   2.40   0.09  98.65  95.48      2    0.013     0    0.000    0.013</span><br><span class="line"> 74.83   0.00   2.40   0.09  98.65  95.48      2    0.013     0    0.000    0.013</span><br><span class="line"> 74.83   0.00   2.40   0.09  98.65  95.48      2    0.013     0    0.000    0.013</span><br></pre></td></tr></table></figure>
<p>这里就是每隔1000毫秒，一共执行3次，查询LVMID为15547的gcutil信息。<br>显示空间占用总空间的百分比，S0和S1就是2个Survivor区，E是Eden，O是Old老年代，M表示MetaSpace(JDK8中的元数据区)。YGC(Young GC)和FGC(Full GC)显示的是GC的次数。FGCT和GCT是时间，</p>
<h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>jinfo(Configuration Info for Java)的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，可以使用jinfo的<code>-flag</code>选项进行查询，jinfo还可以使用<code>-sysprops</code>选项把虚拟机进程的<code>System.getProperties()</code>的内容打印出来，它还有在运行期修改虚拟机参数的能力。<br>jinfo命令格式：</p>
<pre><code>jinfo [ option ] pid</code></pre>
<p>执行样例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jinfo -flag CMSInitiatingOccupancyFraction 15547 </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=-1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意jinfo对windows只提供了-flag选项</p>
</blockquote>
<h3 id="jmap：Java内存映射工具"><a href="#jmap：Java内存映射工具" class="headerlink" title="jmap：Java内存映射工具"></a>jmap：Java内存映射工具</h3><p>jmap(Memory Map for Java)命令用于声称堆转储快照（一般称为heapdump或dump文件）。不用命令要想获取Java堆转储快照，可以使用“-XX:+HeapDumpOnOutOfMemoryError”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令下可以通过kill -3发送进程退出信号也能拿到dump文件。</p>
<p>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在Windows平台下也是受限制的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux和Solaris系统下使用。</p>
<p>jmap命令格式：</p>
<pre><code>jmap [ option ] vmid</code></pre>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-dump</td>
<td align="left">生成Java堆转储快照。格式为-dump:[live, ]format=b,file=<filename>，其中live自参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td align="center">-finalizerinfo</td>
<td align="left">显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux和Solaris系统下有效</td>
</tr>
<tr>
<td align="center">-heap</td>
<td align="left">显示Java堆详细信息，如使用哪种收集器、参数配置、分代状况等。只在Linux和Solaris系统下有效</td>
</tr>
<tr>
<td align="center">-histo</td>
<td align="left">显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td align="center">-permstat</td>
<td align="left">以ClassLoader为统计口径显示永久代内存状态。只在Linux和Solaris系统下有效</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="left">当虚拟机进行对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux和Solaris系统下有效</td>
</tr>
</tbody></table>
<p>jmap生成dump文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jmap -dump:format=b,file=idea.bin 15547</span><br><span class="line">Dumping heap to /Users/xiaomai/idea.bin ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>jhat(JVM Heap Analysis Tool)是与jmap搭配使用的。实际工作中很少用到，比较简陋。分析一下刚才生成的dump文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jhat idea.bin</span><br><span class="line">Reading from idea.bin...</span><br><span class="line">Dump file created Wed Nov 02 16:55:47 CST 2016</span><br><span class="line">Snapshot <span class="built_in">read</span>, resolving...</span><br><span class="line">Resolving 63292 objects...</span><br><span class="line">Chasing references, expect 12 dots............</span><br><span class="line">Eliminating duplicate references............</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/8E34846A-29FF-4342-A1DE-81817C327574.png"></p>
<h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>jstack(Sstack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。『线程快照』就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待。</p>
<pre><code>jstack [ option ] vmid</code></pre>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-F</td>
<td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="left">除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="left">如果调用到本地方法的时候，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<p>下面展示部分输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ jstack -l 15547</span><br><span class="line">2016-11-02 17:36:52</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.31-b07 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Attach Listener&quot;</span> <span class="comment">#13 daemon prio=9 os_prio=31 tid=0x00007f9492316000 nid=0x3f0b waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;NettythreadDeathWatcher-2-1&quot;</span> <span class="comment">#12 daemon prio=1 os_prio=31 tid=0x00007f9491346800 nid=0x5103 waiting on condition [0x00007000061e2000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at io.netty.util.ThreadDeathWatcher<span class="variable">$Watcher</span>.run(ThreadDeathWatcher.java:147)</span><br><span class="line">	at io.netty.util.concurrent.DefaultThreadFactory<span class="variable">$DefaultRunnableDecorator</span>.run(DefaultThreadFactory.java:145)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>

<h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p>jdk/bin下还有两个可视化工具。</p>
<h3 id="JConsole：Java监视与管理平台"><a href="#JConsole：Java监视与管理平台" class="headerlink" title="JConsole：Java监视与管理平台"></a>JConsole：Java监视与管理平台</h3><h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><p>是到目前为止随JDK发布的功能最为强大的运行监视和故障处理工具，除了最基本的运行监视、 故障处理外，还有性能分析的功能，且十分强大。Visual VM还有一个很大的优点，它对应用程序的实际性能影响很小，使得它可以直接应用在生产环境中。VisualVM需要安装一些插件，才能强大的使用，否则就跟没有安装软件的操作系统一样。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM7-类文件结构</title>
    <url>/2016/11/04/jvm/JVM7/</url>
    <content><![CDATA[<h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>本章说一下Java编译后的class文件结构。</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/jvm7.png"><br>我这里用sublime打开一个class文件，看到前面4个字节是十六进制0xCAFEBABE,这个是Class文件的魔数.</p>
<blockquote>
<p>很多文件存储标准中都使用魔数进行身份识别，因为扩展名可以更改，魔数就是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
</blockquote>
<p>然后看0000 0034，转换成十进制是52，这个表示Java编译的版本号，相信大家在工作中也遇见过<code>Unsupported major.minor version 52.0</code>之类的错误，指的就是这个版本号，52对应的是JDK8。</p>
<a id="more"></a>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>再后面的就是常量池，常量池可以理解为Class文件之中的资源仓库，我们前面提到过，Java运行时内存区域里有一块方法区，方法区里面有一个运行时常量池，Class文件的这部分数据，会在运行时被加载到方法区的运行时常量池中。<br>常量池中主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。『字面量』比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而『符号引用』则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>先放一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用<code>javap</code>命令来看一下编译后的class文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ javap -verbose TestClass</span><br><span class="line">Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class clazz.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC\_PUBLIC, ACC\_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#18         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#19         &#x2F;&#x2F; clazz&#x2F;TestClass.m:I</span><br><span class="line">   #3 &#x3D; Class              #20            &#x2F;&#x2F; clazz&#x2F;TestClass</span><br><span class="line">   #4 &#x3D; Class              #21            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #12 &#x3D; Utf8               this</span><br><span class="line">  #13 &#x3D; Utf8               Lclazz&#x2F;TestClass;</span><br><span class="line">  #14 &#x3D; Utf8               inc</span><br><span class="line">  #15 &#x3D; Utf8               ()I</span><br><span class="line">  #16 &#x3D; Utf8               SourceFile</span><br><span class="line">  #17 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #18 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #19 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; m:I</span><br><span class="line">  #20 &#x3D; Utf8               clazz&#x2F;TestClass</span><br><span class="line">  #21 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  public clazz.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC\_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args\_size&#x3D;1</span><br><span class="line">         0: aload\_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lclazz&#x2F;TestClass;</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC\_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args\_size&#x3D;1</span><br><span class="line">         0: aload\_0</span><br><span class="line">         1: getfield      #2                  &#x2F;&#x2F; Field m:I</span><br><span class="line">         4: iconst\_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lclazz&#x2F;TestClass;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>
<p><a name="ref"></a><br>看看常量池里的内容：</p>
<p><code>Utf8</code>就是UTF-8编码的字符串，<code>Class</code>、<code>Methodref</code>和<code>Fieldref</code>则是符号引用。符号引用后面的编号最终也指向了字符串表示他们的值。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>常量池结束后，紧接着2个字节代表访问标志(access_flag)。包括这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final。上面的flags中的值是flags: ACC_PUBLIC, ACC_SUPER表示这个类是public的。</p>
<!--### 类索引、父类引用与接口索引集合
Class文件中由这三项数据来确定这个类的集成关系。3个2字节无符号数表示，本例中索引指向#3和#4
### 字段表集合
字段表（field\_info）用于描述借口或者类中声明的变量。
-->
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>这里说一下方法和字段的描述符。<br>基本类型是取首字母的大写基本上。例如byte就是B,有3个特殊的，long是J，boolean是Z，V是void。<br>L表示对象（例如Ljava/lang/String）。对数组而言，每一维度将使用一个前置的“[”字符来描述。            </p>
<blockquote>
<p>如定义一个为“java.lang.String[][]”类型的二维数组，将被记录为“[[Ljava/lang/String”。</p>
</blockquote>
<p>描述方法的时候，是先参数列表，后返回值。参数列表在小括号“()”内。例如<code>()V</code>表示0个参数，返回值为void，<code>int test(int[] i, char c)</code>的描述符为<code>([IC)I</code>。</p>
<h2 id="字节码指令集"><a href="#字节码指令集" class="headerlink" title="字节码指令集"></a>字节码指令集</h2><p>aload_0、iconst_1之类的都是字节码指令，下面将字节码操作按用途分为9类，按照分类介绍一下。</p>
<h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和<a href="http://sail-y.github.io/2016/10/28/JVM2/#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">操作数栈</a>之间来回传输：</p>
<ul>
<li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></li>
<li>将一个数字从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></li>
<li>将一个常量加载到操作栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li>
<li>扩充局部变量表的访问索引的指令：wide。</li>
</ul>
<p>存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。上面有尖括号的表示一组指令（例如iload_<n>，就代表了iload_0、iload<br>_1、iload_2、iload_3），iload_0也等价于iload 0。</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>运算或算术指令用于堆两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上算术指令可以分为两种：对整型数据进行运算的指令与堆浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem</li>
<li>取反指令：inge、lneg、fneg、dneg</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
<li>局部变量自增指令：iinc</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用于处理字节指令集中数据类型相关指令无法与数据类型一一对应的问题。<br>以下是宽化类型转换，Java虚拟机直接支持，无需指令：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<p>窄化类型指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、和d2f。窄化类型转换可能导致不同的正负号、不同的数量级以及精度丢失的情况。</p>
<h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><ul>
<li>创建类实例的指令：new</li>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>访问类字段和实例字段的指令：getfield、putfield、getstatic、putstatic</li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
<li>取数组长度的指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><ul>
<li>将操作数的组合暂定一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup_x2、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、和if_acmpne</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><ul>
<li>invokevirtual调用对象的实例方法</li>
<li>invokeinterface调用接口方法</li>
<li>invokespecial调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法</li>
<li>invokestatic调用类方法</li>
<li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法</li>
</ul>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>throw语句由athrow指令实现，而catch语句不是由字节码来实现的，采用异常表来实现。</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>同步一段指令集序列在Java语言中是由synchronized语句块来表示的，在Java虚拟机的指令集中由monitorenter和monitorexit两条指令来支持。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM8-类加载机制</title>
    <url>/2016/11/07/jvm/JVM8/</url>
    <content><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段。其中验证、准备、解析3个部分统称为连接，这个阶段的发生顺序如下图所示：</p>
<a id="more"></a>
<p><img src="/img/jvm/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA.png"></p>
<p>图中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>虚拟机规定了5种主动引用必然会触发<strong>初始化</strong>（加载、验证、准备在此之前开始）</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。这4条指令的Java代码场景是：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰，已在编译期放入常量池的除外），调用一个类的静态方法。</li>
<li>使用java.lang.reflect反射调用的时候，如果类还没有初始化，则需要先初始化</li>
<li>父类未初始化，则先初始化一个类的父类</li>
<li>虚拟机启动的时候会先初始化执行的主类（包含main的类）</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<p>除了这些主动引用，其他引用类都不会触发初始化，称为被动引用。例如通过子类引用父类的静态字段，不会触发子类初始化。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>下面分别介绍一下加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成3件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<ol>
<li>文件格式验证<br> 第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，验证通过后，才会存入方法区。例如<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
</ul>
</li>
<li>元数据验证<br> 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范，例如<ul>
<li>是否有父类</li>
<li>是否继承了不允许继承的类(被final修饰的类)</li>
<li>如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法</li>
</ul>
</li>
<li>字节码验证<br> 第三阶段目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如：在操作栈上放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li>
<li>符号引用验证<br> 最后一个阶段的校验发生再虚拟机将符号引用转换为直接引用的时候，这个转化动作将在连接的第三个阶段-解析阶段发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类，在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段等等。</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。这个时候进行内存分配仅包括类变量（static），而不包括实例变量。注意初始值是指分配零值</p>
<pre><code>public static int value = 123;</code></pre>
<p>变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。<br><strong>加了final的常量除外，这个放在方法区常量池中的数据将会在准备阶段被赋值</strong></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<a href="http://sail-y.github.io/2016/11/04/JVM7/#ref">符号引用</a>就是那些我们用javap命令看到的Methodref，Fieldref一类的。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法就是由编译器收集类中所有的类变量的赋值动作和静态语句（static{}块）。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其再Java虚拟机中的唯一性。意思就是比较两个类相等的前提是这两个类由同一个类加载器加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/15 下午3:37.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *  相等是指类的.class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;clazzloader.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> ClassLoader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class clazzloader.ClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="双亲委派模型（重要）"><a href="#双亲委派模型（重要）" class="headerlink" title="双亲委派模型（重要）"></a>双亲委派模型（重要）</h3><p>从Java虚拟机的角度来将，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是其他的类加载器，这些类加载器由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。从开发人员角度来看，还可以划分得更细致一些：</p>
<ul>
<li>启动类加载器<br>前面介绍过，它负责加载的是JAVA_HOME/lib下的类库，系统类加载器无法被Java程序直接应用。</li>
<li>扩展类加载器<br>这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责用于加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量指定所指定的路径中所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器<br>这个类加载器由sun.misc.Launcher$AppClassLoader实现。这个类加载器是ClassLoader.getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><img src="/img/jvm/08/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p>这个图展示的类加载器之间的这种层次关系，称为双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器代码。</p>
<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong><br>这样做能保证一个类始终是被同一个类加载器加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/15 下午4:17.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 我们可以打印一下各种加载器看看是否复合图上描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 应用程序类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">// 扩展类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">        <span class="comment">// 启动类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">        <span class="comment">// 应用程序类加载器加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@330bedb4</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@5cad8086</span><br><span class="line">null</span><br><span class="line">&#x2F;Users&#x2F;xiaomai&#x2F;code&#x2F;IdeaProjects&#x2F;jvm&#x2F;out&#x2F;production&#x2F;jvm:&#x2F;Applications&#x2F;IntelliJ IDEA.app&#x2F;Contents&#x2F;lib&#x2F;idea_rt.jar</span><br></pre></td></tr></table></figure>
<p>这里说到一个实践，就是有时候我们想覆盖第三方jar包中的某个类，除了替换jar包中的class文件的方式，还可以直接在项目中编写一个一样包名的类。上面打印在前面的<code>/Users/xiaomai/code/IdeaProjects/jvm/out/production/jvm</code>（相当于web项目里WEB-INF下的class文件夹）目录下的class会优先于第三方jar包中的class加载。但是却没有办法写一个同样包名的类来覆盖lib和ext下面的库的类。<br>上面的null，表示ClassLoader就是Bootstrap ClassLoader。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM9-虚拟机字节码执行引擎</title>
    <url>/2016/11/15/jvm/JVM9/</url>
    <content><![CDATA[<p>执行引擎是Java虚拟机最核心的组成部分之一，本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行方法代用和方法执行的数据结构，它是虚拟机运行时数据区中的<a href="http://sail-y.github.io/2016/10/28/JVM2/#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a>的栈元素。栈帧存储了局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构图如下：</p>
<a id="more"></a>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/jvm-9-1.jpeg"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放<strong>参数</strong>和<strong>方法内部</strong>定义的局部变量。局部变量表的容量以变量槽（Slot）为最小单位。虚拟机规范中没有明确指明一个Slot应占用的内存空间大小，只是向导性的说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference和returnAddress。reference表示对一个对象实例的引用，returnAddress目前很少见了。一个Slot可以存放一个32位以内的数据，那么64位的long和double会被分配两个连续的Slot空间。<br>实例方法第0位索引的Slot默认是用于传递方法所属对象实例的引用（this），然后从1开始是方法参数，参数表分配完后再是方法体内部的变量。<br>前面提到过，类变量在<strong>准备阶段</strong>会赋予系统初始值，<strong>初始化阶段</strong>赋予程序员定义的初始值，所以就算没有设值也会有一个默认值，但局部变量则不一样，没有设值变进行使用的话，编译无法通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位的数据类型所占的栈容量为1，64为数据类型所占的栈容量为2。<br>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int类型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将加的结果入栈。</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为<a href="http://sail-y.github.io/2016/11/07/JVM8/#%E8%A7%A3%E6%9E%90">静态解析</a>。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式退出方法，要么遇到方法返回的字节码指令，要么是在方法执行过程中遇到了异常。无论哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载解析阶段，会将其中一部分符号引用转化为直接引用，这个前提是调用目标在程序代码写好、编译器进行编译时必须确定下来。这类方法的调用称为解析（Resolution）。</p>
<p>在Java语言符合“编译期可知，运行期不可变”的方法主要包括静态方法和私有方法。</p>
<p>调用方法的虚拟机字节码指令：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<init>方法、私有方法和父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>能被invokestatic和invokespecial指令调用的方法，能在解析阶段把符号引用转化为直接引用，这些方法称为非虚方法，其他方法称为虚方法（final除外）。被final修饰的虽然是用invokevirtual调用的，但是它是一个非虚方法。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>分派调用可能是静态的也可能是动态的，又可分为单分派和多分派。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>先上一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/16 上午11:14.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 静态分派演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, guy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, lady&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, gentleman&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sd.sayHello(man);</span><br><span class="line">        sd.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello, guy</span><br><span class="line">hello, guy</span><br></pre></td></tr></table></figure>
<p>很简单，下面从虚拟机的角度来讲解一下。</p>
<pre><code>Human man = new Man();</code></pre>
<p>上面的“Human”称为变量的静态类型（Static Type），后面的“Man”称为变量的实际类型（Actual Type）。静态类型在编译期是可知的，实际类型变化的结果在运行期才可确定。<strong>虚拟机（编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的</strong>，所以选了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p>
<p>所有依赖<strong>静态类型</strong>来定位方法执行版本的分派动作称为静态分派。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派和多态的重写有着密切的关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/16 下午3:25.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>
<p>我们用javap -c 命令看看输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #2                  &#x2F;&#x2F; class polymorphic&#x2F;DynamicDispatch$Man</span><br><span class="line">     3: dup</span><br><span class="line">     4: invokespecial #3                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     7: astore_1</span><br><span class="line">     8: new           #4                  &#x2F;&#x2F; class polymorphic&#x2F;DynamicDispatch$Woman</span><br><span class="line">    11: dup</span><br><span class="line">    12: invokespecial #5                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    15: astore_2</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #6                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Human.sayHello:()V</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #6                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Human.sayHello:()V</span><br><span class="line">    24: new           #4                  &#x2F;&#x2F; class polymorphic&#x2F;DynamicDispatch$Woman</span><br><span class="line">    27: dup</span><br><span class="line">    28: invokespecial #5                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    31: astore_1</span><br><span class="line">    32: aload_1</span><br><span class="line">    33: invokevirtual #6                  &#x2F;&#x2F; Method polymorphic&#x2F;DynamicDispatch$Human.sayHello:()V</span><br><span class="line">    36: return</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>0~15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量Slot之中，这个动作对应了这两句代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>
<p>然后16~21行是关键。16: aload_1和20: aload_2两句分别将两个对象压入栈顶，17和21的invokevirtual就是调用方法指令，后面的是参数（方法的符号引用）。那么多态如何确定执行的目标方法，下面说一下invokevirtual指令的运行时解析过程：</p>
<ol>
<li>找到操作数栈的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstracMethodError异常。</li>
</ol>
<p>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的过程称为动态分派。</p>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br>看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/16 下午5:07.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">father choose 360</span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>

<p>编译阶段，也就是静态分派的过程，先确定静态类型是Father还是Son，再确定参数是QQ还是360，因为是根据两个宗量进行选择，所以Java语言的静态分派是多分派类型。</p>
<p>运行阶段，也就是动态分派的过程，在执行“son.hardChoice(new QQ());”对应的invokevirtual指令时，由于编译期已决定目标方法的签名必须为hardChoice(QQ),所以只需要确定方法接收者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS Jenkins + Sonar + Nexus 环境搭建</title>
    <url>/2015/03/06/linux/CentOS-Jenkins-Sonar-Nexus-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Nexus篇"><a href="#Nexus篇" class="headerlink" title="Nexus篇"></a>Nexus篇</h1><p>在Centos上安装</p>
<p>如果机器上是JDK1.6的话，nexus-2.5.1是最后一个支持JDK1.6的版本。</p>
<p>下载地址：<a href="http://www.sonatype.org/nexus/archived">http://www.sonatype.org/nexus/archived</a></p>
<p>我这里使用FTP工具上传到服务器上。执行命令的时候如果遇到没有权限的地方用chmod改变文件权限。</p>
<p>设置为系统自启动服务（使用root用户）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/jdk/nexus-2.5.1-01/bin/jsw/linux-x86-64/nexus nexus</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/init.d/nexus</code>文件，添加以下变量定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NEXUS_HOME=/usr/<span class="built_in">local</span>/jdk/nexus-2.5.1-01</span><br><span class="line">PLATFORM=linux-x86-64</span><br><span class="line">PLATFORM_DIR=<span class="string">&quot;<span class="variable">$&#123;NEXUS_HOME&#125;</span>/bin/jsw/<span class="variable">$&#123;PLATFORM&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>修改如下变量，设置启动用户为ycftp(这里用你自己的用户)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN_AS_USER=ycftp</span><br></pre></td></tr></table></figure>
<p>执行命令添加nexus自启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig –add nexus</span><br><span class="line">chkconfig –levels 345 nexus on</span><br></pre></td></tr></table></figure>
<p>执行如下命令启动、停止nexus服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service nexus start</span><br><span class="line">service nexus stop</span><br></pre></td></tr></table></figure>
<p>启动后可通过<a href="http://yourip:8081/nexus%E8%AE%BF%E9%97%AE">http://yourip:8081/nexus访问</a></p>
<p>用admin/admin123登陆<br>登陆后点击左侧Repositories，将下图所示设置为true，就可以搜索了<br><img src="http://img.blog.csdn.net/20140826131253109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br><img src="http://img.blog.csdn.net/20140826131504260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>这个时候还搜索不到</p>
<p>需要再右击选项点击 Repair Index如下所示<br><img src="http://img.blog.csdn.net/20140826131615365?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>修复完成后便可以搜索了。</p>
<h1 id="Jenkins篇"><a href="#Jenkins篇" class="headerlink" title="Jenkins篇"></a>Jenkins篇</h1><p>添加Jenkins的源（repository）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget -O/etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo</span><br><span class="line">sudo rpm--import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</span><br></pre></td></tr></table></figure>
<p>不然你在启动jenkins服务的时候他会说你没有什么key啥的。</p>
<p>安装Jenkins：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum installjenkins</span><br></pre></td></tr></table></figure>
<p>安装完成后，有如下相关目录：</p>
<p><code>/usr/lib/jenkins/</code>：jenkins安装目录，WAR包会放在这里。</p>
<p>注意修改端口号</p>
<p><code>/etc/sysconfig/jenkins</code>：jenkins配置文件，“端口”，“JENKINS_HOME”等都可以在这里配置。内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Path:        Development/Jenkins</span></span><br><span class="line"><span class="comment">## Description: Configuration for theJenkins continuous build server</span></span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;/var/lib/jenkins&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Directory where Jenkins store itsconfiguration and working</span></span><br><span class="line"><span class="comment"># files (checkouts, build reports, artifacts,...).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_HOME=<span class="string">&quot;/var/lib/jenkins&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Java executable to run Jenkins</span></span><br><span class="line"><span class="comment"># When left empty, we&#x27;ll try to find thesuitable Java.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_JAVA_CMD=<span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;jenkins&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unix user account that runs the Jenkinsdaemon</span></span><br><span class="line"><span class="comment"># Be careful when you change this, as youneed to update</span></span><br><span class="line"><span class="comment"># permissions of $JENKINS_HOME and/var/log/jenkins.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_USER=<span class="string">&quot;jenkins&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;-Djava.awt.headless=true&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Options to pass to java when runningJenkins.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_JAVA_OPTIONS=<span class="string">&quot;-Djava.awt.headless=true&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        integer(0:65535)</span></span><br><span class="line"><span class="comment">## Default:     8080</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Port Jenkins is listening on.</span></span><br><span class="line"><span class="comment"># Set to -1 to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;8085&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        integer(0:65535)</span></span><br><span class="line"><span class="comment">## Default:     8009</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ajp13 Port Jenkins is listening on.</span></span><br><span class="line"><span class="comment"># Set to -1 to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_AJP_PORT=<span class="string">&quot;8019&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        integer(1:9)</span></span><br><span class="line"><span class="comment">## Default:     5</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Debug level for logs -- the higher thevalue, the more verbose.</span></span><br><span class="line"><span class="comment"># 5 is INFO.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_DEBUG_LEVEL=<span class="string">&quot;5&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        yesno</span></span><br><span class="line"><span class="comment">## Default:     no</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Whether to enable access logging or not.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_ENABLE_ACCESS_LOG=<span class="string">&quot;no&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        integer</span></span><br><span class="line"><span class="comment">## Default:     100</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Maximum number of HTTP worker threads.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_HANDLER_MAX=<span class="string">&quot;100&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        integer</span></span><br><span class="line"><span class="comment">## Default:     20</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Maximum number of idle HTTP workerthreads.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_HANDLER_IDLE=<span class="string">&quot;20&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass arbitrary arguments to Jenkins.</span></span><br><span class="line"><span class="comment"># Full option list: java -jar jenkins.war--help</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_ARGS=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我这里修改端口号为8085，避免和本机tomcat冲突</p>
<p>启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo servicejenkins start</span><br></pre></td></tr></table></figure>

<p>启动后用 <code>http://yourip:8085/</code> 访问<br><img src="http://img.blog.csdn.net/20140826131719653?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h1 id="Sonar篇"><a href="#Sonar篇" class="headerlink" title="Sonar篇"></a>Sonar篇</h1><p>首先下载<a href="http://www.sonarqube.org/downloads/">http://www.sonarqube.org/downloads/</a></p>
<p>我用的ftp工具上传到服务器。</p>
<p>编辑~/.bash_profile，添加环境变量</p>
<p>添加SONAR_RUNNER_HOME(就是sonar-runner-2.4的全路径名，比如/usr/local/sonar-runner-2.4)环境变量，并将SONAR_RUNNER_HOME/bin加入PATH变量中</p>
<p>记得使环境变量生效</p>
<p>source ~/.bash_profile</p>
<p>我这里使用mysql数据库，但不说mysql怎么安装了。</p>
<p>先配置Sonar要用的数据库环境：</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><ul>
<li><p>在mysql中执行如下脚本创建数据库及mysql用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">CREATE USER <span class="string">&#x27;sonar&#x27;</span> IDENTIFIED BY <span class="string">&#x27;sonar&#x27;</span>;</span><br><span class="line">GRANT ALL ON sonar.* TO <span class="string">&#x27;sonar&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;sonar&#x27;</span>;</span><br><span class="line">GRANT ALL ON sonar.* TO <span class="string">&#x27;sonar&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;sonar&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑${SONAR_HOME}/conf/sonar.properties配置数据库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line"></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionalproperties</span></span><br><span class="line"></span><br><span class="line">sonar.jdbc.driverClassName:com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置DB驱动包<br>如果使用Oracle数据库，必须手动复制驱动类到${SONAR_HOME}/extensions/jdbc-driver/oracle/目录下。其它支持的数据库默认提供了驱动，<a href="http://docs.codehaus.org/display/SONAR/Analysis+Parameters">http://docs.codehaus.org/display/SONAR/Analysis+Parameters</a> 列举了一些常用的配置及默认值.</p>
</li>
</ul>
<h2 id="修改sonar配置文件"><a href="#修改sonar配置文件" class="headerlink" title="修改sonar配置文件"></a>修改sonar配置文件</h2><p>编辑sonar所在的目录（比如/usr/local/sonar-4.4）中conf/sonar.properties文件，配置数据库设置，默认已经提供了各类数据库的支持，只要将注释去掉就可以。这里使用mysql，因此取消mysql模块的注释，并将sonar中原有的嵌入式的数据库的jdbc.url注释掉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vi sonar.properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#需要注释下面这条语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sonar.jdbc.url=jdbc:h2:tcp://localhost:9092/sonar</span></span><br><span class="line"></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line"></span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line"></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=</span><br><span class="line"></span><br><span class="line">utf8&amp;rewriteBatchedStatements=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional properties</span></span><br><span class="line"></span><br><span class="line">sonar.jdbc.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h2 id="修改sonar-runner的配置文件"><a href="#修改sonar-runner的配置文件" class="headerlink" title="修改sonar-runner的配置文件"></a>修改sonar-runner的配置文件</h2><p>切换至sonar-runner的安装目录下，修改sonar-runner.properties根据实际使用数据库情况取消相应注释，这里需要和sonar.properties中保持一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Configure here general information about the environment， such as SonarQube DB details for example</span></span><br><span class="line"><span class="comment">#No information about specific project should appear here</span></span><br><span class="line"><span class="comment">#----- Default SonarQube server</span></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line"><span class="comment">#----- PostgreSQL</span></span><br><span class="line"><span class="comment">#sonar.jdbc.url=jdbc:postgresql://localhost/sonar</span></span><br><span class="line"><span class="comment">#----- MySQL</span></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8</span><br><span class="line">sonar.jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"><span class="comment">#----- Oracle</span></span><br><span class="line"><span class="comment">#sonar.jdbc.url=jdbc:oracle:thin:@localhost/XE</span></span><br><span class="line"><span class="comment">#----- Microsoft SQLServer</span></span><br><span class="line"><span class="comment">#sonar.jdbc.url=jdbc:jtds:sqlserver://localhost/sonar;SelectMethod=Cursor</span></span><br><span class="line"><span class="comment">#----- Global database settings</span></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line"><span class="comment">#----- Default source code encoding</span></span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line"><span class="comment">#----- Security (when &#x27;sonar.forceAuthentication&#x27; is set to &#x27;true&#x27;)</span></span><br><span class="line">sonar.login=admin</span><br><span class="line">sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>运行如下命令启动sonar，其它操作系统sonar均提供了启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;SONAR_HOME&#125;</span>/bin/linux-x86-64/sonar.sh start</span><br></pre></td></tr></table></figure>
<p>如果遇到wrapper没有执行权限，用chmod命令赋予权限</p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 wrapper</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问: <a href="http://yourip:9000/">http://yourip:9000/</a> ，运行界面如下：<br><img src="http://img.blog.csdn.net/20140826131827217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>配置为自启动服务</p>
<p>使用<code>root</code>账户或者开启<code>sudo</code>权限操作。</p>
<p>创建自启动脚本文件<code>/etc/init.d/sonar</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi/etc/init.d/sonar</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc file for SonarQube</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: 345 96 10</span></span><br><span class="line"><span class="comment"># description: SonarQube system (www.sonarsource.org)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides: sonar</span></span><br><span class="line"><span class="comment"># Required-Start: $network</span></span><br><span class="line"><span class="comment"># Required-Stop: $network</span></span><br><span class="line"><span class="comment"># Default-Start: 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop: 0 1 2 6</span></span><br><span class="line"><span class="comment"># Short-Description: SonarQube system (www.sonarsource.org)</span></span><br><span class="line"><span class="comment"># Description: SonarQube system (www.sonarsource.org)</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">/usr/bin/sonar $*</span><br></pre></td></tr></table></figure>
<p>添加启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s <span class="variable">$SONAR_HOME</span>/bin/linux-x86-64/sonar.sh /usr/bin/sonar</span><br><span class="line">chmod 755 /etc/init.d/sonar</span><br><span class="line">chkconfig --add sonar</span><br></pre></td></tr></table></figure>
<h2 id="与Jenkins集成"><a href="#与Jenkins集成" class="headerlink" title="与Jenkins集成"></a>与Jenkins集成</h2><p>在jenkins的插件管理中选择安装sonar jenkins plugin，该插件可以使项目每次构建都调用sonar进行代码度量。具体配置方式不再叙述。</p>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 6.5 安装docker</title>
    <url>/2015/12/08/linux/centos-6-5-%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>先试试把开环境用docker来部署。</p>
<p><a href="http://docs.docker.com/engine/installation/centos/">http://docs.docker.com/engine/installation/centos/</a><br>直接按照这里安装就可以了，不过我在这里遇到了一点问题。<br>我是centos6.5，内核在 3.8 以上<br>通过以下命令查看您的 CentOS 内核：  </p>
<p><code>uname -r</code></p>
<p>如果执行以上命令后，输出的内核版本号低于 3.8，请参考下面的方法来来升级您的 Linux 内核。  </p>
<p>对于 CentOS 6.5 而言，内核版本默认是 2.6。首先，可通过以下命令安装最新内核：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -ivh http://www.elrepo.org/elrepo-release-6-5.el6.elrepo.noarch.rpm</span><br><span class="line">yum -y --enablerepo=elrepo-kernel install kernel-lt</span><br></pre></td></tr></table></figure>

<p>随后，编辑以下配置文件：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/grub.conf</span><br></pre></td></tr></table></figure>

<p>将<code>default=1</code>修改为<code>default=0</code>。</p>
<a id="more"></a>
<p>最后，通过<code>reboot</code>命令重启操作系统。</p>
<p>重启后如果不出意外的话，再次查看内核，您的 CentOS 内核将会显示为 3.10。</p>
<p>如果到这里，您和我们所期望的结果是一致的。恭喜您！下面我们就一起来安装 Docker 了。</p>
<p>接下来按照官网文档的步骤安装  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/<span class="variable">$releasever</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br><span class="line">sudo yum install docker-engine</span><br></pre></td></tr></table></figure>

<p>我在这里遇到了下面的一个问题：</p>
<pre><code>Error: docker-engine conflicts with docker-io-1.7.1-2.el6.x86_64</code></pre>
<p>查了一会发现是因为docker-io改名为docker-engine，所以造成冲突了，我这台服务器还安装过以前版本的，执行以下命令来删除老的版本。 </p>
<pre><code>yum remove docker-io</code></pre>
<p>然后再来安装</p>
<pre><code>sudo yum install docker-engine</code></pre>
<p>就可以安装成功了，继续下一步。我试着部署一个tomcat，执行以下命令下载一个centos镜像</p>
<pre><code>docker pull centos</code></pre>
<p>然后我发现每次命令都要用sudo，很不方便</p>
<p>原来默认安装完 docker 后，每次执行 docker 都需要运行 sudo 命令，非常浪费时间影响效率。如果不跟 sudo，直接执行 <code>docker images</code> 命令会有如下问题：</p>
<pre><code>FATA[0000] Get http:///var/run/docker.sock/v1.18/images/json: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS-enabled daemon without TLS?  </code></pre>
<p>参考这里 <a href="http://bsaunder.github.io/2014/12/21/running-docker-without-sudo/">http://bsaunder.github.io/2014/12/21/running-docker-without-sudo/</a><br>执行以下命令来解决</p>
<pre><code>sudo groupadd docker</code></pre>
<p>将用户加入该 group 内。</p>
<pre><code>sudo gpasswd -a $&#123;USER&#125; docker</code></pre>
<p>重启docker</p>
<pre><code>sudo service docker restart</code></pre>
<p><strong>切换当前会话到新group</strong> (如果想立即生效此步不可少，因为 <code>groups</code> 命令获取到的是缓存的组信息，刚添加的组信息未能生效，所以 docker images 执行时同样有错。)</p>
<pre><code>newgrp - docker</code></pre>
<p>还有就是docker的官方镜像下载实在是太慢了，找到一个国内提供加速服务的<a href="https://dashboard.daocloud.io/">daocloud</a></p>
<p>注册登录后使用加速器功能就可以了</p>
<p>docker默认的images存放路径是/var/lib/docker<br>我的服务器系统硬盘自带的容量很小<br>所以我要修改他的存放路径，修改下面文件里的other_args参数，重启docker。</p>
<pre><code>sudo vim /etc/sysconfig/docker

other_args=&quot;--graph=yourpath&quot;</code></pre>
<p>下面还有一个私库的问题，不用localhost访问出现了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unable to ping registry endpoint https://10.168.248.36:5000/v0/</span><br><span class="line">v2 ping attempt failed with error: Get https://10.168.248.36:5000/v2/: tls: oversized record received with length 20527</span><br><span class="line"> v1 ping attempt failed with error: Get https://10.168.248.36:5000/v1/_ping: tls: oversized record received with length 20527</span><br></pre></td></tr></table></figure>

<p>依然是修改<code>/etc/sysconfig/docker</code>里面的other_args，加上部署私库的机器的IP。</p>
<pre><code> --insecure-registry=yourip:5000</code></pre>
<p>这样就可以正常的push和pull了</p>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 6.5 安装gitlab安装需注意的问题</title>
    <url>/2015/02/06/linux/centos-6-5-%E5%AE%89%E8%A3%85gitlab%E5%AE%89%E8%A3%85%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>安装gitlab<br>首先按照官网进行操作，环境为centos 6.5<br><a href="https://about.gitlab.com/downloads/">https://about.gitlab.com/downloads/</a><br>注意安装过程中执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>出现错误，在<code>/etc/gitlab/gitlab.rb</code>中修改域名后再执行一次方可启动成功<br><img src="http://img.blog.csdn.net/20141207182607301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWZpc2Fib3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<a id="more"></a>
<p>进页面提示<code>502</code>，用命令查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl tail postgresql  </span><br></pre></td></tr></table></figure>
<p>提示内存不足，官方也是建议1g内存进行搭建，512m的话也可以安装但是要添加swap，不然启动后就会提示内存不足，我目前是512的，添加<em>swap</em>后访问成功，但是有点慢可能，还是升为1g最好。</p>
<p>上面的图是我目前的配置，注意这里修改了gitlab默认的仓库存储路径，教程官网有<br><a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md</a><br>我这里贴出来给大家看看</p>
<h4 id="Storing-Git-data-in-an-alternative-directory"><a href="#Storing-Git-data-in-an-alternative-directory" class="headerlink" title="Storing Git data in an alternative directory"></a>Storing Git data in an alternative directory</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prevent users from writing to the repositories while you move them.</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"><span class="comment"># Only move &#x27;repositories&#x27;; &#x27;gitlab-satellites&#x27; will be recreated</span></span><br><span class="line"><span class="comment"># automatically. Note there is _no_ slash behind &#x27;repositories&#x27;, but there _is_ a</span></span><br><span class="line"><span class="comment"># slash behind &#x27;git-data&#x27;.</span></span><br><span class="line">sudo rsync -av /var/opt/gitlab/git-data/repositories /mnt/nas/git-data/</span><br><span class="line"><span class="comment"># Fix permissions if necessary</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"><span class="comment"># Double-check directory layout in /mnt/nas/git-data. Expected output:</span></span><br><span class="line"><span class="comment"># gitlab-satellites repositories</span></span><br><span class="line">sudo ls /mnt/nas/git-data/</span><br><span class="line"><span class="comment"># Done! Start GitLab and verify that you can browse through the repositories in</span></span><br><span class="line"><span class="comment"># the web interface.</span></span><br><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure>
<p>可以看到这下面是安装完成后gitlab一些文件和数据的路径    </p>
<blockquote>
<p>注：看到网上很多资料都不对，可能是过时了，所以搞gitlab建议大家还是以官网为主，说不定你在看我这个文章的时候也过时了</p>
</blockquote>
<h4 id="Omnibus-gitlab-uses-four-different-directories"><a href="#Omnibus-gitlab-uses-four-different-directories" class="headerlink" title="Omnibus-gitlab uses four different directories."></a>Omnibus-gitlab uses four different directories.</h4><ul>
<li><code>/opt/gitlab</code> holds application code for GitLab and its dependencies.</li>
<li><code>/var/opt/gitlab</code> holds application data and configuration files that gitlab-ctl reconfigure writes to.</li>
<li><code>/etc/gitlab</code> holds configuration files for omnibus-gitlab. These are the only files that you should ever have to edit manually.</li>
<li><code>/var/log/gitlab</code> contains all log data generated by components of omnibus-gitlab.</li>
</ul>
<p>有错误的时候尽量用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl tail</span><br><span class="line">``` </span><br><span class="line">查看日志分析错误原因，我在配置邮件的时候也是试了很久才用上</span><br><span class="line"></span><br><span class="line">接下来我们来配置邮件，我这里使用SMTP，用腾讯企业邮箱</span><br><span class="line">还是修改`/etc/gitlab/gitlab.rb` 配置文件，再次**提醒**网上很多文章可以已经过时了</span><br><span class="line">附上官网地址</span><br><span class="line">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/smtp.md</span><br><span class="line">```ruby</span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable&#x27;</span>] = <span class="literal">true</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_address&#x27;</span>] = <span class="string">&quot;smtp.exmail.qq.com&quot;</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_port&#x27;</span>] = 25  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_user_name&#x27;</span>] = <span class="string">&quot;xx@xxx.com&quot;</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_password&#x27;</span>] = <span class="string">&quot;password&quot;</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_domain&#x27;</span>] = <span class="string">&quot;exmail.qq.com&quot;</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_authentication&#x27;</span>] = <span class="string">&quot;login&quot;</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;smtp_enable_starttls_auto&#x27;</span>] = <span class="literal">true</span>  </span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_email_from&#x27;</span>] = <span class="string">&#x27;xx@xxx.com&#x27;</span>  </span><br><span class="line"><span class="comment">##修改gitlab配置的发信人  </span></span><br><span class="line">user[<span class="string">&quot;git_user_email&quot;</span>] = <span class="string">&quot;xx@xxx.com&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>保持发信人和登录邮箱一致,我配置这里的时候也出错了，原因是我在看腾讯官网时候写的是用的SSL，端口是465<br>但是gitlab好像不是用的<code>ssl</code>，gitlab的教程里也没找到是否启用ssl的配置，我也没去深究了，于是把端口号改为<code>25</code>，邮件发送成功。<br>大家在测试邮件的时候可以用忘记密码来发送邮件测试，然后用<code>gitlab-ctl tail</code>来查看，大概等1分钟就能看到发送邮件的日志，出错了再具体分析原因</p>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6.5使用yum安装mysql</title>
    <url>/2015/01/31/linux/centos6-5%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<p>要使用yum 安装mysql，要使用mysql的yum仓库，先从官网下载适合你系统的仓库<br><a href="http://dev.mysql.com/downloads/repo/yum/">http://dev.mysql.com/downloads/repo/yum/</a><br>centos 6.5 对应的是mysql-community-release-el6-5.noarch.rpm<br>然后安装一下这个仓库列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum localinstall mysql-community-release-el6-5.noarch.rpm </span><br></pre></td></tr></table></figure>
<p>执行这个命令后就能看到可安装的mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist enabled | grep <span class="string">&quot;mysql.*-community.*&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果我们是要安装最新的版本，那么可以直接执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>
<p>如果我们要选择版本，可以先执行下面这个命令查看一下有哪些版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure>
<p>如果要选择版本的话，有两种方式，一种是使用命令来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; sudo yum-config-manager --<span class="built_in">disable</span> mysql56-community</span><br><span class="line">shell&gt; sudo yum-config-manager --<span class="built_in">enable</span> mysql57-community-dmr</span><br></pre></td></tr></table></figure>
<p>这个命令就是在仓库中启用5.7版本的，禁用5.6版本子仓库<br>或者编辑/etc/yum.repos.d/mysql-community.repo文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable to use MySQL 5.6</span></span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL 5.6 Community Server</span><br><span class="line">baseurl=//repo.mysql.com/yum/mysql-5.6-community/el/5/<span class="variable">$basearch</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql </span><br></pre></td></tr></table></figure>
<p><code>enabled=0</code>表示禁用<br>比如要安装5.7版本的<em>mysql</em>，要确定5.6的<code>enabled=0</code>，5.7的<code>enabled=1</code>，一次保证只启用一个子仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note: MySQL 5.7 is currently in development. For use at your own risk.</span></span><br><span class="line"><span class="comment"># Please read with sub pages: https://dev.mysql.com/doc/relnotes/mysql/5.7/en/</span></span><br><span class="line">[mysql57-community-dmr]</span><br><span class="line">name=MySQL 5.7 Community Server Development Milestone Release</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/<span class="variable">$basearch</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure>
<p>然后我们就可以愉快的安装mysql了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>
<p>安装完成后我们启动mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure>
<p>查看mysql状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysqld status</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装redis4.0.10并进行生产环境部署</title>
    <url>/2018/07/19/linux/redis-install/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>直奔主题，官网下载redis最新版本（2018年07月19日）</p>
<p><a href="http://download.redis.io/releases/redis-4.0.10.tar.gz">http://download.redis.io/releases/redis-4.0.10.tar.gz</a></p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装tcl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install tcl</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="安装单机版Reids"><a href="#安装单机版Reids" class="headerlink" title="安装单机版Reids"></a>安装单机版Reids</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/redis &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis</span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class="line">tar -zxvf redis-4.0.10.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-4.0.10</span><br><span class="line">make &amp;&amp; make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>最后一步可能需要等的有点久，安装完成以后就开始进行生产环境配置。</p>
<h1 id="Redis生产环境启动方案"><a href="#Redis生产环境启动方案" class="headerlink" title="Redis生产环境启动方案"></a>Redis生产环境启动方案</h1><ol>
<li><p>redis的<code>utils</code>目录下，有个<code>redis_init_script</code>脚本</p>
</li>
<li><p>将<code>redis_init_script</code>脚本拷贝到linux的<code>/etc/init.d</code>目录中，将<code>redis_init_script</code>重命名为<code>redis_6370</code>，<code>6370</code>是我们希望这个redis实例监听的端口号</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/redis/redis-4.0.10/utils/redis_init_scrip /etc/init.d/redis_6370</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>redis_6370</code>脚本的第6行的REDISPORT，设置为相同的端口号（默认是6379）</p>
</li>
<li><p>创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6370（存放redis的持久化文件）</p>
</li>
<li><p>修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6370.conf</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/redis/redis-4.0.10/redis.conf /etc/redis/6370.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改redis.conf中的部分配置为生产环境</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让redis以daemon进程运行</span></span><br><span class="line">daemonize	yes							</span><br><span class="line"><span class="comment"># 设置redis的pid文件位置</span></span><br><span class="line">pidfile		/var/run/redis_6370.pid </span><br><span class="line"><span class="comment"># 设置redis的监听端口号</span></span><br><span class="line">port		6370						</span><br><span class="line"><span class="comment"># 设置持久化文件的存储位置</span></span><br><span class="line">dir 		/var/redis/6370				</span><br><span class="line"><span class="comment"># 打开数据持久化</span></span><br><span class="line">appendonly  yes	 						</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass yourpass	 	  			</span><br><span class="line"><span class="comment"># 设置连接Redis的地址</span></span><br><span class="line"><span class="comment"># 如果提供给其他机器访问，请在此处设置IP为机器IP</span></span><br><span class="line"><span class="built_in">bind</span>  127.0.0.1					</span><br></pre></td></tr></table></figure></li>
<li><p>启动redis</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">chmod 777 redis_6370</span><br><span class="line">./redis_6370 start</span><br></pre></td></tr></table></figure></li>
<li><p>确认redis进程是否启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li>
<li><p>让redis跟随系统启动自动启动，在<code>/etc/init.d/redis_6370</code>脚本中，最上面，加入两行注释</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># chkconfig:   2345 90 10</span><br><span class="line"># description:  Redis is a persistent key-value database</span><br></pre></td></tr></table></figure>
<p> 然后执行命令:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig redis_6370 on</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="redis-cli测试"><a href="#redis-cli测试" class="headerlink" title="redis-cli测试"></a>redis-cli测试</h1><h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6370 -a yourpass PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h2 id="停机"><a href="#停机" class="headerlink" title="停机"></a>停机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6370 SHUTDOWN</span><br></pre></td></tr></table></figure>

<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6370 </span><br><span class="line">127.0.0.1:6370&gt; auth yourpass</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6370&gt; PING</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6370&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6370&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>是不是很简单明了？文章到此结束。。。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB2-查询详解</title>
    <url>/2018/01/01/mongodb/mongo2/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>MongoDB为我们提供了很强大的查询功能，之前演示的都比较简单，接下来将展示一些进阶用法。</p>
<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.personalinfo.remove(&#123;&#125;);</span><br><span class="line">db.personalinfo.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;);</span><br><span class="line">db.personalinfo.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="attr">age</span>:<span class="number">11</span>&#125;);</span><br><span class="line">db.personalinfo.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;wangsu&#x27;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="根据某个字段查询"><a href="#根据某个字段查询" class="headerlink" title="根据某个字段查询"></a>根据某个字段查询</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:<span class="number">11</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤返回的字段"><a href="#过滤返回的字段" class="headerlink" title="过滤返回的字段"></a>过滤返回的字段</h2><p>find的第二个参数可以设置需要返回的字段，以节省网络传输</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;&#125;, &#123;<span class="attr">name</span>:<span class="number">1</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>不能同时使用包含或者排除，如果需要排除，直接不写age的字段即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;&#125;, &#123;<span class="attr">name</span>:<span class="number">1</span>, <span class="attr">age</span>:<span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">Error</span>: error: &#123;</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;Projection cannot have a mix of inclusion and exclusion.&quot;</span>,</span><br><span class="line">	<span class="string">&quot;code&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;codeName&quot;</span> : <span class="string">&quot;BadValue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="findOne"><a href="#findOne" class="headerlink" title="findOne()"></a>findOne()</h2><p>findOne()跟find()的参数是一样的，只是findOne只返回查询到的第一条数据。</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><h3 id="大于-amp-小于"><a href="#大于-amp-小于" class="headerlink" title="大于&amp;小于"></a>大于&amp;小于</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">10</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大于：$gt</li>
<li>大于等于：$gte</li>
<li>小于：$lt</li>
<li>小于等于：$lte</li>
</ul>
<p>多个条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">10</span>,<span class="attr">$lt</span>:<span class="number">12</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="all"><a href="#all" class="headerlink" title="$all"></a>$all</h3><p>$all运算符表示从数组中过滤包含的字段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.address.insert(&#123;<span class="attr">name</span>:[<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;tianjin&#x27;</span>]&#125;);</span><br><span class="line">db.address.insert(&#123;<span class="attr">name</span>:[<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;shanghai&#x27;</span>]&#125;);</span><br><span class="line">db.address.insert(&#123;<span class="attr">name</span>:[<span class="string">&#x27;dalian&#x27;</span>,<span class="string">&#x27;shanghai&#x27;</span>]&#125;);</span><br><span class="line"></span><br><span class="line">&gt; db.address.find(&#123;<span class="attr">name</span>: &#123;<span class="attr">$all</span>: [<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;tianjin&#x27;</span>]&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a4994c2f0ec47e9f5ce2db7&quot;</span>), <span class="string">&quot;name&quot;</span> : [ <span class="string">&quot;beijing&quot;</span>, <span class="string">&quot;tianjin&quot;</span> ] &#125;</span><br><span class="line">&gt; db.address.find(&#123;<span class="attr">name</span>: &#123;<span class="attr">$all</span>: [<span class="string">&#x27;shanghai&#x27;</span>]&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a4994c2f0ec47e9f5ce2db8&quot;</span>), <span class="string">&quot;name&quot;</span> : [ <span class="string">&quot;beijing&quot;</span>, <span class="string">&quot;shanghai&quot;</span> ] &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a4994c2f0ec47e9f5ce2db9&quot;</span>), <span class="string">&quot;name&quot;</span> : [ <span class="string">&quot;dalian&quot;</span>, <span class="string">&quot;shanghai&quot;</span> ] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="exists"><a href="#exists" class="headerlink" title="$exists"></a>$exists</h3><p>查询包含某个字段的文档。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$exists</span>:<span class="literal">true</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>
<p>$exists要和$in结合使用来判断某个字段的值为null，并且字段真的存在的情况下，默认age:null的查询方式，会把没有这个字段的数据也查出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhaoliu&#x27;</span>, <span class="attr">age</span>:<span class="literal">null</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhaoliu&#x27;</span>, <span class="attr">myage</span>:<span class="number">14</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:<span class="literal">null</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a499774f0ec47e9f5ce2dba&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="literal">null</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a49977ef0ec47e9f5ce2dbb&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;myage&quot;</span> : <span class="number">14</span> &#125;</span><br><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$in</span>:[<span class="literal">null</span>],<span class="attr">$exists</span>: <span class="literal">true</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a499774f0ec47e9f5ce2dba&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="literal">null</span> &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>


<h3 id="mod"><a href="#mod" class="headerlink" title="$mod"></a>$mod</h3><p>$mod是取模</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;age:&#123;$mod:[5,2]&#125;&#125;);</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a498d87f0ec47e9f5ce2db6&quot;), &quot;name&quot; : &quot;wangsu&quot;, &quot;age&quot; : 12 &#125;</span><br></pre></td></tr></table></figure>


<h3 id="ne"><a href="#ne" class="headerlink" title="$ne"></a>$ne</h3><p>$ne表示不等于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$ne</span>:<span class="number">5</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a499774f0ec47e9f5ce2dba&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="literal">null</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a49977ef0ec47e9f5ce2dbb&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;myage&quot;</span> : <span class="number">14</span> &#125;</span><br><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$ne</span>:<span class="number">5</span>, <span class="attr">$exists</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a499774f0ec47e9f5ce2dba&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="$in"></a>$in</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$in</span>:[<span class="number">11</span>,<span class="number">12</span>]&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<p>not in</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$nin</span>:[<span class="number">11</span>,<span class="number">12</span>]&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="size"><a href="#size" class="headerlink" title="$size"></a>$size</h3><p>根据数组长度筛选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.mydemo.insert(&#123;myarray:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;);</span><br><span class="line">db.mydemo.insert(&#123;myarray:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;);</span><br><span class="line">db.mydemo.insert(&#123;myarray:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]&#125;);</span><br><span class="line"></span><br><span class="line">&gt; db.mydemo.find(&#123;myarray: &#123;$size: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a4999d8f26cb8a9ec47407e&quot;</span>), <span class="string">&quot;myarray&quot;</span> : [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="a"><a href="#a" class="headerlink" title="/a/"></a>/a/</h3><p>查询某个字段包含字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;<span class="attr">name</span>:<span class="regexp">/a/</span>&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="$where"></a>$where</h3><p>$where比较常用在一些复杂的查询条件，它的内容是一个JavaScript的代码表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find(&#123;$where: <span class="string">&#x27;this.age &gt; 10&#x27;</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find().count();</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; db.personalinfo.find().skip(<span class="number">1</span>);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d87f0ec47e9f5ce2db6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangsu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&gt; db.personalinfo.find().limit(<span class="number">2</span>);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a498d86f0ec47e9f5ce2db5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<p>count()默认是统计整个文档的数量，要根据之前的条件统计，需要加上参数true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.find().limit(<span class="number">2</span>).count();</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; db.personalinfo.find().limit(<span class="number">2</span>).count(<span class="literal">true</span>);</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>查询就介绍到这里，后面的文章将继续介绍MongoDB的聚合操作。</p>
]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB5-副本集</title>
    <url>/2018/01/07/mongodb/mongo5/</url>
    <content><![CDATA[<h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h1><p>MongoDB复制是将数据同步在多个服务器的过程。</p>
<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>
<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>
<h2 id="什么是复制"><a href="#什么是复制" class="headerlink" title="什么是复制?"></a>什么是复制?</h2><ul>
<li>保障数据的安全性</li>
<li>数据高可用性 (24*7)</li>
<li>灾难恢复</li>
<li>无需停机维护（如备份，重建索引，压缩）</li>
<li>分布式读取数据</li>
</ul>
<a id="more"></a>

<h2 id="MongoDB复制原理"><a href="#MongoDB复制原理" class="headerlink" title="MongoDB复制原理"></a>MongoDB复制原理</h2><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。</p>
<p>mongodb各个节点常见的搭配方式为：一主一从、一主多从。</p>
<p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<p>MongoDB复制结构图如下所示：</p>
<p><img src="https://docs.mongodb.com/manual/_images/replica-set-read-write-operations-primary.bakedsvg.svg"></p>
<p><img src="https://docs.mongodb.com/manual/_images/replica-set-primary-with-two-secondaries.bakedsvg.svg"></p>
<p>以上结构图中，客户端从主节点读取数据，在客户端写入数据到主节点时， 主节点与从节点进行数据交互保障数据的一致性。</p>
<h2 id="副本集特征："><a href="#副本集特征：" class="headerlink" title="副本集特征："></a>副本集特征：</h2><ul>
<li>N个节点的集群</li>
<li>任何节点可作为主节点</li>
<li>所有写入操作都在主节点上</li>
<li>自动故障转移</li>
<li>自动恢复</li>
</ul>
<h2 id="MongoDB副本集配置"><a href="#MongoDB副本集配置" class="headerlink" title="MongoDB副本集配置"></a>MongoDB副本集配置</h2><ol>
<li>MongoDB数据文件存储路径</li>
<li>MongoDB日志文件存储路径</li>
<li>MongoBD key文件存储路径</li>
<li>MongoDB实例监听端口（28010/28011/28012）</li>
</ol>
<p>先把要存储的目录和文件先建一下，key0，key1，key2的文件内容是一样的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── data0</span><br><span class="line">│   ├── data1</span><br><span class="line">│   └── data2</span><br><span class="line">├── key</span><br><span class="line">│   ├── key0</span><br><span class="line">│   │   └── key0</span><br><span class="line">│   ├── key1</span><br><span class="line">│   │   └── key1</span><br><span class="line">│   └── key2</span><br><span class="line">│       └── key2</span><br><span class="line">└── <span class="built_in">log</span></span><br><span class="line">    ├── log0</span><br><span class="line">    │   └── log0.log</span><br><span class="line">    ├── log1</span><br><span class="line">    │   └── log1.log</span><br><span class="line">    └── log2</span><br><span class="line">        └── log2.log</span><br></pre></td></tr></table></figure>

<p>启动3个mongod实例的副本集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --replSet myset --keyFile key&#x2F;key0&#x2F;key0 --port 28010 --dbpath data&#x2F;data0 --logpath log&#x2F;log0&#x2F;log0.log --logappend</span><br><span class="line">mongod --replSet myset --keyFile key&#x2F;key1&#x2F;key1 --port 28011 --dbpath data&#x2F;data1 --logpath log&#x2F;log1&#x2F;log1.log --logappend</span><br><span class="line">mongod --replSet myset --keyFile key&#x2F;key2&#x2F;key2 --port 28012 --dbpath data&#x2F;data2 --logpath log&#x2F;log2&#x2F;log2.log --logappend</span><br></pre></td></tr></table></figure>

<p>启动可能会有一个错误：</p>
<blockquote>
<p>mongodb/key/key0/key0 are too open</p>
</blockquote>
<p>查了一下说是key的文件权限太大了，<code>chmod 700 key/key0/key0</code>改一下权限再启动就好了。</p>
<p>现在这3个mongod的实例还没有通信，还没有在一个副本集中，还需要用客户端连接到其中一个实例做一些配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongo --port <span class="number">28010</span></span><br><span class="line">&gt; config_myset=&#123;<span class="attr">_id</span>:<span class="string">&#x27;bafeite&#x27;</span>, <span class="attr">members</span>:[&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28010&#x27;</span>&#125;,&#123;<span class="attr">_id</span>:<span class="number">1</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28011&#x27;</span>&#125;,&#123;<span class="attr">_id</span>:<span class="number">2</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28012&#x27;</span>&#125;]&#125;;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;bafeite&quot;</span>,</span><br><span class="line">	<span class="string">&quot;members&quot;</span> : [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28011&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28012&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(config_myset);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;Attempting to initiate a replica set with name bafeite, but command line reports myset; rejecting&quot;</span>,</span><br><span class="line">	<span class="string">&quot;code&quot;</span> : <span class="number">93</span>,</span><br><span class="line">	<span class="string">&quot;codeName&quot;</span> : <span class="string">&quot;InvalidReplicaSetConfig&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出错了，说准备初始化一个bafeite的副本集，但是命令行启动的时候是<code>myset</code>，所以拒绝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; config_myset=&#123;<span class="attr">_id</span>:<span class="string">&#x27;myset&#x27;</span>, <span class="attr">members</span>:[&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28010&#x27;</span>&#125;,&#123;<span class="attr">_id</span>:<span class="number">1</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28011&#x27;</span>&#125;,&#123;<span class="attr">_id</span>:<span class="number">2</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost:28012&#x27;</span>&#125;]&#125;;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;myset&quot;</span>,</span><br><span class="line">	<span class="string">&quot;members&quot;</span> : [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28011&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;localhost:28012&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(config_myset);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;operationTime&quot;</span> : Timestamp(<span class="number">1515328983</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : Timestamp(<span class="number">1515328983</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : BinData(<span class="number">0</span>,<span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : NumberLong(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.isMaster();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;hosts&quot;</span> : [</span><br><span class="line">		<span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:28011&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:28012&quot;</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">&quot;setName&quot;</span> : <span class="string">&quot;myset&quot;</span>,</span><br><span class="line">	<span class="string">&quot;setVersion&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;ismaster&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;secondary&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;primary&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">	<span class="string">&quot;me&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">	<span class="string">&quot;electionId&quot;</span> : ObjectId(<span class="string">&quot;7fffffff0000000000000001&quot;</span>),</span><br><span class="line">	<span class="string">&quot;lastWrite&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;opTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329025</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;lastWriteDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:43:45Z&quot;</span>),</span><br><span class="line">		<span class="string">&quot;majorityOpTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329025</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;majorityWriteDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:43:45Z&quot;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;maxBsonObjectSize&quot;</span> : <span class="number">16777216</span>,</span><br><span class="line">	<span class="string">&quot;maxMessageSizeBytes&quot;</span> : <span class="number">48000000</span>,</span><br><span class="line">	<span class="string">&quot;maxWriteBatchSize&quot;</span> : <span class="number">100000</span>,</span><br><span class="line">	<span class="string">&quot;localTime&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:43:49.070Z&quot;</span>),</span><br><span class="line">	<span class="string">&quot;logicalSessionTimeoutMinutes&quot;</span> : <span class="number">30</span>,</span><br><span class="line">	<span class="string">&quot;minWireVersion&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;maxWireVersion&quot;</span> : <span class="number">6</span>,</span><br><span class="line">	<span class="string">&quot;readOnly&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;operationTime&quot;</span> : Timestamp(<span class="number">1515329025</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : Timestamp(<span class="number">1515329025</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : BinData(<span class="number">0</span>,<span class="string">&quot;PnIvjYWgF8Z6qEIViYwQHnBs/M8=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : NumberLong(<span class="string">&quot;6508288476205547521&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.status();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;set&quot;</span> : <span class="string">&quot;myset&quot;</span>,</span><br><span class="line">	<span class="string">&quot;date&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:20.742Z&quot;</span>),</span><br><span class="line">	<span class="string">&quot;myState&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;term&quot;</span> : NumberLong(<span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;heartbeatIntervalMillis&quot;</span> : NumberLong(<span class="number">2000</span>),</span><br><span class="line">	<span class="string">&quot;optimes&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;lastCommittedOpTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;readConcernMajorityOpTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;appliedOpTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;durableOpTime&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;members&quot;</span> : [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">			<span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;state&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">			<span class="string">&quot;uptime&quot;</span> : <span class="number">2022</span>,</span><br><span class="line">			<span class="string">&quot;optime&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">				<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;optimeDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:15Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;electionTime&quot;</span> : Timestamp(<span class="number">1515328993</span>, <span class="number">1</span>),</span><br><span class="line">			<span class="string">&quot;electionDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:43:13Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;configVersion&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;self&quot;</span> : <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;localhost:28011&quot;</span>,</span><br><span class="line">			<span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;state&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;SECONDARY&quot;</span>,</span><br><span class="line">			<span class="string">&quot;uptime&quot;</span> : <span class="number">437</span>,</span><br><span class="line">			<span class="string">&quot;optime&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">				<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;optimeDurable&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">				<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;optimeDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:15Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;optimeDurableDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:15Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;lastHeartbeat&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:20.450Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;lastHeartbeatRecv&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:20.416Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;pingMs&quot;</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">			<span class="string">&quot;syncingTo&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">			<span class="string">&quot;configVersion&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;localhost:28012&quot;</span>,</span><br><span class="line">			<span class="string">&quot;health&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;state&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;stateStr&quot;</span> : <span class="string">&quot;SECONDARY&quot;</span>,</span><br><span class="line">			<span class="string">&quot;uptime&quot;</span> : <span class="number">437</span>,</span><br><span class="line">			<span class="string">&quot;optime&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">				<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;optimeDurable&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;ts&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">				<span class="string">&quot;t&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;optimeDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:15Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;optimeDurableDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:15Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;lastHeartbeat&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:20.450Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;lastHeartbeatRecv&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T12:50:20.367Z&quot;</span>),</span><br><span class="line">			<span class="string">&quot;pingMs&quot;</span> : NumberLong(<span class="number">0</span>),</span><br><span class="line">			<span class="string">&quot;syncingTo&quot;</span> : <span class="string">&quot;localhost:28010&quot;</span>,</span><br><span class="line">			<span class="string">&quot;configVersion&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;operationTime&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : Timestamp(<span class="number">1515329415</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : BinData(<span class="number">0</span>,<span class="string">&quot;ADhHuvIZC6jbKdSh8pH00VK+6ic=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : NumberLong(<span class="string">&quot;6508288476205547521&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>members就是副本集里面的mongod实例，stateStr表示了实例是Primary或者Secondary，lastHeartbeat就是上次心跳检测的时间。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.save(&#123;<span class="attr">title</span>:<span class="string">&#x27;MongoDB应用开发实战&#x27;</span>, <span class="attr">author</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">creationDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	<span class="string">&quot;writeError&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span> : <span class="number">13</span>,</span><br><span class="line">		<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;not authorized on mytest to execute command &#123; insert: \&quot;article\&quot;, ordered: true, $clusterTime: &#123; clusterTime: Timestamp(1515329415, 1), signature: &#123; hash: BinData(0, 003847BAF2190BA8DB29D4A1F291F4D152BEEA27), keyId: 6508288476205547521 &#125; &#125;, $db: \&quot;mytest\&quot; &#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>得到一个错误，查了下是因为指定了keyFile以后，mongodb默认就会加上<code>--auth</code>启动，为了简化操作，先把keyFile参数去掉重启一下吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">~ mongo --port <span class="number">28010</span></span><br><span class="line">use mytest;</span><br><span class="line">myset:PRIMARY&gt; db.article.save(&#123;<span class="attr">title</span>:<span class="string">&#x27;MongoDB应用开发实战&#x27;</span>, <span class="attr">author</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">creationDate</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</span><br></pre></td></tr></table></figure>

<p>现在去连接另外一个mongod实例，看看这个数据在不在。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongo --port <span class="number">28011</span></span><br><span class="line">use mytest;</span><br><span class="line">show dbs;</span><br><span class="line">myset:SECONDARY&gt; show dbs;</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span>T21:<span class="number">41</span>:<span class="number">21.587</span>+<span class="number">0800</span> E QUERY    [thread1] <span class="built_in">Error</span>: listDatabases failed:&#123;</span><br><span class="line">	<span class="string">&quot;operationTime&quot;</span> : Timestamp(<span class="number">1515332475</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;not master and slaveOk=false&quot;</span>,</span><br><span class="line">	<span class="string">&quot;code&quot;</span> : <span class="number">13435</span>,</span><br><span class="line">	<span class="string">&quot;codeName&quot;</span> : <span class="string">&quot;NotMasterNoSlaveOk&quot;</span>,</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : Timestamp(<span class="number">1515332475</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : BinData(<span class="number">0</span>,<span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : NumberLong(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行不了，报错了，是因为从实例需要设置一下才能查询。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myset:SECONDARY&gt; db.getMongo().setSlaveOk();</span><br><span class="line">myset:SECONDARY&gt; show dbs;</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">mytest  <span class="number">0.000</span>GB</span><br><span class="line">test    <span class="number">0.000</span>GB</span><br><span class="line">myset:SECONDARY&gt; db.article.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a52221989c0d47f8598d0ad&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;MongoDB应用开发实战&quot;</span>, <span class="string">&quot;author&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;creationDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T13:35:21.111Z&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加副本集"><a href="#添加副本集" class="headerlink" title="添加副本集"></a>添加副本集</h2><p><code>rs.add(&#39;host:port&#39;)</code></p>
<h2 id="删除副本集"><a href="#删除副本集" class="headerlink" title="删除副本集"></a>删除副本集</h2><p><code>rs.remove(&#39;host:port&#39;)</code></p>
<h2 id="重新配置"><a href="#重新配置" class="headerlink" title="重新配置"></a>重新配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> config = rs.config();</span><br><span class="line"></span><br><span class="line">rs....</span><br><span class="line"></span><br><span class="line">rs.reconfig(config);</span><br></pre></td></tr></table></figure>

<h1 id="监控-mongostat"><a href="#监控-mongostat" class="headerlink" title="监控-mongostat"></a>监控-mongostat</h1><p><strong>mongodb</strong>提供了一个mongostat命令用于监控mongodb服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ mongostat --<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">  mongostat &lt;options&gt; &lt;polling interval <span class="keyword">in</span> seconds&gt;</span><br><span class="line"></span><br><span class="line">Monitor basic MongoDB server statistics.</span><br><span class="line"></span><br><span class="line">See http://docs.mongodb.org/manual/reference/program/mongostat/ <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>

<p>监控副本集的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ mongostat --host=myset/localhost:28010,localhost:28011,localhost:28012</span><br><span class="line">           host insert query update delete getmore <span class="built_in">command</span> dirty used flushes vsize   res qrw arw net_in net_out conn   <span class="built_in">set</span> repl                time</span><br><span class="line">localhost:28010     *0    *0     *0     *0       0     3|0  0.0% 0.0%       0 4.94G 39.0M 0|0 1|0   437b   53.4k    3 myset  SEC Jan 16 12:18:50.342</span><br><span class="line">localhost:28011     *0    *0     *0     *0       0     3|0  0.0% 0.0%       0 4.97G 39.0M 0|0 1|0   432b   52.8k    5 myset  PRI Jan 16 12:18:50.342</span><br></pre></td></tr></table></figure>

<h1 id="关于副本集的原理分析："><a href="#关于副本集的原理分析：" class="headerlink" title="关于副本集的原理分析："></a>关于副本集的原理分析：</h1><ol>
<li><p>副本集有且只有一台机器是primary，primary与secondary之间的数据复制是异步进行的，并且通过oplog进行。</p>
</li>
<li><p>副本集中的机器数最好为奇数。</p>
</li>
<li><p>Primary机器接收所有的写操作（无法改变的），我们可以配置read preference，使得读操作可以发生在secondary机器上。如果读操作发生在primary机器上，那么机器就是强一致性的；</p>
</li>
<li><p>副本集中最多有50台机器，之前的版本最多有12台机器。如果超过了50台，那么只能使用Master-Slave方式。不过如果使用Master-Slave方式，那么就失去了自动化的failover机制。</p>
</li>
<li><p>Arbiter机器（仲裁机器），它本身并不存放数据库数据，仅提供选举功能。</p>
</li>
<li><p>不要将arbiter机器放在primary或是secondary机器上。</p>
</li>
<li><p>对于secondary机器，可以进行如下配置：</p>
<ol>
<li>禁止某台secondary机器成为primary机器，priority为0。</li>
<li>禁止客户端读取某台secondary机器的数据，隐藏成员。</li>
<li>仅记录历史快照的secondary，延迟成员。比如说延迟一小时</li>
</ol>
</li>
<li><p>最常见的secondary机器依然是进行数据异步复制与保持系统高可用的形式。</p>
</li>
<li><p>副本集中最多有50台机器，其中<strong>具有投票功能</strong>的机器数量最多是7台。</p>
</li>
<li><p>Priority为0的机器：无法成为primary。不能触发一个选举</p>
</li>
<li><p>关于MongoDB的读写分离：        </p>
<ol>
<li>如果进行读写分离，那么要注意到读会有延迟</li>
<li>secondary机器要通过oplog异步复制primary机器的数据，因此从整体来看，primary与secondary机器的读速度是大体相当的。</li>
<li>默认情况下，MongoDB的读写都是在primary上进行的。</li>
</ol>
</li>
<li><p>关于Read preference：        </p>
<ol>
<li>Primary（默认值）</li>
<li>primaryPreferred</li>
<li>secondary</li>
<li>secondaryPreferred</li>
<li>nearest（网络延迟最少的）</li>
</ol>
</li>
<li><p>关于延迟成员（delayed member）        </p>
<ol>
<li>延迟成员的priority必须为0，表示它无法成为primary。</li>
<li>延迟成员也是隐藏成员，应用是无法通过延迟成员查询数据的。</li>
<li>可以对primary的选举进行投票。</li>
</ol>
</li>
<li><p>请确保副本集中成员的个数为奇数，如果是偶数的话，请添加一个arbiter成员。</p>
</li>
<li><p>关于MongoDB的投票与故障恢复：        </p>
<ol>
<li>MongoDB投票要求投票时系统中可用的机器数量要是全体副本集成员个数的大多数。</li>
<li>如果副本集中有3台机器，那么有几台机器宕掉还可以确保MongoDB副本集可以正常使用？2台。</li>
<li>如果副本集中有4台机器，那么有几台机器宕掉还可以确保MongoDB副本集可以正常使用？3台。</li>
<li>如果副本集中有5台机器，那么有几台机器宕掉还可以确保MongoDB副本集可以正常使用？3台。</li>
<li>如果副本集中有6台机器，那么有几台机器宕掉还可以确保MongoDB副本集可以正常使用？4台。</li>
<li>如果副本集中有7台机器，那么有几台机器宕掉还可以确保MongoDB副本集可以正常使用？4台。</li>
</ol>
</li>
<li><p>向副本集中添加成员并不总是会确保系统的故障恢复能力，不过这样做可以实现一些额外的功：备份、统计报表等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB6-分片</title>
    <url>/2018/01/17/mongodb/mongo6/</url>
    <content><![CDATA[<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p>
<p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>
<h2 id="为什么使用分片"><a href="#为什么使用分片" class="headerlink" title="为什么使用分片"></a>为什么使用分片</h2><ul>
<li>复制所有的写入操作到主节点</li>
<li>延迟的敏感数据会在主节点查询</li>
<li>单个副本集限制在12个节点</li>
<li>当请求量巨大时会出现内存不足。</li>
<li>本地磁盘不足</li>
<li>垂直扩展价格昂贵</li>
</ul>
<a id="more"></a>

<h2 id="分片组件"><a href="#分片组件" class="headerlink" title="分片组件"></a>分片组件</h2><p><img src="https://docs.mongodb.com/manual/_images/sharded-cluster-production-architecture.bakedsvg.svg"></p>
<p>Sharded Cluster（分片集群）共有3个组件：</p>
<ol>
<li>shard（也可以配置成副本集，确保高可用）</li>
<li>query router（查询路由器）</li>
<li>config sever（配置服务器，一般会配置成副本集，确保高可用；以前的版本采取的方式使用3台独立的mongod实例）</li>
</ol>
<p>config server保存了数据的分布情况，哪些数据在哪一个分片中，而query router提供了用户接口对分片进行操作。</p>
<p><img src="https://docs.mongodb.com/manual/_images/sharded-cluster-mixed.bakedsvg.svg"></p>
<h2 id="分片实战"><a href="#分片实战" class="headerlink" title="分片实战"></a>分片实战</h2><p>注意：分片是以集合为目标的</p>
<h3 id="本机部署测试"><a href="#本机部署测试" class="headerlink" title="本机部署测试"></a>本机部署测试</h3><ol>
<li>配置服务器：是一个副本集，由3台mongod实例构成</li>
<li>mongos路由：两台mongos实例</li>
<li>shard节点：两个shard构成，每个shard都是一个副本集（包含了3个mongod实例）</li>
</ol>
<p>11台机器。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>配置服务器</p>
<ol>
<li>不能拥有arbiter</li>
<li>不能拥有delayed member</li>
<li>必须能够build indexes（buildIndexes属性不能为false）</li>
</ol>
<p>先准备目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mongodb tree sharding </span><br><span class="line">sharding</span><br><span class="line">└── config_server</span><br><span class="line">    ├── config1</span><br><span class="line">    │   ├── data</span><br><span class="line">    │   └── <span class="built_in">log</span></span><br><span class="line">    ├── config2</span><br><span class="line">    │   ├── data</span><br><span class="line">    │   └── <span class="built_in">log</span></span><br><span class="line">    └── config3</span><br><span class="line">        ├── data</span><br><span class="line">        └── <span class="built_in">log</span></span><br></pre></td></tr></table></figure>


<h4 id="启动配置服务器"><a href="#启动配置服务器" class="headerlink" title="启动配置服务器"></a>启动配置服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod --configsvr --replSet mytest --port 28010 --dbpath sharding/config_server/config1/data --logpath sharding/config_server/config1/<span class="built_in">log</span>/log.log --logappend --fork</span><br><span class="line">mongod --configsvr --replSet mytest --port 28011 --dbpath sharding/config_server/config2/data --logpath sharding/config_server/config2/<span class="built_in">log</span>/log.log --logappend --fork</span><br><span class="line">mongod --configsvr --replSet mytest --port 28012 --dbpath sharding/config_server/config3/data --logpath sharding/config_server/config3/<span class="built_in">log</span>/log.log --logappend --fork</span><br><span class="line">➜  mongodb mongo localhost:28010</span><br><span class="line">&gt; myconfig = &#123;_id:<span class="string">&#x27;mytest&#x27;</span>, configsvr:<span class="literal">true</span>, members:[&#123;_id:0,host:<span class="string">&#x27;localhost:28010&#x27;</span>&#125;,&#123;_id:1,host:<span class="string">&#x27;localhost:28011&#x27;</span>&#125;,&#123;_id:2,host:<span class="string">&#x27;localhost:28012&#x27;</span>&#125;]&#125;;</span><br><span class="line">&gt; rs.initiate(myconfig);</span><br><span class="line">&gt; rs.status();</span><br></pre></td></tr></table></figure>

<h4 id="启动查询路由器"><a href="#启动查询路由器" class="headerlink" title="启动查询路由器"></a>启动查询路由器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos --configdb mytest/localhost:28010,localhost:28011,localhost:28012 --port 29010</span><br><span class="line">mongos --configdb mytest/localhost:28010,localhost:28011,localhost:28012 --port 29011</span><br></pre></td></tr></table></figure>

<h4 id="分片副本集"><a href="#分片副本集" class="headerlink" title="分片副本集"></a>分片副本集</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">── shard1</span><br><span class="line">│   ├── mongod1</span><br><span class="line">│   │   └── data</span><br><span class="line">│   ├── mongod2</span><br><span class="line">│   │   └── data</span><br><span class="line">│   └── mongod3</span><br><span class="line">│       └── data</span><br><span class="line">└── shard2</span><br><span class="line">    ├── mongod4</span><br><span class="line">    │   └── data</span><br><span class="line">    ├── mongod5</span><br><span class="line">    │   └── data</span><br><span class="line">    └── mongod6</span><br><span class="line">        └── data</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod --replSet shard1 --port 40001 --dbpath sharding/shard1/mongod1/data</span><br><span class="line">mongod --replSet shard1 --port 40002 --dbpath sharding/shard1/mongod2/data</span><br><span class="line">mongod --replSet shard1 --port 40003 --dbpath sharding/shard1/mongod3/data</span><br><span class="line">mongod --replSet shard2 --port 50001 --dbpath sharding/shard2/mongod4/data</span><br><span class="line">mongod --replSet shard2 --port 50002 --dbpath sharding/shard2/mongod5/data</span><br><span class="line">mongod --replSet shard2 --port 50003 --dbpath sharding/shard2/mongod6/data</span><br><span class="line"></span><br><span class="line">mongo localhost:40001</span><br><span class="line"></span><br><span class="line">&gt; myconfig = &#123;_id:<span class="string">&#x27;shard1&#x27;</span>, members:[&#123;_id:0,host:<span class="string">&#x27;localhost:40001&#x27;</span>&#125;,&#123;_id:1,host:<span class="string">&#x27;localhost:40002&#x27;</span>&#125;,&#123;_id:2,host:<span class="string">&#x27;localhost:40003&#x27;</span>&#125;]&#125;;</span><br><span class="line">&gt; rs.initiate(myconfig);</span><br><span class="line"></span><br><span class="line">mongo localhost:50001</span><br><span class="line"></span><br><span class="line">&gt; myconfig = &#123;_id:<span class="string">&#x27;shard2&#x27;</span>, members:[&#123;_id:0,host:<span class="string">&#x27;localhost:50001&#x27;</span>&#125;,&#123;_id:1,host:<span class="string">&#x27;localhost:50002&#x27;</span>&#125;,&#123;_id:2,host:<span class="string">&#x27;localhost:50003&#x27;</span>&#125;]&#125;;</span><br><span class="line">&gt; rs.initiate(myconfig);</span><br></pre></td></tr></table></figure>

<h4 id="配置分片"><a href="#配置分片" class="headerlink" title="配置分片"></a>配置分片</h4><p>添加分片的时候，只写副本集其中一个mongod实例，它也能自动找到剩余的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo localhost:29010</span><br><span class="line">mongos&gt; sh.addShard(<span class="string">&#x27;shard1/localhost:40001,localhost:40002,localhost:40003&#x27;</span>);</span><br><span class="line">mongos&gt; sh.addShard(<span class="string">&#x27;shard2/localhost:50001&#x27;</span>); </span><br></pre></td></tr></table></figure>
<p>下面开始设置分片，先设置可以分片的数据库，然后设置要分片的集合，需要设置索引字段，索引方式为<code>hashed</code>，注意要先切换到admin数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; use admin;</span><br><span class="line">mongos&gt; sh.enableSharding(<span class="string">&#x27;mytest&#x27;</span>);</span><br><span class="line">mongos&gt; sh.shardCollection(<span class="string">&#x27;mytest.student&#x27;</span>,&#123;_id:<span class="string">&#x27;hashed&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来添加一些数据，然后可以看到分片的数据分片状态，我们也可以单独连接到某一个shard的副本集查看数据分布情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; <span class="keyword">for</span>(var i = 0;i &lt; 100;++i)&#123;db.student.insert(&#123;username:<span class="string">&#x27;hello&#x27;</span> + i&#125;)&#125;;</span><br><span class="line">mongos&gt; db.printShardingStatus();</span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">  	<span class="string">&quot;_id&quot;</span> : 1,</span><br><span class="line">  	<span class="string">&quot;minCompatibleVersion&quot;</span> : 5,</span><br><span class="line">  	<span class="string">&quot;currentVersion&quot;</span> : 6,</span><br><span class="line">  	<span class="string">&quot;clusterId&quot;</span> : ObjectId(<span class="string">&quot;5a60594bd9fbe1b3ebca714e&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard1&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard1/localhost:40001,localhost:40002,localhost:40003&quot;</span>,  <span class="string">&quot;state&quot;</span> : 1 &#125;</span><br><span class="line">        &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard2&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard2/localhost:50001,localhost:50002,localhost:50003&quot;</span>,  <span class="string">&quot;state&quot;</span> : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">        <span class="string">&quot;3.6.1&quot;</span> : 2</span><br><span class="line">  autosplit:</span><br><span class="line">        Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">        Currently enabled:  yes</span><br><span class="line">        Currently running:  no</span><br><span class="line">        Failed balancer rounds <span class="keyword">in</span> last 5 attempts:  0</span><br><span class="line">        Migration Results <span class="keyword">for</span> the last 24 hours: </span><br><span class="line">                No recent migrations</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;config&quot;</span>,  <span class="string">&quot;primary&quot;</span> : <span class="string">&quot;config&quot;</span>,  <span class="string">&quot;partitioned&quot;</span> : <span class="literal">true</span> &#125;</span><br><span class="line">                config.system.sessions</span><br><span class="line">                        shard key: &#123; <span class="string">&quot;_id&quot;</span> : 1 &#125;</span><br><span class="line">                        unique: <span class="literal">false</span></span><br><span class="line">                        balancing: <span class="literal">true</span></span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1	1</span><br><span class="line">                        &#123; <span class="string">&quot;_id&quot;</span> : &#123; <span class="string">&quot;<span class="variable">$minKey</span>&quot;</span> : 1 &#125; &#125; --&gt;&gt; &#123; <span class="string">&quot;_id&quot;</span> : &#123; <span class="string">&quot;<span class="variable">$maxKey</span>&quot;</span> : 1 &#125; &#125; on : shard1 Timestamp(1, 0) </span><br><span class="line">        &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mytest&quot;</span>,  <span class="string">&quot;primary&quot;</span> : <span class="string">&quot;shard1&quot;</span>,  <span class="string">&quot;partitioned&quot;</span> : <span class="literal">true</span> &#125;</span><br><span class="line">                mytest.student</span><br><span class="line">                        shard key: &#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;hashed&quot;</span> &#125;</span><br><span class="line">                        unique: <span class="literal">false</span></span><br><span class="line">                        balancing: <span class="literal">true</span></span><br><span class="line">                        chunks:</span><br><span class="line">                                shard1	2</span><br><span class="line">                        &#123; <span class="string">&quot;_id&quot;</span> : &#123; <span class="string">&quot;<span class="variable">$minKey</span>&quot;</span> : 1 &#125; &#125; --&gt;&gt; &#123; <span class="string">&quot;_id&quot;</span> : NumberLong(0) &#125; on : shard1 Timestamp(1, 0) </span><br><span class="line">                        &#123; <span class="string">&quot;_id&quot;</span> : NumberLong(0) &#125; --&gt;&gt; &#123; <span class="string">&quot;_id&quot;</span> : &#123; <span class="string">&quot;<span class="variable">$maxKey</span>&quot;</span> : 1 &#125; &#125; on : shard1 Timestamp(1, 1) </span><br><span class="line">        &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;test&quot;</span>,  <span class="string">&quot;primary&quot;</span> : <span class="string">&quot;shard1&quot;</span>,  <span class="string">&quot;partitioned&quot;</span> : <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-WebSocket介绍和使用</title>
    <url>/2017/06/12/netty/netty2/</url>
    <content><![CDATA[<p>随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。</p>
<p>　　我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和Comet技术。其实后者本质上也是一种轮询，只不过有所改进。
　　</p>
<a id="more"></a>
<p>　　轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p>
<p>　　Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p>
<p>　　这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。</p>
<p>　　伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力。WebSocket的工作流程是这样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小了很多。　　
　　
　　</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面来看一下示例代码，套路还是和之前是一样的，只不过Initializer注册的Handler发生了变化。</p>
<p><code>MyServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// handler是针对于bossGroup的</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// childHandler是针对于workerGroup的</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> WebSocketChannelInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>WebSocketChannelInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        <span class="comment">// 把各段HTTP的请求合并为一个FullHttpRequest</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TextWebSocketFrameHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TextWebSocketFrameHandler.java</code></p>
<p>注意这里SimpleChannelInboundHandler的泛型用<code>TextWebSocketFrame</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;服务器时间：&quot;</span> + LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded: &quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved: &quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生&quot;</span>);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后再来看一下客户端代码，我们来进行一下测试。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket客户端<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:400px;height:200px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>服务端输出：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:400px;height:300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span>清空内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="javascript">        socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8899/ws&quot;</span>);</span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = ta.value + <span class="string">&quot;\n&quot;</span> + event.data;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = <span class="string">&quot;连接开启！&quot;</span>;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ta.value = ta.value + <span class="string">&quot;连接关闭!&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;浏览器不支持WebSocket!&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (socket.readyState == WebSocket.OPEN) &#123;</span><br><span class="line">            socket.send(message);</span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;连接尚未开启！&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行起来观察一下。</p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/QQ20170613-211845.png"></p>
<p>提示连接开启，说明我们的websocket已经连接到了服务端，然后服务端也打印出来handlerAdded的通道ID。</p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-13%20%E4%B8%8B%E5%8D%889.21.24.png"></p>
<p>发送一条消息给服务端试试。</p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/QQ20170613-212539.png"></p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/QQ20170613-212926@2x.png"></p>
<p>从浏览器的界面和开发工具看，我们收到了服务发送给客户端的消息，而且谷歌的开发工具在websocket协议下，还多了一个<code>FRAME</code>来显示浏览器与服务器WebSocket交互的所有数据。<br>服务端的控制台也打印出了浏览器发送给服务端的消息。</p>
<p>通过例子我们了解到Netty通过什么样的方式提供了对WebSocket的支持，为我们简化了大量的代码。希望通过这个例子，我们能更好的理解WebSocket的使用。</p>
<p>其实除了浏览器，现在IOS和Android也有第三方的工具可以来使用WebSocket连接。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-Google Protobuf介绍和使用</title>
    <url>/2017/06/15/netty/netty3/</url>
    <content><![CDATA[<h1 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h1><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>接下来看一下Google Protobuf的使用方式。Protobuf的主要作用是用来进行RPC的传输。它跟Apache Thrift属于同一个领域的框架，都可以用来序列化和反序列化数据进行传输。</p>
<h2 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h2><p>目前Java中有一门比较成熟，同时也是EJB的标准的技术叫做RMI(remote method invocation)。RMI限制了只能基于Java调用。这种跨机器的调用，是客户端序列化后字节码再通过网络进行传输到服务端，服务端再反序列化数据进行代码调用。这就涉及到2个概念，</p>
<a id="more"></a>

<ol>
<li>client: stub(序列化生成代码)</li>
<li>server: skeleton(反序列化)</li>
</ol>
<p>序列化与反序列化，也叫做编码与解码。</p>
<h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><p>Remote Procedure Call, 远程过程调用，很多RPC框架是跨语言的。 </p>
<ol>
<li>定义一个接口说明文件(idl)：描述了对象（结构体）、对象成员、接口方法等一系列信息。</li>
<li>通过RPC框架所提供的编译器，将接口说明文件编译成具体语言文件。</li>
<li>在客户端与服务端分别引入RPC编译器所生产的文件，即可像调用本地方法一样调用远程方法。</li>
</ol>
<h2 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h2><blockquote>
<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</blockquote>
<p>Protocol buffers是谷歌提供的语言中立、平台中立，用于序列化结构数据的可扩展的机制，就像XML一样，但是它的体积更小，它的速度更快、更简单。数据结构你只需要定义一次就可以了，然后就可以使用生成的各种语言源代码去轻松的读写你的各种结构化数据。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a></p>
<p>先下载环境，注意不要下错了，因为我是MAC，所以我这里下载<code>protoc-3.3.0-osx-x86_64.zip</code>，配置好环境变量后可执行protoc命令。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://developers.google.com/protocol-buffers/docs/javatutorial">https://developers.google.com/protocol-buffers/docs/javatutorial</a></p>
<p>然后我们照着官方的demo来写一个。</p>
<p>首先需要编写一个<code>Student.proto</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package com.sail.protobuf;</span><br><span class="line"></span><br><span class="line">option optimize_for &#x3D; SPEED;</span><br><span class="line">option java_package &#x3D; &quot;com.sail.protobuf&quot;;</span><br><span class="line">option java_outer_classname &#x3D; &quot;DataInfo&quot;;</span><br><span class="line"></span><br><span class="line">message Student &#123;</span><br><span class="line">    required string name &#x3D; 1;</span><br><span class="line">    optional int32 age &#x3D; 2;</span><br><span class="line">    optional string address &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后执行命令生成代码，就得到一个<code>DataInfo.java</code></p>
<pre><code>protoc --java_out=src/main/java src/main/protobuf/Student.proto</code></pre>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在测试一下这个类的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        DataInfo.Student student = DataInfo.Student.newBuilder()</span><br><span class="line">                .setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">20</span>).setAddress(<span class="string">&quot;北京&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] student2ByteArray = student.toByteArray();</span><br><span class="line"></span><br><span class="line">        DataInfo.Student student2 = DataInfo.Student.parseFrom(student2ByteArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(student2.getName());</span><br><span class="line">        System.out.println(student2.getAge());</span><br><span class="line">        System.out.println(student2.getAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty-Demo"><a href="#Netty-Demo" class="headerlink" title="Netty Demo"></a>Netty Demo</h2><p>在上述代码中，我们看到正确输出了结果。然后配合Netty使用。Netty代码跟之前的套路都是一样的，还是Handler不同。</p>
<h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><p><code>TestServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// handler是针对于bossGroup的</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// childHandler是针对于workerGroup的</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestServerInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MyDataInfo.Person.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestServerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.Person msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.getName());</span><br><span class="line">        System.out.println(msg.getAge());</span><br><span class="line">        System.out.println(msg.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><p><code>TestClient.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个EventLoopGroup</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> TestClientInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestClientInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MyDataInfo.Person.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestClientHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.Person msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyDataInfo.Person person = MyDataInfo.Person.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">20</span>).setAddress(<span class="string">&quot;成都&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>先启动服务端，再启动客户端。服务端直接输出了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">20</span><br><span class="line">成都</span><br></pre></td></tr></table></figure>

<h2 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h2><p>但是发现我们这个代码非常有局限性，因为代码里写了<code>MyDataInfo.Person.getDefaultInstance</code>,如果要传输其他消息怎么办呢，或者不止一个消息，这个就非常不灵活，下面就介绍一种更灵活的方式。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MyDataInfo.Person.getDefaultInstance()));</span><br></pre></td></tr></table></figure>

<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><p>重新定义一下proto文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sail.protobuf;</span><br><span class="line"></span><br><span class="line">option optimize_for = SPEED;</span><br><span class="line">option java_package = <span class="string">&quot;com.sail.netty.sixthexample&quot;</span>;</span><br><span class="line">option java_outer_classname = <span class="string">&quot;MyDataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line">message MyMessage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">        PersonType = <span class="number">1</span>;</span><br><span class="line">        DogType = <span class="number">2</span>;</span><br><span class="line">        CatType = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required DataType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    oneof dataBody &#123;</span><br><span class="line">        Person person = <span class="number">2</span>;</span><br><span class="line">        Dog dog = <span class="number">3</span>;</span><br><span class="line">        Cat cat = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    optional string name = <span class="number">1</span>;</span><br><span class="line">    optional int32 age = <span class="number">2</span>;</span><br><span class="line">    optional string address = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Dog &#123;</span><br><span class="line">    optional string name = <span class="number">1</span>;</span><br><span class="line">    optional int32 age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Cat &#123;</span><br><span class="line">    optional string name = <span class="number">1</span>;</span><br><span class="line">    optional string city = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面出现了<code>oneof</code></p>
<blockquote>
<p>If you have a message with many optional fields and where at most one field will be set at the same time, you can enforce this behavior and save memory by using the oneof feature.</p>
</blockquote>
<p>这是官方的解释，意思就是说如果有很多个optional但是同一时间内只有一个有值，那么就可以用oneof的方式来提升性能节约内存。我们也正是利用这种方式来用同一个消息进行不同的值传递。</p>
<p>对之前的代码进行一些改动</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>TestServerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (dataType) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> PersonType:</span><br><span class="line">                MyDataInfo.Person person = msg.getPerson();</span><br><span class="line"></span><br><span class="line">                System.out.println(person.getName());</span><br><span class="line">                System.out.println(person.getAge());</span><br><span class="line">                System.out.println(person.getAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DogType:</span><br><span class="line">                MyDataInfo.Dog dog = msg.getDog();</span><br><span class="line">                System.out.println(dog.getName());</span><br><span class="line">                System.out.println(dog.getAge());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CatType:</span><br><span class="line">                MyDataInfo.Cat cat = msg.getCat();</span><br><span class="line">                System.out.println(cat.getName());</span><br><span class="line">                System.out.println(cat.getCity());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestServerInitializer.java</code>主要修改了ProtobufDecoder的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><code>TestClientHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomInt = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        MyDataInfo.MyMessage myMessage;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == randomInt) &#123;</span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder()</span><br><span class="line">                    .setDataType(MyDataInfo.MyMessage.DataType.PersonType)</span><br><span class="line">                    .setPerson(MyDataInfo.Person.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">20</span>).setAddress(<span class="string">&quot;成都&quot;</span>).build()).build();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == randomInt) &#123;</span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder()</span><br><span class="line">                    .setDataType(MyDataInfo.MyMessage.DataType.DogType)</span><br><span class="line">                    .setDog(MyDataInfo.Dog.newBuilder().setName(<span class="string">&quot;一只狗&quot;</span>).setAge(<span class="number">2</span>).build()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder()</span><br><span class="line">                    .setDataType(MyDataInfo.MyMessage.DataType.CatType)</span><br><span class="line">                    .setCat(MyDataInfo.Cat.newBuilder().setName(<span class="string">&quot;七七&quot;</span>).setCity(<span class="string">&quot;成都&quot;</span>).build()).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(myMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestClientInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>然后启动服务端，再多启动几次客户端，得到如下输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">七七</span><br><span class="line">成都</span><br><span class="line">一只狗</span><br><span class="line">2</span><br><span class="line">一只狗</span><br><span class="line">2</span><br><span class="line">张三</span><br><span class="line">20</span><br><span class="line">成都</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-Apache Thrift介绍和使用</title>
    <url>/2017/07/09/netty/netty4/</url>
    <content><![CDATA[<h1 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h1><ul>
<li>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，<strong>支持跨语言</strong>，常用的语言比如C++，Java，Python，PHP，Ruby，Erlang，Perl，Haskell，C#，Cocoa，JavaScript，Node.js，SmallTalk and OCaml都支持。</li>
<li>Thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同语言开发。既然客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，这种语言就是<strong>IDL（Interface Description Language）</strong>。</li>
<li>Thrift不支持无符号类型，因为很多变成语言不存在无符号类型，比如Java</li>
</ul>
<h2 id="Thrift数据类型"><a href="#Thrift数据类型" class="headerlink" title="Thrift数据类型"></a>Thrift数据类型</h2><ul>
<li>byte：有符号字节</li>
<li>i16：16位有符号整数</li>
<li>i32：32位有符号整数</li>
<li>i64：64位有符号整数</li>
<li>double：64位有符号整数</li>
<li>double：64位浮点数</li>
<li>string：字符串</li>
</ul>
<a id="more"></a>

<h2 id="Thrift容器类型"><a href="#Thrift容器类型" class="headerlink" title="Thrift容器类型"></a>Thrift容器类型</h2><ul>
<li>集合中的元素可以是除了service之外的任何类型，包括exception</li>
<li>list：一些列由T类型的数据组成的有序列表，元素可以重复</li>
<li>set：一系列由T类型的数据组成的无序集合，元素不可重复</li>
<li>map：一个字典结构，key为K类型，value为V类型，相当于Java中的HashMap</li>
</ul>
<h2 id="Thrift工作原理"><a href="#Thrift工作原理" class="headerlink" title="Thrift工作原理"></a>Thrift工作原理</h2><p><strong>如何实现多语言之间的通信？</strong></p>
<ul>
<li>数据传输使用socket（多重语言均支持），数据再以特定的格式（string等）发送，接受方语言进行解析。</li>
<li>定义thrift的文件，由thrift文件（IDL）生成双方语言的接口、model，在生成的model以及接口中会有解码编码的代码</li>
</ul>
<h3 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h3><p>就像C语言一样，Thrift支持struct类型，目的就是将一些数据聚合在一起，方便传输管理。struct的定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Prople &#123;</span><br><span class="line">	1:string name;</span><br><span class="line">	2:i32 age;</span><br><span class="line">	3:string gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的定义形式和Java的Enum定义类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Gender &#123;</span><br><span class="line">	MALE,</span><br><span class="line">	FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常（exception）"><a href="#异常（exception）" class="headerlink" title="异常（exception）"></a>异常（exception）</h3><p>Thrift支持自定义exception，规则与struct一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception RequestException &#123;</span><br><span class="line">	1:i32 code;</span><br><span class="line">	2:string reasone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务（service）"><a href="#服务（service）" class="headerlink" title="服务（service）"></a>服务（service）</h3><p>Thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line"> &#x2F;&#x2F;service中定义的函数，相当于Java interface中定义的方法</span><br><span class="line"> string doAction(1:string name, 2:i32 age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>Thrift支持类似C++一样的typedef定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef i32 int</span><br><span class="line">typedef i64 long</span><br></pre></td></tr></table></figure>

<h3 id="常量（const）"><a href="#常量（const）" class="headerlink" title="常量（const）"></a>常量（const）</h3><p>thrift也支持常量定义，使用const关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const i32 MAX_RETRIES_TIME &#x3D; 10</span><br><span class="line">const string MY_WEBSIZE &#x3D; &quot;http:&#x2F;&#x2F;facebook.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li><p>Thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键<code>namespace</code> 定义命名空间：</p>
<p>  <code>namespace java com.test.thrift.demo</code></p>
</li>
<li><p>格式是：namespace 语言名 路径</p>
</li>
</ul>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>Thrift支持文件包含，相当于C/C++中的include，Java中的import。使用关键字include定义：</p>
<p><code>include &quot;global.thrift&quot;</code></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Thrift注释方式支持shell风格的注释，支持C/C++风格的注释，即#和//开头的语句都当作注释，/**/包裹的语句也是注释。</p>
<h3 id="可选与必选"><a href="#可选与必选" class="headerlink" title="可选与必选"></a>可选与必选</h3><p>Thrift提供两个关键字required，optional，分别用于表示对应的字段是必填的还是可以选的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct People &#123;</span><br><span class="line">	1:required string name;</span><br><span class="line">	2:optional i32 age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><ul>
<li>了解了如何定义thrift文件之后，我们需要用定义好的thrift文件生成我们需要的目标语言的源码</li>
<li>首先需要定义thrift接口描述文件</li>
<li>参见data.thrift</li>
</ul>
<p><strong>data.thrift</strong></p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java thrift.generated</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">i16</span> short</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">i32</span> int</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">i64</span> long</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> boolean</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> String</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">optional</span> String username,</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> int age,</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> boolean married</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">exception</span> <span class="title">DataException</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">optional</span> String message,</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">optional</span> String callStack,</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> String date</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    Person getPersonByUsername(<span class="number">1</span>: <span class="keyword">required</span> String username) throws (<span class="number">1</span>: DataException dataException),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> savePerson(<span class="number">1</span>: <span class="keyword">required</span> Person person) throws (<span class="number">1</span>: DataException dataException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行生成代码命令</p>
<p><code>thrift --gen java src/thrift/data.thrift</code></p>
<p>记得导入<code>&#39;org.apache.thrift:libthrift:0.10.0&#39;</code></p>
<p>生成了3个类，分别是<code>Person</code>，<code>DataException</code>，<code>PersonService</code>。</p>
<p>然后我们来写一个service的实现类</p>
<p><code>PersonServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.thrift;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> thrift.generated.DataException;</span><br><span class="line"><span class="keyword">import</span> thrift.generated.Person;</span><br><span class="line"><span class="keyword">import</span> thrift.generated.PersonService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPersonByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> DataException, org.apache.thrift.TException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        person.setUsername(username);</span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        person.setMarried(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> DataException, org.apache.thrift.TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Got Client Param: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person.getUsername());</span><br><span class="line">        System.out.println(person.getAge());</span><br><span class="line">        System.out.println(person.isMarried());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>接下来编写客户端和服务端代码进行测试。</p>
<p><code>ThriftServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TNonblockingServerSocket socket = <span class="keyword">new</span> TNonblockingServerSocket(<span class="number">8899</span>);</span><br><span class="line">        THsHaServer.Args arg = <span class="keyword">new</span> THsHaServer.Args(socket).minWorkerThreads(<span class="number">2</span>).maxWorkerThreads(<span class="number">4</span>);</span><br><span class="line">        PersonService.Processor&lt;PersonServiceImpl&gt; processor = <span class="keyword">new</span> PersonService.Processor&lt;&gt;(<span class="keyword">new</span> PersonServiceImpl());</span><br><span class="line"></span><br><span class="line">        arg.protocolFactory(<span class="keyword">new</span> TCompactProtocol.Factory());</span><br><span class="line">        arg.transportFactory(<span class="keyword">new</span> TFramedTransport.Factory());</span><br><span class="line">        arg.processorFactory(<span class="keyword">new</span> TProcessorFactory(processor));</span><br><span class="line"></span><br><span class="line">        TServer server = <span class="keyword">new</span> THsHaServer(arg);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thrift Server Started&quot;</span>);</span><br><span class="line"></span><br><span class="line">        server.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>ThriftClient.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThriftClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>), <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">        TProtocol protocol = <span class="keyword">new</span> TCompactProtocol(transport);</span><br><span class="line">        PersonService.Client client = <span class="keyword">new</span> PersonService.Client(protocol);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport.open();</span><br><span class="line"></span><br><span class="line">            Person person = client.getPersonByUsername(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(person.getUsername());</span><br><span class="line">            System.out.println(person.getAge());</span><br><span class="line">            System.out.println(person.isMarried());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">            person2.setUsername(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            person2.setAge(<span class="number">30</span>);</span><br><span class="line">            person2.setMarried(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            client.savePerson(person2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            transport.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后分别启动服务端和客户端</p>
<p>服务端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thrift Server Started</span><br><span class="line">Got Client Param: </span><br><span class="line">李四</span><br><span class="line">30</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>客户端输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Received 1</span><br><span class="line">张三</span><br><span class="line">20</span><br><span class="line">false</span><br><span class="line">Received 2</span><br></pre></td></tr></table></figure>


<h2 id="Thrift传输格式"><a href="#Thrift传输格式" class="headerlink" title="Thrift传输格式"></a>Thrift传输格式</h2><ul>
<li>TBinaryProtocol-二进制格式</li>
<li>TCompactProtocal-压缩格式</li>
<li>TJSONProtocol-JSON格式</li>
<li>TSimpleJSONProtocol-提供JSON只写协议，生成的文件很容易通过脚本语言解析。</li>
<li>TDebugProtocol-使用易懂的可读的文本格式，以便于debug</li>
</ul>
<h2 id="Thrift数据传输方式"><a href="#Thrift数据传输方式" class="headerlink" title="Thrift数据传输方式"></a>Thrift数据传输方式</h2><ul>
<li>TSocket-阻塞式Socket</li>
<li>TFramedTransport-以frame为单位进行传输，非阻塞式服务中使用。</li>
<li>TFileTransport-以文件形式进行传输。</li>
<li>TMemortyTransport-将内存用于I/O，Java实现时内部实际使用了简单的ByteArrayOuputStream。</li>
<li>TZlibTransport-使用zlib进行压缩，与其他传输方式联合使用。当前无Java实现。</li>
</ul>
<h2 id="Thrift支持的服务模型"><a href="#Thrift支持的服务模型" class="headerlink" title="Thrift支持的服务模型"></a>Thrift支持的服务模型</h2><ul>
<li>TSimpleServer-简单的单线程服务模型，常用于测试</li>
<li>TThreadPoolServer-多线程服务模型，使用标准的阻塞式IO</li>
<li>TNonblockingServer-多线程服务模型，使用非阻塞式IO（需使用TFramedTransport数据传输方式）</li>
<li>THsHaServer-ThsHa引入了线程池去处理，其模型把读写任务房到线程池去处理；Half-sync/Half-async的处理模式，Half-aysnc是在处理IO时间上（accpect/read/write io），Half-sync是用于handler对rpc的同步处理</li>
</ul>
<h2 id="Thrift对多语言的支持"><a href="#Thrift对多语言的支持" class="headerlink" title="Thrift对多语言的支持"></a>Thrift对多语言的支持</h2><h3 id="Python作为Client"><a href="#Python作为Client" class="headerlink" title="Python作为Client"></a>Python作为Client</h3><p>在<code>data.thrift</code>中增加一行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace java thrift.generated</span><br><span class="line">namespace py py.thrift.generated</span><br></pre></td></tr></table></figure>

<p>然后执行命令生成python代码<br><code>thrift --gen py src/thrift/data.thrift</code></p>
<p>在Java项目中，我们的依赖是通过gradle引入的，这里python我们需要下载thrift的包，然后进入lib/py目录，执行里面的python脚本。</p>
<p><code>sudo python setup.py install</code></p>
<p>生成的依赖位于：**/Library/Python/2.7/site-packages/thrift-0.10.0-py2.7-macosx-10.12-intel.egg**</p>
<p>然后编写客户端的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">__author__ = <span class="string">&#x27;sail&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> PersonService</span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> ttypes</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> Thrift</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TCompactProtocol</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tSocket = TSocket.TSocket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">    tSocket.setTimeout(<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">    transport = TTransport.TFramedTransport(tSocket)</span><br><span class="line">    protocol = TCompactProtocol.TCompactProtocol(transport)</span><br><span class="line">    client = PersonService.Client(protocol)</span><br><span class="line"></span><br><span class="line">    transport.open()</span><br><span class="line"></span><br><span class="line">    person = client.getPersonByUsername(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> person.username</span><br><span class="line">    <span class="keyword">print</span> person.age</span><br><span class="line">    <span class="keyword">print</span> person.married</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;----------------&#x27;</span></span><br><span class="line"></span><br><span class="line">    newPerson = ttypes.Person()</span><br><span class="line">    newPerson.username = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    newPerson.age = <span class="number">30</span></span><br><span class="line">    newPerson.married = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    client.savePerson(newPerson)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Thrift.TException, tx:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;%s&#x27;</span> % tx.message</span><br></pre></td></tr></table></figure>

<p>运行后输出以下结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">20</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="Python作为Server"><a href="#Python作为Server" class="headerlink" title="Python作为Server"></a>Python作为Server</h3><p>编写<code>py_server.py</code>代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py.thrift.generated <span class="keyword">import</span> PersonService</span><br><span class="line"><span class="keyword">from</span> PersonServiceImpl <span class="keyword">import</span> PersonServiceImpl</span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> Thrift</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TCompactProtocol</span><br><span class="line"><span class="keyword">from</span> thrift.server <span class="keyword">import</span> TServer</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    personServiceHandler = PersonServiceImpl()</span><br><span class="line">    processor = PersonService.Processor(personServiceHandler)</span><br><span class="line"></span><br><span class="line">    serverSocket = TSocket.TServerSocket(port=<span class="number">8899</span>)</span><br><span class="line">    transportFactory = TTransport.TFramedTransportFactory()</span><br><span class="line">    protocolFactory = TCompactProtocol.TCompactProtocolFactory()</span><br><span class="line"></span><br><span class="line">    server = TServer.TSimpleServer(processor, serverSocket, transportFactory, protocolFactory)</span><br><span class="line">    server.serve()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Thrift.TException, ex:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;%s&#x27;</span> % ex.message</span><br></pre></td></tr></table></figure>

<p>然后启动python的服务端，再分别执行Java和Python的客户端，都得到了正确的响应。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-gRPC介绍和使用</title>
    <url>/2017/07/23/netty/netty5/</url>
    <content><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><p>Define your service using Protocol Buffers, a powerful binary serialization toolset and language</p>
<p>gRPC是基于Protobuf开发的RPC框架，简化了protobuf的开发，提供了服务端和客户端网络交互这一块的代码。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>照着 <a href="https://grpc.io/docs/quickstart/java.html">https://grpc.io/docs/quickstart/java.html</a> 测试一下官方的Demo。</p>
<p>记得要把<code>Update a gRPC service</code>部分做了。</p>
<a id="more"></a>

<h2 id="gRPC整合Gradle与代码生成"><a href="#gRPC整合Gradle与代码生成" class="headerlink" title="gRPC整合Gradle与代码生成"></a>gRPC整合Gradle与代码生成</h2><p><a href="https://github.com/grpc/grpc-java">https://github.com/grpc/grpc-java</a><br>这个是gRPC-java项目，先引入gRPC的依赖。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">&#x27;io.grpc:grpc-netty:1.4.0&#x27;</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">&#x27;io.grpc:grpc-protobuf:1.4.0&#x27;</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">&#x27;io.grpc:grpc-stub:1.4.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后配置gradle的grpc插件</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply plugin: <span class="string">&#x27;com.google.protobuf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier</span></span><br><span class="line">    <span class="comment">// gradle versions</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.google.protobuf:protobuf-gradle-plugin:0.8.1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">  protoc &#123;</span><br><span class="line">    artifact = <span class="string">&quot;com.google.protobuf:protoc:3.2.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  plugins &#123;</span><br><span class="line">    grpc &#123;</span><br><span class="line">      artifact = <span class="string">&#x27;io.grpc:protoc-gen-grpc-java:1.4.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  generateProtoTasks &#123;</span><br><span class="line">    all()*.plugins &#123;</span><br><span class="line">      grpc &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面直接用gradle的任务就可以生成代码了。</p>
<p>gRPC提供了3种传输层的实现</p>
<ul>
<li><p>gRPC comes with three Transport implementations:</p>
<ol>
<li>The Netty-based transport is the main transport implementation based on Netty. It is for both the client and the server.</li>
<li>The OkHttp-based transport is a lightweight transport based on OkHttp. It is mainly for use on Android and is for client only.</li>
<li>The inProcess transport is for when a server is in the same process as the client. It is useful for testing.</li>
</ol>
</li>
</ul>
<p><a href="https://github.com/google/protobuf-gradle-plugin">https://github.com/google/protobuf-gradle-plugin</a></p>
<p>The Gradle plugin that compiles Protocol Buffer (aka. Protobuf) definition files (*.proto) in your project. There are two pieces of its job:</p>
<ol>
<li>It assembles the Protobuf Compiler (protoc) command line and use it to generate Java source files out of your proto files.</li>
<li>It adds the generated Java source files to the input of the corresponding Java compilation unit (sourceSet in a Java project; variant in an Android project), so that they can be compiled along with your Java sources.</li>
</ol>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>配置好后，进行一个演示</p>
<p>在<code>src/main/proto</code>新建一个文件<code>Student.proto</code></p>
<p>gradle插件默认从<code>src/main/proto</code>找proto源文件进行代码生成，<a href="https://github.com/google/protobuf-gradle-plugin#cutomizing-source-directories">这里</a>有提到，而且这个路径的配置是可以修改的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package com.sail.proto;</span><br><span class="line"></span><br><span class="line">option java_package &#x3D; &quot;com.sail.proto&quot;;</span><br><span class="line">option java_outer_classname &#x3D; &quot;StudentProto&quot;;</span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line"></span><br><span class="line">service StudentService &#123;</span><br><span class="line">    rpc GetRealNameByUsername(MyRequest) returns (MyResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    rpc GetStudentsByAge(StudentRequest) returns (stream StudentResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    rpc GetStudentsWrapperByAges(stream StudentRequest) returns (StudentResponseList) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    rpc BiTalk(stream StreamRequest) returns (stream StreamResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MyRequest &#123;</span><br><span class="line">    string username &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MyResponse &#123;</span><br><span class="line">    string realname &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentRequest &#123;</span><br><span class="line">    int32 age &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentResponse &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">    int32 age &#x3D; 2;</span><br><span class="line">    string city &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StudentResponseList &#123;</span><br><span class="line">    repeated StudentResponse studentResponse &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StreamRequest &#123;</span><br><span class="line">    string request_info &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StreamResponse &#123;</span><br><span class="line">    string response_info &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行<code>gradle generateProto</code>，生成的代码默认是放在<code>/build</code>目录下，我们手动拷贝到<code>src/main/java</code>。</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sail.proto.*;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">StudentServiceGrpc</span>.<span class="title">StudentServiceImplBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRealNameByUsername</span><span class="params">(MyRequest request, StreamObserver&lt;MyResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端信息： &quot;</span> + request.getUsername());</span><br><span class="line">        responseObserver.onNext(MyResponse.newBuilder().setRealname(<span class="string">&quot;张三&quot;</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收StudentRequest参数</span></span><br><span class="line"><span class="comment">     * 返回stream的StudentResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentsByAge</span><span class="params">(StudentRequest request, StreamObserver&lt;StudentResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端信息：&quot;</span> + request.getAge());</span><br><span class="line"></span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">20</span>).setCity(<span class="string">&quot;北京&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;李四&quot;</span>).setAge(<span class="number">30</span>).setCity(<span class="string">&quot;天津&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;王五&quot;</span>).setAge(<span class="number">40</span>).setCity(<span class="string">&quot;成都&quot;</span>).build());</span><br><span class="line">        responseObserver.onNext(StudentResponse.newBuilder().setName(<span class="string">&quot;赵六&quot;</span>).setAge(<span class="number">50</span>).setCity(<span class="string">&quot;深圳&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收stream的StudentRequest参数</span></span><br><span class="line"><span class="comment">     * 返回StudentResponseList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;StudentRequest&gt; <span class="title">getStudentsWrapperByAges</span><span class="params">(StreamObserver&lt;StudentResponseList&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;StudentRequest&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StudentRequest value)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onNext: &quot;</span> + value.getAge());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                StudentResponse studentResponse = StudentResponse.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">20</span>).setCity(<span class="string">&quot;西安&quot;</span>).build();</span><br><span class="line">                StudentResponse studentResponse2 = StudentResponse.newBuilder().setName(<span class="string">&quot;李四&quot;</span>).setAge(<span class="number">30</span>).setCity(<span class="string">&quot;成都&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">                StudentResponseList studentResponseList = StudentResponseList.newBuilder()</span><br><span class="line">                        .addStudentResponse(studentResponse).addStudentResponse(studentResponse2).build();</span><br><span class="line"></span><br><span class="line">                responseObserver.onNext(studentResponseList);</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向流式数据传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;StreamRequest&gt; <span class="title">biTalk</span><span class="params">(StreamObserver&lt;StreamResponse&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;StreamRequest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StreamRequest value)</span> </span>&#123;</span><br><span class="line">                System.out.println(value.getRequestInfo());</span><br><span class="line"></span><br><span class="line">                responseObserver.onNext(StreamResponse.newBuilder().setResponseInfo(UUID.randomUUID().toString()).build());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = ServerBuilder.forPort(<span class="number">8899</span>).addService(<span class="keyword">new</span> StudentServiceImpl()).build().start();</span><br><span class="line">        System.out.println(<span class="string">&quot;server started！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里在关闭JVM的时候会执行JVM回调钩子</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭jvm&quot;</span>);</span><br><span class="line">            GrpcServer.<span class="keyword">this</span>.stop();</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行到这里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitTermination</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        GrpcServer grpcServer = <span class="keyword">new</span> GrpcServer();</span><br><span class="line">        grpcServer.start();</span><br><span class="line">        grpcServer.awaitTermination();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.grpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sail.proto.*;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>)</span><br><span class="line">                .usePlaintext(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">        StudentServiceGrpc.StudentServiceBlockingStub blockingStub = StudentServiceGrpc.newBlockingStub(managedChannel);</span><br><span class="line">        StudentServiceGrpc.StudentServiceStub  stub = StudentServiceGrpc.newStub(managedChannel);</span><br><span class="line">        MyResponse myResponse = blockingStub.getRealNameByUsername(MyRequest.newBuilder().setUsername(<span class="string">&quot;zhangsan&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">        System.out.println(myResponse.getRealname());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;StudentResponse&gt; iter = blockingStub.getStudentsByAge(StudentRequest.newBuilder().setAge(<span class="number">20</span>).build());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            StudentResponse studentResponse = iter.next();</span><br><span class="line"></span><br><span class="line">            System.out.println(studentResponse.getName() + <span class="string">&quot;, &quot;</span> + studentResponse.getAge() + <span class="string">&quot;, &quot;</span> + studentResponse.getCity());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getStudentsWrapperByAges的调用代码</span></span><br><span class="line"></span><br><span class="line">        StreamObserver&lt;StudentResponseList&gt; studentResponseListStreamObserver = <span class="keyword">new</span> StreamObserver&lt;StudentResponseList&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StudentResponseList value)</span> </span>&#123;</span><br><span class="line">                value.getStudentResponseList().forEach(studentResponse -&gt; &#123;</span><br><span class="line">                    System.out.println(studentResponse.getName() + <span class="string">&quot;, &quot;</span> + studentResponse.getAge() + <span class="string">&quot;, &quot;</span> + studentResponse.getCity());</span><br><span class="line">                    System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;completed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要客户端是以流式发送请求，那么一定是异步的</span></span><br><span class="line">        StreamObserver&lt;StudentRequest&gt; studentRequestStreamObserver = stub.getStudentsWrapperByAges(studentResponseListStreamObserver);</span><br><span class="line">        <span class="comment">// 发送多条数据</span></span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">20</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">30</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">40</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onNext(StudentRequest.newBuilder().setAge(<span class="number">50</span>).build());</span><br><span class="line">        studentRequestStreamObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以上代码是没有输出结果的，因为stub是异步的，所以当执行完onCompleted的时候程序就已经结束了，还没有来得及发送请求</span></span><br><span class="line">        <span class="comment">// 现在加入以下代码，让程序多运行一会</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双向数据流的调用</span></span><br><span class="line"></span><br><span class="line">        StreamObserver&lt;StreamRequest&gt; requestStreamObserver = stub.biTalk(<span class="keyword">new</span> StreamObserver&lt;StreamResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(StreamResponse value)</span> </span>&#123;</span><br><span class="line">                System.out.println(value.getResponseInfo());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onCompleted!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            requestStreamObserver.onNext(StreamRequest.newBuilder().setRequestInfo(LocalDateTime.now().toString()).build());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-源码分析(二)</title>
    <url>/2017/09/22/netty/netty7/</url>
    <content><![CDATA[<h1 id="源码分析-二"><a href="#源码分析-二" class="headerlink" title="源码分析(二)"></a>源码分析(二)</h1><p>在理解了Reactor模式后，因为Netty框架本身就是基于Reactor模式的一种实现，所以回过头来再看源码，才能更好的理解代码中一些类的角色和意义。</p>
<p>ServerBootStrap在调用bind()方法后，通过<strong>channelFactory</strong>反射的方式创建了我们指定的Channel（**<em>NioServerSocketChannel.class**</em>）对象，然后调用了init(channel)方法对channel进行了初始化设置。</p>
<p>看一下<strong>ServerBootStrap.init()**，初始化Channel的代码，<code>ChannelPipeline p = channel.pipeline();</code>这里面就出现了一个Netty中一个又一个非常核心的类</strong>ChannelPipeline<strong>，它是在</strong>Channel<strong>的父类</strong>AbstractChannel**初始化的时候创建的。</p>
<h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p><strong>ChannelPipeline</strong>里面是一个一个的ChannelHandler，当客户端的请求到来或者出去的的时候，会一个一个的通过这些处理器，就像一个过滤器一样。每一个<strong>Channel</strong>都拥有自己的<strong>ChannelPipeline</strong>，当一个<strong>Channel</strong>被创建的时候，<strong>ChannelPipeline</strong>也跟着被创建了。I/O事件只能被ChannelInboundHandler和ChannelOutboundHandler其中之一所处理，处理完成后再传递到别的处理器中（ChannelHandlerContext#fireChannelRead(Object)或者ChannelHandlerContext#write(Object)）。</p>
<a id="more"></a>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*                                                 I/O Request</span><br><span class="line">*                                            via &#123;@link Channel&#125; or</span><br><span class="line">*                                        &#123;@link ChannelHandlerContext&#125;</span><br><span class="line">*                                                      |</span><br><span class="line">*  +---------------------------------------------------+---------------+</span><br><span class="line">*  |                           ChannelPipeline         |               |</span><br><span class="line">*  |                                                  \|/              |</span><br><span class="line">*  |    +---------------------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  .               |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">*  |        [ method call]                       [method call]         |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  |               .                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*                  |                                  \|/</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*  |               |                                   |               |</span><br><span class="line">*  |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">*  |                                                                   |</span><br><span class="line">*  |  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line">*  +-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>上面的流程图很清楚的描述了一个请求进和出两个方向是如何被Netty处理的。</p>
<h2 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h2><p>提供协议相关的配置，比如TCP的一些配置，它是类型安全的，实现了<strong>Constant</strong>接口，通过<strong>ConstantPool</strong>维护。ChannelOption本身就是Key的信息，真正的值是在ConstantPool中。详情可以查看<strong>ChannelConfig</strong>，ChannelOption只是Key。</p>
<h2 id="AttributeMap"><a href="#AttributeMap" class="headerlink" title="AttributeMap"></a>AttributeMap</h2><p><img src="/img/netty/netty7-4.png"></p>
<p>AttributeMap接口只有一个attr()方法，接收一个AttributeKey类型的key，返回一个Attribute类型的value。AttributeMap这是是绑定在Channel或者ChannelHandlerContext上的一个附件，相当于依附在这两个对象上的寄生虫一样，相当于附件一样。</p>
<p>AttributeKey相当于Map中的key，AttributeMap相当于Map, Attribute相当于Map中的value，它的实现方式和<strong>ChannelOption</strong>是类似的，都是继承了<strong>AbstractConstant</strong>，包含了一个<strong>ConstantPool</strong>的属性。</p>
<p>在Netty4.0中，每一个ChannelHandlerContext都是ChannelHandler和ChannelPipeline之间连接的桥梁，每一个ChannelHandlerContext都<br>有属于自己的上下文，也就说每一个ChannelHandlerContext上如果有AttributeMap都是绑定上下文的，也就说如果A的ChannelHandlerContext中的AttributeMap，B的ChannelHandlerContext是无法读取到的</p>
<p>但是Channel上的AttributeMap就是大家共享的，每一个ChannelHandler都能获取到。</p>
<p><strong>不过在Netty4.1中，这个情况发生了改变，只在Channel中维护了一个Map，ChannelHanlderContext也是用的Channel中的Map。他们的attr()方法是等价的。</strong></p>
<h2 id="ServerBootstrapAcceptor"><a href="#ServerBootstrapAcceptor" class="headerlink" title="ServerBootstrapAcceptor"></a>ServerBootstrapAcceptor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>继续看init()代码，上一篇文章也提到了Netty在pipeline里添加了一个处理器，将<code>ocnfig.handler</code>也就是代码中的<code>LoggingHandler</code>添加到了channelPipeline中(注意这个是通过handler()方法注册的，也就是提供给BossGroup使用的)。然后紧接着添加了一个<strong>ServerBootstrapAcceptor</strong>，在看完Reactor模式后，这个类是不是觉得很眼熟，它的角色也就是Reactor模式当中的<strong>Acceptor</strong>。</p>
<h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>  接受连接或创建他们只是你的应用程序的一部分，虽然这些任务很重要，但是一个网络应用程序往往是更复杂的，需要更多的代码编写，如处理传入和传出的数据。Netty提供了一个强大的处理这些事情的功能，允许用户自定义ChannelHandler的实现来处理数据。使得ChannelHandler更强大的是可以连接每个ChannelHandler来实现任务，这有助于代码的整洁和重用。但是处理数据只是ChannelHandler所做的事情之一，也可以压制I/O操作，例如写请求。所有这些都可以动态实现。<br>ChannelHandler就是入站(InBound)和出站(OutBound)处理器。</p>
<h2 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h2><p>ChannelInitializer本身也是一个特殊的Inbound处理器，用来初始化channel。</p>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>每创建一个ChannelHandler，随之也会创建一个ChannelHandlerContext。</p>
<p>ChannelPipeline里面真实存放的对象实际上是<strong>ChannelHandlerContext</strong>，ChannelHandlerContext里又维护了ChannelHannlder。所以ChannelHandlerContext实际上是ChannelPipeline和ChannelHandler的桥梁，它提供了api可以获取Channel对象，和与之关联的ChannelHandler对象、ChannelPipeline对象。</p>
<h2 id="Reactor模式在Netty中的体现"><a href="#Reactor模式在Netty中的体现" class="headerlink" title="Reactor模式在Netty中的体现"></a>Reactor模式在Netty中的体现</h2><p><img src="/img/netty/netty7-1.png"></p>
<p>通过这个图我们可以看到，客户端向BossGroup发起连接请求，BossGroup本身监听的是一个<code>OP_ACCEPT</code>事件（NioServerSocketChannel的构造方法中可以找到注册事件的代码），一旦<code>OP_ACCEPT</code>事件产生之后，<code>select()</code>方法就会返回<strong>SelectionKey</strong>的集合，那么<strong>SelectionKey</strong>本身也是包装了<strong>SocketChannel</strong>对象，就是与客户端真正建立连接的<strong>SocketChannel</strong>对象。对于Netty来说，会将<strong>SocketChannel</strong>包装成<strong>NIOSocketChannel</strong>，接着又将<strong>NIOSocketChannel</strong>注册到了<strong>WorkerGroup</strong>的<strong>selector</strong>中。<strong>WorkerGroup</strong>的<strong>Selector</strong>监听的是<code>OP_READ</code>，所以当数据发送过来的时候，就不再跟<strong>BossGroup</strong>打交道了，转而和<strong>WorkerGroup</strong>进行数据的传递。</p>
<p>下面这一段就是<strong>channelFactory</strong>通过反射创建<strong>NioServerSocketChannel</strong>对象的时候，注册了**<em>OP_ACCEPT**</em>事件，并进行一个包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NioServerSocketChannelConfig</strong>代码跟进去看，实际上是调用的父类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelConfig</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(channel, <span class="keyword">new</span> AdaptiveRecvByteBufAllocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AdaptiveRecvByteBufAllocator</strong>是干什么用的呢？它会根据反馈自动调整Channel所关联的buffer的大小。它的规则是如果上次读取的时候填满了Buffer，那么就会增加，反之连续2次没有填充满，就会减少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MINIMUM = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAXIMUM = <span class="number">65536</span>;</span><br></pre></td></tr></table></figure>

<p>这3个变量也定义了默认的Buffer的最小值，初始值和最大值。</p>
<p>其中有一个<strong>SIZE_TABLE</strong>在静态代码块中定义了初始化大小变化的一个数组，通过getSizeTableIndex来引用数组里面的值，动态调整Buffer大小就取数组里面的值来调整。内部类<strong>HandleImpl</strong>（记录每次读取的大小来猜测下一次的大小–动态调整）的父类<strong>MaxMessageHandle</strong>里有一个很重要的方法<strong>allocate()**，通过平台来判断是使用</strong>directBuffer<strong>还是</strong>heapBuffer**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中堆内Buffer是Netty用数组自己实现的，而DirectBuffer最终可以跟踪到**UnpooledUnsafeDirectByteBuf.allocateDirect()**，又发现我们很熟悉的NIO代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.allocateDirect(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel是针对于网络套接字的一个连接点，也可以认为它是一个可以执行I/O操作的组件。</p>
<p>它提供以下功能：</p>
<ul>
<li>获取Channel当前的状态（open,connected)</li>
<li>channel配置参数(buffer size)</li>
<li>IO操作（read,write,connect,bind)</li>
<li>提供一个<strong>ChannelPipline</strong>，可以处理所有当前Channel关联的所有的I/O事件和请求。</li>
</ul>
<h2 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><ol>
<li><p>一个EventLoopGroup中会包含一个或多个EventLoop。</p>
</li>
<li><p>一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。</p>
</li>
<li><p>所有由EventLoop所处理的各种I/O事件都将在它所关联的那个Thread上进行处理。</p>
<p> <img src="/img/netty/netty7-2.png"></p>
<blockquote>
<p>我们可以在**SingleThreadEventExecutor.execute()**发现这段代码。</p>
</blockquote>
</li>
<li><p>一个Channel在它的整个生命周期中只会注册在一个EventLoop上。</p>
</li>
<li><p>一个EventLoop在运行过程当中，会被分配给一个或者多个Channel。</p>
<p> <img src="/img/netty/netty7-3.png"></p>
</li>
</ol>
<p>重要结论：<strong>在Netty中，Channel的实现一定是线程安全的；基于此，我们可以存储一个Channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法；即便当时有很多线程都在使用她也不会出现多线程问题；而且，消息一定会按照顺序发送出去。</strong></p>
<p><strong>我们在业务开发中，不要将长时间执行的耗时任务放入到EventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有Channel上的其他执行任务，如果我们需要进行阻塞调用或是耗时的操作（实际开发中很常见），那么我们就需要使用一个专门的EventExecutor（业务线程池）。</strong></p>
<p>通常会有两种实现方式：</p>
<ol>
<li>在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用。</li>
<li>借助于Netty提供的向ChannelPipeline添加ChannelHandler时调用的addLast方法来传递EventExecutor。</li>
</ol>
<p>说明：默认情况下（调用addLast(handler))，ChannelHandler中的回调方法都是由I/O线程所执行，如果调用了<code>ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers)</code>方法，那么ChannelHandler中的回调方法就是由参数中的group线程组来执行的。</p>
<h2 id="JDK的Futuer和Netty的Futuer"><a href="#JDK的Futuer和Netty的Futuer" class="headerlink" title="JDK的Futuer和Netty的Futuer"></a>JDK的Futuer和Netty的Futuer</h2><p>JDK所提供的Future只能通过手工方式检查执行结果，而这个操作是会阻塞的；Netty则对ChannelFuture进行了增强，通过ChannelFutureListener以回调的方式来获取执行结果，去除了手工检查阻塞的操作；值得注意的是：ChannelFutureListener的operationComplete方法是由I/O线程执行的，因此要注意的是不要在这里执行耗时的操作，否则需要通过另外的线程或线程池来执行。</p>
<h2 id="ctx-write-和ctx-channel-write-的区别"><a href="#ctx-write-和ctx-channel-write-的区别" class="headerlink" title="ctx.write()和ctx.channel().write()的区别"></a>ctx.write()和ctx.channel().write()的区别</h2><p>在Netty中有两种发送消息的方式，可以直接写到Channel中，也可以写到与ChannelHandler所关联的那个ChannelHandlerContext中。对于前一种方式来说，消息会从ChannelPipeline的末尾开始流动；对于后一种方式来说，消息将从ChannelPipeline中的下一个ChannelHandler开始流动。</p>
<p>结论：</p>
<ol>
<li>ChannelHandlerContext与ChannelHandler之间是关联绑定关系是永远都不会发生改变的，因此对其进行缓存是没有任何问题的。</li>
<li>对于与Channel的同名方法来说，ChannelHandlerContext方法将会产生更短的事件流，所以我们应该在可能的情况下利用这个特性来提升应用性能。</li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-源码分析(三）</title>
    <url>/2017/11/19/netty/netty8/</url>
    <content><![CDATA[<h1 id="源码分析-三）"><a href="#源码分析-三）" class="headerlink" title="源码分析(三）"></a>源码分析(三）</h1><p>前面我们已经了解了Netty的启动流程，以及各个组件之间的关系，接下来要看看Netty的数据容器（ByteBuf)。</p>
<h2 id="回顾Java-NIO"><a href="#回顾Java-NIO" class="headerlink" title="回顾Java NIO"></a>回顾Java NIO</h2><p>先回顾一下Java NIO的Buffer使用方式。</p>
<p>使用NIO进行文件读取所涉及的步骤：</p>
<ol>
<li>从FileInputStream对象获取到Channel对象。</li>
<li>创建Buffer.</li>
<li>将数据从Channel中读取到Buffer对象中。</li>
</ol>
<p>0 &lt;= mark &lt;= postion &lt;= limit &lt;= capacity</p>
<h3 id="flip-方法切换读和写的状态："><a href="#flip-方法切换读和写的状态：" class="headerlink" title="flip()方法切换读和写的状态："></a>flip()方法切换读和写的状态：</h3><ol>
<li>将limit值设为当前的position。</li>
<li>将position设为0.</li>
</ol>
<a id="more"></a>

<h3 id="clear-方法，改变属性值，并没有删除数组里面的数据-："><a href="#clear-方法，改变属性值，并没有删除数组里面的数据-：" class="headerlink" title="clear()方法，改变属性值，并没有删除数组里面的数据 ："></a>clear()方法，改变属性值，并没有删除数组里面的数据 ：</h3><ol>
<li>将limit值设置成capacity。</li>
<li>将position值设为0。</li>
</ol>
<h3 id="compact-方法："><a href="#compact-方法：" class="headerlink" title="compact()方法："></a>compact()方法：</h3><ol>
<li>将所有未读的数据复制到buffer起始位置处。</li>
<li>将position设为最后一个未读元素的后面。</li>
<li>将limit设为capacity。</li>
<li>现在buffer准备好了，但是不会覆盖未读的数据。</li>
</ol>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>ByteBuf的使用很简单，一般不建议使用构造方法创建，用非池化的Buffer即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        buffer.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        System.out.println(buffer.getByte(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就包含了创建ByteBuf，写入数据和读取数据。</p>
<p>在ByteBuf中，Netty提供了一个readerIndex和writerIndex，这样避免了调用flip()方法，只有read开头的方法或和write方法开头的方法才会改变这2个变量的值。get和set方法是不会改变索引的，我们可以通过readerIndex()和writerIndex()来修改。</p>
<p>下面图中前面的部分表示已被读取过的数据，是可以丢弃的，中间是可读的数据，最后是可写的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">|                   |     (CONTENT)    |                  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line"><span class="number">0</span>      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br></pre></td></tr></table></figure>



<h3 id="3种缓冲区类型"><a href="#3种缓冲区类型" class="headerlink" title="3种缓冲区类型"></a>3种缓冲区类型</h3><p>Netty ByteBuf所提供的3种缓冲区类型：</p>
<ol>
<li>heap buffer (堆缓冲区)</li>
<li>direct buffer （直接缓冲区）</li>
<li>composite buffer（复合缓冲区）</li>
</ol>
<p>堆上的ByteBuf，这是最常用的类型，ByteBuf将数据存储到JVM的堆空间中， 并且将实际的数据存放到byte array中来实现。        </p>
<p>优点：由于数据是存储在JVM的堆中，因此可以快速的创建与快速的释放，并且它提供了直接访问内部字节数组的方法。</p>
<p>缺点：每次读写数据时，都需要先将数据复制到直接缓冲区中再进行网络传输。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示是堆上的缓冲，是用字节数组存放的</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectBuffer（直接缓冲区）</p>
<p>在堆之外直接分配内存空间，直接缓冲区并不会占用堆的容量空间，因为它是由操作系统在本地内存进行的数据分配。</p>
<p>优点：在使用Socket进行数据传递时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从JVM将数据复制到直接缓冲区中，性能很好。</p>
<p>缺点：因为Direct Buffer是直接在操作系统内存中的，所以内存空间的分配与释放要比堆空间更加复杂，而且速度要慢一些。Netty通过提供内存池来解决这个问题。直接缓冲区并不支持通过字节数组方式来访问数据。</p>
<p><strong>重点：对于后端的业务消息的编解码来说，推荐使用HeapByteBuf；对于I/O通信线程在读写缓冲区时，推荐使用DirectByteBuf。</strong></p>
<p>Composite Buffer（复合缓冲区）</p>
<p>复合缓冲区为多个ByteBuf提供一个聚合视图。在这里你可以根据需要添加或者删除ByteBuf实例， 是一个JDK的ByteBuffer实现缺失的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuf heapBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        ByteBuf directBuf = Unpooled.directBuffer(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        compositeByteBuf.addComponents(heapBuf, directBuf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        compositeByteBuf.removeComponent(0);</span></span><br><span class="line"></span><br><span class="line">        Iterator&lt;ByteBuf&gt; iterator = compositeByteBuf.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        compositeByteBuf.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK的ByteBuffer与Netty的ByteBuf之间的差异比对"><a href="#JDK的ByteBuffer与Netty的ByteBuf之间的差异比对" class="headerlink" title="JDK的ByteBuffer与Netty的ByteBuf之间的差异比对"></a>JDK的ByteBuffer与Netty的ByteBuf之间的差异比对</h3><ol>
<li>Netty的ByteBuf采用了读写索引分离的策略（readerIndex与writerIndex），一个初始化（里面尚未有任何数据）的ByteBuf的readerIndex和writerIndex值都为0。</li>
<li>当读索引与写索引处于同一个位置时，如果我们继续读取，那么就会抛出常见的IndexOutOfBoundsException。</li>
<li>对于ByteBuf的任何读写操作都会分别单独维护读索引和写索引。maxCapacity最大容量默认的限制就是Integer.MAX_VALUE。</li>
</ol>
<p>JDK的ByteBuffer的缺点：</p>
<ol>
<li><code>final byte[] hb;</code>这是JDK的ByteBuffer对中用于存储数据的对象声明；可以看到其数据是被声明为final的，也就是长度是固定不变的。一旦分配好就不能动态扩容与收缩；而且当待存储的数据字节很大时就很有可能出现IndexOutOfBoundsException。如果要预防这个异常，那就需要在存储之前完全确定好待存储的字节大小。如果ByteBuffer的空间不足，我们只有一种解决方案：创建一个全新的ByteBuffer对象，然后再将之前的ByteBuffer的数据复制过去，这一切的操作都需要由开发者自己来手动完成。</li>
<li>ByteBuffer只使用一个position指针来标识位置信息，在进行读写切换时就需要调用flip方法或是rewind方法，使用起来很不方便。</li>
</ol>
<p>Netty的ByteBuf的优点：</p>
<ol>
<li>存储字节是动态的，其最大值默认是Integer.MAX_VALUE。这里的动态性是体现在write方法中的，write方法在执行时会判断buffer容量，如果不足则自动扩容。</li>
<li>ByteBuf的读写索引是完全分开的，使用起来就很方便。</li>
</ol>
<p>在写入的时候，ensureWritable0()方法会检查容量大小来决定是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ensureWritable0(<span class="number">1</span>);</span><br><span class="line">    _setByte(writerIndex++, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>clear()方法只会重置readerIndex和writerIndex()，不会产生数据的移动。</p>
<h3 id="discardReadBytes"><a href="#discardReadBytes" class="headerlink" title="discardReadBytes()"></a>discardReadBytes()</h3><p>通过discardReadBytes()方法，可以丢弃已经读取过的字节，并回收它们的空间。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty在第4版为ByteBuf和ByteBufHolder引入了引用技术技术，它们都实现了<code>interface ReferenceCounted</code>。</p>
<p>ReferenceCounted包含了获取引用数量（refCnt），增加计数（retain），减少计数（realse)等API，用过OC的都应该比较熟悉。</p>
<p><strong>AbstractReferenceCountedByteBuf</strong>的**retain0()**方法是一个死循环，这段代码确保了ByteBuf的引用计数变为0的时候不会再次被使用。里面用了CAS来确保refCnt是原子的修改，没有并发问题。</p>
<h3 id="AtomicIntegerFieldUpdater-VS-AtomicInteger"><a href="#AtomicIntegerFieldUpdater-VS-AtomicInteger" class="headerlink" title="AtomicIntegerFieldUpdater VS AtomicInteger"></a>AtomicIntegerFieldUpdater VS AtomicInteger</h3><p><strong>AbstractReferenceCountedByteBuf</strong>维护了一个<strong>AtomicIntegerFieldUpdater</strong>来修改volatile修饰的refCnt，那么我们都知道JDK5提供了一个<strong>AtomicInteger</strong>来对int进行原子修改，为什么Netty不用我们更熟悉的<strong>AtomicInteger</strong>呢？</p>
<p>AtomicIntegerFieldUpdater要点总结：</p>
<ol>
<li>更新器更新的必须是int类型变量，不能是其包装类型。</li>
<li>更新器更新的必须是volatile类型变量，确保线程之间共享变量值的立即**<a href="http://www.saily.top/2016/12/05/concurrency3/#%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a>**。</li>
<li>变量不能是static的，必须是实例变量。因为Unsafe.objectFieldOffset()方法不支持静态变量（CAS操作本质上是通过对象实例的偏移量来直接进行赋值）。</li>
<li>更新器只能修改它可见范围内的变量，因为更新器是通过反射来得到这个变量，如果变量不可见就会报错。</li>
</ol>
<p>如果要更新的变量是包装类型，我们可以使用AtomicReferenceFieldUpdater来进行更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fieldt != int.class)</span><br><span class="line">    throw new IllegalArgumentException(<span class="string">&quot;Must be integer type&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">    throw new IllegalArgumentException(<span class="string">&quot;Must be volatile type&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="为什么不用AtomicInteger"><a href="#为什么不用AtomicInteger" class="headerlink" title="为什么不用AtomicInteger"></a>为什么不用AtomicInteger</h3><p>这是Netty为了性能上的考虑，因为使用AtomicInteger，创建多个ByteBuf也会随之创建多个AtomicInteger对象，但是<strong>AtomicIntegerFieldUpdater</strong>是static修饰的，只有一个对象，由此可见Netty对性能的优化也是考虑到了极致。</p>
<h2 id="数据-gt-ByteBuf"><a href="#数据-gt-ByteBuf" class="headerlink" title="数据 -&gt; ByteBuf"></a>数据 -&gt; ByteBuf</h2><p>Netty是在AbstractNioChannel的NioByteUnsafe内部类的read()方法将入站数据转换成ByteBuf对象的。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-cloud OAuth2.0配置</title>
    <url>/2016/03/31/springcloud/Spring-cloud-OAuth2-0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>在spring cloud项目环境中配置oauth2.0认证。<br><img src="http://callistaenterprise.se/assets/blogg/build-microservices-part-3/system-landscape.png">    </p>
<p><a href="http://callistaenterprise.se/blogg/teknik/2015/04/27/building-microservices-part-3-secure-APIs-with-OAuth/">http://callistaenterprise.se/blogg/teknik/2015/04/27/building-microservices-part-3-secure-APIs-with-OAuth/</a><br>可以先看看这篇文章。</p>
<p>我花了不少时间才把这个调通，spring cloud的版本和文档也存在不一致的地方。<br>以下所有的操作都基于Brixton.RC1搭建，须保持所有相关项目都引用此parent。否则会出现各种莫名其妙的错误。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><a href="https://spring.io/blog/2015/11/30/migrating-oauth2-apps-from-spring-boot-1-2-to-1-3">https://spring.io/blog/2015/11/30/migrating-oauth2-apps-from-spring-boot-1-2-to-1-3</a></p>
<p>这篇文章显示了不同版本之间的区别。<br>目前官网最新提供的<code>Angel SR6</code>和<code>Brixton RC1</code>，它们引用的Spring Boot版本不一样。这2个版本在Spring Security这一块改动比较大。<br>Spring Boot1.3 移除了官方文档中提到的<code>@EnableOAuth2Resource</code>注解。<br><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_token_relay">http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_token_relay</a><br>反正感觉官网提供这个文档写得不太对。            </p>
<p>下面展示我最终正常运行的一个配置。<br><code>Zuul Proxy</code>和<code>AuthServer</code>，我把它们放在了同一个应用里。<br>在pom中加入oauth2的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是<code>Application</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="comment">//必须添加@EnableResourceServer，Zuul才会进行Token Relay。</span></span><br><span class="line"><span class="comment">//(查看各种源码后才发现。文档描述的@EnableOAuth2Sso根本没有什么卵用。只有</span></span><br><span class="line"><span class="comment">//@EnableResourceServer才会加载OAuth2AuthenticationProcessingFilter)</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么不用自动配置。因为/oauth/check_token默认是denyAll.</span></span><br><span class="line">    <span class="comment">//必须手动设置oauthServer.checkTokenAccess(&quot;isAuthenticated()&quot;);</span></span><br><span class="line">    <span class="comment">//才访问能验证Access Token。</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuthSecurityConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            endpoints.authenticationManager(authenticationManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer oauthServer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            oauthServer.checkTokenAccess(<span class="string">&quot;isAuthenticated()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            clients.inMemory()</span><br><span class="line">                    .withClient(<span class="string">&quot;clientId&quot;</span>)</span><br><span class="line">                    .secret(<span class="string">&quot;secretId&quot;</span>)</span><br><span class="line">                    .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;client_credentials&quot;</span>)</span><br><span class="line">                    .scopes(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            http.anonymous().disable()</span><br><span class="line">                    .sessionManagement()</span><br><span class="line">                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                    .and()</span><br><span class="line">                    .exceptionHandling()</span><br><span class="line"><span class="comment">//                    .accessDeniedHandler(accessDeniedHandler()) // handle access denied in general (for example comming from @PreAuthorization</span></span><br><span class="line"><span class="comment">//                    .authenticationEntryPoint(entryPointBean()) // handle authentication exceptions for unauthorized calls.</span></span><br><span class="line">                    .and()</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line"><span class="comment">//                    .antMatchers(&quot;/hystrix.stream/**&quot;, &quot;/info&quot;, &quot;/error&quot;).permitAll()</span></span><br><span class="line">                    .anyRequest().authenticated().and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">		  </span><br><span class="line"><span class="comment">//        @Bean</span></span><br><span class="line"><span class="comment">//        @Autowired</span></span><br><span class="line"><span class="comment">//        AccessDeniedHandler accessDeniedHandler() &#123;</span></span><br><span class="line"><span class="comment">//            return new AccessDeniedExceptionHandler();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        @Bean</span></span><br><span class="line"><span class="comment">//        @Autowired</span></span><br><span class="line"><span class="comment">//        AuthenticationEntryPoint entryPointBean() &#123;</span></span><br><span class="line"><span class="comment">//            return new UnauthorizedEntryPoint();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">		<span class="comment">// 不需要权限控制的路径</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            web.ignoring().antMatchers(<span class="string">&quot;/hystrix.stream/**&quot;</span>, <span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在API里同样加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.yml中加入以下配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">token-info-uri:</span> <span class="string">http://localhost:10000/oauth/check_token</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">          <span class="attr">client-id:</span> <span class="string">clientId</span></span><br><span class="line">          <span class="attr">client-secret:</span> <span class="string">secretId</span></span><br><span class="line">          <span class="attr">user-authorization-uri:</span> <span class="string">http://localhost:10000/oauth/authorize</span></span><br><span class="line">          <span class="attr">access-token-uri:</span> <span class="string">http://localhost:10000/oauth/token</span></span><br><span class="line">          <span class="attr">grant-type:</span> <span class="string">client_credentials</span></span><br></pre></td></tr></table></figure>

<p><code>Application.java</code>中加上<code>@EnableResourceServer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//不需要权限控制的URL</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            web.ignoring().antMatchers(<span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完了，启动应用。<br>获取access_token。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -s clientId:secretId@localhost:10000/oauth/token  \</span><br><span class="line"> -d grant_type=client_credentials \</span><br><span class="line"> -d scope=app</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>: <span class="string">&quot;8265eee1-1309-4481-a734-24a2a4f19299&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>: 43189,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;app&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>访问API的时候在Http Header中带上，Authorization: Bearer$access_token。即可…</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud @EnableOAuth2Client</title>
    <url>/2016/07/15/springcloud/Spring-cloudt-EnableOAuth2Client/</url>
    <content><![CDATA[<p>Spring Cloud oauth2 开启客户端功能，并启用LoadBalanced</p>
<p>如果不添加以下配置，只添加<code>@EnableOAuth2Client</code>注解，spring cloud默认是在web环境下使用的<code>AuthorizationCodeResourceDetails</code>。</p>
<p>具体代码在<code>OAuth2RestOperationsConfiguration</code>类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnBean(OAuth2ClientConfiguration.class)</span><br><span class="line">@ConditionalOnWebApplication</span><br><span class="line">protected static class SessionScopedConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConfigurationProperties(&quot;security.oauth2.client&quot;)</span><br><span class="line">	@Primary</span><br><span class="line">	public AuthorizationCodeResourceDetails oauth2RemoteResource() &#123;</span><br><span class="line">		AuthorizationCodeResourceDetails details &#x3D; new AuthorizationCodeResourceDetails();</span><br><span class="line">		return details;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public FilterRegistrationBean oauth2ClientFilterRegistration(</span><br><span class="line">			OAuth2ClientContextFilter filter, SecurityProperties security) &#123;</span><br><span class="line">		FilterRegistrationBean registration &#x3D; new FilterRegistrationBean();</span><br><span class="line">		registration.setFilter(filter);</span><br><span class="line">		registration.setOrder(security.getFilterOrder() - 10);</span><br><span class="line">		return registration;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Configuration</span><br><span class="line">	protected static class ClientContextConfiguration &#123;</span><br><span class="line"></span><br><span class="line">		@Resource</span><br><span class="line">		@Qualifier(&quot;accessTokenRequest&quot;)</span><br><span class="line">		protected AccessTokenRequest accessTokenRequest;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@Scope(value &#x3D; &quot;session&quot;, proxyMode &#x3D; ScopedProxyMode.INTERFACES)</span><br><span class="line">		public DefaultOAuth2ClientContext oauth2ClientContext() &#123;</span><br><span class="line">			return new DefaultOAuth2ClientContext(this.accessTokenRequest);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>这个东西我也没找到在哪里可以配置，就自己在Application手动加入以下配置来使用吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Primary</span><br><span class="line">@LoadBalanced</span><br><span class="line">public OAuth2RestTemplate xmRestTemplate(ClientCredentialsResourceDetails xmOauth2RemoteResource) &#123;</span><br><span class="line">    return new OAuth2RestTemplate(xmOauth2RemoteResource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(&quot;security.oauth2.client&quot;)</span><br><span class="line">public ClientCredentialsResourceDetails xmOauth2RemoteResource() &#123;</span><br><span class="line">    return new ClientCredentialsResourceDetails();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud项目实践(三)</title>
    <url>/2016/03/22/springcloud/Spring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>配置jenkins构建项目，自动build出docker镜像，发布到docker私库中，或者从目标服务器中启动容器。</p>
<h2 id="Maven的Docker插件"><a href="#Maven的Docker插件" class="headerlink" title="Maven的Docker插件"></a>Maven的Docker插件</h2><p><a href="http://www.cnblogs.com/skyblog/p/5163691.html">http://www.cnblogs.com/skyblog/p/5163691.html</a> 有讲到如何用Dockerfile构建，下面是采用Maven插件的方式构建，插件的文档在<a href="https://github.com/spotify/docker-maven-plugin">这里</a></p>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;docker.plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--绑定build命令到mvn package中--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--绑定push命令到mvn deploy中--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>push-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--&lt;imageTag&gt;$&#123;project.version&#125;&lt;/imageTag&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Dockerfile文件在src/main/docker/Dockerfile<br>内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD pin-user-0.1.0.jar app.jar</span><br><span class="line">RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">EXPOSE 9000</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://spring.io/guides/gs/spring-boot-docker/">https://spring.io/guides/gs/spring-boot-docker/</a><br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-22%20%E4%B8%8A%E5%8D%889.08.51.png" alt="说明"></p>
<p>特别解释一下<code>ENTRYPOINT</code>指令,<code>docker run</code>命令中的参数都会传递给<code>ENTRYPOINT</code>指令。<br>执行<code>docker run -d pin-user --config.host=localhost</code>启动容器。<br>会把–config.host加在<code>ENTRYPOINT</code>后面,相当于执行了<code>java -Djava.security.egd=file:/dev/./urandom -jar /app.jar --config.host=localhost</code>。有了这个参数后我们就能很方便的控制环境和配置文件了。</p>
<h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><p>jenkins中新建一个项目，配置好git后，执行目标服务器的一个shell脚本来启动容器。<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-22%20%E4%B8%8A%E5%8D%889.24.33.png" alt="配置界面"></p>
<p>然后开始构建项目，因为在<code>pom.xml</code>配置中绑定了<code>docker:build</code>到<code>package</code>命令中，所以会自动执行<code>docker:build</code>，这里遇到了一个docker命令的权限问题，jenkins抛出一个错误。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.io.IOException: Permission denied</span><br></pre></td></tr></table></figure>
<p>在jenkins所在的服务器上执行以下命令查看jenkins用户组    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id jenkins </span><br></pre></td></tr></table></figure>
<p>将jenkins用户加入到docker组中。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -a -G docker jenkins</span><br></pre></td></tr></table></figure>

<p>再构建，权限问题没有了，但是我又得到另外一个错误</p>
<blockquote>
<p>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:0.3.258:build (default) on project pin-user: Exception caught: Error getting container 1e509efd653d0a3a942bf5ef34601305b7301d64378381614b55d3f5f88c7166 from driver devicemapper: open /dev/mapper/docker-202:33-5767218-1e509efd653d0a3a942bf5ef34601305b7301d64378381614b55d3f5f88c7166: no such file or directory</p>
</blockquote>
<p>说是因为docker在centos下的存储驱动原因，我这里试试把devicemapper换成btrfs。在centos下只能选择这2种方式。</p>
<p>需要把docker使用的分区的文件系统换掉。这一步会镜像会被全部清除掉，记得备份镜像，因为我是测试环境，所以镜像全部丢了也无所谓。教程如下。</p>
<p><a href="https://wiki.centos.org/PhilipJensen/CentOS6ConvertToBTRFS#head-c0851e0e7c9205aa8ca5616b85179b96981b24a7">https://wiki.centos.org/PhilipJensen/CentOS6ConvertToBTRFS#head-c0851e0e7c9205aa8ca5616b85179b96981b24a7</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount &#x2F;dev&#x2F;xvdc1</span><br></pre></td></tr></table></figure>
<p>提示divice busy。下面命令把相关进程kill掉再umount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fuser -m -v -i -k &#x2F;dev&#x2F;xvdc1</span><br></pre></td></tr></table></figure>
<p>再执行这个命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btrfs-convert &#x2F;dev&#x2F;xvdc1</span><br></pre></td></tr></table></figure>
<p>完事后再挂载回去 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;xvdc1 &#x2F;mnt2</span><br></pre></td></tr></table></figure>
<p>还是提示busy，reboot重启下，再mount。<br>然后在<code>/etc/sysconfig/docker</code>加上<code>--storage-driver btrfs</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">other_args&#x3D;&quot;--graph&#x3D;&#x2F;mnt2&#x2F;apps&#x2F;docker --storage-driver btrfs --insecure-registry&#x3D;10.168.248.36:5000&quot;</span><br></pre></td></tr></table></figure>

<p>重启docker，再执行<code>docker info</code>就看到docker的存储驱动已经变了</p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/2F11C9E9-193C-445E-86BA-CA76BB259CCA.png"></p>
<p>启动docker容器的时候报错了，把<code>/var/lib/docker/linkgraph.db</code>删了<br>因为我在<code>/etc/sysconfig/docker</code>修改了docker的目录。<br>所以我这里是目录是<code>/mnt2/apps/docker/linkgraph.db</code>。<br>service restart docker<br>重启下docker即可。<br>现在再用jenkins构建和发布就没有错误了。</p>
<h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/mnt/web/scripts/docker_run.sh 10.168.248.36:5000/pin-user 9000 <span class="string">&quot;--config.profile=dev --config.host=10.168.248.36&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面我解释一下这个启动docker容器的脚本。<br>脚本后面跟了3个参数，一个是镜像名称，一个是端口号，一个是启动容器加在<code>ENTRYPOINT</code>的项目配置。<br>先找出之前镜像对应的containerId，把它删除掉，然后再用新的镜像启动容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#defined </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_40/</span><br><span class="line"></span><br><span class="line">IMAGE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">OPTIONS=<span class="string">&quot;&quot;</span></span><br><span class="line">PORT=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="comment">#param validate</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 2 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;you must use like this : ./deploy_run.sh &lt;image&gt; &lt;port&gt; [options]&quot;</span>  </span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$3</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   OPTIONS=<span class="string">&quot;<span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拿到容器ID后kill掉并删除。</span></span><br><span class="line"><span class="function"><span class="title">delete_container</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;the container id is <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;delete container:&quot;</span> <span class="variable">$1</span></span><br><span class="line">        docker stop <span class="variable">$1</span></span><br><span class="line">        docker rm -f <span class="variable">$1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&gt;&gt;&gt; Get old image <span class="variable">$IMAGE</span> container id&quot;</span></span><br><span class="line">CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">#因为jenkins每次的build的时候，如果镜像的tag没有指定，那么新的镜像build成功后，之前的镜像名称就会变成none。</span></span><br><span class="line"><span class="comment">#所以我们找出为名字为none的就是之前的镜像。</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;get old image id&quot;</span></span><br><span class="line">        OLD_IMAGE_IDS=$(docker images --no-trunc| grep none | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$OLD_IMAGE_IDS</span></span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$OLD_IMAGE_IDS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">if</span> [ -n <span class="variable">$&#123;OLD_IMAGE_IDS[1]&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">for</span> OLD_IMAGE_ID <span class="keyword">in</span> <span class="variable">$OLD_IMAGE_IDS</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                    CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$&#123;OLD_IMAGE_ID:0:12&#125;</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">                    delete_container <span class="variable">$CID</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">                delete_container <span class="variable">$OLD_IMAGE_IDS</span></span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        delete_container <span class="variable">$CID</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;docker run -d -v /mnt:/mnt -p <span class="variable">$&#123;PORT&#125;</span>:<span class="variable">$&#123;PORT&#125;</span> <span class="variable">$IMAGE</span> <span class="variable">$OPTIONS</span>&quot;</span></span><br><span class="line">docker run -d -v /mnt:/mnt -p <span class="variable">$&#123;PORT&#125;</span>:<span class="variable">$&#123;PORT&#125;</span> <span class="variable">$IMAGE</span> <span class="variable">$OPTIONS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;clean docker images&quot;</span></span><br><span class="line"><span class="comment">#再次清理名称为none的docker镜像。</span></span><br><span class="line">docker images --no-trunc| grep none | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | xargs -r docker rmi -f</span><br><span class="line"><span class="comment">#清理所有已经退出的容器</span></span><br><span class="line"><span class="comment">#docker rm `docker ps -a | grep Exited | awk &#x27;&#123;print $1&#125;&#x27;`</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;finished&quot;</span> </span><br></pre></td></tr></table></figure>

<p>可能最好的方式还是每次用不同的tag来build镜像，不过我这里就偷懒了，等到发布到生产环境的时候再指定吧。<br>注意到<code>&quot;--config.profile=dev --config.host=10.168.248.36&quot;</code>这个参数配合<code>ENTRYPOINT</code>就可以针对生产环境和测试环境加载不同的配置文件了。<br>项目中的配置文件:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://$&#123;config.host:192.168.99.100&#125;:8888</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">$&#123;config.profile:dev&#125;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line"></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">failOnError:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>到此我们的一个基本的spring-cloud项目实践就完成了，其他特性和功能自行选择后再添加就可以了。<br>我接下来要继续加入的模块就是使用API网关构建微服务。概念如下</p>
<p><a href="http://www.infoq.com/cn/articles/construct-micro-service-using-api-gateway/">http://www.infoq.com/cn/articles/construct-micro-service-using-api-gateway/</a></p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud项目实践(一)</title>
    <url>/2016/03/21/springcloud/Spring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="基本概念和重要组件"><a href="#基本概念和重要组件" class="headerlink" title="基本概念和重要组件"></a>基本概念和重要组件</h1><p>最近看了一篇<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=400645575&idx=1&sn=da55d75db55117046c520de88dde1123&scene=1&srcid=0315vVImLcHZpO2tTRVKg1w8&key=710a5d99946419d9ff6bc76720229c7216fbcf348001d543434dfad7944207441ed01f44e57b0d87a834f8e8b6f673b7&ascene=0">文章</a>，了解到微服务架构的组成部分和概念，以前有看过一点dubbo，文章里介绍到Netflix这么一个公司：</p>
<blockquote>
<p>Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix就把它的几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括</p>
</blockquote>
<ul>
<li>Eureka:　服务注册发现框架</li>
<li>Zuul:　服务网关</li>
<li>Karyon:　服务端框架</li>
<li>Ribbon:　客户端框架</li>
<li>Hystrix:    服务容错组件</li>
<li>Archaius: 服务配置组件</li>
<li>Servo: Metrics组件</li>
<li>Blitz4j: 日志组件</li>
</ul>
<blockquote>
<p>Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。对于一些打算构建微服务框架体系的公司来说，充分利用或参考借鉴Netflix的开源微服务组件(或Spring Cloud)，在此基础上进行必要的企业定制，无疑是通向微服务架构的捷径。</p>
</blockquote>
<p>Spring Cloud是微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。</p>
<p>觉得挺不错的，就找找资料尝试实战一下。<br>在此记录和回顾一下过程中遇到的问题和实际项目中需要解决的一些问题。</p>
<a id="more"></a>
<p>接下来我看了2个文章<br>第一个是<br><a href="http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html">http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html</a><br>中文版的：<a href="http://www.chinacloud.cn/show.aspx?id=20968&amp;cid=12">http://www.chinacloud.cn/show.aspx?id=20968&amp;cid=12</a><br>第二个是<br><a href="http://www.cnblogs.com/skyblog/category/774535.html">http://www.cnblogs.com/skyblog/category/774535.html</a>    </p>
<p>在继续往下看之前，可以先把上面2个文章看了。第一个是老外写的，用一个实例的demo演示了spring-cloud构建微服务架构的项目。</p>
<p>第二个文章则很好的介绍了spring-cloud各个子项目的作用。也用了一个demo演示了spring-cloud构建的微服务架构的项目。建议也看看动手试试，我这里就不再赘述了。后面的文章都是在基于看过这2篇文章后的基础上写的，很多东西没有再进行二次解释。这里贴一下spring-cloud的子项目。        </p>
<blockquote>
<p>目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，spring cloud子项目包括：</p>
</blockquote>
<ul>
<li>Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。</li>
<li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</li>
<li>Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。</li>
<li>Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。</li>
<li>Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li>
<li>Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。</li>
<li>Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li>
<li>Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</li>
<li>Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。</li>
<li>Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。</li>
<li>Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。</li>
<li>Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</li>
<li>Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。</li>
<li>Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</li>
<li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在了解了微服务的概念，以及spring-cloud各个子项目之间的关系后。<br>接下来我们就自己动手构建一个项目，做一个能跑起来的项目实际上需要3个模块：        </p>
<ol>
<li>Spring Cloud Config</li>
<li>Spring Cloud Eureka</li>
<li>自己的项目</li>
</ol>
<p>在配置好这几个项目后，我会用jenkins自动build项目，然后发布到docker中再启动容器。其中还可以针对生产和测试环境采用不同的配置。我的服务器环境是centos6.5。</p>
<p>我的服务应用目前做了以下2个配置。<br>1.mongodb<br>2.mybatis</p>
<p>下篇文章详细讲解。</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Netflix生产实践</title>
    <url>/2020/05/17/springcloud/SpringCloud%E7%94%9F%E4%BA%A7%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="服务注册生产实践"><a href="#服务注册生产实践" class="headerlink" title="服务注册生产实践"></a>服务注册生产实践</h1><h2 id="服务注册的时效性（毫秒级）"><a href="#服务注册的时效性（毫秒级）" class="headerlink" title="服务注册的时效性（毫秒级）"></a>服务注册的时效性（毫秒级）</h2><p>服务在启动后，会向eureka server发起注册，应该是在1秒以内的。</p>
<p>会通过SpringCloud额外封装的<code>EurekaAutoServiceRegistration#start()</code>发起注册，这个类的实例被EurekaClientAutoConfiguration定义。</p>
<h2 id="服务发现的时效性（毫秒级和分钟级）"><a href="#服务发现的时效性（毫秒级和分钟级）" class="headerlink" title="服务发现的时效性（毫秒级和分钟级）"></a>服务发现的时效性（毫秒级和分钟级）</h2><p>一个服务启动后，发现其他所有的服务需要多长时间？如果其他服务新增了机器，那么又需要多长时间才能发现。</p>
<ol>
<li>服务启动后，会主动拉取全量注册表，可以发现已经注册的服务列表（毫秒级）</li>
<li>服务每隔30秒会拉取增量注册表（先走ALL_APPS_DELTA缓存，读不到查queue）</li>
<li>eureka server 二级缓存，定时任务30秒从readWriterCacheMap同步到readOnlyCacheMap</li>
<li>一个服务启动注册后，要30秒才会被其他服务发现（1分钟以内）</li>
</ol>
<a id="more"></a>

<p>eureka的服务发现是分钟级，可通过修改配置减少这个时间：</p>
<p>eureka client端(EurekaClientConfigBean)：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.client.registryFetchIntervalSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<p>eureka server端(EurekaServerConfigBean)：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.server.responseCacheUpdateIntervalMs</span>=<span class="string">30 * 1000</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/spring-cloud/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7%E5%88%86%E6%9E%90.png" alt="服务发现的时效性分析"></p>
<h2 id="服务心跳的时效性（30秒）"><a href="#服务心跳的时效性（30秒）" class="headerlink" title="服务心跳的时效性（30秒）"></a>服务心跳的时效性（30秒）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务心跳流程分析</a></p>
<p>服务启动以后，会定时发送心跳给eureka server，默认是30秒一次(EurekaInstanceConfigBean)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.instance.leaseRenewalIntervalInSeconds</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<h2 id="服务故障感知的时效性（5分）"><a href="#服务故障感知的时效性（5分）" class="headerlink" title="服务故障感知的时效性（5分）"></a>服务故障感知的时效性（5分）</h2><p><a href="%5Bhttp://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%5D(http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E6%95%85%E9%9A%9C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)">服务故障流程分析</a></p>
<p>在eureka server中，每隔60秒会执行一次evict task（加上JVM gc等原因的补偿时间），判断当前所有的服务实例是否有的实例出现了故障（一直没有发送心跳）。</p>
<p>这个任务的逻辑是，默认90s没有收到过心跳就认为已经过期，但是这里有bug，实际上是90s * 2 = 180s才会认为已经故障了，那么算到这里，eureka server可能要4分钟才能感知到一个服务宕机后认为是下线了。 （而且每次只会摘除最多15%数量的故障实例）,</p>
<p><strong>客户端</strong>：服务摘除后，会清空readWriteCacheMap的缓存，算eureka server的读写缓存30秒，然后每隔30秒会同步到readOnlyCacheMap里。所以宕机后要被客户端感知到，极端情况下可能要5分钟。</p>
<h2 id="服务下线感知的时效性（1分钟）"><a href="#服务下线感知的时效性（1分钟）" class="headerlink" title="服务下线感知的时效性（1分钟）"></a>服务下线感知的时效性（1分钟）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">服务下线流程分析</a></p>
<p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。逻辑也是从内存的map里删除，然后放入recentlyChangedQueue队列里，最后让缓存失效。</p>
<p>无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能<strong>60秒</strong>才能感知到服务的下线。</p>
<h2 id="eureka-server自我保护机制（不要用）"><a href="#eureka-server自我保护机制（不要用）" class="headerlink" title="eureka server自我保护机制（不要用）"></a>eureka server自我保护机制（不要用）</h2><p><a href="http://www.saily.top/2020/03/22/springcloud/eureka04/#%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">服务自我保护机制</a></p>
<p>eureka的自我保护机制，充斥着大量的hash code硬编码，写死你的心跳间隔时间是30秒，1分钟2次，通过统计服务的心跳次数来判断自己是不是网络故障了。这个根本就是很严重的bug，无法在生产环境使用。</p>
<p>直接在配置中关闭</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">eureka.server.enableSelfPreservation</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h2 id="eureka-server集群的负载均衡（按配置顺序）"><a href="#eureka-server集群的负载均衡（按配置顺序）" class="headerlink" title="eureka server集群的负载均衡（按配置顺序）"></a>eureka server集群的负载均衡（按配置顺序）</h2><p>服务在注册的时候，如果在yml里配置了多个eureka server，会按顺序用第一个eureka server的机器发起注册，只有在第一个机器挂掉的情况下，在重试一定次数失败以后，才会尝试用第二台机器。</p>
<p>那如果第一台又恢复了呢，其实还是会一直用第二台，除非第二台死掉了，才会重试别的机器。</p>
<p>这些重试的逻辑的源码，都在<code>RetryableEurekaHttpClient</code>类里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</span><br><span class="line">    List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</span><br><span class="line">        EurekaHttpClient currentHttpClient = delegate.get();</span><br><span class="line">        EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></span><br><span class="line">            <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</span><br><span class="line">                candidateHosts = getHostCandidates();</span><br><span class="line">                <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;There is no known eureka server; cluster server list is empty&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></span><br><span class="line">            <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Cannot execute request on any known server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建候选的 EurekaHttpClient</span></span><br><span class="line">            currentEndpoint = candidateHosts.get(endpointIdx++);</span><br><span class="line">            currentHttpClient = clientFactory.newClient(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</span><br><span class="line">            <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></span><br><span class="line">            <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</span><br><span class="line">                delegate.set(currentHttpClient);</span><br><span class="line">                <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Request execution succeeded on retry #&#123;&#125;&quot;</span>, retry);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failure with status code &#123;&#125;; retrying on another server if available&quot;</span>, response.getStatusCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Request execution failed with message: &#123;&#125;&quot;</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></span><br><span class="line">        <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></span><br><span class="line">        delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></span><br><span class="line">        <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quarantineSet.add(currentEndpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;Retry limit reached; giving up on completing the request&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eureka-server集群同步的时效性（1秒内）"><a href="#eureka-server集群同步的时效性（1秒内）" class="headerlink" title="eureka server集群同步的时效性（1秒内）"></a>eureka server集群同步的时效性（1秒内）</h2><p><a href="http://www.saily.top/2020/03/28/springcloud/eureka05/#%E6%B3%A8%E5%86%8C%E3%80%81%E4%B8%8B%E7%BA%BF%E3%80%81%E6%95%85%E9%9A%9C%E9%9B%86%E7%BE%A4%E9%97%B4%E5%90%8C%E6%AD%A5">集群间同步</a></p>
<p>在eureka server收到注册请求的时候，就会将注册数据同步到其他节点，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，并且这里包含了一个注册逻辑的批处理。</p>
<p><img src="http://www.saily.top/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p>
<p>可以看到，因为有一个批处理的机制，每500毫秒以内的请求会统一打包处理，所以集群间的数据同步，是一秒以内完成同步。</p>
<h1 id="服务调用生产实践"><a href="#服务调用生产实践" class="headerlink" title="服务调用生产实践"></a>服务调用生产实践</h1><h2 id="Ribbon-Eureka服务发现与故障的时效性"><a href="#Ribbon-Eureka服务发现与故障的时效性" class="headerlink" title="Ribbon+Eureka服务发现与故障的时效性"></a>Ribbon+Eureka服务发现与故障的时效性</h2><h3 id="服务正常上线-修改，最大可能会有60s滞后"><a href="#服务正常上线-修改，最大可能会有60s滞后" class="headerlink" title="服务正常上线/修改，最大可能会有60s滞后"></a>服务正常上线/修改，最大可能会有60s滞后</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br></pre></td></tr></table></figure>

<p>前面已经分析了Eureka本身的时效性，刚启动发现其他服务是毫秒级，发现新注册的服务是分钟级。那么在结合Ribbon使用后，他有一个PollingServerListUpdater，这个是每30秒从eureka client同步一次到Ribbon的缓存中，所以一个新注册的服务要被Ribbon感知到，极端情况下需要90秒。</p>
<h3 id="服务异常下线：最大可能会有300s滞后"><a href="#服务异常下线：最大可能会有300s滞后" class="headerlink" title="服务异常下线：最大可能会有300s滞后"></a>服务异常下线：最大可能会有300s滞后</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 定时清理任务每eureka.server.evictionIntervalTimerInMs(默认60)执行一次清理任务</span><br><span class="line">- 每次清理任务会把90秒(3个心跳周期，eureka.instance.leaseExpirationDurationInSeconds)没收到心跳的踢除，但是根据官方的说法 ，因为代码实现的bug，这个时间其实是两倍，即180秒，也就是说如果一个客户端因为网络问题或者主机问题异常下线，可能会在180秒后才剔除</span><br><span class="line">- 读取端，因为readOnlyCacheMap以及客户端缓存的存在，可能会在30(readWriterCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br><span class="line">- 所以极端情况最终可能会是60+180+90&#x3D;330</span><br></pre></td></tr></table></figure>

<p>那如果某一个服务宕机了，Eureka Client感知到的时间是5分钟，再加上Ribbon的PollingServerListUpdater的30秒，Ribbon在极端情况下是需要5.5分钟才能感知到。</p>
<h2 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h2><p>Ribbon默认是用ZoneAwareLoadBalancer，默认算法就是轮询</p>
<p><a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">负载均衡算法如何选择一个server</a></p>
<h2 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h2><p><a href="http://www.saily.top/2020/04/18/springcloud/feign04/">Feign超时和重试分析</a></p>
<p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>feign的超时时间优先级更高</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h2 id="Ribbon预加载"><a href="#Ribbon预加载" class="headerlink" title="Ribbon预加载"></a>Ribbon预加载</h2><p>网关的项目第一次访问的时候总是会超时，是因为在第一次访问的时候，Ribbon会去调用eureka-client里的服务列表，所以这里会消耗一些时间，而zuul默认超时时间又是1秒，所以加上下面的参数，让Ribbon提前加载好。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure>

<h2 id="Zuul-Ribbon-eureka感知服务上线和故障的时效性"><a href="#Zuul-Ribbon-eureka感知服务上线和故障的时效性" class="headerlink" title="Zuul+Ribbon+eureka感知服务上线和故障的时效性"></a>Zuul+Ribbon+eureka感知服务上线和故障的时效性</h2><p>这块儿和<a href="#Ribbon+Eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%95%85%E9%9A%9C%E7%9A%84%E6%97%B6%E6%95%88%E6%80%A7">Ribbon+Eureka服务发现与故障的时效性</a>是一样的</p>
<h2 id="Zuul降级和异常"><a href="#Zuul降级和异常" class="headerlink" title="Zuul降级和异常"></a>Zuul降级和异常</h2><p>Error Filter错误处理和<a href="http://www.saily.top/2020/05/10/springcloud/zuul01/#hystrix%E9%85%8D%E7%BD%AE">降级</a></p>
<h2 id="Zuul超时"><a href="#Zuul超时" class="headerlink" title="Zuul超时"></a>Zuul超时</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Hystrix的超时时间应该大于Ribbon的超时时间，加上Ribbon的重试机制，基于上面的参数计算，(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)。</p>
<p>Hystrix的超时时间应该是设置为8秒。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud组件的各种MaxTotalConnections详解</title>
    <url>/2020/04/29/springcloud/SpringCloud%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%84%E7%A7%8DMaxTotalConnections%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在zuul网关中，有关于配置连接数量的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">max-per-route-connections:</span> <span class="number">20</span> <span class="comment">#默认值</span></span><br><span class="line">    <span class="attr">max-total-connections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure>

<p>这个是只是的zuul调用静态路由配置的Http连接池数量，按照实际情况设置就好（请注意不要和Tomcat的maxConnections搞混了）。</p>
<p>这个配置并不会对基于Ribbon的下游服务访问生效，如果要配置Ribbon相关的配置，需要配置以下的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">MaxConnectionsPerHost:</span> <span class="number">50</span> <span class="comment">#默认值</span></span><br><span class="line">  <span class="attr">MaxTotalConnections:</span> <span class="number">200</span> <span class="comment">#默认值</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>还有Feign的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 默认值 </span></span><br><span class="line">      <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 默认值</span></span><br></pre></td></tr></table></figure>

<p>那么问题来了，在服务中既有Feign，又有Ribbon，那如果都配置了，是用哪一个配置？仔细的分析了一下，情况还比较复杂。</p>
<h1 id="zuul-host-max-per-route-connections"><a href="#zuul-host-max-per-route-connections" class="headerlink" title="zuul.host.max-per-route-connections"></a>zuul.host.max-per-route-connections</h1><p>刚才说这个配置和基于RIbbon调用服务没有什么关系，放个证据看一下，SimpleHostRoutingFilter是用于静态路由的具体请求处理类，这里面的初始化代码就是读取这个参数，并进行连接池的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleHostRoutingFilter.java</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!customHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.connectionManager = connectionManagerFactory.newConnectionManager(</span><br><span class="line">            !<span class="keyword">this</span>.sslHostnameValidationEnabled,</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxTotalConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getMaxPerRouteConnections(),</span><br><span class="line">            <span class="keyword">this</span>.hostProperties.getTimeToLive(), <span class="keyword">this</span>.hostProperties.getTimeUnit(),</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">this</span>.httpClient = newClient();</span><br><span class="line">      <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SimpleHostRoutingFilter.<span class="keyword">this</span>.connectionManager.closeExpiredConnections();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="number">30000</span>, <span class="number">5000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="服务里的Ribbon"><a href="#服务里的Ribbon" class="headerlink" title="服务里的Ribbon"></a>服务里的Ribbon</h2><p>先说在服务里只有Ribbon，并没有引入Feign的情况下，用RestTemplate发送请求，底层是通过SimpleBufferingClientHttpRequest发起实际http请求，用的是JDK原生的http。</p>
<p>所以在什么都不配置的情况下，上面的<code>ribbon.MaxConnectionsPerHost</code>配置是没有用的，而且我从这个源码看下来，像那些重试参数什么的，应该都没有用。他仅仅只是给RestTemplate赋予了负载均衡的功能，其他什么都没有控制。</p>
<p>在<code>RibbonClientConfiguration</code>类中，还额外Import了几个关于HttpClient的类，但是在默认情况下，都没什么用。</p>
<p>所以其实在服务里边，什么<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>，配置了以后，他只会去注册这些bean，不会被用到。自己搞的那个RestTemplate，用的就是spring默认的JDK 原生http组件。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于RestTemplate的方式使用Ribbon，在yaml里的大多数配置都不会生效，也没什么用。</p>
<h2 id="网关里的Ribbon"><a href="#网关里的Ribbon" class="headerlink" title="网关里的Ribbon"></a>网关里的Ribbon</h2><p>在网关里面，大有不同，我们先看ZuulProxyAutoConfiguration配置类，他引入了几个跟http组件有关的配置类，在这里<code>ribbon.okhttp.enable</code>，<code>ribbon.httpclient.enable</code>就能直接起作用了，他决定了加载哪一个具体的配置。在没有okhttpclient的情况下，默认就是使用apache的httpcomponents。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZuulProxyAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">      HttpClientConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonCommandFactoryConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnRibbonHttpClient</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;ZuulFallbackProvider&gt; zuulFallbackProviders = Collections.emptySet();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> RibbonCommandFactory&lt;?&gt; ribbonCommandFactory(</span><br><span class="line">      SpringClientFactory clientFactory, ZuulProperties zuulProperties) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommandFactory(clientFactory, zuulProperties, zuulFallbackProviders);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpClientRibbonCommandFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpClientRibbonCommand <span class="title">create</span><span class="params">(<span class="keyword">final</span> RibbonCommandContext context)</span> </span>&#123;</span><br><span class="line">  ZuulFallbackProvider zuulFallbackProvider = getFallbackProvider(context.getServiceId());</span><br><span class="line">  <span class="keyword">final</span> String serviceId = context.getServiceId();</span><br><span class="line">  <span class="comment">//  最终还是从ribbon管理的上下文中获取到一个RibbonLoadBalancingHttpClient。注意，SpringClientFactory里的bean基本都来自于RibbonClientConfiguration，看过Ribbon的源码就知道</span></span><br><span class="line">  <span class="keyword">final</span> RibbonLoadBalancingHttpClient client = <span class="keyword">this</span>.clientFactory.getClient(</span><br><span class="line">      serviceId, RibbonLoadBalancingHttpClient.class);</span><br><span class="line">  client.setLoadBalancer(<span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId));</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpClientRibbonCommand(serviceId, client, context, zuulProperties, zuulFallbackProvider,</span><br><span class="line">      clientFactory.getClientConfig(serviceId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，Ribbon本身也会对<code>RibbonClientConfiguration</code>配置类也进行初始化，一样的，他也引入了几个Http组件，和上面不同的是，zuul的几个配置类，主要是为了封装Hystrix的逻辑，实际上最终还是调用的<code>RibbonLoadBalancingHttpClient</code>执行请求。所以我们接下来去看<code>RibbonClientConfiguration</code>的配置，以及<code>RibbonLoadBalancingHttpClient</code>是如何被注册的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 各种http组件支持，默认是加载最后一个</span></span><br><span class="line"><span class="meta">@Import(&#123;HttpClientConfiguration.class, OkHttpRibbonConfiguration.class, RestClientRibbonConfiguration.class, HttpClientRibbonConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HttpClientRibbonConfiguration.java</span></span><br><span class="line"><span class="comment">// 在zuul中，httpcomponents已经被自动引入了</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.apache.http.client.HttpClient&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;ribbon.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientRibbonConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个配置被RibbonClientConfiguration一起被加载，可通过@RibbonClient注解的configuration属性覆盖</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">httpClientConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 终于在这里找到了读取MaxTotalConnections等配置的代码</span></span><br><span class="line">     Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">     Integer maxConnectionsPerHost = config.getPropertyAsInteger(</span><br><span class="line">           CommonClientConfigKey.MaxConnectionsPerHost,</span><br><span class="line">           DefaultClientConfigImpl.DEFAULT_MAX_CONNECTIONS_PER_HOST);</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里声明了一个基于Apache的httpClient的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">(ApacheHttpClientFactory httpClientFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpClientConnectionManager connectionManager, IClientConfig config)</span> </span>&#123;</span><br><span class="line">    Boolean followRedirects = config.getPropertyAsBoolean(</span><br><span class="line">        CommonClientConfigKey.FollowRedirects,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_FOLLOW_REDIRECTS);</span><br><span class="line">    Integer connectTimeout = config.getPropertyAsInteger(</span><br><span class="line">        CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">        DefaultClientConfigImpl.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    RequestConfig defaultRequestConfig = RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(connectTimeout)</span><br><span class="line">        .setRedirectsEnabled(followRedirects).build();</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClientFactory.createBuilder().</span><br><span class="line">        setDefaultRequestConfig(defaultRequestConfig).</span><br><span class="line">        setConnectionManager(connectionManager).build();</span><br><span class="line">    <span class="keyword">return</span> httpClient;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 划重点。。。终于在这里发现了RibbonLoadBalancingHttpClient的声明，并且MaxTotalConnections等属性在上面的代码已经被注册了。</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass(value = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RibbonLoadBalancingHttpClient <span class="title">ribbonLoadBalancingHttpClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		IClientConfig config, ServerIntrospector serverIntrospector,</span></span></span><br><span class="line"><span class="function"><span class="params">		ILoadBalancer loadBalancer, RetryHandler retryHandler, CloseableHttpClient httpClient)</span> </span>&#123;</span><br><span class="line">		RibbonLoadBalancingHttpClient client = <span class="keyword">new</span> RibbonLoadBalancingHttpClient(httpClient, config, serverIntrospector);</span><br><span class="line">		client.setLoadBalancer(loadBalancer);</span><br><span class="line">		client.setRetryHandler(retryHandler);</span><br><span class="line">		Monitors.registerObject(<span class="string">&quot;Client_&quot;</span> + <span class="keyword">this</span>.name, client);</span><br><span class="line">		<span class="keyword">return</span> client;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在网关打断点测试了一下，请求确实是通过RibbonLoadBalancingHttpClient执行的。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>基于网关使用Ribbon，会读取<code>ribbon.MaxTotalConnections</code>和<code>ribbon.MaxConnectionsPerHost</code>等配置，并给予HTTPComponents组件进行访问。</p>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>那么Fiegn的配置在什么时候生效？情况又有变化了，Feign同样有一个配置类<code>FeignRibbonClientAutoConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>在默认没有额外配置的情况下，是读取的<code>DefaultFeignLoadBalancedConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="comment">// Client.Default就基于JDK的http组件完成了http的请求，底层没有连接池</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>),</span><br><span class="line">            cachingFactory, clientFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Feign在默认情况下使用的是JDK原生的<code>URLConnection</code>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的<code>persistence connection</code> 。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在默认情况下，也就是不开启<code>feign.okhttp.enable</code>和<code>feign.httpclient.enable</code>的时候，feign的<code>feign.max-connections</code>配置，也是没有什么用的。</p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>在开启<code>feign.httpclient.enable</code>以后，HttpClientFeignLoadBalancedConfiguration会被加载。这里得加个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign-httpclient&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和Ribbon一样，Feign也定义了自己的HttpClient等组件，在定义过程中，读取了配置并利用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">connectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        FeignHttpClientProperties httpClientProperties)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在这里读取了feign相关的MaxConnectionsPerRoute和MaxConnections配置</span></span><br><span class="line">     <span class="keyword">final</span> HttpClientConnectionManager connectionManager = connectionManagerFactory</span><br><span class="line">           .newConnectionManager(httpClientProperties.isDisableSslValidation(), httpClientProperties.getMaxConnections(),</span><br><span class="line">                 httpClientProperties.getMaxConnectionsPerRoute(),</span><br><span class="line">                 httpClientProperties.getTimeToLive(),</span><br><span class="line">                 httpClientProperties.getTimeToLiveUnit(), registryBuilder);</span><br><span class="line">     <span class="keyword">this</span>.connectionManagerTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           connectionManager.closeExpiredConnections();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="number">30000</span>, httpClientProperties.getConnectionTimerRepeat());</span><br><span class="line">     <span class="keyword">return</span> connectionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(Client.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                SpringClientFactory clientFactory, HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    ApacheHttpClient delegate = <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/spring-cloud/image-20200429174359246.png" alt="image-20200429174359246"></p>
<p>经过打了断点测试和验证， 确实在这里加载到了连接池的配置。请求也是通过ApacheHttpClient发送的。</p>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>在引入了feign-httpclient的包以后，feign才会启用<code>feign.max-connections</code>等连接池的配置。那么Ribbon之前的配置呢，在使用Feign的时候，Ribbon的那些Http相关的Bean就没有用了，不会被用到。</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>和上面一样，不过OkHttp只会读取MaxTotalConnections属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(ConnectionPool.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionPool <span class="title">httpClientConnectionPool</span><span class="params">(IClientConfig config, OkHttpClientConnectionPoolFactory connectionPoolFactory)</span> </span>&#123;</span><br><span class="line">   Integer maxTotalConnections = config.getPropertyAsInteger(</span><br><span class="line">         CommonClientConfigKey.MaxTotalConnections,</span><br><span class="line">         DefaultClientConfigImpl.DEFAULT_MAX_TOTAL_CONNECTIONS);</span><br><span class="line">   Object timeToLiveObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTime);</span><br><span class="line">   Long timeToLive = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME;</span><br><span class="line">   Object ttlUnitObj = config</span><br><span class="line">         .getProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits);</span><br><span class="line">   TimeUnit ttlUnit = DefaultClientConfigImpl.DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;</span><br><span class="line">   <span class="keyword">if</span> (timeToLiveObj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">      timeToLive = (Long) timeToLiveObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ttlUnitObj <span class="keyword">instanceof</span> TimeUnit) &#123;</span><br><span class="line">      ttlUnit = (TimeUnit) ttlUnitObj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于这个值应该怎么设置，大家根据自己的项目情况来设置，其实就是访问其他服务的Http连接池数量，不要设置的过于夸张了，有些人可能会跟Tomcat的maxconnections搞混了，甚至配个几千上万的，虽然名字一样，但是含义却不同。SpringBoot给我们设置的默认值，也是有参考意义的，在实际项目中，大家可以根据压测情况进行调整。</p>
<h1 id="Tomcat-maxConnections"><a href="#Tomcat-maxConnections" class="headerlink" title="Tomcat:maxConnections"></a>Tomcat:maxConnections</h1><p>关于Tomcat这个参数的详细解释，可以看这个博客：<a href="https://blog.csdn.net/zzzgd_666/article/details/88740198%E3%80%82">https://blog.csdn.net/zzzgd_666/article/details/88740198。</a></p>
<p>大概说一下，Tomcat有Nio、Bio、APR三种运行模式，maxConnections是Tomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为-1，则连接数不受限制。</p>
<p>默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</p>
<p>在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。</p>
<p>maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，maxConnections值应该远大于maxThreads。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码01-eureka启动流程</title>
    <url>/2020/03/15/springcloud/eureka01/</url>
    <content><![CDATA[<h1 id="如何阅读一个开源框架的源码"><a href="#如何阅读一个开源框架的源码" class="headerlink" title="如何阅读一个开源框架的源码"></a>如何阅读一个开源框架的源码</h1><p>如果要阅读一个开源框架的源码，我们应该从什么地方入手。首先应该想到的是，从框架启动的入口入手，比如Eureka，肯定是从Eureka服务本身启动的入口开始。或者我们也可以从框架的单元测试开始看，因为单元测试都包含了框架的核心流程和功能。所以我们通过这2个入口，可以通过打断点执行的方式阅读代码的逻辑。下面我将开始学习Eureka的源码，我将基于<a href="https://github.com/Netflix/eureka.git">https://github.com/Netflix/eureka.git</a> 的v1.7.2分支进行阅读，因为我目前所用的SpringCloud引入的就是这个版本。</p>
<a id="more"></a>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>IDE选用idea2018版本进行阅读，为什么选2018版本，eureka的源码是基于gradle构建的，v1.7.2的分支是基于2.10的gradle版本，这个现在已经比较旧了，在JDK10以上的版本，无法运行，而dea2019已经开始用JDK11开始运行，具体情况可以看这篇文章，<a href="https://blog.csdn.net/jiajane/article/details/103014036">https://blog.csdn.net/jiajane/article/details/103014036</a>，是类似的问题。经过一番倒腾我最终也没有能在2019版本上加载依赖，所以我还是选择了2018版本开始源码的阅读，使用上没有区别。</p>
<p>先看下Eureka的核心流程，核心功能包括：</p>
<ul>
<li>服务注册</li>
<li>服务发现</li>
<li>client向server发送心跳</li>
<li>client向server获取服务注册表</li>
<li>服务实例摘除</li>
<li>自我保护机制</li>
<li>通信</li>
</ul>
<p>下面将从源码找到eureka的启动类，并作为入口进行源码分析。</p>
<h1 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h1><p>eureka-server依赖了eureka-client和eureka-core2个模块，server又当服务器，又当作客户端，因为在集群模式下，他们也会相互注册。注册中心相关核心的代码都在eureka-core模块里，也能看出来eureka是基于jersey（类似spring mvc)开发的接口，和客户端http请求，在服务之间相互通信。</p>
<p><img src="/img/spring-cloud/image-20200315153312195.png" alt="image-20200315153312195"  /><img src="/img/spring-cloud/image-20200315153257597.png" alt="image-20200315153257597"  /></p>
<p>然后eureka-resources里，其实就是一些css、js和jsp文件。</p>
<img src="/img/spring-cloud/image-20200315153346879.png" alt="image-20200315153346879"  />

<p>那么eureka-server本质上其实就是一个web应用，并且在eureka-server里发现还有一个web.xml文件，所以我们应该重点分析下<code>web.xml</code>文件，里面包含了一些listener和filter，这些类应该都是我们要重点看一下的源码，先猜一下这几个类都是干什么的。</p>
<ul>
<li>com.netflix.eureka.EurekaBootStrap（初始化逻辑？）</li>
<li>com.netflix.eureka.StatusFilter（状态管理？）</li>
<li>com.netflix.eureka.ServerRequestAuthFilter（授权认证相关？）</li>
<li>com.netflix.eureka.RateLimitingFilter（限流控制？）</li>
<li>com.netflix.eureka.GzipEncodingEnforcingFilter（压缩和编码相关？）</li>
<li>com.sun.jersey.spi.container.servlet.ServletContainer（jersey框架初始化加载类，类似Spring MVC的DispatcherServlet）</li>
</ul>
<p>文件下面的filter-mapping里默认没有开启限流的过滤器，Gzip也只过滤<code>/v2/apps</code>路径下的请求。</p>
<h2 id="EurekaBootStrap（启动类，重要）"><a href="#EurekaBootStrap（启动类，重要）" class="headerlink" title="EurekaBootStrap（启动类，重要）"></a>EurekaBootStrap（启动类，重要）</h2><p>这个类在eureka-core里，监听器要关注<code>contextInitialized</code>方法，这里就是eureka-server启动，初始化的入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initEurekaEnvironment();</span><br><span class="line">    initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">    ServletContext sc = event.getServletContext();</span><br><span class="line">    sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Cannot bootstrap eureka server :&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot bootstrap eureka server :&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initEurekaEnvironment"><a href="#initEurekaEnvironment" class="headerlink" title="initEurekaEnvironment"></a>initEurekaEnvironment</h3><ol>
<li>在initEurekaEnvironment中，ConfigurationManager.getConfigInstance()初始化ConcurrentCompositeConfiguration实例，基于<strong>双检锁单例模式</strong>的配置管理器，管理eureka的所有配置，。</li>
<li>初始化dataCenter，数据中心的配置，如果没有配置的话，就给个默认的（default）。</li>
<li>初始化eureka.environment，默认是test环境。</li>
</ol>
<h3 id="initEurekaServerContext"><a href="#initEurekaServerContext" class="headerlink" title="initEurekaServerContext"></a>initEurekaServerContext</h3><h4 id="加载eureka-server-properties文件中的配置"><a href="#加载eureka-server-properties文件中的配置" class="headerlink" title="加载eureka-server.properties文件中的配置"></a>加载eureka-server.properties文件中的配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String eurekaPropsFile &#x3D; EUREKA_PROPS_FILE.get();</span><br></pre></td></tr></table></figure>

<p>DefaultEurekaServerConfig的init方法中，加载了一个properties文件，文件名默认叫eureka-server.properties（<code>EUREKA_PROPS_FILE</code>变量），通过ConfigurationManager加载到内存中，然后EurekaServerConfig的方法，再用configInstance获取对应的值。EurekaServerConfig是个接口，有很多get方法，包含了eureka server需要的所有配置，都可以通过这个接口获取。通过接口，对properties文件里的配置项进行了封装，增加了代码的可读性，不像我们自己可能做的有些项目里，读取配置文件都是去调用get某个key。</p>
<p>在DefaultEurekaServerConfig的方法中，也能看到大量的硬编码配置项和默认值。</p>
<h4 id="初始化ApplicationInfoManager"><a href="#初始化ApplicationInfoManager" class="headerlink" title="初始化ApplicationInfoManager"></a>初始化ApplicationInfoManager</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">  ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">  : <span class="keyword">new</span> MyDataCenterInstanceConfig();</span><br><span class="line"></span><br><span class="line">applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</span><br><span class="line">  instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</span><br></pre></td></tr></table></figure>

<p>查看ApplicationInfoManager的javadoc说明，这个类用来初始化服务注册和被其他服务发现的一些配置，其中配置通过EurekaInstanceConfig设置，从MyDataCenterInstanceConfig的父类的构造方法可以看到，其实也是读取的eureka-client.properties文件加载的。和<code>DefaultEurekaServerConfig</code>一样<code>EurekaInstanceConfig</code>也是提供了一些方法，实际是从配置文件读取，同时也提供了默认值。</p>
<p><code>new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get()</code>方法返回了InstanceInfo。InstanceInfo是服务实例本身的信息，用<strong>构造器模式</strong><code>InstanceInfo.Builder.newBuilder()</code>构造了一个<code>InstanceInfo.Builder</code>实例，从instanceConfig里获取了大量配置，再加创建的几个类完成了构造。</p>
<p>最后，EurekaInstanceConfig和InstnaceInfo，构造了ApplicationInfoManager，作为服务实例的一个管理器。</p>
<h4 id="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"><a href="#初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）" class="headerlink" title="初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）"></a>初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点注册和通信的）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br></pre></td></tr></table></figure>

<p>DefaultEurekaClientConfig一样也是面向接口的配置项读取方式，也同样是读取了eureka-client.properties配置，不过它只读取了eureka开头的配置项，在DefaultEurekaTransportConfig里可看到，包含了很多client相关的配置项。<strong>EurekaClientConfig</strong>配置，和前面构建好的<strong>ApplicationInfoManager</strong>（包含了服务的实例信息、配置，作为服务实例管理的一个组件）构建了eurekaClient的子类DiscoveryClient。</p>
<p>DiscoveryClient我们可以看一下构造方法，初始化了很多东西，重点处理：</p>
<ol>
<li>是否需要拉取注册信息，shouldRegisterWithEureka</li>
<li>是否要注册自己，shouldRegisterWithEureka</li>
<li>初始化调度线程池，scheduler</li>
<li>初始化心跳线程池，heartbeatExecutor</li>
<li>初始化缓存刷新的线程池，cacheRefreshExecutor</li>
<li>new EurekaTransport()，支持底层eureka client和eureka server通信的一些初始化。</li>
<li>如果要抓取注册表，则抓取注册表表，fetchRegistryFromBackup();</li>
<li>初始化调度任务，initScheduledTasks(); 定时抓取注册表、心跳。初始化服务实例副本传播器（instanceInfoReplicator），服务实例状态变更监听器（statusChangeListener）。</li>
</ol>
<h4 id="处理注册相关的事情"><a href="#处理注册相关的事情" class="headerlink" title="处理注册相关的事情"></a>处理注册相关的事情</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        eurekaClient</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>通过javadoc看下PeerAwareInstanceRegistryImpl是干什么用的：将所有操作复制到集群里对等的Eureka节点，以使它们保持同步。复制的主要操作是Registers,Renewals,Cancels,Expirations 和 Status Changes。</p>
<h4 id="处理peer节点相关的事情"><a href="#处理peer节点相关的事情" class="headerlink" title="处理peer节点相关的事情"></a>处理peer节点相关的事情</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">        registry,</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        eurekaClient.getEurekaClientConfig(),</span><br><span class="line">        serverCodecs,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>初始化Eureka集群的信息，PeerEurekaNode包含了每个节点自己分享给其他节点的信息。</p>
<h4 id="完成eureka-server上下文（context）的构建以及初始化"><a href="#完成eureka-server上下文（context）的构建以及初始化" class="headerlink" title="完成eureka-server上下文（context）的构建以及初始化"></a>完成eureka-server上下文（context）的构建以及初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</span><br><span class="line">        eurekaServerConfig,</span><br><span class="line">        serverCodecs,</span><br><span class="line">        registry,</span><br><span class="line">        peerEurekaNodes,</span><br><span class="line">        applicationInfoManager</span><br><span class="line">);</span><br><span class="line">EurekaServerContextHolder.initialize(serverContext);</span><br></pre></td></tr></table></figure>

<p>serverContext.initialize方法中调用了peerEurekaNodes.start();，定时当前的eureka server同步集群里其他eureka server的一些信息。</p>
<p>registry.init(peerEurekaNodes);</p>
<p>用从集群获取的到的信息，初始化本实例的注册表。其实就是和集群之间的信息同步，这个研究这块的时候再细看。</p>
<h4 id="从相邻的eureka节点拷贝注册信息"><a href="#从相邻的eureka节点拷贝注册信息" class="headerlink" title="从相邻的eureka节点拷贝注册信息"></a>从相邻的eureka节点拷贝注册信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</span><br></pre></td></tr></table></figure>

<p>看syncUp的javadoc，从一个节点拷贝注册信息，如果失败就换个节点。细节后面再看。</p>
<h4 id="处理监控统计项"><a href="#处理监控统计项" class="headerlink" title="处理监控统计项"></a>处理监控统计项</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EurekaMonitors.registerAllStats();</span><br></pre></td></tr></table></figure>

<p>注册一些监控和统计。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>启动流程，到这里就结束了，我们总结一下，源码里用了不少设计模式和优秀的实现机制，例如基于双检锁的单例模式、构建器模式，面向接口的配置读取等，这都是我们值得去学习的。</p>
<p>![eureka server启动流程图](/img/spring-cloud/eureka server启动流程图.jpg)</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码02-服务注册流程分析</title>
    <url>/2020/03/18/springcloud/eureka02/</url>
    <content><![CDATA[<h1 id="eureka-client启动流程"><a href="#eureka-client启动流程" class="headerlink" title="eureka client启动流程"></a>eureka client启动流程</h1><p>上一篇文章，我们分析了eureka server的启动流程，这一篇来分析一下eureka client的启动流程。我们先要找到启动入口在哪里。在eureka-examples里，有一个ExampleEurekaClient的测试类。要执行这个类，首先需要复制一段代码，设置一些基础属性，这是从eureka-server的单元测试里复制过来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This will be read by server internal discovery client. We need to salience it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEurekaConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">  String myHostName = InetAddress.getLocalHost().getHostName();</span><br><span class="line">  String myServiceUrl = <span class="string">&quot;http://&quot;</span> + myHostName + <span class="string">&quot;:8080/v2/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.region&quot;</span>, <span class="string">&quot;default&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.name&quot;</span>, <span class="string">&quot;eureka&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.vipAddress&quot;</span>, <span class="string">&quot;eureka.mydomain.net&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.port&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.preferSameZone&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.shouldUseDns&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.shouldFetchRegistry&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.serviceUrl.defaultZone&quot;</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.serviceUrl.default.defaultZone&quot;</span>, myServiceUrl);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.awsAccessId&quot;</span>, <span class="string">&quot;fake_aws_access_id&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.awsSecretKey&quot;</span>, <span class="string">&quot;fake_aws_secret_key&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;eureka.numberRegistrySyncRetries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在main方法的第一行调用一下上面的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    injectEurekaConfiguration();</span><br><span class="line">    ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the client</span></span><br><span class="line">    ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">    EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the client</span></span><br><span class="line">    sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown the client</span></span><br><span class="line">    eurekaClient.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下上面这个方法，这段逻辑几乎和上一篇文章中介绍的eureka server启动流程中，初始化eureka client逻辑的是一样的。</p>
<ol>
<li>读取eureka-client.properties配置文件，形成服务实例配置，基于接口对外提供服务实例配置项的读取。（MyDataCenterInstanceConfig）</li>
<li>基于服务实例配置，构造服务实例（InstanceInfo）</li>
<li>基于eureka client配置和服务实例，构造服务实例管理器（ApplicationInfoManager）</li>
<li>读取eureka-client.properties配置文件，形成一个eureka client的配置，基于接口对外提供eureka client配置项读取（DefaultEurekaClientConfig）。</li>
<li>基于eureka client配置，和服务实例管理器构造了一个EurekaClient（DiscoveryClient），保存了一些配置，处理服务的注册和注册表的抓取，启动了几个线程池，启动了网络通信组件，启动了一些调度任务，注册了监控项。</li>
</ol>
<p>在DiscoveryClient的构造方法里，做了很多操作，具体可以看下图。</p>
<h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p>![eureka client启动流程](/img/spring-cloud/eureka client启动流程.jpg)</p>
<h1 id="eureka-client服务注册逻辑"><a href="#eureka-client服务注册逻辑" class="headerlink" title="eureka client服务注册逻辑"></a>eureka client服务注册逻辑</h1><p>上面的逻辑咱们理完了后，发现不知道服务注册是哪一个步骤完成的，实际上注册的逻辑，是在初始化调度任务那里，和心跳任务一起初始化的<code>InstanceInfoReplicator</code>任务里。<strong>这儿其实感觉比较奇怪，注册服务和实例信息复制，在我们常见的分布式系统里应该是不同的概念，比如redis、mongodb、elastic search里都有副本的概念（Replica），但是在eureka这里，这里面实际上却是注册服务的逻辑。</strong></p>
<ol>
<li><code>InstanceInfoReplicator</code>的start方法里，将自己作为一个线程放到一个调度线程池中去了，默认</li>
</ol>
<p>是延迟40秒执行。</p>
<ol start="2">
<li><p>那么执行线程的时候，是执行run()方法。</p>
</li>
<li><p>在run方法里，刷新了一下服务实例的信息discoveryClient.refreshInstanceInfo();，里面其实是调用ApplicationInfoManager的一些方法刷新了服务实例的配置，看看配置有没有改变，如果改变了，就刷新一下；用健康检查器检查状态，将状态设置到了ApplicationInfoManager中，更新服务实例状态。</p>
</li>
<li><p>然后调用discoveryClient.register();进行服务注册。</p>
</li>
<li><p>服务注册的时候，是基于EurekaClient的register()方法去注册的，调用的是底层的eurekaTransport的registrationClient，将InstanceInfo服务实例的信息，通过http请求，调用eureka server对外暴露的一个restful接口，将InstanceInfo发送过去。注意：EurekaTransport在构造的下一行代码的时候，调用了<strong>scheduleServerEndpointTask</strong>（一个令人迷惑的方法名），其实这个方法里就初始化了专门用于注册的registrationClient。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line"><span class="comment">// 其实是初始化eurekaTransport</span></span><br><span class="line">scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line">......</span><br><span class="line">httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后实际上底层执行发送请求的逻辑，实在是非常难找，代码嵌套过多，最后在EurekaHttpClient的子类里，寻找和http库有关的类，我们找到了AbstractJersey2EurekaHttpClient，在这里的<code>register</code>方法，发现了实际发送注册请求的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送请求，http://localhost:8080/v2/apps/ServiceA</span></span><br><span class="line"><span class="comment">// 发送的是post请求，服务实例的对象打成了一个json发送过去，包含了自己的主机，ip，端口号</span></span><br><span class="line"><span class="comment">// eureka server就知道这个ServiceA这个服务，有一个服务实例，比如是在172.16.21.33、dev-server、8080</span></span><br><span class="line">Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>eureka client在服务注册的这块代码，可以也是看到有用到工厂模式、装饰器模式，但是也有很多<strong>槽点</strong>：</p>
<ol>
<li>服务注册，不应该放在<code>InstanceInfoReplicator</code>中，语意不明朗。</li>
<li>负责发送请求的HttpClient，类体系过于<strong>复杂</strong>，导致看代码的人根本找不到对应的client，最后是根据顶层接口(EurekaHttpClient)和项目依赖实际是使用jersey框架来进行restful接口暴露和调用，才找到真正发送服务注册请求的地方(AbstractJersey2EurekaHttpClient)。</li>
</ol>
<h1 id="eureka-server收到注册请求的处理"><a href="#eureka-server收到注册请求的处理" class="headerlink" title="eureka server收到注册请求的处理"></a>eureka server收到注册请求的处理</h1><p>上面分析到了，eureka client向eureka server发起了http请求进行注册，下面就看一下在eureka server中，是如何接收并处理注册请求的。</p>
<p>因为eureka是基于jersey开发，所以我们去找/v2/apps/{appId}这样的post请求路径处理类，这个请求是在eureka-core模块中<code>ApplicationsResource</code>的<code>getApplicationResource</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;&#123;appId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@PathParam(&quot;version&quot;)</span> String version,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@PathParam(&quot;appId&quot;)</span> String appId)</span> </span>&#123;</span><br><span class="line">  CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到ApplicationResource里去找处理post的方法，就找到了接收注册请求的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="meta">@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication)</span> </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>接收的是InstanceInfo，代表了一个服务实例。</p>
<p>在单元测试里，有一个ApplicationResourceTest类，包含了许多功能的测试。接下来，在ApplicationResourceTest里，用断点的方式执行testGoodRegistration方法，对注册流程进行调试和源码分析。</p>
<p><img src="/img/spring-cloud/image-20200319222757757.png" alt="image-20200319222757757"></p>
<p>InstanceInfo主要包含2部分数据：</p>
<ol>
<li>主机名、ip地址、端口号、url地址</li>
<li>lease（租约）的信息：保持心跳的间隔时间，最近心跳的时间，服务注册的时间，服务启动的时间。</li>
</ol>
<p>register逻辑：</p>
<ol>
<li><p>检查了一些必要的参数</p>
</li>
<li><p>判断是否是在AWS数据中心，做额外的操作</p>
</li>
<li><p>调用registry.register(info, “true”.equals(isReplication));（PeerAwareInstanceRegistry）。向服务实例注册表里注册。</p>
</li>
<li><p>调用<a href="http://www.saily.top/2020/03/15/springcloud/eureka01/#%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E6%83%85">PeerAwareInstanceRegistry</a>父类的register方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    read.lock();</span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">    REGISTER.increment(isReplication);</span><br><span class="line">    <span class="comment">// 如果是第一次注册，这个map肯定是null</span></span><br><span class="line">    <span class="comment">// 对Map进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">      <span class="comment">// 一个服务会有多个实例，所以这样存</span></span><br><span class="line">      gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">      <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        gMap = gNewMap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次执行，这里肯定也是null</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">    ......省略部分代码</span><br><span class="line">    <span class="comment">// 如果是服务第一次注册，将服务实例信息放到map中</span></span><br><span class="line">    Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">    <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">    gMap.put(registrant.getId(), lease);</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>这里的registry，他的数据结构里面就是保存的服务和实例信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;APP_A&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;00000&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;00001&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;00002&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;APP_B&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;10000&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line"> <span class="attr">&quot;20001&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">    <span class="attr">&quot;30002&quot;</span>:Lease&lt;InstanceInfo&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将服务实例的服务名和实例ID访问一个队列中（recentRegisteredQueue）</p>
</li>
<li><p>再后面也是更新一些状态。</p>
</li>
</ol>
<p><strong>所以服务注册，最终数据就是服务实例信息放在了一个内存的注册表中：<code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</code>。</strong></p>
<p>注册这里包含了一个读写锁的应用，ReentrantReadWriteLock，在这里注册的时候，上的是读锁，多个服务实例，可以同时注册。灵活运用读写锁，可以控制多线程的并发，有些操作是可以并发执行的，有些操作的互斥的。</p>
<h2 id="画图总结-1"><a href="#画图总结-1" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/image-20200319232127915.png" alt="image-20200319232127915"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码03-服务列表同步分析</title>
    <url>/2020/03/21/springcloud/eureka03/</url>
    <content><![CDATA[<h1 id="eureka-client全量抓取注册表"><a href="#eureka-client全量抓取注册表" class="headerlink" title="eureka client全量抓取注册表"></a>eureka client全量抓取注册表</h1><p>eureka client第一次启动的时候，会从eureka server端抓取全量的注册表，在本地进行缓存。后续每隔30秒从eureka server端抓取增量的注册表信息，和本地缓存进行合并。</p>
<p>先找到第一次抓取全量注册表的源码，没记错的话应该是在创建DiscoveryClient的构造方法里。就是下面这几行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">  fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这个fetchRegistry方法，就是抓取注册表的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DiscoveryClient.fetchRegistry()</span></span><br><span class="line"><span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line"><span class="comment">// applications</span></span><br><span class="line"><span class="comment">// 本地的Application缓存，在执行完成后续的全量注册表拉取后，也会将数据缓存到这个地方</span></span><br><span class="line">Applications applications = getApplications();</span><br><span class="line"><span class="keyword">if</span> 一大堆条件 &#123;</span><br><span class="line">  <span class="comment">// localRegionApps.set(this.filterAndShuffle(apps));</span></span><br><span class="line">  <span class="comment">// 用jeresy从server端获取全量注册表，然后缓存到本地（也就是上方的getApplications()）</span></span><br><span class="line">  getAndStoreFullRegistry();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 增量</span></span><br><span class="line">  getAndUpdateDelta(applications);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="eureka-server端处理抓取注册表的请求（多级缓存机制）"><a href="#eureka-server端处理抓取注册表的请求（多级缓存机制）" class="headerlink" title="eureka server端处理抓取注册表的请求（多级缓存机制）"></a>eureka server端处理抓取注册表的请求（多级缓存机制）</h1><p>根据客户端请求的接口（GET ip:port/v2/apps），去服务端找对应的处理方法。是在ApplicationsResource.getContainers方法。</p>
<p>eureka server端，有一套多级缓存的机制，这里的cacheKey，就是缓存用的Key，然后下面就是从缓存读取数据的逻辑，注意这里的key是ALL_APPS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">                       ResponseCacheImpl.ALL_APPS,</span><br><span class="line">                       keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">);</span><br><span class="line">Response response;</span><br><span class="line"><span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">  response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">    .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">    .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response = Response.ok(responseCache.get(cacheKey))</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eureka server的缓存，是基于ResponseCache这样的一个接口开发的。实现类是ResponseCacheImpl，看下它的get方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line">String get(final Key key, boolean useReadOnlyCache) &#123;</span><br><span class="line">    Value payload &#x3D; getValue(key, useReadOnlyCache);</span><br><span class="line">    if (payload &#x3D;&#x3D; null || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return payload.getPayload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的条件useReadOnlyCache，是通过配置读取的。再跟进去看看源码，getValue方法里，看到有了2个map，做了两级缓存，分别是readOnlyCacheMap和readWriteCacheMap，readWriteCacheMap是基于Guava Cache封装的一个缓存，程序先从只读缓存里去读，如果没有的话，会从读写缓存里去读，还是没有的话，才会从registry的map里读。实际上在ResponseCacheImpl的构造方法里，就包含了readWriteCacheMap数据初始化的逻辑。</p>
<blockquote>
<p>generatePayload方法中，从注册表中获取所有的Applications，通过ServerCodecs组件，将Applications对象序列化成一个json字符串，然后放入读写缓存（readWriteCacheMap）。接着，放入只读缓存中（readOnlyCacheMap）。</p>
</blockquote>
<p><img src="/img/spring-cloud/image-20200322172453943.png" alt="image-20200322172453943"></p>
<h2 id="多级缓存过期机制"><a href="#多级缓存过期机制" class="headerlink" title="多级缓存过期机制"></a>多级缓存过期机制</h2><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>有新的服务实例发生注册、下线、故障的时候，会刷新readWriteCacheMap。PeerAwareInstanceRegistryImpl的javadoc，说这个类会同步一些状态变化到其他节点，同时我们也看他也维护了注册表信息，并且注册的register方法也是在这里面，我们在register方法里，找到invalidateCache代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invalidate cache</span></span><br><span class="line">responseCache.invalidate(appName, vipAddress, secureVipAddress);</span><br></pre></td></tr></table></figure>

<p>这不就是调用responseCache的主动过期方法吗？之前注册的时候看不懂的逻辑，现在一切都明了。借助IDEA的快捷键，在invalidateCache方法上按<code>option + F7</code>，还能找到所有调用的方法，分别是：register、internalCancel、statusUpdate、deleteStatusOverride。</p>
<h3 id="定时过期"><a href="#定时过期" class="headerlink" title="定时过期"></a>定时过期</h3><p>被动过期在初始化缓存的时候就已经设置了过期属性，<code>.expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</code>，默认值是180秒。</p>
<h3 id="被动过期"><a href="#被动过期" class="headerlink" title="被动过期"></a>被动过期</h3><p>readOnlyCacheMap是在初始化的时候，设置了一个定时器，默认每隔30从readWriteCacheMap里对数据进行比对，如果数据不一致，就同步数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以说有服务注册、故障或者下线了，因为缓存的原因，其他客户端可能要30秒才能感知到。</p>
<h1 id="增量抓取注册表"><a href="#增量抓取注册表" class="headerlink" title="增量抓取注册表"></a>增量抓取注册表</h1><p>上面有说到，在eureka client初始化的时候，会全量的抓取一次注册表，然后在initScheduledTasks里启动了一个定时任务，每隔30秒会定时增量同步一次注册表的信息，具体的执行类叫做<code>CacheRefreshThread</code>。</p>
<ol>
<li>定时任务，30秒一次</li>
<li>因为本地有缓存的Applications，所以走增量抓取的逻辑</li>
<li>走eurekaHttpClient的getDelta接口，<code>GET apps/delta</code></li>
<li>ApplicationsResources.getContainerDifferential处理增量请求</li>
<li>一样是走多级缓存机制，key是ALL_APPS_DELTA。后面就是一样了，唯一的区别就是因为key不一样，所以在generatePayload方法里，执行的逻辑不一样，这里不再用registry.getApplications()获取全量数据，而是用registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));获取增量的注册表信息。</li>
<li>这儿有个recentlyChangedQueue，在状态变化的时候会往里边放数据，代表着最近有变化的服务实例，增量信息就是从这里边去抓取。在Registry初始化的时候有个定时任务，每隔30秒检查一次，这个队列里面的服务实例变更信息是否已经超过180秒了，如果超过会移除。所以这个队列里保留的其实是最近3分钟的服务实例变更数据。</li>
<li>eureka client每隔30秒，去抓取增量注册表的时候，会拿到最近3分钟内有变化的服务实例的注册表。</li>
<li>抓取到的注册表和本地缓存的注册表进行合并，完成服务实例的增删改。updateDelta(delta);</li>
<li>对合并后的注册表计算一个hash值，之前返回的delta带了一个eureka server全量注册表的hash值。对这2个值进行对比，如果不一致，此时会从eureka server抓取全量的注册表到本地。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/img/spring-cloud/image-20200322183205931.png" alt="image-20200322183205931"></p>
<h3 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h3><ol>
<li>如果要保存增量的最新数据变更，可以基于LinkedQueue将最新变更的数据放入这个queue中，然后用定时任务在队列超过一定时间的数据移除，保持这个队列中就是最近几分钟内变更的增量数据。</li>
<li>数据同步的hash值对：如果在分布式系统里，在不同的地方进行数据的同步，可以采用hash值的思想，从一个地方计算一个hash值，在另外一个地方也计算一个hash值，保证两个hash值是一样的，这样可以保证数据的准确性。 </li>
</ol>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码05-服务集群初始化和同步原理分析</title>
    <url>/2020/03/28/springcloud/eureka05/</url>
    <content><![CDATA[<h1 id="eureka-server集群相关源码分析"><a href="#eureka-server集群相关源码分析" class="headerlink" title="eureka server集群相关源码分析"></a>eureka server集群相关源码分析</h1><p>前面的文章分别介绍了服务启动、注册、下线、故障和自我保护机制等原理，这里就开始介绍集群相关的东西。</p>
<p><img src="/img/spring-cloud/image-20200329222305903.png" alt="image-20200329222305903"></p>
<a id="more"></a>
<h2 id="集群信息初始化"><a href="#集群信息初始化" class="headerlink" title="集群信息初始化"></a>集群信息初始化</h2><p>eureka server集群高可用，是需要相互注册的，然后会相互同步服务实例列表。前面分析eureka server启动流程的时候，在EurekaBootstrap的初始化代码里有一段和集群相关的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第五步，处理peer节点相关的事情</span></span><br><span class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">  registry,</span><br><span class="line">  eurekaServerConfig,</span><br><span class="line">  eurekaClient.getEurekaClientConfig(),</span><br><span class="line">  serverCodecs,</span><br><span class="line">  applicationInfoManager</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>这个PeerEurekaNodes的start方法，在DefaultEurekaServerContext的初始化代码中被调用。它会解析配置文件中配置的其他eureka server的地址，基于URL地址构造一个一个的PeerEurekaNode，然后将其他节点的信息保存到本地。默认是每隔10分钟，会定时基于这个配置刷新集群配置信息。</p>
<h2 id="集群数据同步"><a href="#集群数据同步" class="headerlink" title="集群数据同步"></a>集群数据同步</h2><p>在初始化集群的节点信息后，还需要同步其他节点的注册表到本地。也就是EurekaBootstrap初始化代码里的registry.syncUp();，因为自己本来也是一个eureka client，<a href="http://www.saily.top/2020/03/21/springcloud/eureka03/#eureka-client%E5%85%A8%E9%87%8F%E6%8A%93%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8">所以在启动初始化的时候，就已经从任意一个其他的eureka server节点拉取到注册表在本地</a>，在这里只需要将缓存的实例信息取出来，然后在挨个本地注册一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果第一次没有在本地的eureka client 中获取任何注册表</span></span><br><span class="line">      <span class="comment">// 那么就等待30秒，看DiscoveryClient.fetchRegistry是否已经执行完成。</span></span><br><span class="line">      Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Interrupted during registry transfer..&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是读取的eureka client在本地初始化的时候拉取的全量注册表缓存。</span></span><br><span class="line">  Applications apps = eurekaClient.getApplications();</span><br></pre></td></tr></table></figure>

<p>那么在源码里我们可以看到，这里有一个重试的机制，里面还包含了sleep的代码，其实就是因为eureka client在本地的缓存可能还没有生成成功，就先执行了这里的代码，所以会等到30秒后再重试，看是否缓存已经有了数据。</p>
<p>这里也包含了上一节中提到的统计服务实例数量，后续会用来计算预期收到的心跳次数。</p>
<h2 id="注册、下线、故障集群间同步"><a href="#注册、下线、故障集群间同步" class="headerlink" title="注册、下线、故障集群间同步"></a>注册、下线、故障集群间同步</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>还记得eureka server处理注册请求的代码，在ApplicationResource.addInstance方法中，调用PeerAwareInstanceRegistryImpl.register方法进行注册，那么replicateToPeers方法，就会将注册数据同步到其他节点，此时这里的<code>isReplication</code>参数是false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">  <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">  <span class="comment">// 将注册信息同步到其他集群节点</span></span><br><span class="line">  replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到这个方法里面看一下，它会循环所有配置的集群节点信息，并排除自己。然后带上服务实例的注册信息，分别调用其他节点的注册接口，但是这里和client调用是有区别的，他底层的调用发起类是JerseyReplicationClient，在发起http请求的时候，一定会带上请求头：<code>webResource.header(PeerEurekaNode.HEADER_REPLICATION, &quot;true&quot;);</code>，那么其他节点在收到请求的时候，上面的<code>isReplication</code>就是肯定是true了。当<code>isReplication</code>是true的时候，不会像其他节点进行注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> Cancel:</span><br><span class="line">    node.cancel(appName, id);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Heartbeat:</span><br><span class="line">    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Register:</span><br><span class="line">    node.register(info);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> StatusUpdate:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.statusUpdate(appName, id, newStatus, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DeleteStatusOverride:</span><br><span class="line">    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">    node.deleteStatusOverride(appName, id, infoFromRegistry);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注册逻辑的批处理"><a href="#注册逻辑的批处理" class="headerlink" title="注册逻辑的批处理"></a>注册逻辑的批处理</h2><p>跟到node.register(info);里去看，这块代码有点复杂，他用了一个三层队列做了一个批处理请求。</p>
<ol>
<li>集群同步的机制：client可以找任意一个几点发送请求，然后这个server会将请求同步到其他所有的节点上去，但是其他的server仅仅只会在本地执行，不会再往其他节点同步。</li>
<li>数据同步的异步批处理机制：有三个队列，第一个队列纯写入（acceptorQueue），第二个队列用来根据时间和大小来拆分队列（processingOrder），第三个队列用来放批处理任务(batchWorkQueue)—&gt;任务批处理机制。</li>
</ol>
<p>流程如下图所示。</p>
<p><img src="/img/spring-cloud/image-20200329230726176.png" alt="image-20200329230726176"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在看完Eureka集群的源码以后，关于Eureka的核心概念涉及到的源码已经分析完成。在SpringCloud中，其实只是做了一层简单的封装，比如把配置文件从读取properties文件改成了从application.yml里，然后利用SpringBoot的自动装配去做了一些自动配置，并没有什么新鲜的东西。下面一张图总结下eureka 核心流程和原理</p>
<p><img src="/img/spring-cloud/image-20200330224323248.png" alt="image-20200330224323248"></p>
<ol>
<li>eureka server启动：注册中心</li>
<li>eureka client启动：服务实例</li>
<li>服务注册：map数据结构</li>
<li>eureka server集群：注册表的同步，三层队列任务批处理机制</li>
<li>全量拉取注册表：多级缓存机制，</li>
<li>增量拉取注册表：一致性hash比对机制，recentChangedQueue</li>
<li>心跳机制：服务续约，renew，刷新时间</li>
<li>服务下线：cancel</li>
<li>服务故障：expiration，eviction</li>
<li>自我保护机制：自动识别eureka server出现网络故障了，上一分钟心跳次数少于期望的心跳次数。</li>
<li>控制台：jsp页面。</li>
</ol>
<p><img src="/img/spring-cloud/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="未命名文件"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign01-流程大体分析和源码分析入口</title>
    <url>/2020/04/12/springcloud/feign01/</url>
    <content><![CDATA[<h1 id="Feign的组件简介"><a href="#Feign的组件简介" class="headerlink" title="Feign的组件简介"></a>Feign的组件简介</h1><p>Feign负责简化接口调用，发起Http请求，Feign也包含了几个核心组件</p>
<ol>
<li>编码器和解码器：Encoder和Decoder。<br>Encoder：如果调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode解码，json序列化，把一个对象转成json格式。<br>Decoder：json反序列化，收到json以后，将json转换成本地的一个Java对象。</li>
<li>Logger：用于打印接口请求相关的调用日志</li>
<li>Contract：feign注解和spring web mvc 支持的@PathVariable,@RequesstMapping，@RequestParam等注解结合起来使用了。feign本来是没法支持spring web mvc的注解的，但是有了contract（契约组件）支持后，这个组件负责解释其他的注解，让feign可以跟其他注解结合起来使用。 </li>
<li>Feign.Builder：Feign客户端的一个实例构造器，基于构建器模式的，Ribbon也有。</li>
<li>FeignClient：最核心的入口，和RibbonLoadBalancerClient类似，包含以上这些核心的组件，基于这些组件去协作调用。</li>
</ol>
<a id="more"></a>

<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a><strong>默认配置</strong></h2><p>Spring Cloud对feign的默认组件</p>
<ul>
<li>Encoder:SpringEncoder</li>
<li>Decoder:ResponseEntityDecoder</li>
<li>Logger:Sl4jLogger</li>
<li>Contract:SpringMvcContract，解析Spring web mvc的注解</li>
<li>Feign.Builder:HystrixFeign.Builder，和Hystrix整合使用</li>
<li>FeignClient:LoadBalancerFeignClient，底层还是和Ribbon整合</li>
</ul>
<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a><strong>自定义配置</strong></h2><p>可以通过自定义配置覆盖一些默认的组件，也可以定义拦截器配置，可实现对feign的请求进行拦截，可用于在发起请求之前动态添加请求头，或者打印日志等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;serviceA&quot;,configuration=MyConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyRequestInterceptor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><h3 id="feign配置"><a href="#feign配置" class="headerlink" title="feign配置"></a>feign配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 某个服务的配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">ServiceA:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br></pre></td></tr></table></figure>

<h3 id="启用feign的压缩"><a href="#启用feign的压缩" class="headerlink" title="启用feign的压缩"></a>启用feign的压缩</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">    <span class="attr">compression:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">            <span class="attr">min-request-size:</span> <span class="number">2048</span></span><br><span class="line">        <span class="attr">response:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="启用请求日志"><a href="#启用请求日志" class="headerlink" title="启用请求日志"></a>启用请求日志</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.com.zhss.service.ServiceAClient:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<h2 id="大体流程画图"><a href="#大体流程画图" class="headerlink" title="大体流程画图"></a>大体流程画图</h2><p>大体分析一下Feign是如何完成请求的，包含动态代理，路径和参数的拼装，与Ribbon的整合等。</p>
<p><img src="/img/spring-cloud/Feign%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="Feign的核心工作流程"></p>
<h1 id="Feign源码入口"><a href="#Feign源码入口" class="headerlink" title="Feign源码入口"></a>Feign源码入口</h1><p>在分析feign源码之前，应该从哪里入手？那么我们在接入feign的时候，有2个很重要的注解，分别是@EnableFeignClients开启feign，和每个接口上的@FeignClient。</p>
<p>分别看一下注解源码上的javadoc。</p>
<h2 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h2><p>用@FeignClient注解标记的接口，会被创建为一个Rest Client，可以被其他组件注入使用。</p>
<p>如果Ribbon启用的话，就会采用负载均衡的方式发送http请求。负载均衡器可以用@RibbonClient来配置，RibbonClient的和名字要和FeignClient的名字一样。就是@FeignClient(“serviceA”)可以通过下面的配置来指定对应服务Ribbon的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClient(name = &quot;serviceA&quot;, configuration = ServiceAConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ribbon.client.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                         serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h2><p>扫描那些标记了@FeignClient的接口，指定要扫描哪些包下面的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FeignClientsRegistrar是非常重要的一个类，SpringBoot大多数的EnableXXX注解都是通过@Import来完成功能开启的，所以我们猜测，SpringBoot项目启动后，在识别到EnableFeignClients注解后，FeignClientsRegistrar肯定是扫描了标记@FeignClient的接口，完成了@FeignClient的注册。这部分代码和RibbonClientConfigurationRegistrar的相似的，都是先加载了一个default开头的默认配置，然后将每个服务对应的client的配置再加载一些，包装了FeignClientSpecification类放在spring上下文中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="registerDefaultConfiguration"><a href="#registerDefaultConfiguration" class="headerlink" title="registerDefaultConfiguration"></a>registerDefaultConfiguration</h3><p>注册默认配置和注册FeignClient，这儿和Ribbon的代码差不多。</p>
<p>1、Application启动类的全的限定名</p>
<p>2、获取@EnableFeignClients注解里配置的defaultConfiguration属性</p>
<p>3、利用以上2个属性，构建一个FeignClientSpecification，注册到了Spring上下文中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 拿到EnableFeignClients注解所有配置的属性</span></span><br><span class="line">   Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 属性里是否包含defaultConfiguration配置</span></span><br><span class="line">   <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">&quot;defaultConfiguration&quot;</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="comment">// 组装成default.com.demo.DemoApplication这样的name</span></span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         name = <span class="string">&quot;default.&quot;</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册feign Client配置</span></span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">            defaultAttrs.get(<span class="string">&quot;defaultConfiguration&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Object configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是Spring用来构建Bean实例用的构建器，这里搞一个FeignClientSpecification的实例</span></span><br><span class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">    .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">  builder.addConstructorArgValue(name);</span><br><span class="line">  builder.addConstructorArgValue(configuration);</span><br><span class="line">  <span class="comment">// 这儿就是default.com.demo.DemoApplication.org.springframework.cloud.netflix.feign.FeignClientSpecification作为bean的name,FeignClientSpecification的实例作为对象，注册到了Spring的上下文中。</span></span><br><span class="line">  registry.registerBeanDefinition(</span><br><span class="line">    name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">    builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="registerFeignClients"><a href="#registerFeignClients" class="headerlink" title="registerFeignClients"></a>registerFeignClients</h3><p>这个方法会扫描配置的包，然后将标注了@FeignClient注解的接口，进行配置的注册。</p>
<ol>
<li>获得组件扫描器ClassPathScanningCandidateComponentProvider，这是个内部类。</li>
<li>如果没有配置clients属性，设置扫描的组件为标记了@FeignClient注解类或者接口。读取@EnableFeignClients的basePackages属性</li>
<li>如果没有配置basePackages属性，就会根据注解所在的类设置为扫描的包，例如DemoApplication所在的包</li>
<li>如果配置了clients属性，则不会开启扫描，直接使用配置的clients。一般不会配置</li>
<li>遍历basePackages，扫描所有注解了@FeignClient的类或者接口。判断的逻辑在内部匿名类ClassPathScanningCandidateComponentProvider.isCandidateComponent方法里</li>
<li>得到标记了@FeignClient的接口</li>
<li>根据@FeignClient的配置注册serviceId对应的个性化配置</li>
<li>根据配置的属性，构建器模式构建基于FeignClientFactoryBean的BeanDefinition并注册到BeanDefinitionRegistry中。此时FeignClient类的实例并没有生成，只是构建了一个FeignClientFactoryBean的BeanDefinition，并将其注册到了BeanDefinitionRegistry（也就是Spring上下文）里。大胆猜一下，应该是在后面才会用动态代理去创建FeignClient接口的实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 扫描用的组件</span></span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">   </span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient.class);</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">   <span class="comment">// 如果没有配置clients属性</span></span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 扫描标记了@FeignClient注解的接口</span></span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      <span class="comment">// 扫描EnableFeignClients里配置的basePackages</span></span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则遍历配置的clients，加载相应配置。</span></span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">&quot;\\$&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line">	 <span class="comment">// 如果EnableFeignClients没有配置basePackages，则扫描DemoApplication所在的包</span></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      <span class="comment">// 找到标记了@FeignClient的注解</span></span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line">            <span class="comment">// 拿到@FeignClient注解配置的属性</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient.class.getCanonicalName());</span><br><span class="line">						<span class="comment">// 拿到配置的serviceId</span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 根据配置的configuration，注册服务名个性化的配置</span></span><br><span class="line">            <span class="comment">// ServiceA.org.springframework.cloud.netflix.feign.FeignClientSpecification</span></span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">						<span class="comment">// 注册FeignClient</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientsRegistrar.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   <span class="comment">// 构建器模式构建基于FeignClientFactoryBean的BeanDefinition</span></span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">   validate(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(attributes));</span><br><span class="line">   <span class="comment">// ServiceA</span></span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;decode404&quot;</span>, attributes.get(<span class="string">&quot;decode404&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>, attributes.get(<span class="string">&quot;fallback&quot;</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">   <span class="comment">// ServiceAFeignClient</span></span><br><span class="line">   String alias = name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">   <span class="comment">// 构建器构造完成</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">&quot;primary&quot;</span>); <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="画图总结流程"><a href="#画图总结流程" class="headerlink" title="画图总结流程"></a>画图总结流程</h3><p><img src="/img/spring-cloud/%E6%89%AB%E6%8F%8F@FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="扫描@FeignClient注解的机制"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign02-动态代理创建FeignClient的实例</title>
    <url>/2020/04/18/springcloud/feign02/</url>
    <content><![CDATA[<h1 id="动态代理创建FeignClient的实例"><a href="#动态代理创建FeignClient的实例" class="headerlink" title="动态代理创建FeignClient的实例"></a>动态代理创建FeignClient的实例</h1><p>在做完前面的事情以后，FeignClientFactoryBean已经被注册到Spring上下文中，根据Spring的原理，FactoryBean是用于构造复杂对象实例的一种工厂，可定制创建，初始化，刷新，销毁的各个过程。重点需要去看getObject()方法，看对象实例是如何产生的。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 每个服务对应一个Spring容器，里面就包含了所有的FeignClientSpecification，在FeignAutoConfiguration中定义好了</span></span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   <span class="comment">// Feign对象构建器，Feign包含了动态代理生成对象的代码，详细分析在下一节</span></span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面先看下Feign.Builder是如何构造的</p>
<h2 id="Feign-Builder构造过程以及Feign在SpringCloud中的默认组件"><a href="#Feign-Builder构造过程以及Feign在SpringCloud中的默认组件" class="headerlink" title="Feign.Builder构造过程以及Feign在SpringCloud中的默认组件"></a>Feign.Builder构造过程以及Feign在SpringCloud中的默认组件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 这里的所有组件默认bean，定义都是在FeignClientsConfiguration里</span></span><br><span class="line"><span class="comment">// 除非用@FeignClients的defaultConfiguration覆盖</span></span><br><span class="line"><span class="comment">// 或者用@FeignClient的configuration覆盖</span></span><br><span class="line"><span class="comment">// 优先级 代码可以在NamedContextFactory.createContext查看</span></span><br><span class="line"><span class="comment">// 1、@FeignClient的configuration</span></span><br><span class="line"><span class="comment">// 2、@FeignClients的defaultConfiguration</span></span><br><span class="line"><span class="comment">// 3、SpringCloud的FeignClientsConfiguration</span></span><br><span class="line"><span class="keyword">protected</span> Feign.<span class="function">Builder <span class="title">feign</span><span class="params">(FeignContext context)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 去ServiceA对应的Spring容器里获取自己的FeignLoggerFactory，默认是DefaultFeignLoggerFactory</span></span><br><span class="line">   FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);</span><br><span class="line">   <span class="comment">// type就是feignClient的class</span></span><br><span class="line">   <span class="comment">// Slf4jLogger</span></span><br><span class="line">   Logger logger = loggerFactory.create(<span class="keyword">this</span>.type);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder</span></span><br><span class="line">   <span class="comment">// 否则是Feign.Builder，那么默认就是Feign.Builder</span></span><br><span class="line">   <span class="comment">// @formatter:off</span></span><br><span class="line">   Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">         <span class="comment">// required values</span></span><br><span class="line">         .logger(logger)</span><br><span class="line">         <span class="comment">// 默认是SpringEncoder</span></span><br><span class="line">         .encoder(get(context, Encoder.class))</span><br><span class="line">	       <span class="comment">// 默认是ResponseEntityDecoder</span></span><br><span class="line">         .decoder(get(context, Decoder.class))</span><br><span class="line">         <span class="comment">// 默认是SpringMvcContract</span></span><br><span class="line">         .contract(get(context, Contract.class));</span><br><span class="line">   <span class="comment">// @formatter:on</span></span><br><span class="line">   <span class="comment">// 读取application.yml设置一些参数，feign.client开头的，超时、日志级别等</span></span><br><span class="line">   configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>从ServiceA对应的Spring容器读取FeignLoggerFactory，默认是DefaultFeignLoggerFactory</li>
<li>DefaultFeignLoggerFactory创建并设置Logger，是Slf4jLogger</li>
<li>从ServiceA对应的Spring容器读取并设置Feign.Builder，如果开启feign.hystrix.enabled配置，是HystrixFeign.Builder，默认是Feign.Builder</li>
<li>从ServiceA对应的Spring容器读取并设置Encoder，默认是SpringEncoder</li>
<li>从ServiceA对应的Spring容器读取并设置Decoder，默认是ResponseEntityDecoder</li>
<li>从ServiceA对应的Spring容器读取并设置Contract，默认是SpringMvcContract</li>
<li>读取并设置application.yml属性</li>
</ol>
<h2 id="超时、日志级别、拦截器等属性设置"><a href="#超时、日志级别、拦截器等属性设置" class="headerlink" title="超时、日志级别、拦截器等属性设置"></a>超时、日志级别、拦截器等属性设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="comment">// 用@FeignClient指定的configuration进行配置，和读取application.yml</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureFeign</span><span class="params">(FeignContext context, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">  FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.class);</span><br><span class="line">  <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个默认是true</span></span><br><span class="line">    <span class="keyword">if</span> (properties.isDefaultToProperties()) &#123;</span><br><span class="line">      <span class="comment">// 读取configuration</span></span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line"> 			<span class="comment">// 全局配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      <span class="comment">// 特定服务配置</span></span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">      configureUsingProperties(properties.getConfig().get(<span class="keyword">this</span>.name), builder);</span><br><span class="line">      configureUsingConfiguration(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    configureUsingConfiguration(context, builder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureUsingProperties</span><span class="params">(FeignClientProperties.FeignClientConfiguration config, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getLoggerLevel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.logLevel(config.getLoggerLevel());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getConnectTimeout() != <span class="keyword">null</span> &amp;&amp; config.getReadTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.options(<span class="keyword">new</span> Request.Options(config.getConnectTimeout(), config.getReadTimeout()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRetryer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Retryer retryer = getOrInstantiate(config.getRetryer());</span><br><span class="line">      builder.retryer(retryer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getErrorDecoder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ErrorDecoder errorDecoder = getOrInstantiate(config.getErrorDecoder());</span><br><span class="line">      builder.errorDecoder(errorDecoder);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getRequestInterceptors() != <span class="keyword">null</span> &amp;&amp; !config.getRequestInterceptors().isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// this will add request interceptor to builder, not replace existing</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;RequestInterceptor&gt; bean : config.getRequestInterceptors()) &#123;</span><br><span class="line">         RequestInterceptor interceptor = getOrInstantiate(bean);</span><br><span class="line">         builder.requestInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (config.getDecode404() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.getDecode404()) &#123;</span><br><span class="line">         builder.decode404();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置读取过程详解：</p>
<ol>
<li><p>读取@FeignClient中指定的MyConfiguration配置，比如Logger.Level，Retryer，ErrorDecoder，Request.Options，RequestInterceptors。</p>
</li>
<li><p>读取application.yml中feign.client开头的配置，application.yml的优先级更高。</p>
</li>
<li><p>读取application.yml中feign.client.serviceA开头的配置，这个优先级最高</p>
</li>
</ol>
<h2 id="动态代理创建ServiceAClient的实例"><a href="#动态代理创建ServiceAClient的实例" class="headerlink" title="动态代理创建ServiceAClient的实例"></a>动态代理创建ServiceAClient的实例</h2><p>根据配置构造好了Feign.Builder后，就要开始创建Feign.Client的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查@FeignClient是否配置了url地址</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">// 拼了一个http://ServiceA出来</span></span><br><span class="line">         url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="comment">// Target 一般就是和动态代理有关的类，即被代理的对象</span></span><br><span class="line">      <span class="comment">// HardCodedTarget包含了 type:接口类class(ServiceAClient)，name(ServiceA)和url(http://ServiceA)。</span></span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter.class);</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>如果@FeignClient没有配置url属性，就将服务名拼接成<a href="http://servicea)这样的地址/">http://ServiceA）这样的地址</a></li>
<li>构造了一个HardCodedTarget，包含了type:接口类class(ServiceAClient)，name(ServiceA)和url(<a href="http://servicea),和feign.builder、feigncontext一起传入loadbalance./">http://ServiceA)，和Feign.Builder、FeignContext一起传入loadBalance。</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientFactoryBean.java</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">loadBalance</span><span class="params">(Feign.Builder builder, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">      HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 从上下文中获得一个LoadBalancerFeignClient，这里，就和ribbon结合起来了</span></span><br><span class="line">   Client client = getOptional(context, Client.class);</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      builder.client(client);</span><br><span class="line">      <span class="comment">// 那么targeter就是动态代理的组件</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>步骤：</p>
<ol>
<li><p>从上下文获取了一个Client，通过IDEA强大的源码查看能力，找到一个实现类LoadBalancerFeignClient，取决于不同的实现，可能会由<code>DefaultFeignLoadBalancedConfiguration</code> 或者<code>HttpClientFeignLoadBalancedConfiguration</code>或者<code>OkHttpFeignLoadBalancedConfiguration</code>定义的，通过FeignRibbonClientAutoConfiguration的@Import注解导入。默认是Default开头的。LoadBalancerFeignClient就是基于Ribbon，可负载均衡的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      OkHttpFeignLoadBalancedConfiguration.class,</span></span><br><span class="line"><span class="meta">      DefaultFeignLoadBalancedConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从Spring容器中获取到targeter动态代理的组件，Targeter的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 这个条件明显是成立的，所以代码拿到的肯定是HystrixTargeter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignTargeterConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Targeter <span class="title">feignTargeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultTargeter();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在HystrixTargeter中，如果没有开启feign.hystrix.enabled配置，那么就进入默认的Feign.Builder.target方法，不过在生产环境中，一般都会开启。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 默认情况下是Feign.Builder，所以会进入这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   feign.target(target)方法里，将Feign.Builder中所有的的东西集成在一起，构造一个ReflectiveFeign，调用newInstance方法，传入target生成动态代理</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Feign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">    <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                         logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">    <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                            errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>调用newInstance方法，传入target，生成ServiceAClient的动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 关键代码，接口中的每个方法的名称，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">  <span class="comment">// 接口中的每个方法对应的Method对象，对应一个处理这个方法的SynchronousMethodHandler</span></span><br><span class="line">  <span class="comment">// 到时候每一个handler，都会去触发真正的调用</span></span><br><span class="line">  Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">  List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 反射遍历ServiceAClient的方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;</span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 基于工厂创建的InvocationHandler，JDK动态代理的组件, 这里是ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  <span class="comment">// 基于JDK的动态代理创建了一个动态代理对象，这个proxy对象，就实现了ServiceAClient接口</span></span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建完成后，对象被放入Sping容器中，可以被其他类注入使用。</p>
</li>
</ol>
<h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/feign%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.jpg" alt="feign动态代理的构造过程"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign03-Feign请求处理机制分析</title>
    <url>/2020/04/18/springcloud/feign03/</url>
    <content><![CDATA[<h1 id="接口方法与MethodHandler映射map的生成机制"><a href="#接口方法与MethodHandler映射map的生成机制" class="headerlink" title="接口方法与MethodHandler映射map的生成机制"></a>接口方法与MethodHandler映射map的生成机制</h1><p>在开始之前，先说一下FeignClient接口的上的SpringMVC注解是如何被解析的，回顾到之前生成动态代理的时候，有个nameToHandler的map，有一句非常关键的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br></pre></td></tr></table></figure>

<p>这里面就完成了SpringMVCContract对方法的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这就用contract完成了方法上的SpringMVC注解的转换</span></span><br><span class="line">  <span class="comment">// ServiceAClient的每一个方法都会被解析成MethodMetadata</span></span><br><span class="line">  <span class="comment">// 对各种SpringMVC的注解进行解析，将解析出来的header，method，path，body,form param，返回值等等等，放入了MethodMetadata中</span></span><br><span class="line">  List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">  Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">  <span class="comment">// 遍历方法元数据</span></span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">    BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">    <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里就创建了SynchronousMethodHandler，key就是方法名</span></span><br><span class="line">    <span class="comment">// SynchronousMethodHandler就是所有的方法被代理后实际处理的处理器</span></span><br><span class="line">    result.put(md.configKey(),</span><br><span class="line">               factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="画个图"><a href="#画个图" class="headerlink" title="画个图"></a>画个图</h2><p><img src="/img/spring-cloud/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E4%B8%8EMethodHandler%E6%98%A0%E5%B0%84map%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6.jpg" alt="接口方法与MethodHandler映射map的生成机制"></p>
<h1 id="Feign请求处理大体流程"><a href="#Feign请求处理大体流程" class="headerlink" title="Feign请求处理大体流程"></a>Feign请求处理大体流程</h1><p><img src="/img/spring-cloud/Feign%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%BA%E5%88%B6.jpg" alt="Feign基于动态代理处理请求的机制"></p>
<h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><h2 id="动态代理拦截Client所有的方法调用"><a href="#动态代理拦截Client所有的方法调用" class="headerlink" title="动态代理拦截Client所有的方法调用"></a>动态代理拦截Client所有的方法调用</h2><p>在动态代理生成以后，动态代理所有的调用都会被FeignInvocationHandler拦截，所以我们分析实际的请求流程，需要去查看invoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReflectiveFeign.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 排除掉equals等方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object</span><br><span class="line">          otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个dispatch，就是Map&lt;Method, MethodHandler&gt; dispatch;</span></span><br><span class="line">  <span class="comment">// 那么拿到的对象就是SynchronousMethodHandler，然后将参数传过去了</span></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将方法上的请求参数封装到RequestTemplate里"><a href="#将方法上的请求参数封装到RequestTemplate里" class="headerlink" title="将方法上的请求参数封装到RequestTemplate里"></a>将方法上的请求参数封装到RequestTemplate里</h2><p>Map&lt;Method, MethodHandler&gt; dispatch;维护了方法对象和SynchronousMethodHandler的映射，所以流程到这里，直接跟到SynchronousMethodHandler利的invoke方法去看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 又是关键代码，用于替换PathVariable、@RequestParam以及RequestBody</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发起调用</span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将拿到的参数拼到url上，例如 /user/{id}拼接成， /user/1?name=xxx&amp;age=19</p>
<h2 id="执行所有的RequestInterceptor"><a href="#执行所有的RequestInterceptor" class="headerlink" title="执行所有的RequestInterceptor"></a>执行所有的RequestInterceptor</h2><p>然后开始调用executeAndDecode方法，执行http调用的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SynchronousMethodHandler.java</span></span><br><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line">  <span class="comment">// 并创建可用于发送请求的Request对象</span></span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target.apply(<span class="keyword">new</span> RequestTemplate(template));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>遍历请求拦截器，将每个请求拦截都应用到RequestTemplate模板上去，也就是让每个请求拦截器对请求进行处理</li>
<li>基于RequestTemplate创建一个Request对象，用于发送请求</li>
<li>将请求的参数都传入了进去，连接超时时间都是10s，读超时时间是60s。基于LoadBalancerFeignClient进行了请求的处理和发送，同时获取了Response。</li>
</ol>
<h2 id="获得负载均衡器选择服务发起请求"><a href="#获得负载均衡器选择服务发起请求" class="headerlink" title="获得负载均衡器选择服务发起请求"></a>获得负载均衡器选择服务发起请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerFeignClient.execute</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      URI asUri = URI.create(request.url());</span><br><span class="line">      <span class="comment">// 获取请求的服务名称，也就是ServiceA</span></span><br><span class="line">      String clientName = asUri.getHost();</span><br><span class="line">      <span class="comment">// 从请求URL中剔除了服务名称，</span></span><br><span class="line">      URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">      <span class="comment">// 基于去除了服务名称的地址创建了一个RibbonRequest</span></span><br><span class="line">      FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">            <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line">			<span class="comment">// 这是ribbon的配置</span></span><br><span class="line">      IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">      <span class="comment">// 创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</span></span><br><span class="line">      <span class="keyword">return</span> lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">            requestConfig).toResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">      IOException io = findIOException(e);</span><br><span class="line">      <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> io;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取请求的服务名称，也就是ServiceA</li>
<li>从请求URL中剔除了服务名称</li>
<li>基于去除了服务名称的地址创建了一个RibbonRequest</li>
<li>读取某个服务ribbon的配置IClientConfig</li>
<li>创建FeignLoadBalancer，封装了ribbon的ILoadBalancer（重点）</li>
</ol>
<h2 id="Feign是如何与Ribbon进行整合的"><a href="#Feign是如何与Ribbon进行整合的" class="headerlink" title="Feign是如何与Ribbon进行整合的"></a>Feign是如何与Ribbon进行整合的</h2><p>上面已经创建了FeignLoadBalancer，他内部封装了Ribbon的ILoadBalancer，所以要重点分析下他究竟是如何与Ribbon进行整合的，用的是Ribbon的哪一个ILoadBalancer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CachingSpringLoadBalancerFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FeignLoadBalancer <span class="title">create</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(clientName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(clientName);</span><br><span class="line">   &#125;</span><br><span class="line">   IClientConfig config = <span class="keyword">this</span>.factory.getClientConfig(clientName);</span><br><span class="line">   <span class="comment">// 从SpringClientFactory获取，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer</span></span><br><span class="line">   ILoadBalancer lb = <span class="keyword">this</span>.factory.getLoadBalancer(clientName);</span><br><span class="line">   ServerIntrospector serverIntrospector = <span class="keyword">this</span>.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">   FeignLoadBalancer client = enableRetry ? <span class="keyword">new</span> RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">      loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : <span class="keyword">new</span> FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">   <span class="keyword">this</span>.cache.put(clientName, client);</span><br><span class="line">   <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从SpringClientFactory获取ILoadBalancer等组件，SpringClientFactory就是Ribbon初始化的时候创建的，所以这里获取到的是ZoneAwareLoadBalancer，这里也就自然的与Eureka完成了整合。</p>
<h2 id="FeignLoadBalancer如何负载均衡选择Server"><a href="#FeignLoadBalancer如何负载均衡选择Server" class="headerlink" title="FeignLoadBalancer如何负载均衡选择Server"></a>FeignLoadBalancer如何负载均衡选择Server</h2><p>进入到executeWithLoadBalancer方法中构造了一个LoadBalancerCommand，然后下面的submit方法，有一个匿名内部类ServerOperation的的实现传进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractLoadBalancerAwareClient.executeWithLoadBalancer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">executeWithLoadBalancer</span><span class="params">(<span class="keyword">final</span> S request, <span class="keyword">final</span> IClientConfig requestConfig)</span> <span class="keyword">throws</span> ClientException </span>&#123;</span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这提交了一个匿名内部类进去，那么ServerOperation.call方法就一定会在submit方法里被调用</span></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure>

<p>提交了一个匿名内部类作为参数，那么ServerOperation.call方法就一定会在submit方法里被调用，跟到submit方法里去看下，因为是第一次进入，所以server肯定是null，selectServer()方法，看名字明显就是调用负载均衡选择服务实例的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="keyword">final</span> ServerOperation&lt;T&gt; operation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// ribbon的重试参数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    <span class="comment">// selectServer 负载均衡选择实例</span></span><br><span class="line">    Observable&lt;T&gt; o = </span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">      ......省略部分代码</span><br><span class="line">      <span class="comment">// 选择出服务实例后，对operation进行回调，进行url的替换，然后发起真正的http请求</span></span><br><span class="line">      <span class="keyword">return</span> operation.call(server)...</span><br><span class="line">      ......胜率部分代码</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 选择一个服务实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Server&gt; <span class="title">selectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Server&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取host信息，也就是服务名，然后调用负载均衡器chooseServer方法选择一个服务实例</span></span><br><span class="line">                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构造了一个LoadBalancerCommand</li>
<li>构造了一个ServerOperation，包含了发起http调用的逻辑，作为参数传入LoadBalancerCommand.submit方法，后面会进行回调</li>
<li>在submit方法中，会调用selectServer方法，选择服务实例</li>
<li>selectServer方法调用loadBalancerContext.getServerFromLoadBalancer，最终调用负载均衡器<a href="http://www.saily.top/2020/03/31/springcloud/ribbon01/#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAserver">chooseServer</a>方法选择一个服务实例，</li>
<li>拿到服务实例后，将Server对象传入ServerOperation的call方法进行回调</li>
<li>ServerOperation用server的信息替换host里的服务名，拿到真正的请求地址</li>
<li>再调用子类也就是FeignLoadBalancer.execute方法执行http请求</li>
<li>默认的connectTimeout和readTimeout都是1000毫秒</li>
<li>响应结果封装为RibbonResponse</li>
</ol>
<h2 id="收到响应后将json串转换成对象"><a href="#收到响应后将json串转换成对象" class="headerlink" title="收到响应后将json串转换成对象"></a>收到响应后将json串转换成对象</h2><p>回到最初的SynchronousMethodHandler方法里，在executeAndDecode方法中，<code>response = client.execute(request, options);</code>在拿到RibbonResponse以后，开始进行对响应的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response;</span><br><span class="line">  <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前面已经执行完这里的代码了，拿到了RibbonResponse</span></span><br><span class="line">    response = client.execute(request, options);</span><br><span class="line">    <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">    response.toBuilder().request(request).build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> shouldClose = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      response =</span><br><span class="line">          logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">      response.toBuilder().request(request).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Response.class == metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.body().length() == <span class="keyword">null</span> ||</span><br><span class="line">              response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">        shouldClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Ensure the response body is disconnected</span></span><br><span class="line">      <span class="keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      <span class="keyword">return</span> response.toBuilder().body(bodyData).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键代码在这里</span></span><br><span class="line">        <span class="keyword">return</span> decode(response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) &#123;</span><br><span class="line">      <span class="keyword">return</span> decode(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> errorReading(request, response, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldClose) &#123;</span><br><span class="line">      ensureClosed(response.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到响应以后，执行decode方法，这个decoder默认是ResponseEntityDecoder，将json字符串转换成java对象，也就是方法的返回类型，metadata.returnType()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">decode</span><span class="params">(Response response)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DecodeException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="画个图总结"><a href="#画个图总结" class="headerlink" title="画个图总结"></a>画个图总结</h2><p><img src="/img/spring-cloud/Feign%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6-7217603.jpg" alt="Feign请求处理机制"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign04-Feign超时和重试分析</title>
    <url>/2020/04/18/springcloud/feign04/</url>
    <content><![CDATA[<h1 id="Feign超时和重试"><a href="#Feign超时和重试" class="headerlink" title="Feign超时和重试"></a>Feign超时和重试</h1><p><strong>超时</strong></p>
<p>在微服务架构中，一个服务对服务的访问至少得配置一个超时时间，不可能请求一个接口等了好几分钟都还没有返回，在设置超时时间后，超时后就认为这次接口请求失败了。</p>
<p><strong>重试</strong></p>
<p>服务B调用服务A，服务A部署了3台机器，现在服务B通过负载均衡的算法，调用到了服务A的机器1，因为服务A的机器1宕机了，请求超时了，可以让服务B再次请求一次服务A的机器1，如果还是不行，再请求服务A的机器2，如果还是不行，就再请求服务A的服务3，这就是重试机制。</p>
<a id="more"></a>

<h2 id="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"><a href="#在SpringCloud的Feign和Ribbon整合的时候，如何配置？" class="headerlink" title="在SpringCloud的Feign和Ribbon整合的时候，如何配置？"></a>在SpringCloud的Feign和Ribbon整合的时候，如何配置？</h2><p>在早期的Feign也有重试的模块，但是后来发现和Ribbon冲突了，于是SpringCloud团队在后面的版本将Feign的重试设置为NERVER_RETRY了。具体的缘由，可以看下这篇文章：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都进行重试</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 同一实例最大重试次数，不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 重试其他实例的最大重试次数，不包括首次所选的server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>feign的超时时间优先级更高</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h2 id="超时和重试源码"><a href="#超时和重试源码" class="headerlink" title="超时和重试源码"></a>超时和重试源码</h2><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>如果feign没有配置超时时间，则读取ribbon的配置，否则读取feign的超时配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IClientConfig <span class="title">getClientConfig</span><span class="params">(Request.Options options, String clientName)</span> </span>&#123;</span><br><span class="line">   IClientConfig requestConfig;</span><br><span class="line">   <span class="keyword">if</span> (options == DEFAULT_OPTIONS) &#123;</span><br><span class="line">      requestConfig = <span class="keyword">this</span>.clientFactory.getClientConfig(clientName);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestConfig = <span class="keyword">new</span> FeignOptionsClientConfig(options);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> requestConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FeignLoadBalancer.execute()，发送实际的http请求的时候，就会传入设置的超时参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (configOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(</span><br><span class="line">         configOverride.get(CommonClientConfigKey.ConnectTimeout,</span><br><span class="line">               <span class="keyword">this</span>.connectTimeout),</span><br><span class="line">         (configOverride.get(CommonClientConfigKey.ReadTimeout,</span><br><span class="line">               <span class="keyword">this</span>.readTimeout)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   options = <span class="keyword">new</span> Request.Options(<span class="keyword">this</span>.connectTimeout, <span class="keyword">this</span>.readTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><h4 id="Feign的重试"><a href="#Feign的重试" class="headerlink" title="Feign的重试"></a>Feign的重试</h4><p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p>
<p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。</p>
<p>SynchronousMethodHandler.invoke()方法里面，如果抛了异常的话，也会默认根据Retryer进行重试。</p>
<p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  <span class="comment">// 重试，这个默认是NEVER_RETRY</span></span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ribbon的重试"><a href="#Ribbon的重试" class="headerlink" title="Ribbon的重试"></a>Ribbon的重试</h4><p>因为SpringCloud的Feign重试默认是NEVER_RETRY，所以主要是靠Ribbon的重试机制。</p>
<p>FeignLoadBalancer.getRequestSpecificRetryHandler()方法中，会读取配置的几个参数：OkToRetryOnAllOperations、MaxAutoRetries、MaxAutoRetriesNextServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestSpecificRetryHandler <span class="title">getRequestSpecificRetryHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.clientConfig.get(CommonClientConfigKey.OkToRetryOnAllOperations,</span><br><span class="line">         <span class="keyword">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!request.toRequest().method().equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestSpecificRetryHandler(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">this</span>.getRetryHandler(),</span><br><span class="line">            requestConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> LoadBalancerCommand.submit()方法中，读取RetryHandler中配置的参数，会根据请求的情况，是否报错，是否报异常，进行重试的控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br></pre></td></tr></table></figure>

<p>LoadBalancerCommand包含了大量的重试逻辑，这里是判断是否对同一台机器进行重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>) </span><br><span class="line">  o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>

<p>重试都会进入retryPolicy方法，判断是否需要进行重试，然后利用rxjava的retry方法进行重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Func2&lt;Integer, Throwable, Boolean&gt; <span class="title">retryPolicy</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxRetrys, <span class="keyword">final</span> <span class="keyword">boolean</span> same)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer tryCount, Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AbortExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCount &gt; maxRetrys) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e.getCause() != <span class="keyword">null</span> &amp;&amp; e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                e = e.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> retryHandler.isRetriableException(e, same);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其他机器进行重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>) </span><br><span class="line">    o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的逻辑是服务宕机的时候的重试逻辑，在超时的时候重试逻辑却是在RetryableFeignLoadBalancer里</p>
</blockquote>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix监控和运维</title>
    <url>/2018/06/10/springcloud/hystrix04/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="为什么需要监控与报警？"><a href="#为什么需要监控与报警？" class="headerlink" title="为什么需要监控与报警？"></a>为什么需要监控与报警？</h3><p>HystrixCommand执行的时候，会生成一些执行耗时等方面的统计信息。这些信息对于系统的运维来说，是很有帮助的，因为我们通过这些统计信息可以看到整个系统是怎么运行的。hystrix对每个command key都会提供一份metric，而且是秒级统计粒度的。</p>
<a id="more"></a>
<p>这些统计信息，无论是单独看，还是聚合起来看，都是很有用的。如果将一个请求中的多个command的统计信息拿出来单独查看，包括耗时的统计，对debug系统是很有帮助的。聚合起来的metric对于系统层面的行为来说，是很有帮助的，很适合做报警或者报表。hystrix dashboard就很适合。</p>
<h3 id="hystrix的事件类型"><a href="#hystrix的事件类型" class="headerlink" title="hystrix的事件类型"></a>hystrix的事件类型</h3><p>对于hystrix command来说，只会返回一个值，execute只有一个event type，fallback也只有一个event type，那么返回一个SUCCESS就代表着命令执行的结束</p>
<p>对于hystrix observable command来说，多个值可能被返回，所以emit event代表一个value被返回，success代表成功，failure代表异常</p>
<h4 id="execute-event-type"><a href="#execute-event-type" class="headerlink" title="execute event type"></a>execute event type</h4><p>EMIT                    observable command返回一个value<br>SUCCESS                 完成执行，并且没有报错<br>FAILURE                    执行时抛出了一个异常，会触发fallback<br>TIMEOUT                    开始执行了，但是在指定时间内没有完成执行，会触发fallback<br>BAD_REQUEST                执行的时候抛出了一个HystrixBadRequestException<br>SHORT_CIRCUITED            短路器打开了，触发fallback<br>THREAD_POOL_REJECTED    线程成的容量满了，被reject，触发fallback<br>SEMAPHORE_REJECTED        信号量的容量满了，被reject，触发fallback</p>
<h4 id="fallback-event-type"><a href="#fallback-event-type" class="headerlink" title="fallback event type"></a>fallback event type</h4><p>FALLBACK_EMIT            observable command，fallback value被返回了<br>FALLBACK_SUCCESS        fallback逻辑执行没有报错<br>FALLBACK_FAILURE        fallback逻辑抛出了异常，会报错<br>FALLBACK_REJECTION        fallback的信号量容量满了，fallback不执行，报错<br>FALLBACK_MISSING        fallback没有实现，会报错</p>
<h4 id="其他的event-type"><a href="#其他的event-type" class="headerlink" title="其他的event type"></a>其他的event type</h4><p>EXCEPTION_THROWN        command生命自周期是否抛出了异常<br>RESPONSE_FROM_CACHE        command是否在cache中查找到了结果<br>COLLAPSED                command是否是一个合并batch中的一个</p>
<h4 id="thread-pool-event-type"><a href="#thread-pool-event-type" class="headerlink" title="thread pool event type"></a>thread pool event type</h4><p>EXECUTED                线程池有空间，允许command去执行了<br>REJECTED                 线程池没有空间，不允许command执行，reject掉了</p>
<h4 id="collapser-event-type"><a href="#collapser-event-type" class="headerlink" title="collapser event type"></a>collapser event type</h4><p>BATCH_EXECUTED            collapser合并了一个batch，并且执行了其中的command<br>ADDED_TO_BATCH            command加入了一个collapser batch<br>RESPONSE_FROM_CACHE        没有加入batch，而是直接取了request cache中的数据</p>
<h3 id="metric-storage"><a href="#metric-storage" class="headerlink" title="metric storage"></a>metric storage</h3><p>metric被生成之后，就会按照一段时间来存储，存储了一段时间的数据才会推送到其他系统中，比如hystrix dashboard。</p>
<p>另外一种方式，就是每次生成metric就实时推送metric流到其他地方，但是这样的话，会给系统带来很大的压力。</p>
<p>hystrix的方式是将metric写入一个内存中的数据结构中，在一段时间之后就可以查询到，hystrix 1.5x之后，采取的是为每个command key都生成一个start event和completion event流，而且可以订阅这个流。每个thread pool key也是一样的，包括每个collapser key也是一样的。</p>
<p>每个command的event是发送给一个线程安全的RxJava中的rx.Subject，因为是线程安全的，所以不需要进行线程同步。</p>
<p>因此每个command级别的，threadpool级别的，每个collapser级别的，event都会发送到对应的RxJava的rx.Subject对象中。这些rx.Subject对象接着就会被暴露出Observable接口，可以被订阅。</p>
<h3 id="metric统计相关的配置"><a href="#metric统计相关的配置" class="headerlink" title="metric统计相关的配置"></a>metric统计相关的配置</h3><h4 id="metrics-rollingStats-timeInMilliseconds"><a href="#metrics-rollingStats-timeInMilliseconds" class="headerlink" title="metrics.rollingStats.timeInMilliseconds"></a>metrics.rollingStats.timeInMilliseconds</h4><p>设置统计的rolling window，单位是毫秒，hystrix只会维持这段时间内的metric供短路器统计使用</p>
<p>这个属性是不允许热修改的，默认值是10000，就是10秒钟</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingStatisticalWindowInMilliseconds(int value)</p>
<h4 id="metrics-rollingStats-numBuckets"><a href="#metrics-rollingStats-numBuckets" class="headerlink" title="metrics.rollingStats.numBuckets"></a>metrics.rollingStats.numBuckets</h4><p>该属性设置每个滑动窗口被拆分成多少个bucket，而且滑动窗口对这个参数必须可以整除，同样不允许热修改</p>
<p>默认值是10，也就是说，每秒钟是一个bucket</p>
<p>随着时间的滚动，比如又过了一秒钟，那么最久的一秒钟的bucket就会被丢弃，然后新的一秒的bucket会被创建</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingStatisticalWindowBuckets(int value)</p>
<h4 id="metrics-rollingPercentile-enabled"><a href="#metrics-rollingPercentile-enabled" class="headerlink" title="metrics.rollingPercentile.enabled"></a>metrics.rollingPercentile.enabled</h4><p>控制是否追踪请求耗时，以及通过百分比方式来统计，默认是true</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileEnabled(boolean value)</p>
<h4 id="metrics-rollingPercentile-timeInMilliseconds"><a href="#metrics-rollingPercentile-timeInMilliseconds" class="headerlink" title="metrics.rollingPercentile.timeInMilliseconds"></a>metrics.rollingPercentile.timeInMilliseconds</h4><p>设置rolling window被持久化保存的时间，这样才能计算一些请求耗时的百分比，默认是60000，60s，不允许热修改</p>
<p>相当于是一个大的rolling window，专门用于计算请求执行耗时的百分比</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileWindowInMilliseconds(int value)</p>
<h4 id="metrics-rollingPercentile-numBuckets"><a href="#metrics-rollingPercentile-numBuckets" class="headerlink" title="metrics.rollingPercentile.numBuckets"></a>metrics.rollingPercentile.numBuckets</h4><p>设置rolling percentile window被拆分成的bucket数量，上面那个参数除以这个参数必须能够整除，不允许热修改</p>
<p>默认值是6，也就是每10s被拆分成一个bucket</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileWindowBuckets(int value)</p>
<h4 id="metrics-rollingPercentile-bucketSize"><a href="#metrics-rollingPercentile-bucketSize" class="headerlink" title="metrics.rollingPercentile.bucketSize"></a>metrics.rollingPercentile.bucketSize</h4><p>设置每个bucket的请求执行次数被保存的最大数量，如果在一个bucket内，执行次数超过了这个值，那么就会重新覆盖从bucket的开始再写</p>
<p>举例来说，如果bucket size设置为100，而且每个bucket代表一个10秒钟的窗口，但是在这个bucket内发生了500次请求执行，那么这个bucket内仅仅会保留100次执行</p>
<p>如果调大这个参数，就会提升需要耗费的内存，来存储相关的统计值，不允许热修改</p>
<p>默认值是100</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsRollingPercentileBucketSize(int value)</p>
<h4 id="metrics-healthSnapshot-intervalInMilliseconds"><a href="#metrics-healthSnapshot-intervalInMilliseconds" class="headerlink" title="metrics.healthSnapshot.intervalInMilliseconds"></a>metrics.healthSnapshot.intervalInMilliseconds</h4><p>控制成功和失败的百分比计算，与影响短路器之间的等待时间，默认值是500毫秒</p>
<p>HystrixCommandProperties.Setter()<br>   .withMetricsHealthSnapshotIntervalInMilliseconds(int value)</p>
<h2 id="监控部署"><a href="#监控部署" class="headerlink" title="监控部署"></a>监控部署</h2><p>找到之前的eshop-cache-ha项目，引入配置：</p>
<p><a href="https://github.com/sail-y/eshop-cache-ha">https://github.com/sail-y/eshop-cache-ha</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-metrics-event-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再注册一个servlet的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">indexServletRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> HystrixMetricsStreamServlet());</span><br><span class="line">    registration.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Tomcat</strong></p>
<p>准备一个tomcat部署HystrixDashboard，网上下载一个<code>hystrix-dashboard-1.5.12.war</code>，再装一个turbin，turbin是用来监控一个集群的，可以将一个集群的所有机器都配置在这里。</p>
<p>在/WEB-INF/classes下添加一个配置文件，告诉turbin需要监控哪些实例。</p>
<p><strong>config.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turbine.ConfigPropertyBasedDiscovery.default.instances&#x3D;localhost</span><br><span class="line">turbine.instanceUrlSuffix&#x3D;:8081&#x2F;hystrix.stream</span><br></pre></td></tr></table></figure>

<p><img src="/img/hystrix/hystrix-running.png"></p>
<p>然后启动我们自己的<code>eshop-cache-ha</code>项目，</p>
<p>访问页面查看</p>
<p><a href="http://localhost:8080/hystrix-dashboard/">http://localhost:8080/hystrix-dashboard/</a></p>
<p>填入我们要监控的URL.</p>
<p><img src="/img/hystrix/hystrix-running2.png"></p>
<p><a href="http://localhost:8081/hystrix.stream%EF%BC%8C%E7%9B%91%E6%8E%A7%E5%8D%95%E4%B8%AA%E6%9C%BA%E5%99%A8">http://localhost:8081/hystrix.stream，监控单个机器</a></p>
<p><a href="http://localhost:8080/turbine/turbine.stream%EF%BC%8C%E7%9B%91%E6%8E%A7%E6%95%B4%E4%B8%AA%E9%9B%86%E7%BE%A4">http://localhost:8080/turbine/turbine.stream，监控整个集群</a></p>
<p>现在还看不到什么东西，我们对项目发送几个请求，再看看效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控请求测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/hystrix/hystrix-running3.png"></p>
<p>hystrix的dashboard可以支持实时监控metric</p>
<p>netflix开始用这个dashboard的时候，大幅度优化了工程运维的操作，帮助节约了恢复系统的时间。大多数生产系统的故障持续时间变得很短，而且影响幅度小了很多，主要是因为hystrix dashborad提供了可视化的监控。</p>
<p>截图说明，dashboard上的指标都是什么？</p>
<p>圆圈的颜色和大小代表了健康状况以及流量，折线代表了最近2分钟的请求流量</p>
<p>集群中的机器数量，请求延时的中位数以及平均值</p>
<p>最近10秒内的异常请求比例，请求QPS，每台机器的QPS，以及整个集群的QPS</p>
<p>断路器的状态</p>
<p>最近一分钟的请求延时百分比，TP90，TP99，TP99.5</p>
<p>几个有颜色的数字，代表了最近10秒钟的统计，以1秒钟为粒度</p>
<p>成功的请求数量，绿颜色的数字; 短路的请求数量，蓝色的数字; timeout超时的请求数量，黄色的数字; 线程池reject的请求数量，紫色的数字; 请求失败，抛出异常的请求数量，红色的数字</p>
<h2 id="生产环境运维"><a href="#生产环境运维" class="headerlink" title="生产环境运维"></a>生产环境运维</h2><p>如果发现了严重的依赖调用延时，先不用急着去修改配置，如果一个command被限流了，可能本来就应该限流</p>
<p>在netflix早期的时候，经常会有人在发现短路器因为访问延时发生的时候，去热修改一些配置，比如线程池大小，队列大小，超时时长，等等，给更多的资源，但是这其实是不对的。</p>
<p>如果我们之前对系统进行了良好的配置，然后现在在高峰期，系统在进行线程池reject，超时，短路，那么此时我们应该集中精力去看底层根本的原因，而不是调整配置</p>
<p>为什么在高峰期，一个10个线程的线程池，搞不定这些流量呢？那就是代码写的太烂了，可以使用异步，或者更好的算法。</p>
<p>千万不要急于给你的依赖调用过多的资源，比如线程池大小，队列大小，超时时长，信号量容量，等等，因为这可能导致我们自己对自己的系统进行DDOS攻击。</p>
<p>举例来说，想象一下，我们现在有100台服务器组成的集群，每台机器有10个线程大小的线程池去访问一个服务，那么我们对那个服务就有1000个线程资源去访问了，在正常情况下，可能只会用到其中200~300个线程去访问那个后端服务。但是如果再高峰期出现了访问延时，可能导致1000个线程全部被调用去访问那个后端服务，如果我们调整到每台服务器20个线程呢？</p>
<p>如果因为你的代码等问题导致访问延时，即使有20个线程可能还是会导致线程池资源被占满，此时就有2000个线程去访问后端服务，可能对后端服务就是一场灾难。</p>
<p>这就是断路器的作用了，如果我们把后端服务打死了，或者产生了大量的压力，有大量的timeout和reject，那么就自动短路，一段时间后，等流量洪峰过去了，再重启访问。</p>
<p>简单来说，让系统自己去限流，短路，超时，以及reject，直到系统重新变得正常了，就是不要随便乱改资源配置，不要随便乱增加线程池大小，等待队列大小，异常情况是正常的。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud微服务-1-什么是微服务</title>
    <url>/2019/04/10/springcloud/microservices-1/</url>
    <content><![CDATA[<p>微服务学习笔记</p>
<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><p><a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></p>
<blockquote>
<p>“Microservices” - yet another new term on the crowded streets of software architecture. Although our natural inclination is to pass such things by with a contemptuous glance, this bit of terminology describes a style of software systems that we are finding more and more appealing. We’ve seen many projects use this style in the last few years, and results so far have been positive, so much so that for many of our colleagues this is becoming the default style for building enterprise applications. Sadly, however, there’s not much information that outlines what the microservice style is and how to do it.</p>
</blockquote>
<a id="more"></a>

<p>单体应用 -&gt; 微服务应用</p>
<p><a href="https://time.geekbang.org/column/article/13882">从0开始学微服务-胡忠想</a></p>
<h2 id="单体架构存在的缺点"><a href="#单体架构存在的缺点" class="headerlink" title="单体架构存在的缺点"></a>单体架构存在的缺点</h2><ul>
<li>复杂性逐渐变高</li>
<li>技术债务逐渐上升</li>
<li>部署速度逐渐变慢</li>
<li>阻碍技术创新</li>
<li>无法按需伸缩</li>
</ul>
<h2 id="什么是微服务-1"><a href="#什么是微服务-1" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><ul>
<li>Martin Fowler：简而言之，微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。<strong>其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。</strong>这些服务围绕这些功能进行构建，并能通过全自动的部署机制来进行独立部署。<strong>这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。</strong>对这些微服务我们仅做最低限度的集中管理。</li>
<li>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体的业务进行构建，并且能够独立地被部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</li>
<li>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</li>
</ul>
<h2 id="微服务是一种架构风格"><a href="#微服务是一种架构风格" class="headerlink" title="微服务是一种架构风格"></a>微服务是一种架构风格</h2><ul>
<li>服务组件化（Componentization via Services）</li>
<li>服务围绕业务（Organized around Business Capabilities）</li>
<li>产品开发模式（Products not Projects）</li>
<li>轻量级通信机制（Smart endpoints and dumb pipes）</li>
<li>去中心化治理（Decentralized Governance）</li>
<li>去中心化数据设计（Decentralized Data Management）</li>
<li>故障处理设计（Design for failure）</li>
<li>演进式设计（Evolutionary Design）</li>
<li>基础设施自动化（Infrastructure Automation）</li>
</ul>
<h2 id="微服务的优点和挑战"><a href="#微服务的优点和挑战" class="headerlink" title="微服务的优点和挑战"></a>微服务的优点和挑战</h2><ul>
<li>开发简单</li>
<li>技术栈灵活</li>
<li>服务独立</li>
<li>按需扩展</li>
</ul>
<hr>
<ul>
<li>运维复杂</li>
<li>数据一致性问题</li>
<li>集成测试复杂</li>
<li>重复代码</li>
<li>监控困难</li>
</ul>
<h3 id="微服务具备的特性"><a href="#微服务具备的特性" class="headerlink" title="微服务具备的特性"></a>微服务具备的特性</h3><ul>
<li>每个微服务可独立运行在自己的进程里</li>
<li>一系列独立运行的微服务共同构建起了整个系统</li>
<li>每个服务为独立的业务开发，一个微服务一般完成某个特定的功能，比如：订单管理，用户管理等</li>
<li>微服务之间通过一些轻量的通信机制进行通信，例如通过REST API或者RPC的方式进行调用</li>
</ul>
<h3 id="微服务的优点"><a href="#微服务的优点" class="headerlink" title="微服务的优点"></a>微服务的优点</h3><ul>
<li>易于开发和维护</li>
<li>启动较快</li>
<li>局部修改容易部署</li>
<li>技术栈不受限</li>
<li>按需伸缩</li>
<li>DevOps</li>
</ul>
<h3 id="微服务带来的挑战"><a href="#微服务带来的挑战" class="headerlink" title="微服务带来的挑战"></a>微服务带来的挑战</h3><ul>
<li>运维要求较高</li>
<li>分布式的复杂性</li>
<li>接口调整成本高</li>
<li>重复劳动</li>
</ul>
<h3 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h3><ul>
<li>单一职责原则</li>
<li>服务自治原则</li>
<li>轻量级通信原则</li>
<li>接口明确原则</li>
</ul>
<h1 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h1><p>很多人会把SOA和微服务搞混，甚至理解为同一个东西。实际上SOA已经面世20多年了，和微服务是不一样的，接下来去维基百科看看SOA到底是什么。</p>
<p><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">https://en.wikipedia.org/wiki/Service-oriented_architecture</a></p>
<p>学技术，一定要去阅读原版的英文资料。</p>
<blockquote>
<p><strong>Service-oriented architecture (SOA)</strong> is a style of software design where services are provided to the other components by application components, through a communication protocol over a network. The basic principles of service-oriented architecture are independent of vendors, products and technologies.[1] A service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card statement online.</p>
</blockquote>
<blockquote>
<p>A service has four properties according to one of many definitions of SOA:[2]</p>
</blockquote>
<blockquote>
<ol>
<li>It logically represents a business activity with a specified outcome.        </li>
<li>It is self-contained.        </li>
<li>It is a black box for its consumers.</li>
<li>It may consist of other underlying services.[3]</li>
</ol>
<p>Different services can be used in conjunction to provide the functionality of a large software application,[5] a principle SOA shares with modular programming. Service-oriented architecture integrates distributed, separately-maintained and -deployed software components. It is enabled by technologies and standards that facilitate components’ communication and cooperation over a network, especially over an IP network.</p>
</blockquote>
<p>SOA是一种软件设计风格，SOA包含了一些服务，服务是通过应用组件的形式，通过网络上的一些通信协议像向其他应用提供服务。不同的服务可以联合起来构成一个大型的应用，SOA遵循模块化编程，它的这种架构集成了分布式的，独自维护的，独自部署的软件组件。也是通过网络来通信的。</p>
<p>好像看起来SOA的和微服务的概念也没什么太大差别？</p>
<blockquote>
<p>In SOA, services use protocols that describe how they pass and parse messages using description metadata. This metadata describes both the functional characteristics of the service and quality-of-service characteristics. Service-oriented architecture aims to allow users to combine large chunks of functionality to form applications which are built purely from existing services and combining them in an ad hoc manner. A service presents a simple interface to the requester that abstracts away the underlying complexity acting as a black box. Further users can also access these independent services without any knowledge of their internal implementation.[6]</p>
</blockquote>
<p>在SOA里，服务是用元数据描述的服务的功能特性和质量特性。有没有想起wsdl实现的webservice？</p>
<p>SOA里有3个角色</p>
<ul>
<li>Service provider</li>
<li>Service broker, service registry or service repository</li>
<li>Service requester/consumer</li>
</ul>
<p>SOA可以借助webservice实现，通过标准的internet协议，通过网络来访问这些功能。比如SOAP，Jini，CORBA，Rest</p>
<p>有很多技术都可以实现SOA，比如</p>
<ul>
<li>Web services based on WSDL and SOAP</li>
<li>Messaging, e.g., with ActiveMQ, JMS, RabbitMQ</li>
<li>RESTful HTTP, with Representational state transfer (REST) constituting its own constraints-based architectural style</li>
<li>OPC-UA</li>
<li>WCF (Microsoft’s implementation of Web services, forming a part of WCF)</li>
<li>Apache Thrift</li>
<li>SORCER</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>SOA已经被Web Service合并了，然而Web Service只是实现SOA的一种方式。在缺乏本地或二进制的数据传递调用的情况下，远程调用和效率都会变慢。XML是比较慢的，JSON相比XML会好一些。</p>
<p>有状态的服务不利于管理。</p>
<p>SOA主要的挑战是元数据的管理，服务于服务之间的通信会生成大量的消息。</p>
<p>难以测试。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务是现代化的SOA架构，用于构建分布式的软件系统。在微服务架构中的服务都是一些进程，它们之间是通过网络来进行通信去完成一个目标。这些服务使用技术不可知的协议，在服务内部去封装语言和框架。微服务是一种SOA的一种新的实现方式，从2014年开始变得流行起来（在引入DevOps后）。它强调的是持续的部署和其他敏捷的实现。</p>
<p>微服务没有统一的定义，但是有以下特征和原则</p>
<ul>
<li>fine-grained interfaces (to independently deployable services),</li>
<li>business-driven development (e.g. domain-driven design),</li>
<li>IDEAL cloud application architectures,</li>
<li>polyglot programming and persistence,</li>
<li>lightweight container deployment,</li>
<li>decentralized continuous delivery, and</li>
<li>DevOps with holistic service monitoring.</li>
</ul>
<h1 id="SOA和微服务的差异性"><a href="#SOA和微服务的差异性" class="headerlink" title="SOA和微服务的差异性"></a>SOA和微服务的差异性</h1><h2 id="文章1"><a href="#文章1" class="headerlink" title="文章1"></a>文章1</h2><p><a href="https://www.ibm.com/blogs/cloud-computing/2018/09/06/soa-versus-microservices/">https://www.ibm.com/blogs/cloud-computing/2018/09/06/soa-versus-microservices/</a></p>
<blockquote>
<p>The main distinction comes down to scope. To put it simply, service-oriented architecture (SOA) has an enterprise scope, while the microservices architecture has an application scope.</p>
</blockquote>
<p>SOA着重点在企业范围，微服务着重点在应用范围。</p>
<p><img src="https://www.ibm.com/blogs/cloud-computing/wp-content/uploads/2018/08/SOA_microservices.png"></p>
<p>从这个图可以看出来，SOA的范围更大，他关注的是应用与应用之间的关系。而微服务是应用内部的关联。</p>
<h2 id="文章2"><a href="#文章2" class="headerlink" title="文章2"></a>文章2</h2><p><a href="https://dzone.com/articles/microservices-vs-soa-is-there-any-difference-at-al">https://dzone.com/articles/microservices-vs-soa-is-there-any-difference-at-al</a></p>
<blockquote>
<p>Service Oriented Architecture is less about how to modularize an application, and more about how to compose an application by integration of distributed, separately-maintained and deployed software components. It is enabled by technologies and standards that make it easier for components to communicate and cooperate over a network, especially an IP network.</p>
</blockquote>
<p><img src="/img/spring-cloud/sc01-1.jpg"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud微服务-3-SpringBoot源码初探</title>
    <url>/2019/10/13/springcloud/microservices-3/</url>
    <content><![CDATA[<h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h1><p>Class that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application:</p>
<ul>
<li>Create an appropriate ApplicationContext instance (depending on your classpath)</li>
<li>Register a CommandLinePropertySource to expose command line arguments as Spring properties</li>
<li>Refresh the application context, loading all singleton beans</li>
<li>Trigger any CommandLineRunner beans</li>
</ul>
<a id="more"></a>


<p> SpringApplications can read beans from a variety of different sources. It is generally recommended that a single @Configuration class is used to bootstrap your application, however, you may also set sources from:</p>
<ul>
<li>The fully qualified class name to be loaded by AnnotatedBeanDefinitionReader</li>
<li>The location of an XML resource to be loaded by XmlBeanDefinitionReader, or a groovy script to be loaded by GroovyBeanDefinitionReader</li>
<li>The name of a package to be scanned by ClassPathBeanDefinitionScanner</li>
</ul>
<p>除了用@Configuration标记的类可以启动应用，还有上面介绍的3种方式可以启动应用。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>看看构造方法的说明：</p>
<blockquote>
<p>Create a new SpringApplication instance. The application context will load beans from the specified primary sources (see class-level documentation for details. The instance can be customized before calling run(String…).</p>
</blockquote>
<p>创建一个SpringApplication，应用上下文从指定的primary sources加载bean。</p>
<p>构造方法的实现里有一行this.webApplicationType=WebApplicationType.deduceFromClasspath();，这行决定了应用是用的什么web容器启动的，非web环境，Servlet容器，或者Reactive（Spring 5新增的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">	Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">	<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">			ApplicationContextInitializer.class));</span><br><span class="line">	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>里面的具体内容都干了些什么。</p>
<p>从getSpringFactoriesInstances方法代码里执行跟到SpringFactoriesLoader.loadSpringFactories这个方法中，有行很关键的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">					</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The location to look for factories.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;					</span><br></pre></td></tr></table></figure>

<p>urls就包含了所有jar包里的spring.factories文件。</p>
<p>SpringFactoriesLoader是框架内部用来加载工厂的一种机制，它会读取META-INF/spring.factories这个文件的内容，这个文件存在于多个jar文件中（所有的spring.factories都会被读取并加载），随便看一个，比如spring-boot-autoconfigure-2.1.4.RELEASE.jar里的，定义了7种类型的类，Spring会去加载这个文件中定义的工厂信息配置文件，左边都是接口或者抽象类，右边都是具体的实现类。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Listeners</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line"><span class="attr">....</span></span><br></pre></td></tr></table></figure>

<p>在读取了这些文件内容以后，文件里的内容就会作为缓存把数据放入到<code>private static final Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</code>中。</p>
<p>接下来，就获取了key为<code>org.springframework.context.ApplicationContextInitializer</code>的类列表。</p>
<p>这里也对应了前面提到过的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">				ApplicationContextInitializer.class));</span><br></pre></td></tr></table></figure>


<p>后面就是通过反射的方式来创建这些ApplicationContextInitializer工厂类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">				classLoader, args, names);</span><br></pre></td></tr></table></figure>


<p>再下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>也是一样的逻辑，只不过这次是从缓存里获取的class名称了。</p>
<p>到这里ApplicationContextInitializer和ApplicationListener都实例化完成。</p>
<p>再往下面看<code>this.mainApplicationClass = deduceMainApplicationClass();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">		<span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;main&quot;</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">				<span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// Swallow and continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>万万没想到，Spring Boot竟然是通过这种方式来找到main方法所在类的，直接new一个RuntimeException()，然后从堆栈里去找main方法所在的类。</p>
<p>SpringApplication对象构造完成后，接下来就调用了run()方法。</p>
<h2 id="run-方法-amp-ApplicationContext"><a href="#run-方法-amp-ApplicationContext" class="headerlink" title="run()方法&amp; ApplicationContext"></a>run()方法&amp; ApplicationContext</h2><p>运行Spring应用，创建并且刷新一个新的ApplicationContext，在run方法中执行了很多代码，下面一一进行分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先就声明了变量，ConfigurableApplicationContext context = null;</p>
<p><code>ApplicationContext</code>是Spring里非常重要的一个接口，看看它的注释。</p>
<p>是一个中心的接口，为一个应用提供了配置。当应用在运行的时候，它是只读的，但是如果实现支持的话，可以被重新加载。</p>
<p>提供的功能如下：</p>
<ul>
<li>提供了访问应用组件的bean工厂方法，继承自ListableBeanFactory</li>
<li>加载文件资源的能力，继承自 ResourceLoader接口</li>
<li>向注册的监听器发布事件的能力，继承自ApplicationEventPublisher接口</li>
<li>解析消息的能力，支持国际化，继承自MessageSource接口</li>
<li>继承父上下文的相关信息。子上下文有更高的优先级</li>
</ul>
<p>ConfigurableApplicationContext会被大多数应用上下文实现，比<code>ApplicationContext</code>又多补充了些功能。</p>
<p>再往下就是异常报告器，用于支持对SpringBootApplication启动错误的报告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>再往下的代码，就是将系统属性设置为无头模式，表示是没有界面的服务器程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureHeadlessProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(</span><br><span class="line">            SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(<span class="keyword">this</span>.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码，获取了非常重要的<code>SpringApplicationRunListener</code>，这个监听器提供了很多应用生命周期不同阶段的事件监听，例如启动，上下文加载后，停止等。而这里的<code>SpringApplicationRunListener</code>正是读取的<code>spring.factories</code>文件中定义的监听器。紧接着就触发了启动事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br></pre></td></tr></table></figure>

<p>在后续的几行代码也可以看到对listeners的environmentPrepared，contextPrepared，contextLoaded，started，running等方法的调用。</p>
<p>如下图，EventPublishingRunListener会去SimpleApplicationEventMulticaster发送真正的event事件，这是设计模式中的观察者模式在Spring应用中的体现。</p>
<p><img src="/img/spring-cloud/sc03-1.jpg"></p>
<p><img src="/img/spring-cloud/sc03-2.jpg"></p>
<p>ConfigurableEnvironment也是Spring中非常重要的一个组件，包含了2部分： profiles 和 properties，profile用来分组不同的属性，表示当前应用启动的环境，同一时刻只会有一个profile处于激活状态，例如dev,test,uat,prod等，property通常用${…}这种placeholder的方式被开发人员获取。</p>
<p>prepareEnvironment方法里面就会调用这2个方法，对property和profile进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configurePropertySources(environment, args);</span><br><span class="line">configureProfiles(environment, args);</span><br></pre></td></tr></table></figure>

<p>然后就是banner的打印，默认打印的代码实现在SpringBootBanner里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Banner printedBanner &#x3D; printBanner(environment);</span><br></pre></td></tr></table></figure>

<p>创建应用上下文，会通过webApplicationType变量判断创建不同的上下文类型，然后准备、刷新上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context = createApplicationContext();</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br></pre></td></tr></table></figure>

<p>在prepareContext方法里，有logStartupInfo和logStartupProfileInfo打印启动的日志，加载profile的日志。</p>
<p>refreshContext就调用了ApplicationContext的refresh方法，对上下文里的东西做了很多初始化。</p>
<p>最后，stopWatch.stop();记录了应用启动的耗时，并进行日志打印，到此，SpringBoot应用启动流程完成。</p>
<p>callRunners触发调用我们自定义的ApplicationRunner和CommandLineRunner，等于是应用启动完成之后的回调。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud微服务-4-SpringBoot日志，JSP，WebSocket等</title>
    <url>/2019/11/23/springcloud/microservices-4/</url>
    <content><![CDATA[<h2 id="SpringBoot日志处理"><a href="#SpringBoot日志处理" class="headerlink" title="SpringBoot日志处理"></a>SpringBoot日志处理</h2><p>默认情况下，SpringBoot会引入spring-boot-starter-logging，也就是logback的日志实现。</p>
<p>在resources下新建<code>logback-spring.xml</code>可以自定义日志配置，这是约定的文件名字。</p>
<p>在spring-boot-starter-logging-2.1.4.RELEASE这个依赖中，在/org/springframework/boot/logging/logback/base.xml位置可以找到SpringBoot提供的一个默认配置，基于这个配置进行自定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.test.springlecture&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.test.springlecture&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<p>可以指定不同的springProfile，可以做到当在开发环境的时候打印debug日志，在生产的时候则打印info。</p>
<p>也可以直接在application.yml里配置日志级别：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h2 id="SprintBoot整合JSP"><a href="#SprintBoot整合JSP" class="headerlink" title="SprintBoot整合JSP"></a>SprintBoot整合JSP</h2><p>现在用JSP的项目应该已经很少了，大部分都是前后端分离的项目。不过SpringBoot还是提供了对JSP的支持。</p>
<p>在SpringBoot中访问jsp，需要新增一个依赖，没有这个依赖，SpringBoot是无法编译jsp文件的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;org.apache.tomcat.embed:tomcat-embed-jasper&#39;</span><br></pre></td></tr></table></figure>

<p>以及路径配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">view:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">/WEB-INF/jsp</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">.jsp</span></span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot整合WebSocket"><a href="#SpringBoot整合WebSocket" class="headerlink" title="SpringBoot整合WebSocket"></a>SpringBoot整合WebSocket</h2><p>SpringBoot对WebSocket也提供了强有力的支持，这里简单介绍一下如何在SpringBoot里开发WebSocket接口，首先引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;org.springframework.boot:spring-boot-starter-websocket&#39;,</span><br><span class="line">&#39;org.springframework.boot:spring-boot-starter-json&#39;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEchoService</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String echoFormat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEchoService</span><span class="params">(String echoFormat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.echoFormat = echoFormat != <span class="keyword">null</span> ? echoFormat : <span class="string">&quot;%s&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="keyword">this</span>.echoFormat, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是用户的业务代码，下面是要实现TextWebSocketHandler，对WebSocket连接进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoWebSocketHandler</span><span class="params">(EchoService echoService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.echoService = echoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接建立&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.close(CloseStatus.SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String echoMessage = echoService.getMessage(message.getPayload());</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> TextMessage(echoMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后对所有的类进行配置，注意添加@EnableWebSocket注解和实现WebSocketConfigurer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(webSocketHandler(), <span class="string">&quot;/echo&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EchoService <span class="title">echoService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultEchoService(<span class="string">&quot;You said \&quot;%s\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">webSocketHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EchoWebSocketHandler(echoService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试页面</p>
<p><a href="http://www.websocket.org/echo.html">http://www.websocket.org/echo.html</a></p>
<p><img src="/img/spring-cloud/sc04-1.png" alt="sc04-1"></p>
<h2 id="SpringBoot单元测试"><a href="#SpringBoot单元测试" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h2><p>SpringBoot为单元测试提供了非常方便的集成，引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;org.springframework.boot:spring-boot-starter-test&#39;</span><br></pre></td></tr></table></figure>



<p>编写单元测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpMockMvc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/api/person&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MockHttpServletRequest:</span><br><span class="line">      HTTP Method &#x3D; GET</span><br><span class="line">      Request URI &#x3D; &#x2F;api&#x2F;person</span><br><span class="line">       Parameters &#x3D; &#123;&#125;</span><br><span class="line">          Headers &#x3D; [Content-Type:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, Accept:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;]</span><br><span class="line">             Body &#x3D; null</span><br><span class="line">    Session Attrs &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">Handler:</span><br><span class="line">             Type &#x3D; com.test.springlecture.controller.MyController</span><br><span class="line">           Method &#x3D; public com.test.springlecture.domain.Person com.test.springlecture.controller.MyController.getPerson()</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">    Async started &#x3D; false</span><br><span class="line">     Async result &#x3D; null</span><br><span class="line"></span><br><span class="line">Resolved Exception:</span><br><span class="line">             Type &#x3D; null</span><br><span class="line"></span><br><span class="line">ModelAndView:</span><br><span class="line">        View name &#x3D; null</span><br><span class="line">             View &#x3D; null</span><br><span class="line">            Model &#x3D; null</span><br><span class="line"></span><br><span class="line">FlashMap:</span><br><span class="line">       Attributes &#x3D; null</span><br><span class="line"></span><br><span class="line">MockHttpServletResponse:</span><br><span class="line">           Status &#x3D; 200</span><br><span class="line">    Error message &#x3D; null</span><br><span class="line">          Headers &#x3D; [Content-Type:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;]</span><br><span class="line">     Content type &#x3D; application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">             Body &#x3D; &#123;&quot;id&quot;:18,&quot;name&quot;:&quot;张三&quot;,&quot;birthday&quot;:&quot;2019-11-23T09:59:18.761+0000&quot;&#125;</span><br><span class="line">    Forwarded URL &#x3D; null</span><br><span class="line">   Redirected URL &#x3D; null</span><br><span class="line">          Cookies &#x3D; []</span><br></pre></td></tr></table></figure>



<p>SpringBoot重要组件就介绍到这里，后面的文章会介绍Apache kafka的使用以及和SpringBoot应用的集成。</p>
<p>本文涉及到的源码：<a href="https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture">https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud微服务-5-SpringBoot整合Spring MVC</title>
    <url>/2020/01/30/springcloud/microservices-5/</url>
    <content><![CDATA[<p>本文涉及到的源码：<a href="https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture">https://github.com/sail-y/spring-cloud-lecture/tree/master/spring-lecture</a></p>
<p>拖延中。。。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Sleuth在异步线程中丢失traceId的解决方案</title>
    <url>/2018/12/29/springcloud/sleuth-lost-traceId/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天同事说在Hystrix的执行方法里打印日志的时候，Sleuth的traceId丢失了，产生了新的traceId，我第一反应是难道是因为Hystrix采用的是线程隔离模式，所以导致sleuth在线程切换的时候丢失了traceId吗？但是我记得Sleuth是针对是Hystrix处理过的，具体的处理的类就是<code>SleuthHystrixConcurrencyStrategy</code>。Spring Cloud Sleuth专门对Hystrix处理过线程切换上下文传递的问题。</p>
<a id="more"></a>

<p>所以我猜测可能是同事的业务代码里使用了线程池。经确认后确实有线程池代码，原因同样是线程上下文切换丢失了traceId。那么接下来就去找一找解决方案吧。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在Spring的官方文档中，我们找到了关于异步通讯的部分。</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/1.3.4.RELEASE/single/spring-cloud-sleuth.html#_asynchronous_communication">https://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/1.3.4.RELEASE/single/spring-cloud-sleuth.html#_asynchronous_communication</a></p>
<p>我也贴一下原文：</p>
<blockquote>
<h2 id="Executor-ExecutorService-and-ScheduledExecutorService"><a href="#Executor-ExecutorService-and-ScheduledExecutorService" class="headerlink" title="Executor, ExecutorService and ScheduledExecutorService"></a>Executor, ExecutorService and ScheduledExecutorService</h2></blockquote>
<blockquote>
<p>We’re providing LazyTraceExecutor, TraceableExecutorService and TraceableScheduledExecutorService. Those implementations are creating Spans each time a new task is submitted, invoked or scheduled.</p>
</blockquote>
<blockquote>
<p>Here you can see an example of how to pass tracing information with TraceableExecutorService when working with CompletableFuture:</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Long&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="comment">// perform some logic</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1_000_000L</span>;</span><br><span class="line">&#125;, <span class="keyword">new</span> TraceableExecutorService(executorService,</span><br><span class="line">	<span class="comment">// &#x27;calculateTax&#x27; explicitly names the span - this param is optional</span></span><br><span class="line">	tracer, traceKeys, spanNamer, <span class="string">&quot;calculateTax&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>Important</strong></p>
<p>Sleuth doesn’t work with parallelStream() out of the box. If you want to have the tracing information propagated through the stream you have to use the approach with supplyAsync(…) as presented above.</p>
</blockquote>
<p>大概意思就是Sleuth提供了一个<code>TraceableExecutorService</code>包装我们自己的ExecutorService，我们手动传入traceId等参数。并且在提交新的任务的时候，<code>TraceableExecutorService</code>会为我们创建新的Span，但是traceId是一致的。</p>
<p>所以大家在用Sleuth的时候，如果代码里有用到线程池、或者Spring Boot提供的@Async注解的时候，大家需要注意一下traceId丢失的问题，这样会导致链路无法追踪。</p>
<p>下面分别贴出两种情况的解决方案代码。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TraceableExecutorService traceableExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    traceableExecutorService = <span class="keyword">new</span> TraceableExecutorService(beanFactory, ThreadUtil.newExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getR</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    traceableExecutorService.execute(() -&gt; someMethod());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[demo,96d8ba3676199532,96d8ba3676199532] [ix-RedisGroup-1]</span><br><span class="line">[demo,96d8ba3676199532,d5538e854c35b369] [ix-redisGroup-1] </span><br><span class="line">[demo,96d8ba3676199532,96d8ba3676199532] [nio-5000-exec-3]</span><br></pre></td></tr></table></figure>

<p>第一行是Hystrix执行的时候打印的，第二行是异步线程执行的时候打印的，第三行是同步执行的时候打印的。</p>
<h2 id="Async注解"><a href="#Async注解" class="headerlink" title="@Async注解"></a>@Async注解</h2><p>用<code>TraceableExecutorService</code>包装线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExecutorConfig</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">		<span class="comment">// CUSTOMIZE HERE</span></span><br><span class="line">		executor.setCorePoolSize(<span class="number">7</span>);</span><br><span class="line">		executor.setMaxPoolSize(<span class="number">42</span>);</span><br><span class="line">		executor.setQueueCapacity(<span class="number">11</span>);</span><br><span class="line">		executor.setThreadNamePrefix(<span class="string">&quot;MyExecutor-&quot;</span>);</span><br><span class="line">		<span class="comment">// DON&#x27;T FORGET TO INITIALIZE</span></span><br><span class="line">		executor.initialize();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LazyTraceExecutor(<span class="keyword">this</span>.beanFactory, executor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赶紧查查代码里有没有这个问题吧</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot-admin</title>
    <url>/2017/08/12/springcloud/spring-boot-admin/</url>
    <content><![CDATA[<h1 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h1><p><a href="https://github.com/sail-y/spring-boot-admin-kotlin">Kotlin版本</a></p>
<p><a href="https://github.com/sail-y/spring-boot-admin">Java版本</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单的后台开发模板框架，具备用户管理，菜单管理和角色管理3个功能，权限控制到按钮层级。       </p>
<p>采用JWT+Spring Security进行权限验证和会话保持<br>项目基于Spring Boot+Mybatis+BootStrap+DataTables</p>
<p>前端代码不是我自己写的，后端有Kotlin和Java两个版本，Kotlin对Java生态的兼容比较好，我是先做的Java版，只花了一点时间就把Java版本’<strong>复制</strong>‘成了Kotlin版本。</p>
<a id="more"></a>

<h2 id="相关框架"><a href="#相关框架" class="headerlink" title="相关框架"></a>相关框架</h2><ul>
<li><a href="http://projects.spring.io/spring-boot/">Spring boot</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">Mybatis</a></li>
<li><a href="https://github.com/alibaba/druid">druid</a></li>
<li><a href="https://projectlombok.org/">lombok</a></li>
<li><a href="http://backbonejs.org/">backbone.js</a></li>
<li><a href="http://getbootstrap.com/">bootstrap</a></li>
<li><a href="https://datatables.net/">datatables</a></li>
</ul>
<h2 id="修改application-dev-yml里的数据库连接"><a href="#修改application-dev-yml里的数据库连接" class="headerlink" title="修改application-dev.yml里的数据库连接"></a>修改application-dev.yml里的数据库连接</h2><p>执行<code>mysql -uroot -p 数据库 &lt; dmc.sql</code>导入数据库脚本。</p>
<p>直接Run<code>DMCApplication</code>启动后访问：<a href="http://localhost:10000/">http://localhost:10000</a></p>
<p>帐号：admin<br>密码：111111</p>
<h2 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h2><p><img src="/img/login.png"><br><img src="/img/page1.png"><br><img src="/img/page2.png"></p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud OAuth2RestTemplate loadBalanced</title>
    <url>/2016/04/21/springcloud/spring-cloud-OAuth2RestTemplate-loadBalanced/</url>
    <content><![CDATA[<p>在项目中访问另一个微服务的时候我们可以这样用RestTemplate来调用其他服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br><span class="line">RestResponse response &#x3D; restTemplate.postForObject(&quot;http:&#x2F;&#x2F;user-service&#x2F;user&#x2F;getUser&quot;, para, User.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring cloud环境下，这个注入的restTemplate是具备了客户端负载均衡功能的，也会用到eureka服务发现功能，<code>user-service</code>就是服务的名称。<br>我的项目启用了oauth2认证。spring cloud也提供了一个<code>OAuth2RestTemplate</code>来很方便的调用其他服务。但是在我测试的时候一直报错<code>UnknownHost</code>，我猜测他肯定是没有用到loadBalanced和eureka的服务发现功能。我翻遍了官方文档也没有找到相关的说明。</p>
<p>Google搜了大半天后，看了作者在git也讨论过这个类loadBalanced功能之类的，还翻到一个没有什么用 @LoadBalanced<a href="https://github.com/spring-cloud/spring-cloud-security/issues/51">注解</a>，翻了半天源码后终于在<code>OAuth2LoadBalancerClientAutoConfiguration</code>这样一个类中发现了一点蛛丝马迹。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; LoadBalancerInterceptor.class, OAuth2RestTemplate.class &#125;)</span><br><span class="line">@ConditionalOnBean(LoadBalancerInterceptor.class)</span><br><span class="line">@AutoConfigureAfter(OAuth2AutoConfiguration.class)</span><br><span class="line">public class OAuth2LoadBalancerClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnProperty(value &#x3D; &quot;security.oauth2.resource.loadBalanced&quot;, matchIfMissing &#x3D; false)</span><br><span class="line">	protected static class UserInfoLoadBalancerConfig &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public UserInfoRestTemplateCustomizer loadBalancedUserInfoRestTemplateCustomizer(</span><br><span class="line">				final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">			return new UserInfoRestTemplateCustomizer() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void customize(OAuth2RestTemplate restTemplate) &#123;</span><br><span class="line">					List&lt;ClientHttpRequestInterceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;(</span><br><span class="line">							restTemplate.getInterceptors());</span><br><span class="line">					interceptors.add(loadBalancerInterceptor);</span><br><span class="line">					restTemplate.setInterceptors(interceptors);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到，只要配置了<code>security.oauth2.resource.loadBalanced</code>为<code>true</code>，我们的<code>OAuth2RestTemplate</code>就具有<code>LoadBalancer</code>功能了。我们先在<code>application.yml</code>中加上这样的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  oauth2:</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br></pre></td></tr></table></figure>

<p>然后注入这个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private OAuth2RestTemplate restTemplate;</span><br></pre></td></tr></table></figure>

<p>结果还是不行，一样的错误，难道这个类没有用吗，于是我在我的代码和<code>customize</code>方法初始化执行的时候打了2个断点，发现注入对象的根本就不是这个地方初始化使用的那个对象。又倒腾了好一会才找到，必须得注入一个bean名字为<code>userInfoRestTemplate</code>的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userInfoRestTemplate&quot;)</span><br><span class="line">private OAuth2RestTemplate restTemplate;</span><br></pre></td></tr></table></figure>

<p>终于可以正常使用了，不知道为什么这个配置并没有在文档中提到，估计以后会补上这个文档的。现在spring cloud的文档有些地方跟最新的代码也表现得不太一致，特别是spring security这一块，做的时候一定要多多注意。</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)eureka缓存细节以及生产环境的最佳配置</title>
    <url>/2018/04/14/springcloud/spring-cloud-eureka/</url>
    <content><![CDATA[<p>本文转自 <a href="http://bhsc881114.github.io/2018/04/01/eureka%E7%BC%93%E5%AD%98%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/">eureka缓存细节以及生产环境的最佳配置</a></p>
<p>作者：<a href="http://bhsc881114.github.io/">http://bhsc881114.github.io/</a></p>
<p>eureka作为spring cloud微服务架构里的注册中心，是非常核心的一个组件，它避免了复杂的选主算法，架构比较简单，搭个demo也确实很快，但是如果要用于生产环境，还是得注意很多东西，尤其是下线延迟…</p>
<a id="more"></a>

<h2 id="服务获取中的缓存问题"><a href="#服务获取中的缓存问题" class="headerlink" title="服务获取中的缓存问题"></a>服务获取中的缓存问题</h2><p>本节的内容都是从这个issue翻译的：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373">Documentation: changing Eureka renewal frequency WILL break the self-preservation feature of the server</a></p>
<h3 id="为什么修改client的默认心跳时间，会导致自我保护模式失效？"><a href="#为什么修改client的默认心跳时间，会导致自我保护模式失效？" class="headerlink" title="为什么修改client的默认心跳时间，会导致自我保护模式失效？"></a>为什么修改client的默认心跳时间，会导致自我保护模式失效？</h3><p>Eureka Service会认为客户端是以30s的频率来发送心跳的。服务端期望收到的最大心跳时间是：<br>n instances x 2(60s/30s) x threshold</p>
<p>如果是2个实例，Eureka会期望每分钟有：2 instances x 2 x 85% =3.4个心跳,也就是说需要3个心跳。<br>如果client的心跳改成15s，挂掉一个，另一个在1min内会发出4个心跳，而这时候的阈值还是3.4个，自我保护模式就失效了。<br>核心原因就是在Eureka Server计算期望心跳数的时候写死了每分钟的心跳间隔，即30秒，所以他永远会是*2(感觉像是新手写的代码啊啊啊 -_-)</p>
<p><img src="http://7xijc0.com1.z0.glb.clouddn.com/eureka-self.png"></p>
<p>还有一个参数可以调整，eureka.server.renewalThresholdUpdateIntervalMs，心跳阈值重新计算的周期，默认15分钟，可以改短一点，2min</p>
<h3 id="客户端首次注册时间为什么要30s？如何改进？"><a href="#客户端首次注册时间为什么要30s？如何改进？" class="headerlink" title="客户端首次注册时间为什么要30s？如何改进？"></a>客户端首次注册时间为什么要30s？如何改进？</h3><p>首次注册行为是和首次心跳绑定在一起的，首次心跳发送以后会收到not found的响应,client就知道还没注册过，client就会马上注册。首次心跳由参数<br>eureka.instance.leaseRenewalIntervalInSeconds控制的，默认30</p>
<p>可以通过eureka.client.initialInstanceInfoReplicationIntervalSeconds参数来加快首次注册的速度。他是控制首次改变实例状态（UP/DOWN ）的时间，启动的时候状态肯定是需要改变的，所以他可以用来加快首次注册速度，并且改变这个值不会影响到保护模式</p>
<p>另外如果你使用的是spring cloud eureka的话没首次注册延迟的问题，他会马上注册</p>
<h3 id="其他影响快速获取服务信息的因素"><a href="#其他影响快速获取服务信息的因素" class="headerlink" title="其他影响快速获取服务信息的因素"></a>其他影响快速获取服务信息的因素</h3><p><strong>【服务端缓存】</strong></p>
<p>因为服务端默认会有个read only response cache（下面会细说），每30秒更新一次(eureka.server.response-cache-update-interval-ms),所以可能注册了不是马上能看到（虽然通过rest api不能看到，但是你可以在web ui上看到，因为ui没有缓存）</p>
<p><strong>【客户端缓存】</strong></p>
<p>Eureka Client缓存的定期更新周期，他由eureka.client.registryFetchIntervalSeconds控制，默认30秒， 改成5秒</p>
<p><strong>【Ribbon缓存】</strong></p>
<p>如果你采用Ribbon来访问服务，那么这里会有个缓存（他的数据来源是本地Eureka Client缓存），他由ribbon. ServerListRefreshInterval控制，默认30秒， 改成2秒</p>
<h3 id="怎么更快的踢掉没有心跳的机器"><a href="#怎么更快的踢掉没有心跳的机器" class="headerlink" title="怎么更快的踢掉没有心跳的机器"></a>怎么更快的踢掉没有心跳的机器</h3><p>eureka.instance.leaseExpirationDurationInSeconds，这个值用来控制多久踢掉机器，默认是3个心跳周期，有点久，可以考虑改成2个，他不会影响到保护模式（如果开启自我保护模式，心跳间隔因为上面的bug不能改，只能改这个了 -_-）</p>
<hr>
<h2 id="服务端缓存细节"><a href="#服务端缓存细节" class="headerlink" title="服务端缓存细节"></a>服务端缓存细节</h2><p>Eureka内部的缓存分很多级，主要有registry、readWriterCacheMap、readOnlyCacheMap；另外还有一个维护最近180s增量的队列recentlyChangedQueue</p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>包括注册、取消注册等，都直接操作在registry上，同时也会更新recentlyChangedQueue和readWriterCacheMap</p>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>读默认是从readOnlyCacheMap读取，读不到的话再从readWriterCacheMap，还没有再从registry</p>
<h3 id="滥用缓存的读操作"><a href="#滥用缓存的读操作" class="headerlink" title="滥用缓存的读操作"></a>滥用缓存的读操作</h3><p>这个读操作的三级缓存结构，非常让人困惑，registry已经是ConcurrentHashMap，纯内存操作，性能非常高了，为什么前面还要加两级缓存；readWriterCacheMap的数据是在写入以后responseCacheAutoExpirationInSeconds(默认180)秒内失效，readOnlyCacheMap则是一个定时任务，每responseCacheUpdateIntervalMs(默认30)秒从readWriterCacheMap获取最新数据</p>
<h3 id="去掉readOnlyCacheMap"><a href="#去掉readOnlyCacheMap" class="headerlink" title="去掉readOnlyCacheMap"></a>去掉readOnlyCacheMap</h3><p>从CAP理论上看，Eureka是一个AP系统，但是在C层面这么弱，就是因为各种无谓的缓存造成的，看了下readWriterCacheMap去掉比较难，但是readOnlyCacheMap有一个开关useReadOnlyResponseCache，果断关掉！！</p>
<hr>
<h2 id="Time-Lag"><a href="#Time-Lag" class="headerlink" title="Time Lag"></a>Time Lag</h2><p>最后再来看下Eureka wiki中提到的2min time lag问题，其实分多个角度看，不一定是2min</p>
<h3 id="服务正常上线-修改，最大可能会有120s滞后"><a href="#服务正常上线-修改，最大可能会有120s滞后" class="headerlink" title="服务正常上线/修改，最大可能会有120s滞后"></a>服务正常上线/修改，最大可能会有120s滞后</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 30(首次注册 init registe) + 30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;120</span><br><span class="line">- 如果是在Spring Cloud环境下使用这些组件(Eureka, Ribbon)，不会有首次注册30秒延迟的问题，服务启动后会马上注册,所以从注册到发现，最多可能是90s。</span><br></pre></td></tr></table></figure>

<h3 id="服务异常下线：最大可能会有270s滞后"><a href="#服务异常下线：最大可能会有270s滞后" class="headerlink" title="服务异常下线：最大可能会有270s滞后"></a>服务异常下线：最大可能会有270s滞后</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 定时清理任务每eureka.server. evictionIntervalTimerInMs(默认60)执行一次清理任务</span><br><span class="line">- 每次清理任务会把90秒(3个心跳周期，eureka.instance.leaseExpirationDurationInSeconds)没收到心跳的踢除，但是根据官方的说法 ，因为代码实现的bug，这个时间其实是两倍，即180秒，也就是说如果一个客户端因为网络问题或者主机问题异常下线，可能会在180秒后才剔除</span><br><span class="line">- 读取端，因为readOnlyCacheMap以及客户端缓存的存在，可能会在30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)&#x3D;90</span><br><span class="line">- 所以极端情况最终可能会是180+90&#x3D;270</span><br></pre></td></tr></table></figure>

<h2 id="生产环境最佳配置"><a href="#生产环境最佳配置" class="headerlink" title="生产环境最佳配置"></a>生产环境最佳配置</h2><p>总结前面3点，经过梳理后，推荐的生产环境最佳配置如下：（可用于中小规模环境）：</p>
<h3 id="Eureka-Server端配置"><a href="#Eureka-Server端配置" class="headerlink" title="Eureka Server端配置"></a>Eureka Server端配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 中小规模下，自我保护模式坑比好处多，所以关闭它</span></span><br><span class="line">eureka.server.enableSelfPreservation=<span class="literal">false</span></span><br><span class="line"><span class="comment">## 心跳阈值计算周期，如果开启自我保护模式，可以改一下这个配置</span></span><br><span class="line"><span class="comment">## eureka.server.renewalThresholdUpdateIntervalMs=120000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 主动失效检测间隔,配置成5秒</span></span><br><span class="line">eureka.server.evictionIntervalTimerInMs=5000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line">eureka.instance.leaseRenewalIntervalInSeconds=5</span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds=10</span><br><span class="line"></span><br><span class="line"><span class="comment">## 禁用readOnlyCacheMap</span></span><br><span class="line">eureka.server. useReadOnlyResponseCache=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="服务提供者和client配置"><a href="#服务提供者和client配置" class="headerlink" title="服务提供者和client配置"></a>服务提供者和client配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line">eureka.instance.leaseRenewalIntervalInSeconds=5</span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds=10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定时刷新本地缓存时间</span></span><br><span class="line">eureka.client.registryFetchIntervalSeconds=5</span><br><span class="line"><span class="comment"># ribbon缓存时间</span></span><br><span class="line">ribbon.ServerListRefreshInterval=2000</span><br></pre></td></tr></table></figure>

<p>改成上面配置后:</p>
<ul>
<li><p>正常上线下线客户端最大感知时间：eureka.client.registryFetchIntervalSeconds+ribbon. ServerListRefreshInterval = 7秒</p>
</li>
<li><p>异常下线客户端最大感知时间：<br>2*eureka.instance.leaseExpirationDurationInSeconds+<br>eureka.server.evictionIntervalTimerInMs+<br>eureka.client.registryFetchIntervalSeconds+<br>ribbon. ServerListRefreshInterval = 32</p>
</li>
</ul>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 不停机发布服务(0-downtime Blue/Green deployments)</title>
    <url>/2018/04/14/springcloud/spring-cloud-gray/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目初期由于BUG和需求改动可能都会比较多，我们会很频繁的发布我们的应用。但是如果不进行处理，在升级的过程中会导致用户服务中断。</p>
<a id="more"></a>

<p>通常我们需要发布的内容如下：</p>
<ol>
<li>某一个服务BUG紧急修复。</li>
<li>某一个服务新的需求上线。</li>
</ol>
<p>实际上针对这两种情况，在传统的应用中我们是很容易做到不停机升级的。例如nginx负载均衡2台tomcat实例，在升级的时候切断其中一台访问，升级完成以后切换流量，再升级另外一台。但是我这里用的是Spring Cloud，所有的实例状态都维护在Eureka中，Eureka本身也提供了很多保护机制，所以你的服务在down掉的时候，不会立马从服务列表中剔除掉。具体的配置项可以周立老师一篇文章里查看：<a href="http://www.itmuch.com/spring-cloud-sum-eureka/">如何解决Eureka Server不踢出已关停的节点的问题</a>。</p>
<p>所以如果我们想要做到不停机去升级/发布一个服务，需要我们从Spring Cloud架构本身上着手去进行一些改造。我们需要去了解Eureka的使用方式，Spring Retry的使用，Spring Cloud的负载均衡规则等等，最终达到这个目的。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果一个不了解Spring Cloud的人来做这种不停机发布，比如运维部门的同事。他会将某个需要升级的实例新版本启动起来，然后将老版本的进程杀掉。但是因为Spring Cloud的特性，被干掉的实例并没有被踢出服务列表，客户端仍然会访问到一个不存在的实例，直接返回500错误。可能需要等1~2分钟以后才能恢复正常。</p>
<p>我们知道这个是因为Eureka的机制问题，但是它注定不可能做成实时感知上下线的。Eureka是通过定期扫描去下线已经down掉的服务，不过他的默认时间是60秒，我们可以优化这个配置，让它能比较快的感知到服务已经下线。</p>
<h2 id="关于Eureka的常见问题"><a href="#关于Eureka的常见问题" class="headerlink" title="关于Eureka的常见问题"></a>关于Eureka的常见问题</h2><ul>
<li><p>问题可以参考：<a href="http://www.itmuch.com/spring-cloud-sum-eureka/">Spring Cloud中，Eureka常见问题总结</a></p>
</li>
<li><p>生产环境最佳配置：<a href="http://www.saily.top/2018/04/14/spring-cloud-eureka/">eureka缓存细节以及生产环境的最佳配置</a></p>
</li>
</ul>
<p><strong>中小规模生产环境参考配置：</strong></p>
<p><strong>Eureka Server</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span>           <span class="comment"># 中小规模下，自我保护模式坑比好处多，所以关闭它</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">5000</span>       <span class="comment"># 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms）从服务列表中剔除</span></span><br><span class="line">    <span class="attr">use-read-only-response-cache:</span> <span class="literal">false</span>       <span class="comment"># 禁用readOnlyCacheMap</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">      <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span>      <span class="comment"># 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">      <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span>  <span class="comment"># 没有心跳的淘汰时间，10秒，即服务续约到期时间（缺省为90s）</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;defaultZone:http://peer2:8760/eureka/&#125;</span></span><br></pre></td></tr></table></figure>


<p><strong>Eureka Client</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span>      <span class="comment"># 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span>  <span class="comment"># 没有心跳的淘汰时间，10秒，即服务续约到期时间（缺省为90s）</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 向注册中心注册</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 服务清单的缓存更新时间，默认30秒一次</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;defaultZone:http://$&#123;DISCOVERY_URL:discovery&#125;:8761/eureka/&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过优化Eureka配置，服务在启动后能够较快的被使用上，Eureka也能较快的感知到服务以及下线并踢出服务列表。</p>
<h2 id="巧用Spring-Retry重试机制"><a href="#巧用Spring-Retry重试机制" class="headerlink" title="巧用Spring Retry重试机制"></a>巧用Spring Retry重试机制</h2><p>我在搜寻解决方案的时候，也看到了Github上讨论的一个issue：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1290">Best practices for using Eureka for 0-downtime Blue/Green deployments #1290</a>.</p>
<p>这里面讨论了利用重试机制去实现不停机发布的一种方式。前面的Eureka配置已经缩短了服务上线和服务下线的时间，但是这中间仍然一段延迟，可能还是会有请求随机访问一个不存在的服务实例上。</p>
<p>重试机制的原理就是利用Spring Cloud提供的重试机制在请求访问出现错误的时候自动重试当前实例或者其他实例，而不是直接返回错误。</p>
<p>主要配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment"># ribbon缓存时间</span></span><br><span class="line">  <span class="attr">ServerListRefreshInterval:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">30000</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">30000</span></span><br><span class="line">  <span class="comment"># 是否所有操作都重试</span></span><br><span class="line">  <span class="comment"># OkToRetryOnAllOperations: true</span></span><br><span class="line">  <span class="comment"># 重试负载均衡其他的实例最大重试次数,不包括首次server</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 同一台实例最大重试次数,不包括首次调用</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>但是这里要注意一点，<code>OkToRetryOnAllOperations</code>如果设置为true，那么ribbon超时时间最好设置长一点，否则post等请求如果超时会被提交多次，还要注意hystrix的超时时间要大于ribbion的超时时间，否则hystrix会先超时。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure>



<p>在不同的版本中，Spring Cloud的重试机制是比较混乱的，周立老师对重试机制的详细解释：<a href="http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/">http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/</a></p>
<p>Feign本身也具备重试能力，在早期的Spring Cloud中，Feign使用的是 <code>feign.Retryer.Default#Default()</code> ，重试5次。但Feign整合了Ribbon，Ribbon也有重试的能力，此时，就可能会导致行为的混乱。</p>
<p>Spring Cloud意识到了此问题，因此做了改进，将Feign的重试改为 <code>feign.Retryer#NEVER_RETRY</code> ，如需使用Feign的重试，只需使用Ribbon的重试配置即可。因此，对于Camden以及以后的版本，Feign的重试可使用如下属性进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>相关Issue可参考：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/467">https://github.com/spring-cloud/spring-cloud-netflix/issues/467</a></p>
<p>结合之前对Eureka配置的优化，我们就可以愉快的进行测试了，开启2个服务访问几次，可以发现随机访问。然后干掉一个服务，再次访问，依然没有问题，不会出现500等情况。Feign自动为我们选择了另外可用的服务发送了重试请求。</p>
<h2 id="灰度发布方案"><a href="#灰度发布方案" class="headerlink" title="灰度发布方案"></a>灰度发布方案</h2><p>还有一种特别的需求，我们除了想做到不停机发布，可能还需要做到某些用户测试新版本代码，实现降级、限流、滚动、灰度、AB、金丝雀等操作。我在Github上发现了一个开源的代码在一定程度上提供了很好的思路去做这个事情。地址：<a href="https://github.com/JeromeLiuLly/springcloud-gray">https://github.com/JeromeLiuLly/springcloud-gray</a></p>
<p>看这个实现方式可以看出来，他的方案是基于<a href="https://www.jianshu.com/p/37ee1e84900a">spring cloud 实践-降级、限流、滚动、灰度、AB、金丝雀等等等等</a>的方案做的。</p>
<p>因Spring Cloud都是客户端负载均衡，会从Eureka读取服务列表，然后通过一定的负载均衡规则来选择请求的服务器。这个方案就是重写了Ribbon负载均衡的策略，将一些自定义信息放入了Eureka的metdata-map中，在路由的时候根据这些信息来选择服务。我这里不再多说，大家可以自行去查看他们的文章和代码。</p>
<p>这个方案灵活性非常大，你可以根据自定义的信息来构建任何你想做的策略，去实现AB Test等等功能，甚至我在开发环境中也能使用。举个例子，因为我们的服务太多了，如果在本机开发的时候，关联的服务较多，要启动比较多的服务才能够进行开发和测试，可能机器会有点吃不消。我基于上述方案让开发的同学们在启动服务的上将本机的IP添加到<code>metadata-map</code>中，这样我在路由的时候判断客户端请求过来的IP是多少，如果跟实例里的信息匹配，那么所有来自这个IP请求就转发到开发同学启动的那台实例上。</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
        <tag>灰度发布</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)Spring Cloud 实践-降级、限流、滚动、灰度、AB、金丝雀等等等等</title>
    <url>/2018/04/14/springcloud/spring-cloud-green-blue/</url>
    <content><![CDATA[<h1 id="spring-cloud-实践"><a href="#spring-cloud-实践" class="headerlink" title="spring cloud 实践"></a>spring cloud 实践</h1><p>源码地址：<a href="https://github.com/charlesvhe/spring-cloud-practice">https://github.com/charlesvhe/spring-cloud-practice</a></p>
<a id="more"></a>

<p><img src="https://upload-images.jianshu.io/upload_images/6144762-b7706923f43d4642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="config-配置中心"><a href="#config-配置中心" class="headerlink" title="config 配置中心"></a>config 配置中心</h2><p>端口：8888，方便起见直接读取配置文件，生产环境可以读取git。application-dev.properties为全局配置。先启动配置中心，所有服务的配置（包括注册中心的地址）均从配置中心读取。</p>
<h2 id="consumer-服务消费者"><a href="#consumer-服务消费者" class="headerlink" title="consumer 服务消费者"></a>consumer 服务消费者</h2><p>端口：18090，调用服务提供者，为了演示header传递。</p>
<h2 id="core-框架核心包"><a href="#core-框架核心包" class="headerlink" title="core 框架核心包"></a>core 框架核心包</h2><p>核心jar包，所有微服务均引用该包，使用AutoConfig实现免配置，模拟生产环境下spring-cloud的使用。</p>
<h2 id="eureka-注册中心"><a href="#eureka-注册中心" class="headerlink" title="eureka 注册中心"></a>eureka 注册中心</h2><p>端口：8761，/metadata端点实现metadata信息配置。</p>
<h2 id="provider-服务提供者"><a href="#provider-服务提供者" class="headerlink" title="provider 服务提供者"></a>provider 服务提供者</h2><p>端口：18090，服务提供者，无特殊逻辑。</p>
<h2 id="zuul-网关"><a href="#zuul-网关" class="headerlink" title="zuul 网关"></a>zuul 网关</h2><p>端口：8080，演示解析token获得label并放入header往后传递</p>
<h1 id="实践：降级、限流、滚动、灰度、AB、金丝雀等等等等"><a href="#实践：降级、限流、滚动、灰度、AB、金丝雀等等等等" class="headerlink" title="实践：降级、限流、滚动、灰度、AB、金丝雀等等等等"></a>实践：降级、限流、滚动、灰度、AB、金丝雀等等等等</h1><p>我本人是从dubbo转过来的，经常看到社区里面拿dubbo和spring-cloud做对比，一对比就提到dubbo所谓的降级、限流功能。spring-cloud默认没有这个能力，让我们来扩展spring-cloud，使她具备比dubbo更牛逼的各种能力。</p>
<p>所谓的降级、限流、滚动、灰度、AB、金丝雀等等等等，在我看来无非就是扩展了服务路由能力而已。这里说的服务降级，说的是服务A部署多个实例，实例级别的降级限流。如果要做整个服务A的降级，直接采用docker自动扩容缩容即可。</p>
<p>我们先来看应用场景：</p>
<p>服务A 发布了1.0版，部署了3个实例A1、A2、A3，现在要对服务A进行升级，由1.0升级到2.0。先将A1服务流量关闭，使A2、A3负担；升级A1代码版本到2.0；将A1流量调整为1%，观察新版本运行情况，如果运行稳定，则逐步提升流量5%、10%直到完全放开流量控制。A2、A3重复上述步骤。</p>
<p>在上述步骤中，我们想让特别的人使用2.0，其他人还是使用1.0版，稳定后再全员开放。</p>
<p>我们想不依赖sleuth做链路跟踪，想自己实现一套基于ELK的链路跟踪。</p>
<p>我们还有各种千奇百怪的想法。。。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现这些想法，我们需要对spring-cloud的各个组件、数据流非常熟悉，这样才能知道该在哪里做扩展。一个典型的调用：外网-》Zuul网关-》服务A-》服务B。。。</p>
<p>spring-cloud跟dubbo一样都是客户端负载均衡，所有调用均由Ribbon来做负载均衡选择服务器，所有调用前后会套一层hystrix做隔离、熔断。服务间调用均用带LoadBalanced注解的RestTemplate发出。RestTemplate-》Ribbon-》hystrix</p>
<p>通过上述分析我们可以看到，我们的扩展点就在Ribbon，Ribbon根据我们的规则，选择正确的服务器即可。</p>
<p>我们先来一个dubbo自带的功能：基于权重的流量控制。dubbo自带的控制台可以设置服务实例粒度的半权，倍权。其实就是在客户端负载均衡时，选择服务器带上权重即可，spring-cloud默认是ZoneAvoidanceRule，优先选择相同Zone下的实例，实例间采用轮询方式做负载均衡。我们的想把基于轮询改为基于权重即可。接下来的问题是，每个实例的权重信息保存在哪里？从哪里取？dubbo放在zookeeper中，spring-cloud放在eureka中。我们只需从eureka拿每个实例的权重信息，然后根据权重来选择服务器即可。具体代码LabelAndWeightMetadataRule（先忽略里面的优先匹配label相关代码）。</p>
<h2 id="放入核心框架"><a href="#放入核心框架" class="headerlink" title="放入核心框架"></a>放入核心框架</h2><p>LabelAndWeightMetadataRule写好了，那么我们如何使用它，使之生效呢？有3种方式。</p>
<p>1）写个AutoConfig将LabelAndWeightMetadataRule声明成@Bean，用来替换默认的ZoneAvoidanceRule。这种方式在技术验证、开发测试阶段使用短平快。但是这种方式是强制全局设置，无法个性化。</p>
<p>2）由于spring-cloud的Ribbon并没有实现netflix Ribbon的所有配置项。netflix配置全局rule方式为：ribbon.NFLoadBalancerRuleClassName=package.YourRule，spring-cloud并不支持，spring-cloud直接到服务粒度，只支持SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.YourRule。我们可以扩展org.springframework.cloud.netflix.ribbon.PropertiesFactory修正spring cloud ribbon未能完全支持netflix ribbon配置的问题。这样我们可以将全局配置写到配置中心的application-dev.properties全局配置中，然后各个微服务还可以根据自身情况做个性化定制。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741%E3%80%82">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。</a></p>
<p>3）使用spring cloud官方建议的@RibbonClient方式。该方式仅存在于spring-cloud单元测试中（在我提问后，现在还存在于spring-cloud issue list）。具体代码参见DefaultRibbonConfiguration、CoreAutoConfiguration。</p>
<h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul</p>
<p>访问 <a href="http://localhost:8761/metadata.html">http://localhost:8761/metadata.html</a> 这是我手写的一个简单的metadata管理界面，分别设置两个provider实例的weight值（设置完需要一段2分钟才能生效），然后访问 <a href="http://localhost:8080/provider/user">http://localhost:8080/provider/user</a> 多刷几次来测试zuul是否按权重发送请求，也可以访问 <a href="http://localhost:8080/consumer/test">http://localhost:8080/consumer/test</a> 多刷几次来测试consumer是否按权重来调用provide服务。</p>
<h2 id="进阶，基于标签"><a href="#进阶，基于标签" class="headerlink" title="进阶，基于标签"></a>进阶，基于标签</h2><p>基于权重的搞定之后，接下来才是重头戏：基于标签的路由。入口请求含有各种标签，然后我们可以根据标签幻化出各种各样的路由规则。例如只有标注为粉丝的用户才使用新版本（灰度、AB、金丝雀），例如标注为中国的用户请求必须发送到中国的服务器（全球部署），例如标注为写的请求必须发送到专门的写服务实例（读写分离），等等等等，唯一限制你的就是你的想象力。</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><p>根据标签的控制，我们当然放到之前写的Ribbon的rule中，每个实例配置的不同规则也是跟之前一样放到注册中心的metadata中，关键是标签数据如何传过来。权重随机的实现思路里面有答案，请求都通过zuul进来，因此我们可以在zuul里面给请求打标签，基于用户，IP或其他看你的需求，然后将标签信息放入ThreadLocal中，然后在Ribbon Rule中从ThreadLocal拿出来使用就可以了。然而，按照这个方式去实验时，发现有问题，拿不到ThreadLocal。原因是有hystrix这个东西，回忆下hystrix的原理，为了做到故障隔离，hystrix启用了自己的线程，不在同一个线程ThreadLocal失效。那么还有什么办法能够将标签信息一传到底呢，想想之前有没有人实现过类似的东西，没错sleuth，他的链路跟踪就能够将spam传递下去，翻翻sleuth源码，找找其他资料，发现可以使用HystrixRequestVariableDefault，这里不建议直接使用HystrixConcurrencyStrategy，会和sleuth的strategy冲突。代码参见CoreHeaderInterceptor。现在可以测试zuul里面的rule，看能否拿到标签内容了。</p>
<p>这里还不是终点，解决了zuul的路由，服务A调服务B这里的路由怎么处理呢？zuul算出来的标签如何往后面依次传递下去呢，我们还是抄sleuth：把标签放入header，服务A调服务B时，将服务A header里面的标签放到服务B的header里，依次传递下去。这里的关键点就是：内部的微服务在接收到发来的请求时（zuul-》A，A-》B都是这种情况）我们将请求放入ThreadLocal，哦，不对，是HystrixRequestVariableDefault，还记得上面说的原因么：）。这个容易处理，写一个spring mvc拦截器即可，代码参见CoreHeaderInterceptor。然后发送请求时自动带上这个里面保存的标签信息，参见RestTemplate的拦截器CoreHttpRequestInterceptor。到此为止，技术上全部走通实现。</p>
<p>总结一下：zuul依据用户或IP等计算标签，并将标签放入header里向后传递，后续的微服务通过拦截器，将header里的标签放入RestTemplate请求的header里继续向后接力传递。标签的内容通过放入类似于ThreadLocal的全局变量（HystrixRequestVariableDefault），使Ribbon Rule可以使用。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>参见PreFilter源码，模拟了几个用户的标签，参见LabelAndWeightMetadataRule源码，模拟了OR AND两种标签处理策略。依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul</p>
<p>访问 <a href="http://localhost:8761/metadata.html">http://localhost:8761/metadata.html</a> 设置第一个provide 实例 orLabel为 CN,Test 发送请求头带入Authorization: emt 访问<a href="http://localhost:8080/provider/user">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第一个实例。访问<a href="http://localhost:8080/consumer/test">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第一个实例。</p>
<p>设置第二个provide 实例 andLabel为 EN,Male 发送请求头带入Authorization: em 访问<a href="http://localhost:8080/provider/user">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第二个实例。访问<a href="http://localhost:8080/consumer/test">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第二个实例。</p>
<p>Authorization头还可以设置为PreFilter里面的模拟token来做测试，至此所有内容讲解完毕，技术路线拉通，剩下的就是根据需求来完善你自己的路由策略啦。</p>
<p>作者：Charles_He<br>链接：<a href="https://www.jianshu.com/p/37ee1e84900a">https://www.jianshu.com/p/37ee1e84900a</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud基于用户和ip的灰度发布方案</title>
    <url>/2019/02/28/springcloud/spring-cloud-nepxion-gray/</url>
    <content><![CDATA[<h1 id="基于用户和ip的灰度发布方案"><a href="#基于用户和ip的灰度发布方案" class="headerlink" title="基于用户和ip的灰度发布方案"></a>基于用户和ip的灰度发布方案</h1><p>为了能够更好的解决系统新版本上线无法验证的风险，我们通常需要在升级的时候进行灰度发布，下面调研了一个上线灰度发布的流程。</p>
<p>下面先看一张图，然后再用一段文字描述整个发布的逻辑。</p>
<p><img src="/img/spring-cloud/%E7%81%B0%E5%BA%A6%E6%B5%81%E9%87%8FV2.jpg"></p>
<a id="more"></a>

<p>在正常情况下，用户的流量是可以随意打到A，A1，A2服务上的，A到B的流量，也是可以随意打的。<br>当灰度发布的开关打开以后，如图上所示，例如A3,B2,C4的链路为灰度路由的配置。此时将切断正常用户对A3,B2,C4的服务实例的访问，并且正常流量到A1以后，也不会再打到B2上。<br>当指定的测试账号访问系统的时候，所有的测试流量都会打到A3,B2,C4的链路服务实例上，第一步流量到A3以后，也不会将A调用B的流量打到B1的服务实例上。<br>当测试将这一组验证完毕后，即可将对配置进行修改，进而发布下一组。<br>当所有的实例都发布完成后，再将灰度发布开关关闭，此时，发布完成。<br>所有的这些操作，都可以在Apollo配置中心一键完成。</p>
<p>链路配置格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sevice-demo-a&quot;</span>: <span class="string">&quot;172.16.101.90:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sevice-demo-b&quot;</span>: <span class="string">&quot;172.16.101.90:5020&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>本方案基于Nepxion Discovery开发</p>
<blockquote>
<p>Nepxion Discovery is an enhancement for Spring Cloud Discovery on Eureka + Consul + Zookeeper + Nacos with Nacos + Apollo config for gray release, router and isolation 灰度发布、服务隔离、服务路由、服务权重、黑/白名单过滤 <a href="http://www.nepxion.com/">http://www.nepxion.com</a></p>
</blockquote>
<p>要了解灰度发布的原理，首先需要知道SpringCloud是基于Ribbon实现负载均衡算法的，以及是如何从注册中心拉取的服务列表。</p>
<p>灰度路由除了可以根据请求头来路由请求，也可以跟服务实例本身的版本号来决定路由。下面给出一个逻辑图，以及两个个源码解析的UML图。</p>
<p><img src="/img/spring-cloud/%E7%89%88%E6%9C%AC%E5%92%8CIP%E8%B7%AF%E7%94%B1%E9%80%BB%E8%BE%91.jpg" alt="版本和IP路由逻辑"></p>
<p><img src="/img/spring-cloud/%E7%89%88%E6%9C%AC%E5%8F%B7%E8%BF%87%E6%BB%A4%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%E9%80%BB%E8%BE%91.jpg" alt="版本号过滤服务列表逻辑"></p>
<p><img src="/img/spring-cloud/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%89%A7%E8%A1%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%84%E5%88%99%EF%BC%88%E6%9D%83%E9%87%8D%E9%80%BB%E8%BE%91%EF%BC%89.jpg" alt="根据请求头执行负载均衡规则（权重逻辑）"></p>
<p>nepxion本来就提供了良好的服务过滤扩展，所以我的代码就是核心的一个过滤策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本策略实现了当灰度开关开启，对服务实例的ip进行过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/01/02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrayIpDiscoveryEnabledStrategy</span> <span class="keyword">implements</span> <span class="title">DiscoveryEnabledStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IS_GRAY_USER = <span class="string">&quot;isGrayUser&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_IP = <span class="string">&quot;serviceIp&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GRAY_SWITCH = <span class="string">&quot;graySwitch&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceStrategyContextHolder serviceStrategyContextHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; serviceIpMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> graySwitch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;apollo.plugin.namespace&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String namespace;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = ConfigService.getConfig(namespace);</span><br><span class="line">        serviceIpMap = toMap(config.getProperty(SERVICE_IP, <span class="string">&quot;&#123;&#125;&quot;</span>));</span><br><span class="line">        graySwitch = config.getBooleanProperty(SWITCH, Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">        config.addChangeListener(changeEvent -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ip配置发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (changeEvent.isChanged(SERVICE_IP)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String newValue = changeEvent.getChange(SERVICE_IP).getNewValue();</span><br><span class="line">                <span class="keyword">final</span> String oldValue = changeEvent.getChange(SERVICE_IP).getOldValue();</span><br><span class="line">                log.info(<span class="string">&quot;service ip map changed, oldValue is &#123;&#125;, newValue is &#123;&#125;&quot;</span>, () -&gt; oldValue, () -&gt; newValue);</span><br><span class="line">                serviceIpMap = toMap(newValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开关发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (changeEvent.isChanged(GRAY_SWITCH)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String newValue = changeEvent.getChange(GRAY_SWITCH).getNewValue();</span><br><span class="line">                <span class="keyword">final</span> String oldValue = changeEvent.getChange(GRAY_SWITCH).getOldValue();</span><br><span class="line">                log.info(<span class="string">&quot;graySwitch changed, oldValue is &#123;&#125;, newValue is &#123;&#125;&quot;</span>, () -&gt; oldValue, () -&gt; newValue);</span><br><span class="line">                graySwitch = Boolean.valueOf(changeEvent.getChange(GRAY_SWITCH).getNewValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, Sets.newHashSet(SERVICE_IP, GRAY_SWITCH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Server server, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ip过滤</span></span><br><span class="line">        <span class="keyword">boolean</span> enabled = applyIpFilter(server, metadata);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当灰度开关打开后，正在灰度的region不能被正常流量访问到</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyIpFilter</span><span class="params">(Server server, Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!graySwitch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String appName = server.getMetaInfo().getAppName();</span><br><span class="line">        String ip = server.getHostPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ip匹配，灰度请求，灰度实例可访问</span></span><br><span class="line">        <span class="keyword">final</span> String ipHost = serviceIpMap.get(appName);</span><br><span class="line">        <span class="keyword">if</span> (ipHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> ipMatch = ip.equals(ipHost);</span><br><span class="line"></span><br><span class="line">            ServletRequestAttributes restAttributes = serviceStrategyContextHolder.getRestAttributes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非http请求</span></span><br><span class="line">            <span class="keyword">if</span> (restAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                log.info(<span class="string">&quot;The ServletRequestAttributes object is null, ignore to do gray ip filter for service=&#123;&#125;&quot;</span>, appName);</span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String isGrayUser = restAttributes.getRequest().getHeader(IS_GRAY_USER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无法识别是否是灰度用户</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(isGrayUser)) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                log.info(<span class="string">&quot;The isGrayUser header is null, ignore to do gray ip filter for service=&#123;&#125;&quot;</span>, appName);</span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 灰度用户</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.valueOf(isGrayUser)) &#123;</span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，通过访问</span></span><br><span class="line">                <span class="keyword">if</span> (ipMatch) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;found gray user request, service &#123;&#125; route to ip &#123;&#125;&quot;</span>, appName, ipHost);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ipMatch;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非灰度用户</span></span><br><span class="line">                <span class="comment">// ip和灰度实例匹配，不予访问</span></span><br><span class="line">                <span class="keyword">return</span> !ipMatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">toMap</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = getParametricTypeJavaType(String.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(str, javaType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JavaType <span class="title">getParametricTypeJavaType</span><span class="params">(Class... clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.getTypeFactory().constructParametricType(HashMap.class, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nepxion discovery框架的作者是个很用心的作者，我在开发的时候也遇到了一些问题，作者都耐心的和我一起分析，一一帮我解决了，推荐大家去Star，去学习。</p>
<p><a href="https://github.com/Nepxion/Discovery">https://github.com/Nepxion/Discovery</a></p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
        <tag>灰度发布</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Zuul中修改URI</title>
    <url>/2018/12/11/springcloud/zuul-change-uri/</url>
    <content><![CDATA[<h1 id="Zuul-修改URI"><a href="#Zuul-修改URI" class="headerlink" title="Zuul 修改URI"></a>Zuul 修改URI</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目中有一个需求，因为系统要进行重构，所以在重构期间网关需要判断URL请求的是老系统还是新系统。如果请求的是老系统那么就需要根据URL和参数在网关层对进行转换，也就是要修改成新系统的URL，并转发到新系统上去。如果请求的是新系统，那么则不做处理，进行相应的鉴权操作。</p>
<a id="more"></a>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在网上搜索了一番以后，发现zuul提供了一种方式，就是自定义一个Pre类型的Filter，然后写入这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.set(FilterConstants.REQUEST_URI_KEY, yourUri);</span><br></pre></td></tr></table></figure>

<p>经过我的测试，他确实可以修改URI，但是并不满足我的需求。</p>
<p>客户端请求的是/a/helloA，我在这里修改成/b/helloB，我会得到一个404错误。经过分析发现，它已经确定了/a/**开头对应的服务，然后在a服务里去找/b/helloB这个路径，所以得到的是一个404。我的需求是修改成b服务下的/helloB请求。</p>
<p>所以我必须在zuul解析/a/** -&gt;&gt; a服务之前就将路径修改了，经过一番探索，以及zuul自带的filter里的源码，我发现<code>PreDecorationFilter</code>里有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">		<span class="keyword">final</span> String requestURI = <span class="keyword">this</span>.urlPathHelper.getPathWithinApplication(ctx.getRequest());</span><br><span class="line">		Route route = <span class="keyword">this</span>.routeLocator.getMatchingRoute(requestURI);</span><br><span class="line">		<span class="keyword">if</span> (route != <span class="keyword">null</span>) &#123;</span><br><span class="line">			String location = route.getLocation();</span><br><span class="line">			<span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">				ctx.put(REQUEST_URI_KEY, route.getPath());</span><br><span class="line">				ctx.put(PROXY_KEY, route.getId());</span><br><span class="line">		.....</span><br></pre></td></tr></table></figure>

<p>这不就是获取URI，然后routeLocator获取匹配的Route的代码吗？</p>
<p>那我们跟进<code>this.urlPathHelper.getPathWithinApplication(ctx.getRequest());</code>，看看它是怎么获取URI的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPathWithinApplication</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	String contextPath = getContextPath(request);</span><br><span class="line">	String requestUri = getRequestUri(request);</span><br><span class="line">	String path = getRemainingPath(requestUri, contextPath, <span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Normal case: URI contains context path.</span></span><br><span class="line">		<span class="keyword">return</span> (StringUtils.hasText(path) ? path : <span class="string">&quot;/&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> requestUri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequestUri</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	String uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">		uri = request.getRequestURI();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> decodeAndCleanUriString(request, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现Spring是这样来获取URI的：<code>request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);</code></p>
<p>既然这样，那我们就可以自由发挥一下了。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>我的思路就是在执行<code>PreDecorationFilter</code>之前，将request的attribute中的<code>WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE</code>先设置一下。首先<code>PreDecorationFilter</code>的order是5，自定义的过滤得在它前面执行，接下来自定义一个过滤器吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceName2APIFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        <span class="keyword">final</span> String uri = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uri.contains(<span class="string">&quot;/helloB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">final</span> HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        <span class="comment">// 转发回到helloA</span></span><br><span class="line">        <span class="comment">// 将替换掉的url set进去,在对应的转发请求的url就会使用这个url</span></span><br><span class="line"></span><br><span class="line">        request.setAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE, <span class="string">&quot;/a/helloA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得标记@Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceName2APIFilter <span class="title">serviceName2APIFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceName2APIFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我测试了一下，成功了，需求解决。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul01-网关介绍和基本使用</title>
    <url>/2020/05/10/springcloud/zuul01/</url>
    <content><![CDATA[<h1 id="为什么微服务需要网关"><a href="#为什么微服务需要网关" class="headerlink" title="为什么微服务需要网关"></a>为什么微服务需要网关</h1><p>在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中聚合数据，而且服务的划分位置结构可能会有所改变。网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。</p>
<a id="more"></a>

<p>当然这只是网关众多功能中的一部分，它还可以做负载均衡，统一鉴权，协议转换，监控监测等一系列功能。</p>
<ol>
<li>统一安全认证</li>
<li>统一限流</li>
<li>统一降级</li>
<li>统一异常处理</li>
<li>统一请求统计</li>
<li>统一超时</li>
</ol>
<p><img src="/img/spring-cloud/sgxpes8edv.png" alt="sgxpes8edv"></p>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>用一张图过一下zuul的核心原理，Zuul是一个责任链模式</p>
<p><img src="/img/spring-cloud/Zuul%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Zuul核心原理"></p>
<p>过滤器前面的数字，表示执行的时候的顺序</p>
<h2 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h2><ul>
<li><p>-3：ServletDetectionFilter</p>
</li>
<li><p>-2：Servlet30WrapperFilter</p>
</li>
<li><p>-1：FromBodyWrapperFilter</p>
</li>
<li><p>1：DebugFilter</p>
</li>
<li><p>5：PreDecorationFilter</p>
</li>
</ul>
<h2 id="routing过滤器"><a href="#routing过滤器" class="headerlink" title="routing过滤器"></a>routing过滤器</h2><ul>
<li><p>10：RibbonRoutingFilter</p>
</li>
<li><p>100：SimpleHostRoutingFilter</p>
</li>
<li><p>500：SendForwardFilter</p>
</li>
</ul>
<h2 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h2><ul>
<li>1000：SendResponseFilter </li>
</ul>
<h2 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h2><ul>
<li>0：SendErrorFilter</li>
</ul>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="路由规则配置"><a href="#路由规则配置" class="headerlink" title="路由规则配置"></a>路由规则配置</h2><h3 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h3><p>SimpleHostRoutingFilter 往指定的地址路由</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SimpleHostRoutingFilter 往指定的地址跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/ServiceB/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">http://localhost:9090/ServiceB</span></span><br><span class="line"><span class="comment"># 这是配置连接到目标主机的最大http连接数，是用来配置http连接池的，默认是200</span></span><br><span class="line"><span class="meta">zuul.host.maxTotalConnections</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 就是每个主机的初始连接数，默认是20</span></span><br><span class="line"><span class="meta">zuul.host.maxPerRouteConnections</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure>

<h3 id="跳转路由"><a href="#跳转路由" class="headerlink" title="跳转路由"></a>跳转路由</h3><p>SendForwardFilter 往自己的接口跳转</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SendForwardFilter 往自己的接口跳</span></span><br><span class="line"><span class="meta">zuul.routes.demo.path</span>=<span class="string">/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.demo.url</span>=<span class="string">forward: /gateway/sayHello</span></span><br></pre></td></tr></table></figure>

<h3 id="Ribbon路由"><a href="#Ribbon路由" class="headerlink" title="Ribbon路由"></a>Ribbon路由</h3><p>RibbonRoutingFilter 基于Ribbon的服务路由</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RibbonRoutingFilter</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.serviceId</span>=<span class="string">ServiceB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line"><span class="meta">zuul.routes.ServiceB.path</span>=<span class="string">/demo/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h3><p>请求：test/**的路径，转发给zuul-test-service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRouteRuleConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">patternServiceRouteMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(<span class="string">&quot;(zuul)-(?&lt;test&gt;.+)-(service)&quot;</span>, <span class="string">&quot;$&#123;test&#125;/**&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="忽略路由"><a href="#忽略路由" class="headerlink" title="忽略路由"></a>忽略路由</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.ignoredPatterns</span>=<span class="string">/ServiceB/test</span></span><br></pre></td></tr></table></figure>

<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="请求头配置"><a href="#请求头配置" class="headerlink" title="请求头配置"></a>请求头配置</h3><p>默认情况下，zuul有些敏感的请求头不会转发给下游的服务，比如：Cookie、Set-Cookie、Authorization，也可以自己配置敏感请求头</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.sensitiveHeaders</span>=<span class="string">accept-language, cookie</span></span><br><span class="line"><span class="meta">zuul.routes.demo.sensitiveHeaders</span>=<span class="string">cookie</span></span><br></pre></td></tr></table></figure>

<h3 id="路由映射信息"><a href="#路由映射信息" class="headerlink" title="路由映射信息"></a>路由映射信息</h3><p>在Zuul项目中，引入actuator依赖，然后在配置文件中，将<code>management.security.enabled</code>设置为false，就可以访问<code>/actuator/routes</code>地址，然后可以看到路由的映射信息</p>
<h3 id="hystrix配置"><a href="#hystrix配置" class="headerlink" title="hystrix配置"></a>hystrix配置</h3><p>与Ribbon整合的时候，会使用Hystrix，可以在网关写统一的降级实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBFallbackProvider</span> <span class="keyword">implements</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 服务名，一般都设置全局的降级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;fallback&quot;</span>.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(MediaType.TEXT_PLAIN);</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ZuulFallbackProvider <span class="title">fallbackProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> ServiceBFallbackProvider();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ribbon客户端预加载"><a href="#ribbon客户端预加载" class="headerlink" title="ribbon客户端预加载"></a>ribbon客户端预加载</h3><p>默认情况下，第一次请求zuul才会初始化ribbon客户端，所以可以配置预加载</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.ribbon.eager-load.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><p>Zuul用的是ribbon+Hystrix，所以设置超时得考虑这2个组件的配置，而且hystrix的超时要考虑ribbon的重试次数和单次超时时间。</p>
<p>hystrix的超时时间计算公式如下：</p>
<p>(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">ribbon.ReadTimeout</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">ribbon.ConnectTimeout</span>=<span class="string">500</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetries</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetriesNextServer</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<p>如果不配置ribbon的超时时间，默认的hystrix超时时间是4000ms</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否要执行过滤器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">publici Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行过滤器&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在哪个阶段执行</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FilterConstants.ROUTE_TYPE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是过滤器的优先级</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyFilter <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="groovy动态加载过滤器"><a href="#groovy动态加载过滤器" class="headerlink" title="groovy动态加载过滤器"></a>groovy动态加载过滤器</h3><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.groovy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>增加代码配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zuulInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterLoader.getInstance().setCompiler(<span class="keyword">new</span> GroovyCompiler());</span><br><span class="line">    String scriptRoot = System.getProperty(<span class="string">&quot;zuul.filter.root&quot;</span>, <span class="string">&quot;groovy/filters&quot;</span>);</span><br><span class="line">    String refreshInterval = System.getProperty(<span class="string">&quot;zuul.filter.refreshInterval&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(scriptRoot.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        scriptRoot = scriptRoot + File.separator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FilterFileManager.setFilenameFilter(<span class="keyword">new</span> GroovyFileFilter());</span><br><span class="line">        FilterFileManager.init(Integer.parseInt(refreshInterval), scriptRoot + <span class="string">&quot;pre&quot;</span>, scriptRoot + <span class="string">&quot;route&quot;</span>, scriptRoot + <span class="string">&quot;post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.filter.root</span>=<span class="string">groovy/filters</span></span><br><span class="line"><span class="meta">zuul.filter.refreshInterval</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>

<p>然后将groovy编写的过滤器，放在<code>groovy/filters</code>文件夹下，几秒后就会生效。</p>
<h3 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.SendForwardFilter.route.disable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="EnableZuulServer"><a href="#EnableZuulServer" class="headerlink" title="@EnableZuulServer"></a>@EnableZuulServer</h3><p>会自动禁用掉PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter等过滤器</p>
<h3 id="error过滤器-1"><a href="#error过滤器-1" class="headerlink" title="error过滤器"></a>error过滤器</h3><p>在自定义的过滤器有异常可以抛一个ZuulException，然后写一个MyErrorController，继承BasicErrorController，统一处理异常。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</title>
    <url>/2020/06/04/springcloud/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B9%B6%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="记一次线上故障排查并解决-Spring-Cloud健康检查的坑"><a href="#记一次线上故障排查并解决-Spring-Cloud健康检查的坑" class="headerlink" title="记一次线上故障排查并解决(Spring Cloud健康检查的坑)"></a>记一次线上故障排查并解决(Spring Cloud健康检查的坑)</h1><p>今天下班在回家路上的时候，同事反馈他们的生产环境项目不停的在输出错误日志，一时半会没有找到原因，让我帮忙看看。我到家后登录VPN，打开了kibana查看日志，确实一直在报错，错误日志如下：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.io.IOException: 断开的管道    </span><br><span class="line">at sun.nio.ch.FileDispatcherImpl.write0(Native Method)    </span><br><span class="line">at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:<span class="number">47</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:<span class="number">93</span>)    </span><br><span class="line">at sun.nio.ch.IOUtil.write(IOUtil.java:<span class="number">65</span>)    </span><br><span class="line">at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:<span class="number">471</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:<span class="number">134</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:<span class="number">101</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:<span class="number">157</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:<span class="number">1276</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:<span class="number">670</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:<span class="number">607</span>)    </span><br><span class="line">at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:<span class="number">597</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:<span class="number">646</span>)    </span><br><span class="line">at org.apache.coyote.http11.filters.ChunkedOutputFilter.flush(ChunkedOutputFilter.java:<span class="number">169</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:<span class="number">252</span>)    </span><br><span class="line">at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:<span class="number">1564</span>)    </span><br><span class="line">at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:<span class="number">352</span>)    </span><br><span class="line">at org.apache.coyote.Response.action(Response.java:<span class="number">173</span>)    </span><br><span class="line">at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:<span class="number">317</span>)    </span><br><span class="line">... <span class="number">92</span> more </span><br></pre></td></tr></table></figure>

<p>搜索<code>ERROR</code>级别日志，看到的全是这个日志，而且有两个项目都在输出这个错误日志，询问同事后确定了几个问题：</p>
<ol>
<li>项目近期没有升级</li>
<li>这两个项目当前都没有人访问，也就是没有接口流量</li>
<li>这个日志似乎是有周期性的输出，1分钟~3分钟不等</li>
</ol>
<p>记录一下我自己的排查思路，首先项目没有流量，也没有人访问，<strong>但是这个错明显是有接口请求，并且是因为客户端主动断开链接导致的，这一点可以确定</strong>。那么再结合周期性的错误日志输出，我首先想到的是不是采集监控的端点，或者是健康检查的端点出问题了，于是我登录堡垒机，测试了一下问题项目的采集监控数据的接口，没有问题，健康检查端点也没有问题，都是可以访问的。</p>
<p>我们的项目是SpringCloud的，所以健康检查端点是：<code>/actuator/health</code>，但是我多刷新了几次，发现有的时候很慢，有的时候很快，慢的时候能达到十几二十秒，健康检查的结果才出来。因为我们的项目是接入了prometheus的，紧接着我又去看了下监控，没有发现问题（监控排除了健康检查端点的访问情况，因为如果是SLB的话每秒会检查10+次），于是我将Grafana中的条件做了调整，得到了健康检查端点的耗时情况。</p>
<p><img src="/img/spring-cloud/image-20200604221611065.png" alt="image-20200604221611065"></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>可以看得出来，健康检查端点的耗时确实很长，基本可以确定，上面异常产生的原因是因为consul在对服务进行心跳检查的时候，<strong>超时了</strong>。所以consul的agent主动断开了<code>/actuator/health</code>的请求，所以得到了 <code>java.io.IOException: Broken pipe</code>的错误。</p>
<p><img src="/img/spring-cloud/image-20200604222132779.png" alt="image-20200604222132779"></p>
<p>这一点从监控数据原文里也得到了确认，是健康检查的端点在输出异常日志。</p>
<h2 id="为什么健康检查端点会超时"><a href="#为什么健康检查端点会超时" class="headerlink" title="为什么健康检查端点会超时"></a>为什么健康检查端点会超时</h2><p>现在知道了原因，但是这只是表面现象，为什么健康检查会超时？这不太正常，之前都是好好的，为什么突然开始就一直超时了，于是我开始观察健康检查里都有些什么内容，发现有一个可能会比较耗时的东西。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mail&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;xxx.com:-1&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我对比了这两个出问题的项目，他们都有邮件的健康检查，我问了下同事，是不是只有这两个项目会用到发邮件的功能，而其他项目没有，同事确认说是的。</p>
<p>基本可以确认，就是因为邮件的健康检查导致的，可能因为网络或是什么原因，导致邮件服务器的健康检查比较慢，从而导致健康检查的端点也非常耗时。</p>
<p>所以联系了运维的同事，加上了以下配置，关闭了邮件的健康检查。因为邮件并不是核心的功能，所以先关闭掉，验证一下是否能解决问题。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.health.mail.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>在加入配置关闭邮件服务器的健康检查以后，重启服务，观察了5分钟日志，发现一切恢复如初，没有产生新的异常日志，健康检查的端点，也变得非常快了。</p>
<p><img src="/img/spring-cloud/image-20200604223511793.png" alt="image-20200604223511793"></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本次故障是因为邮件服务器的健康检查很慢，导致consul对服务进行心跳检查的时候超时，主动断开连接，然后定期的输出了 <code>java.io.IOException: Broken pipe</code>的异常日志。</p>
<p>关于SpringCloud提供的健康检查机制，其实大多数情况下，好多功能的检查都可以关闭，按需打开，举个例子，如果Redis挂掉了，这里整个服务的健康检查就会是<strong>DOWN</strong>了，会直接导致其他服务无法调用，但是实际上在业务中如果Redis挂掉的话，我们是会去做降级从数据库查询的，仍然可以为其他服务提供调用。</p>
<p>所以我们在项目里，完全可以把这些第三方中间件的健康检查默认给关闭掉。按需打开必要的健康检查选项。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">health:</span></span><br><span class="line">    <span class="attr">defaults:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 按需打开db或者redis等中间件健康检查</span></span><br><span class="line">    <span class="attr">db:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/2017/08/12/nio/nio1/</url>
    <content><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><blockquote>
<p>“对语言设计人员来说，创建好的输入／输出系统是一项特别困难的任务。”<br>――《Think in Java》</p>
</blockquote>
<p>下面一起来研究一下NIO的用法，先来一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> randomNumber = <span class="keyword">new</span> SecureRandom().nextInt(<span class="number">20</span>);</span><br><span class="line">            buffer.put(randomNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>以上代码会输出10个随机数，输出很简单，但是包含的逻辑却很丰富。</p>
<p>java的io现在分为2种:</p>
<ol>
<li>java.io</li>
<li>java.nio</li>
</ol>
<p>java.io中最为核心的一个概念是流(Stream)，面向流的编程，里面也大量运用了装饰模式，在java.io中。<strong>Java中一个流要么是输入流，要么是输出流，不可能同时既是输入流又是输出流。</strong>java.nio中拥有3个核心概念：Selector，Channel与Buffer。在java.nio中，我们是面向块（block）或是缓冲区（buffer）编程的。Buffer本身就是块内存，底层实现上，它实际上是个数组。<strong>数据的读、写都是通过Buffer来实现的。</strong></p>
<p>除了数组之外，Buffer还提供了对于数据的结构化访问方式，并且可以追踪到系统的读写过程。Java中的7种原生数据类型都有各自对应的Buffer类型，如IntBuffer，LongBuffer，ByteBuffer及CharBuffer等等，并没有BooleanBuffer类型。</p>
<p><code>Channel</code>指的是可以向其写入数据或是从中读取数据的对象，它类似于java.io中的Stream。所有数据的读写都是通过Buffer来进行的，永远不会出现直接向Channel写入数据的情况，或是直接从Channel读取数据的情况。与Stream不同的是，Channel是双向的，一个流只可能是InputStream或是OutputStream，Channel打开后则可以进行读取、写入或是读写。由于Channel是双向的，因此它能更好的反映出底层操作系统的真实情况；在linux系统中，底层操作系统的通道就是双向的。</p>
<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p>读取文件</p>
<p><strong>NioTest2.txt</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hello world welcome</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;NioTest2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过文件输入流可以获取到通道对象</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论读写都必须通过Buffer来操作</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 之前是往Buffer里面写，现在进行Buffer的读，所以要调用flip()方法</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Character: &quot;</span> + (<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>写入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;NioTest3.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] messages = <span class="string">&quot;hello world welcome, nihao&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> message : messages) &#123;</span><br><span class="line">            byteBuffer.put(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面2个例子，能看出一定的模式，就是数据一定是跟Buffer打交道的，然后再读或写到Channel中。</p>
<p>读： file-&gt;channel-&gt;buffer-&gt;filp()-&gt;打印内容<br>写： 数据-&gt;buffer-&gt;flip()-&gt;channel-&gt;输出到文件</p>
<h2 id="Buffer中的3个重要属性"><a href="#Buffer中的3个重要属性" class="headerlink" title="Buffer中的3个重要属性"></a>Buffer中的3个重要属性</h2><p>看实例中都调用了一句关键代码<code>filp()</code>，这个方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关于NIO Buffer中的3个重要状态属性的含义：position，limit与capacity。</p>
<ul>
<li>Buffer的capacity是指它所包含的元素的数量，capacity不可能为负数，也不会变化。</li>
<li>Buffer的limit是指第一个不能被读或者写的元素的索引，并且永远不会超过capacity。</li>
<li>Buffer的position是说下一个将要被读或者写的索引，不能为负数，并且不会超过limit。</li>
</ul>
<p>假设执行Buffer.allocate(6),下面看内存划分情况。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center">↑</td>
</tr>
<tr>
<td align="center">position</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center">capacity</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center">limit</td>
</tr>
</tbody></table>
<p>最后一个是虚拟的位置。</p>
<p>现在往Buffer中放入2个元素,记住position是下一个可以被读或者写的位置，所以应该是在索引为2的地方。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">↑</td>
<td></td>
<td></td>
<td></td>
<td align="center">↑</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">position</td>
<td></td>
<td></td>
<td></td>
<td align="center">capacity</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td align="center">limit</td>
</tr>
</tbody></table>
<p>再放2个元素。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">↑</td>
<td align="center"></td>
<td align="center">↑</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">position</td>
<td align="center"></td>
<td align="center">capacity</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">limit</td>
</tr>
</tbody></table>
<p>现在调用<code>flip()</code>，看看会发生什么事。</p>
<p>先把position归位,然后limit变为之前position的位置。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↑</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">↑</td>
<td align="center"></td>
<td align="center">↑</td>
</tr>
<tr>
<td align="center">position</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">limit</td>
<td align="center"></td>
<td align="center">capacity</td>
</tr>
</tbody></table>
<p>而且position是不会大于limit的，所以<code>hasRemaining()</code>的实现其实也很简单，当<br>position和limit相等的时候，表示Buffer的东西已经被读取完毕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean hasRemaining() &#123;</span><br><span class="line">    return position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel inputChannel = inputStream.getChannel();</span><br><span class="line">        FileChannel outputChannel = outputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果删除这行代码，第一次运行后position和limit是相等的，那么这个时候是不能再写入数据的了，所以read会返回0，导致死循环不停的重复写入数据到文件中</span></span><br><span class="line">            buffer.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先读取数据,返回值是每次读取的字节</span></span><br><span class="line">            <span class="keyword">int</span> read = inputChannel.read(buffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;read: &quot;</span> + read);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次读取完成后，调用clear()将position设置为0，limit归位。</span></span><br><span class="line">            <span class="comment">// 那么这个时候返回的read应该是-1，因为Channel里面已经没有数据了</span></span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == read) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转</span></span><br><span class="line">            <span class="comment">// position为0，limit为之前的position</span></span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入数据</span></span><br><span class="line">            outputChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        inputChannel.close();</span><br><span class="line">        outputChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过NIO读取文件涉及到3个步骤：</p>
<ol>
<li>从FileInputStream获取到FileChannel对象。</li>
<li>创建Buffer。</li>
<li>将数据从Channel读取到Buffer中。</li>
</ol>
<h2 id="绝对方法与相对方法"><a href="#绝对方法与相对方法" class="headerlink" title="绝对方法与相对方法"></a>绝对方法与相对方法</h2><p>绝对方法与相对方法的含义：</p>
<ol>
<li>相对方法：limit值与position值会在操作时被考虑到。</li>
<li>绝对方法：完全忽略掉limit值和position值。</li>
</ol>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO Buffer详解</title>
    <url>/2017/08/15/nio/nio2/</url>
    <content><![CDATA[<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>java NIO中的Buffer用于和NIO通道进行交互。数据从通道读入到缓冲区，从缓冲区写入到通道中。<br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>之前代码里面用到了<code>ByteBuffer</code>，实际上<code>ByteBuffer</code>不只是可以放byte在里面，也可以放别的类型数据，但是取出来的时候必须跟放进去的类型顺序也保持一致，否则会报错。(<code>BufferUnderflowException</code>)</p>
<h2 id="put-amp-get"><a href="#put-amp-get" class="headerlink" title="put &amp; get"></a>put &amp; get</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        buffer.putInt(<span class="number">15</span>);</span><br><span class="line">        buffer.putLong(<span class="number">50000000L</span>);</span><br><span class="line">        buffer.putDouble(<span class="number">14.123123</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;好&#x27;</span>);</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) <span class="number">2</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;的&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getDouble());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Slice-Buffer"><a href="#Slice-Buffer" class="headerlink" title="Slice Buffer"></a>Slice Buffer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffer的分片--slice()</span></span><br><span class="line"><span class="comment"> * Slice Buffer与原有Buffer共享相同的底层数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.position(<span class="number">2</span>);</span><br><span class="line">        buffer.limit(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会返回一个包含[2,6)原始数据的Buffer，任意修改2个Buffer的数据，对应都会发生变化</span></span><br><span class="line">        ByteBuffer sliceBuffer = buffer.slice();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sliceBuffer.capacity(); i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = sliceBuffer.get(i);</span><br><span class="line">            b *= <span class="number">2</span>;</span><br><span class="line">            sliceBuffer.put(i , b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出下面结果</span></span><br><span class="line"><span class="comment">//        0</span></span><br><span class="line"><span class="comment">//        1</span></span><br><span class="line"><span class="comment">//        4</span></span><br><span class="line"><span class="comment">//        6</span></span><br><span class="line"><span class="comment">//        8</span></span><br><span class="line"><span class="comment">//        10</span></span><br><span class="line"><span class="comment">//        6</span></span><br><span class="line"><span class="comment">//        7</span></span><br><span class="line"><span class="comment">//        8</span></span><br><span class="line"><span class="comment">//        9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="只读Buffer"><a href="#只读Buffer" class="headerlink" title="只读Buffer"></a>只读Buffer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只读Buffer,我们可以随时将一个普通Buffer调用asReadOnlyBuffer方法返回一个只读Buffer</span></span><br><span class="line"><span class="comment"> * 但不能将一个只读Buffer转换为读写Buffer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class java.nio.HeapByteBuffer</span></span><br><span class="line">        System.out.println(buffer.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class java.nio.HeapByteBufferR</span></span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"></span><br><span class="line">        readOnlyBuffer.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ReadOnlyBufferException</span></span><br><span class="line">        readOnlyBuffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO DirectBuffer详解</title>
    <url>/2017/08/17/nio/nio3/</url>
    <content><![CDATA[<h1 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h1><p>之前我们用ByteBuffer.allocate()看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HeapByteBuffer</code>是从堆上分配的内存空间创建的Buffer，实际上JDK还提供了另外一种方式ByteBuffer.allocateDirect()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><code>DirectByteBuffer</code>创建的buffer是从直接内存中开辟的空间分配，我们叫做堆外内存，不会被gc回收，里面用到了很多没有开源的sun的api。</p>
<p>new DirectByteBuffer()，这个对象本身是在堆上创建的，但是源码里的<br><code>base = unsafe.allocateMemory(size);</code>则是在堆外内存中分配的，那么java堆上的数据是如何找到堆外的数据的呢，一定是保存了一个地址，找了一下发现如下变量：</p>
<p><code>Buffer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Used only by direct buffers</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> hoisted here for speed in JNI GetDirectBufferAddress</span></span><br><span class="line"><span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure>

<p>说放在Buffer这个类里是为了效率。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>如果使用<em>HeapByteBuffer</em>在进行文件读写的时候，所有的数据都在Java堆上，然而操作系统不是直接处理堆上的数据，而是把堆上的数据拷贝到操作系统里（Java内存模型之外）某一块内存空间中，然后再把数据和IO设备进行交互。意思用<em>HeapByteBuffer</em>进行IO操作的时候中间多了一次数据拷贝的过程。</p>
<p>而使用<em>DirectByteBuffer</em>，因为数据本来就在堆外内存中，所以跟IO设备交互的时候没有拷贝的过程，提升了效率，这有一个专有名词，也就是<strong>零拷贝</strong>。</p>
<p>以下内容转自<a href="https://www.zhihu.com/question/57374068?utm_source=wechat_session&utm_medium=social&utm_campaign=ge13_1&utm_division=ge13_2">知乎</a>：</p>
<blockquote>
<p>DirectByteBuffer 自身是一个Java对象，在Java堆中；而这个对象中有个long类型字段address，记录着一块调用 malloc() 申请到的native memory。</p>
<p>HotSpot VM里的GC除了CMS之外都是要移动对象的，是所谓“compacting GC”。</p>
<p>如果要把一个Java里的 byte[] 对象的引用传给native代码，让native代码直接访问数组的内容的话，就必须要保证native代码在访问的时候这个 byte[] 对象不能被移动，也就是要被“pin”（钉）住。</p>
<p>可惜HotSpot VM出于一些取舍而决定不实现单个对象层面的object pinning，要pin的话就得暂时禁用GC——也就等于把整个Java堆都给pin住。HotSpot VM对JNI的Critical系API就是这样实现的。这用起来就不那么顺手。</p>
<p>所以 Oracle/Sun JDK / OpenJDK 的这个地方就用了点绕弯的做法。它假设把 HeapByteBuffer 背后的 byte[] 里的内容拷贝一次是一个时间开销可以接受的操作，同时假设真正的I/O可能是一个很慢的操作。</p>
<p>于是它就先把 HeapByteBuffer 背后的 byte[] 的内容拷贝到一个 DirectByteBuffer 背后的native memory去，这个拷贝会涉及 sun.misc.Unsafe.copyMemory() 的调用，背后是类似 memcpy() 的实现。这个操作本质上是会在整个拷贝过程中暂时不允许发生GC的，虽然实现方式跟JNI的Critical系API不太一样。（具体来说是 Unsafe.copyMemory() 是HotSpot VM的一个intrinsic方法，中间没有safepoint所以GC无法发生）。</p>
<p>然后数据被拷贝到native memory之后就好办了，就去做真正的I/O，把 DirectByteBuffer 背后的native memory地址传给真正做I/O的函数。这边就不需要再去访问Java对象去读写要做I/O的数据了。</p>
</blockquote>
<h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p><em>DirectBuffer</em>是继承于<em>MappedByteBuffer</em>的，内存映射文件是一种允许Java直接从内存访问的特殊文件，操作系统再负责将内存的改动写入的IO设备中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MappedByteBuffer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;NioTest9.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将文件映射到内存中，就可以在内存中直接修改文件了</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>)<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行完成会直接修改<em>NioTest9.txt</em>中的内容。</p>
<h2 id="FileLock文件锁"><a href="#FileLock文件锁" class="headerlink" title="FileLock文件锁"></a>FileLock文件锁</h2><p>这个用的不多，共享锁是只读，都只能读，排他是只能自己读写，别人不能读也不能写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;NioTest10.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从索引3锁6个长度</span></span><br><span class="line">        <span class="comment">// true表示共享锁，false表示排他锁</span></span><br><span class="line">        FileLock fileLock = fileChannel.lock(<span class="number">3</span>, <span class="number">6</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;valid: &quot;</span> + fileLock.isValid());</span><br><span class="line">        System.out.println(<span class="string">&quot;lock type: &quot;</span> + fileLock.isShared());</span><br><span class="line"></span><br><span class="line">        fileLock.release();</span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Scattering-amp-Gathering"><a href="#Scattering-amp-Gathering" class="headerlink" title="Scattering &amp; Gathering"></a>Scattering &amp; Gathering</h2><p>之前的例子中在进行读写的时候，都是用的一个Buffer对象来完成的，Buffer的Scattering(散开)，可以接受传递一个Buffer的数组。比如我要把Channel中的信息读到Buffer中，那么channel里面有20个字节，传递一个Buffer数组，往里面读信息，第一个数组长度是10，第二个数组长度是5，第三个长度也是5，它会按顺序将第一个Buffer读满，再接着往第二个读，再读第三个。就是将一个Channel中的数据读取到多个Buffer中。而Gathering则是相反的，他是写操作，先将第一个Buffer写到Channel中，然后也是顺序写入后面的channel。</p>
<p>下面用一个网络IO的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于Buffer的Scattering与Gathering</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        ByteBuffer[] buffers = <span class="keyword">new</span> ByteBuffer[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        buffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">        buffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">        buffers[<span class="number">2</span>] = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (bytesRead &lt; messageLength) &#123;</span><br><span class="line">                <span class="comment">// 数组类型的读</span></span><br><span class="line">                <span class="keyword">long</span> r = socketChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">                bytesRead += r;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;bytesRead: &quot;</span> + bytesRead);</span><br><span class="line"></span><br><span class="line">                Stream.of(buffers)</span><br><span class="line">                        .map(buffer -&gt; <span class="string">&quot;position: &quot;</span> + buffer.position() + <span class="string">&quot;, limit: &quot;</span> + buffer.limit())</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Stream.of(buffers).forEach(Buffer::flip);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> bytesWritten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (bytesWritten &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> r = socketChannel.write(buffers);</span><br><span class="line">                bytesWritten += r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Stream.of(buffers).forEach(Buffer::clear);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;bytesRead:  &quot;</span> + bytesRead + <span class="string">&quot;， byteWritten: &quot;</span> + bytesWritten + <span class="string">&quot;, messageLength: &quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nc localhost 8899</code></p>
<p><code>telnet localhost 8899</code></p>
<p>这2个命令都可以进行刚才的程序测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc localhost 8899</span><br><span class="line">hellowor</span><br><span class="line">hellowor</span><br></pre></td></tr></table></figure>

<p>回车也算一个字节，所以输入<em>hellowor</em>后，程序马上回写了数据。控制台输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bytesRead: 9</span><br><span class="line">position: 2, <span class="built_in">limit</span>: 2</span><br><span class="line">position: 3, <span class="built_in">limit</span>: 3</span><br><span class="line">position: 4, <span class="built_in">limit</span>: 4</span><br><span class="line">bytesRead:  9， byteWritten: 9, messageLength: 9</span><br></pre></td></tr></table></figure>

<p>现在程序依旧在等待输入，我们继续输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>这里先输入一个<em>hello</em>+回车，再输入<em>a</em>+回车，再回车，进行了3次操作，也一共是9个字节，数据进行了回写，接下来看控制台的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bytesRead: 6</span><br><span class="line">position: 2, <span class="built_in">limit</span>: 2</span><br><span class="line">position: 3, <span class="built_in">limit</span>: 3</span><br><span class="line">position: 1, <span class="built_in">limit</span>: 4</span><br><span class="line">bytesRead: 8</span><br><span class="line">position: 2, <span class="built_in">limit</span>: 2</span><br><span class="line">position: 3, <span class="built_in">limit</span>: 3</span><br><span class="line">position: 3, <span class="built_in">limit</span>: 4</span><br><span class="line">bytesRead: 9</span><br><span class="line">position: 2, <span class="built_in">limit</span>: 2</span><br><span class="line">position: 3, <span class="built_in">limit</span>: 3</span><br><span class="line">position: 4, <span class="built_in">limit</span>: 4</span><br><span class="line">bytesRead:  9， byteWritten: 9, messageLength: 9</span><br></pre></td></tr></table></figure>

<p>第一次输入<em>hello</em>+回车的时候，输入了6个字节，0、1索引的buffer读满了，2索引的buffer读取了一个位置，再敲入<em>a</em>+回车，2索引的Buffer还剩一个位置，此时再敲入回车，Buffer全部读满，Buffer开始进行写入操作。</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO Selector</title>
    <url>/2017/08/23/nio/nio4/</url>
    <content><![CDATA[<p>参考：<a href="http://blog.csdn.net/lianjiww/article/details/53540145">http://blog.csdn.net/lianjiww/article/details/53540145</a></p>
<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>NIO的三大组件Channel、Buffer、Selector已经讲了2个了，接着我们一起探索一下Selector。</p>
<p>Selector（选择器）是Java NIO的一个组件，能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源。因此，使用的线程越少越好。</p>
<h2 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h2><p>通过调用Selector.open()方法创建一个Selector，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Selector里持有3个集合:</p>
<ol>
<li>key set 注册在Selector的所有通道。</li>
<li>selected-key set 准备好进行操作的通道。</li>
<li>cancelled-key set 准备取消的通道。</li>
</ol>
<h2 id="注册通道"><a href="#注册通道" class="headerlink" title="注册通道"></a>注册通道</h2><p>通过SelectableChannel.register()方法来注册，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>register()方法会返回一个SelectionKey 对象，这个对象代表了注册到该Selector的通道。<br>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。<br>register()方法的第二个参数是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，这四种事件用SelectionKey的四个常量来表示： </p>
<ol>
<li>Connect事件-SelectionKey.OP_CONNECT </li>
<li>Accept事件-SelectionKey.OP_ACCEPT </li>
<li>Read事件-SelectionKey.OP_READ </li>
<li>Write事件-SelectionKey.OP_WRITE </li>
</ol>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>register()方法返回的是一个SelectionKey对象，它包含了以下属性：</p>
<h3 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h3><p>interest集合是你所选择的感兴趣的事件集合。用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个给定的事件是否在interest 集合中，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</span><br></pre></td></tr></table></figure>


<h3 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h3><p>ready集合是通道已经准备就绪的操作的集合。从SelectionKey访问ready集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>

<p>可以用“位与”，来检测channel中什么事件或操作已经就绪，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>从SelectionKey访问Channel：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel channel = selectionKey.channel();</span><br></pre></td></tr></table></figure>

<h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><p>从SelectionKey访问Selector：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>

<h3 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h3><p>可以将一个对象或者更多信息附加到SelectionKey上，这样就能方便的识别某个给定的通道。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<p>还可以在向Selector注册Channel的时候附加对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h2 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a>选择通道</h2><p>向Selector注册了通道以后，可以用select()方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。select()方法有几个重载：</p>
<p><strong>int select()</strong><br>阻塞到至少有一个通道在你注册的事件上就绪了。 </p>
<p><strong>int select(long timeout)</strong><br>和select()一样，除了最长会阻塞timeout毫秒。 </p>
<p><strong>int selectNow()</strong><br>不会阻塞，不管什么通道就绪都立刻返回。如果自从前一次选择操作后，没有通道变成可选择的，则返回零。 </p>
<p>select()方法返回的int值表示自上次调用select()方法后有多少通道已经就绪。<br>调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以调用selectedKeys()方法，访问就绪通道，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ports = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        ports[<span class="number">0</span>] = <span class="number">5000</span>;</span><br><span class="line">        ports[<span class="number">1</span>] = <span class="number">5001</span>;</span><br><span class="line">        ports[<span class="number">2</span>] = <span class="number">5002</span>;</span><br><span class="line">        ports[<span class="number">3</span>] = <span class="number">5003</span>;</span><br><span class="line">        ports[<span class="number">4</span>] = <span class="number">5004</span>;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ports.length; i++) &#123;</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 配置成非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);</span><br><span class="line">            serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// register()会触发一个SelectionKey被添加到Selector的keys中，可以用selector.keys()查看。</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(selector.keys().size());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;监听端口： &quot;</span> + ports[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> numbers = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;numbers: &quot;</span> + numbers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备好的通道（有客户端连接了）</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 准备建立连接</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iter.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    iter.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;获得客户端连接： &quot;</span> + socketChannel);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 接收数据</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> read = socketChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">                        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">                        bytesRead += read;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;读取： &quot;</span> + bytesRead + <span class="string">&quot;, 来自于: &quot;</span> + socketChannel);</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子可以看出来，所有的操作都是主动或者被动的对SelectionKey的OP状态改变进行的操作，所以异步编程里面事件无处不在。</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 模拟聊天</title>
    <url>/2017/08/27/nio/nio5/</url>
    <content><![CDATA[<p>接下来看看如何用NIO来做一个模拟聊天，通过这个例子来更加理解NIO的使用方式，下面展示了服务端代码，用命令进行测试，然后再用NIO的方式编写客户端进行测试，对NIO的服务端和客户端的开发，都更加深入的理解。</p>
<a id="more"></a>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟聊天</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存客户端连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketChannel&gt; clientMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nums = selector.select();</span><br><span class="line">                <span class="comment">// 拿到触发OP_ACCEPT事件的SelectionKey集合，访问对应通道</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                selectionKeys.forEach(selectionKey -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> SocketChannel client;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 通道已连接</span></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                            ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                            client = server.accept();</span><br><span class="line">                            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">// 连接后注册读取事件</span></span><br><span class="line">                            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 每次有客户端连接后，生成一个ID并放入map中</span></span><br><span class="line">                            String key = <span class="string">&quot;[&quot;</span> + UUID.randomUUID().toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                            clientMap.put(key, client);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 通道有数据写入</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 已经变成SocketChannel</span></span><br><span class="line">                            client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">int</span> count = client.read(readBuffer);</span><br><span class="line">                            String senderKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (client == entry.getValue()) &#123;</span><br><span class="line">                                    senderKey = entry.getKey();</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                                String receivedMessage = String.valueOf(charset.decode(readBuffer).array());</span><br><span class="line">                                System.out.println(client + <span class="string">&quot;:&quot;</span> + receivedMessage);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                                    SocketChannel value = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                    ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                                    writeBuffer.put((senderKey + <span class="string">&quot;: &quot;</span> + receivedMessage).getBytes());</span><br><span class="line">                                    writeBuffer.flip();</span><br><span class="line"></span><br><span class="line">                                    value.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (receivedMessage.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                                    selectionKeys.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == -<span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="comment">// 判断是否客户端断开了连接</span></span><br><span class="line">                                clientMap.remove(senderKey);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次读取完成状态后必须清除，因为每一个selectionKey的channel只能被读取一次</span></span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这部分代码基本上NIO开发的模板式代码，服务端启动代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>));</span><br></pre></td></tr></table></figure>

<p>open()一个Selector后，channel调用register将自己注册到selector上，并传入<strong>SelectionKey.OP_ACCEPT</strong>表示等待连接。</p>
<p>接下来<code>selector.select();</code>会阻塞，直到有客户端连接，程序才会继续往下走，<code>selector.selectedKeys()</code>返回有状态变化可以被使用的keys，每一个判断分支后对应的channel可以强转为对应的Channel。</p>
<p>比如代码中注册为<strong>OP_ACCEPT</strong>的是ServerSocketChannel，而注册为<strong>OP_READ</strong>的是一个SocketChannel。最后不要忘记将selectedKeys清空，否则下次循环进入，遗留下来的selectKey.channel()是获取不到对应的Channel的。</p>
<p>用命令先测试一下，结果如下，一方发送一条消息后，都收到了消息输出，并且带上了连接的时候生成的客户端ID。</p>
<p><img src="/img/nio/nio5-1.png"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>NIO客户端的开发，代码跟服务端的差不多，只是由ServerSocketChannel，换成了SocketChannel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                selectionKeys.forEach(selectionKey -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 表示已经与服务端建立连接</span></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                            SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                            <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                                client.finishConnect();</span><br><span class="line"></span><br><span class="line">                                ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                                writeBuffer.put((LocalDateTime.now() + <span class="string">&quot; 连接成功&quot;</span>).getBytes());</span><br><span class="line">                                writeBuffer.flip();</span><br><span class="line"></span><br><span class="line">                                client.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                                ExecutorService executorService = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());</span><br><span class="line"></span><br><span class="line">                                executorService.submit(() -&gt; &#123;</span><br><span class="line">                                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                        writeBuffer.clear();</span><br><span class="line">                                        InputStreamReader input = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">                                        BufferedReader br = <span class="keyword">new</span> BufferedReader(input);</span><br><span class="line"></span><br><span class="line">                                        String sendMessage = br.readLine();</span><br><span class="line"></span><br><span class="line">                                        writeBuffer.put(sendMessage.getBytes());</span><br><span class="line">                                        writeBuffer.flip();</span><br><span class="line">                                        client.write(writeBuffer);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 发送完数据后，向selector注册读取事件，等待服务器的返回结果</span></span><br><span class="line">                            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                            SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                            ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">int</span> count = client.read(readBuffer);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                String receivedMessage = <span class="keyword">new</span> String(readBuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                                System.out.println(receivedMessage);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                selectionKeys.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动客户端后输出：</p>
<p><img src="/img/nio6-1.png"></p>
<p>mac用户会看到后面有很多框框，感觉有点奇怪，是哪里出问题了呢？</p>
<p>单独用一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChartSetTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] msg = <span class="string">&quot;中文&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        buffer.put(msg);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(msg));</span><br><span class="line">        System.out.println(String.valueOf(StandardCharsets.UTF_8.decode(buffer).array()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，真相就是buffer的数组在这里是6个字节，decode转换成中文以后，数组里就只有2个元素了，但是长度还是6，还有4个\u0000占位，可以在debug的时候看出来，这也就解释了前面的输出为什么会是那样了。</p>
<p><img src="/img/nio/nio6-2.jpg"></p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 编码和解码</title>
    <url>/2017/08/27/nio/nio6/</url>
    <content><![CDATA[<p>做过web开发的人一定遇到过中文乱码的问题，一般情况下我们都是直接把所有的编码都设置成UTF-8，可是并没有真正的去理解为什么会导致乱码的问题，这里一起研究一下编码和解码究竟是怎么一回事。</p>
<p>这段代码很简单，就是读取一个文件的内容，然后输出到另外一个文件里面。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java的编解码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/08/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String inputFile = <span class="string">&quot;NioTest13_In.txt&quot;</span>;</span><br><span class="line">        String outputFile = <span class="string">&quot;NioTest13_Out.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把一个文件拷贝到另一个文件</span></span><br><span class="line"></span><br><span class="line">        RandomAccessFile inputRandomAccessFile = <span class="keyword">new</span> RandomAccessFile(inputFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        RandomAccessFile outputRandomAccessFile = <span class="keyword">new</span> RandomAccessFile(outputFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> inputLength = <span class="keyword">new</span> File(inputFile).length();</span><br><span class="line"></span><br><span class="line">        FileChannel inputFileChannel = inputRandomAccessFile.getChannel();</span><br><span class="line">        FileChannel outputFileChannel = outputRandomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        MappedByteBuffer inputData = inputFileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inputLength);</span><br><span class="line"></span><br><span class="line">        Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">        CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line"></span><br><span class="line">        CharBuffer charBuffer = decoder.decode(inputData);</span><br><span class="line"></span><br><span class="line">        ByteBuffer outputData = encoder.encode(charBuffer);</span><br><span class="line"></span><br><span class="line">        outputFileChannel.write(outputData);</span><br><span class="line"></span><br><span class="line">        inputRandomAccessFile.close();</span><br><span class="line">        outputRandomAccessFile.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>但这里有很关键的几行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">CharsetEncoder encoder = charset.newEncoder();</span><br></pre></td></tr></table></figure>

<p><code>NioTest13_In.txt </code>读取的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,world</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>

<p>程序执行后，得到了正确的结果。</p>
<p>无论是用程序还是用工具保存的文件，最后都是以字节的形式保存在硬盘上的，那么在保存的时候，是有一个字符编码。我们可以用一些工具查看某个文件的编码是什么，比如mac上有一个叫enca的工具，可以执行<code>brew install enca</code>进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enca NioTest13_In.txt </span><br><span class="line">Universal transformation format 8 bits; UTF-8</span><br></pre></td></tr></table></figure>

<p>我们之前的代码<code>Charset.forName(&quot;utf-8&quot;);</code>表示用utf8来对文件编解码，读取的文件和输出的文件，都是utf8格式的。</p>
<p>现在对代码进行一点改动，把编码格式改成<code>Charset charset = Charset.forName(&quot;iso-8859-1&quot;);</code>,查看输出的文件内容，发现竟然没有乱码，而且用工具查看编码格式依然是utf8，这是怎么回事呢?</p>
<p>下面分别解释一下我们常见的几种编码:</p>
<ol>
<li><p>ASCII (American Standard Code for Information Interchange, 美国信息交换标准代码)</p>
<p> 7 bit表示一个字符，共计可以表示128种字符。</p>
</li>
<li><p>IOS-8859-1，基于ASCII的扩展</p>
<p> 8 bit表示一个字符，即用一个字节（byte）(8 bit)来表示一个字符，共计可以表示256个字符。</p>
</li>
<li><p>gb2312，常见汉字编码</p>
<p> 2个字节表示1个汉字</p>
</li>
<li><p>GBK，包括生僻字的编码</p>
</li>
<li><p>GB18030，最完整的汉字编码</p>
</li>
<li><p>BIG5，台湾繁体字编码</p>
</li>
<li><p>unicode，包括全球所有编码的字符节。</p>
<p> 采用2个字节表示一个字符。</p>
</li>
<li><p>utf-Unicode Translation Format. </p>
<p> 因为unicode太占存储空间了，所以又诞生了utf8,utf16等格式，unicode本身是一种编码方式，而utf是一种存储方式；utf-8是unicode的实现方式之一。</p>
<p> utf-16LE(little endian), utf16-be(big endian)</p>
<blockquote>
<p>大端和小端：unicode编码的文件开头有一个Zero Width No-break Space。如果是0xFEFF (BE), 0xFFFE(LE)，表示大端还是小端。</p>
</blockquote>
<p> utf-8，变长字节表示形式，一般来说，utf-8会通过3个字节来表示一个中文。</p>
<p> utf8有个概念：BOM(Byte Order Mark)，就是文件头，在windows里用16进制打开文件能看到，但是mac和linux里是没有的。</p>
</li>
</ol>
<p>那么刚才用<code>ios-8859-1</code>来读取，读取英文的部分没有问题，那么为什么中文也是正确的呢？<code>你好</code>，因为utf8是用3个字节表示一个中文，这2个字的字节表示为<code>E4 BD A0 E5 A5 BD</code>。那么用<code>ios-8859-1</code>解码的时候，先读取一个字节<strong>E4</strong>，这个肯定是乱码，但是在解码完成后，再进行编码的时候完整了放入了6个字节的数据，而输出的文件又是<code>utf-8</code>格式，所以我们查看文件的时候，又把字节进行了正确的解析。</p>
<p>如果我们解码和编码用的不同的字符集，那么肯定就会出错了。</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO-零拷贝</title>
    <url>/2017/09/12/nio/nio7/</url>
    <content><![CDATA[<h1 id="NIO-零拷贝"><a href="#NIO-零拷贝" class="headerlink" title="NIO 零拷贝"></a>NIO 零拷贝</h1><p>OIO在读取文件传输的时候，在操作系统中发生了多次上下文的切换和多次的数据拷贝。</p>
<p>BIO在读取文件的流程图</p>
<p><img src="/img/nio/nio8-1.png"></p>
<a id="more"></a>

<p>NIO零拷贝读取文件的流程图，实际上这个也有一次拷贝，就是从kernel内核空间拷贝到socket buffer中。</p>
<p><img src="/img/nio/nio8-2.png"></p>
<p>下面再写个零拷贝的例子深刻理解一下，首先是OIO的方式。</p>
<h2 id="OldServer"><a href="#OldServer" class="headerlink" title="OldServer"></a>OldServer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/09/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteArry = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(byteArry, <span class="number">0</span>, byteArry.length);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="OldClient"><a href="#OldClient" class="headerlink" title="OldClient"></a>OldClient</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/09/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里选择一个比较大一点的文件，否则看不出来效果</span></span><br><span class="line">        String fileName = <span class="string">&quot;/Users/xiaomai/software/工具/CleanMyMac 3.5.1.dmg&quot;</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"></span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((readCount = inputStream.read(buffer)) &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(buffer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送总字节数：&quot;</span> + total + <span class="string">&quot;，耗时：&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        inputStream.close();</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">发送总字节数：41500918，耗时：251</span><br></pre></td></tr></table></figure>


<p>下面是NIO的方式：</p>
<h2 id="NewIOServer"><a href="#NewIOServer" class="headerlink" title="NewIOServer"></a>NewIOServer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/09/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        <span class="comment">// 复用客户端连接的端口号，断开后保留一段时间</span></span><br><span class="line">        serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readCount) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readCount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取后将position设置为0</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="NewIOClient"><a href="#NewIOClient" class="headerlink" title="NewIOClient"></a>NewIOClient</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/09/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里选择一个比较大一点的文件，否则看不出来效果</span></span><br><span class="line">        String fileName = <span class="string">&quot;/Users/xiaomai/software/工具/CleanMyMac 3.5.1.dmg&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一行代码解决传输</span></span><br><span class="line">        <span class="comment">// 这行代码是用的零拷贝的方式来进行的文件传输，交给操作系统直接将文件系统缓存传输给了目标Channel</span></span><br><span class="line">        <span class="comment">// 而没有拷贝进用户空间的过程</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送总字节数：&quot;</span> + transferCount + <span class="string">&quot;, 耗时：&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">发送总字节数：41500918, 耗时：103</span><br></pre></td></tr></table></figure>


<p>通过简单的测试我们也可以发现，NIO方式的速度确实快了很多。</p>
<p>从Linux2.4开始，还提供了scatter/gather的方式使速度更上一层，实现了真正意义上的零拷贝。</p>
<p><img src="/img/nio/nio8-3.png"></p>
<p>将文件拷贝到kernel缓冲区后，只将地址和长度等必要信息拷贝到socket buffer中，等到要发送文件的时候，从socket buffer中读取文件长度和地址，从kernel中读取真正的文件，这是一种gather操作，然后把数据直接发送到了服务器端，跟之前的对比，省去了从kernel内核空间拷贝到socket buffer的过程。</p>
<p><img src="/img/nio/nio8-4.png"></p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战1-Redis配置和持久化</title>
    <url>/2018/02/12/cache/cache01/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>Redis与其他key-value缓存产品有以下三个特点：</p>
<ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<a id="more"></a>

<h2 id="Redis持久化的意义"><a href="#Redis持久化的意义" class="headerlink" title="Redis持久化的意义"></a>Redis持久化的意义</h2><p>Redis的安装：<a href="http://www.saily.top/2018/07/19/redis-install/">centos7安装redis4.0.10并进行生产环境部署</a>。</p>
<p>都知道redis数据可以做持久化，但是有个问题，redis的持久化意义是什么？redis的持久化方式RDB，AOF的区别，各自的特点是什么，适合什么场景，redis的企业级的持久化方案是什么，是用来跟哪些企业级的场景结合起来使用的？</p>
<blockquote>
<p>Redis持久化的意义在于故障恢复，比如你部署了一个redis作为cache缓存，当然也可以保存一些较为重要的数据，如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据，如果通过持久化将数据存一份在磁盘上，然后定期同步和备份到云存储服务上去，那么就可以保证数据不丢失全部，可以恢复一部分数据回来。</p>
</blockquote>
<h3 id="持久化和高可用的关系"><a href="#持久化和高可用的关系" class="headerlink" title="持久化和高可用的关系"></a>持久化和高可用的关系</h3><p>企业级redis集群架构：海量数据、高并发、高可用。</p>
<p>所以对于一个企业级的redis架构来说，持久化是必不可少的。持久化主要是做灾难恢复，数据恢复，也可以归类到高可用的一个环节里面去。</p>
<p>如果redis整个挂了，redis就不可用了，你要做的事情是让redis变得可用，尽快变得可用。重启redis，尽快让它对外提供服务，如果你没做数据备份，这个时候redis启动了，也不可用，数据都没了。</p>
<p>很可能大量的请求过来，缓存全部无法命中，在redis里根本找不到数据，这个时候就死定了，缓存雪崩，所有请求都没有在redis命中，就会去mysql数据库这种数据源头中去找，一下子mysql承接高并发，然后就挂了。如果mysql再挂掉，你都没法去找数据恢复到redis里面去，因为redis的数据从哪来？从mysql来的。</p>
<p>如果你把redis的持久化做好，备份和恢复方案做到企业级的程度，那么即使你的redis故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。</p>
<p><strong>所以说Redis的持久化跟高可用，是密切相关的。</strong></p>
<h3 id="Redis持久化：RDB和AOF两种持久化机制的介绍"><a href="#Redis持久化：RDB和AOF两种持久化机制的介绍" class="headerlink" title="Redis持久化：RDB和AOF两种持久化机制的介绍"></a>Redis持久化：RDB和AOF两种持久化机制的介绍</h3><ul>
<li><p>RDB持久化机制，对redis中的数据执行周期性的持久化。</p>
</li>
<li><p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。</p>
</li>
</ul>
<blockquote>
<p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制。</p>
</blockquote>
<p>通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘，然后可以将这些数据备份到别的地方去，比如阿里云或者其他云服务。</p>
<p>如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务.</p>
<p>如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整</p>
<h4 id="RDB持久化机制的优点"><a href="#RDB持久化机制的优点" class="headerlink" title="RDB持久化机制的优点"></a>RDB持久化机制的优点</h4><p>1.RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据。</p>
<ul>
<li>RDB可以做冷备，生成多个文件，每个文件都代表了某一个时刻的完整的数据快照。</li>
<li>AOF也可以做冷备，只有一个文件，但是可以每隔一定时间复制一份这个文件出来。</li>
</ul>
<p>RDB做冷备，优势在哪儿呢？由redis去控制固定时长生成快照文件的事情，比较方便; AOF的话还需要自己写一些各种定时脚本去做这个事情。<br>RDB数据做冷备，在最坏的情况下，提供数据恢复的时候，速度比AOF快。</p>
<p>2.RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</p>
<ul>
<li>RDB：每次写都是直接写redis内存，只是在一定的时候，才会将数据写入磁盘中。</li>
<li>AOF：每次都是要写文件中，虽然可以快速写入<code>os cache</code>中，但是还是有一定的时间开销，速度肯定比RDB略慢一些。</li>
</ul>
<p>3.相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速        </p>
<ul>
<li>AOF：存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据。</li>
<li>RDB：就是一份数据文件，恢复的时候，直接加载到内存中。</li>
</ul>
<p><strong>结合上述优点，RDB特别适合做冷备。</strong></p>
<h4 id="RDB持久化机制的缺点"><a href="#RDB持久化机制的缺点" class="headerlink" title="RDB持久化机制的缺点"></a>RDB持久化机制的缺点</h4><ol>
<li><p>如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据。</p>
</li>
<li><p>RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</p>
</li>
</ol>
<h4 id="AOF持久化机制的优点"><a href="#AOF持久化机制的优点" class="headerlink" title="AOF持久化机制的优点"></a>AOF持久化机制的优点</h4><ol>
<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p>
</li>
<li><p>AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p>
</li>
<li><p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>
</li>
<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</p>
</li>
</ol>
<h4 id="AOF持久化机制的缺点"><a href="#AOF持久化机制的缺点" class="headerlink" title="AOF持久化机制的缺点"></a>AOF持久化机制的缺点</h4><ol>
<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</p>
</li>
<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的，如果你要保证一条数据都不丢，也是可以的，AOF的fsync设置成每写入一条数据，fsync一次，那就完蛋了，redis的QPS大降。</p>
</li>
<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p>
</li>
<li><p>唯一的比较大的缺点，其实就是做数据恢复的时候，会比较慢，还有做冷备，定期的备份，不太方便，可能要自己手写复杂的脚本去做，做冷备不太合适</p>
</li>
</ol>
<h3 id="RDB和AOF到底该如何选择"><a href="#RDB和AOF到底该如何选择" class="headerlink" title="RDB和AOF到底该如何选择"></a>RDB和AOF到底该如何选择</h3><ol>
<li><p>不要仅仅使用RDB，因为那样会导致你丢失很多数据。</p>
</li>
<li><p>也不要仅仅使用AOF，因为那样有两个问题，第一，通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p>
</li>
<li><p>综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p>
</li>
</ol>
<h3 id="持久化配置和数据恢复实验"><a href="#持久化配置和数据恢复实验" class="headerlink" title="持久化配置和数据恢复实验"></a>持久化配置和数据恢复实验</h3><h4 id="如何配置RDB持久化机制"><a href="#如何配置RDB持久化机制" class="headerlink" title="如何配置RDB持久化机制"></a>如何配置RDB持久化机制</h4><p>在redis的配置文件里，save配置项用来配置RDB。</p>
<p><code>redis.conf</code>文件，也就是<code>/etc/redis/6379.conf</code>，去配置持久化</p>
<p>这是默认的配置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>每隔60s，如果有超过10000个key发生了变更，那么就生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，这个操作也被称之为snapshotting，快照。</p>
<p>也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成。</p>
<p>save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件。</p>
<h5 id="RDB持久化机制的工作流程"><a href="#RDB持久化机制的工作流程" class="headerlink" title="RDB持久化机制的工作流程"></a>RDB持久化机制的工作流程</h5><ol>
<li>redis根据配置自己尝试去生成rdb快照文件        </li>
<li>fork一个子进程出来        </li>
<li>子进程尝试将数据dump到临时的rdb快照文件中    </li>
<li>完成rdb快照文件的生成之后，就替换之前的旧的快照文件</li>
</ol>
<p>dump.rdb，每次生成一个新的快照，都会覆盖之前的老快照</p>
<h5 id="基于RDB持久化机制的数据恢复实验"><a href="#基于RDB持久化机制的数据恢复实验" class="headerlink" title="基于RDB持久化机制的数据恢复实验"></a>基于RDB持久化机制的数据恢复实验</h5><ol>
<li><p>在redis中保存几条数据，立即用命令停掉redis，然后重启redis，看看刚才插入的数据还在不在</p>
<p> 经过测试发现数据还在，为什么？通过redis-cli SHUTDOWN这种方式去停掉redis，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照。</p>
</li>
<li><p>在redis中再保存几条新的数据，用kill -9粗暴杀死redis进程，模拟redis故障异常退出，导致内存数据丢失的场景。<br> 这次就发现，redis进程异常被杀掉，数据没有进dump文件，几条最新的数据就丢失了</p>
</li>
<li><p>手动设置一个save检查点，<code>save 5 1</code>，5秒检查一次，有一条数据就写入磁盘，写入几条数据，等待5秒钟，会发现自动进行了一次dump rdb快照，在dump.rdb中发现了数据。异常停掉redis进程，再重新启动redis，看刚才插入的数据还在.</p>
</li>
</ol>
<h4 id="AOF持久化的配置"><a href="#AOF持久化的配置" class="headerlink" title="AOF持久化的配置"></a>AOF持久化的配置</h4><p>AOF持久化，默认是关闭的，默认是打开RDB持久化。</p>
<p><code>appendonly yes</code>属性，可以打开AOF持久化机制，在生产环境里面，一般来说AOF都是要打开的，除非你说随便丢个几分钟的数据也无所谓，打开AOF持久化机制之后，redis每次接收到一条写命令，就会写入日志文件中，当然是先写入os cache的，然后每隔一定时间再fsync一下。</p>
<p><strong>而且即使AOF和RDB都开启了，redis重启的时候，也是优先通过AOF进行数据恢复的，因为aof数据比较完整。</strong></p>
<p>可以配置AOF的fsync策略，有三种策略可以选择:一种是每次写入一条数据就执行一次fsync; 一种是每隔一秒执行一次fsync; 一种是不主动执行fsync。</p>
<ol>
<li><p>always: 每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘上去，性能非常非常差，吞吐量很低; 如果要确保redis里的数据一条都不丢，那就只能这样了。            </p>
<p> 为什么说性能差，这里用mysql和redis比较：    </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -&gt; 内存策略，大量磁盘操作，QPS最多到1、2k。(QPS，每秒钟的请求数量)</span><br><span class="line">redis -&gt; 内存，磁盘持久化，QPS一般来说上万QPS没问题。</span><br></pre></td></tr></table></figure>
</li>
<li><p>everysec: 每秒将os cache中的数据fsync到磁盘，这个是最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万的。</p>
</li>
<li><p>no: 仅仅redis负责将数据写入os cache就撒手不管了，然后后面os自己会时不时有自己的策略将数据刷入磁盘，不可控。</p>
</li>
</ol>
<h4 id="AOF持久化的数据恢复实验"><a href="#AOF持久化的数据恢复实验" class="headerlink" title="AOF持久化的数据恢复实验"></a>AOF持久化的数据恢复实验</h4><ol>
<li><p>先仅仅打开RDB，写入一些数据，然后kill -9杀掉redis进程，接着重启redis，发现数据没了，因为RDB快照还没生成</p>
</li>
<li><p>打开AOF的开关，启用AOF持久化</p>
</li>
<li><p>写入一些数据，观察AOF文件中的日志内容</p>
<p> 其实在<code>appendonly.aof</code>文件中，可以看到刚写的日志，它们其实就是先写入os cache的，然后1秒后才fsync到磁盘中，只有fsync到磁盘中了，才是安全的，要不然光是在os cache中，机器只要重启，就什么都没了。</p>
</li>
<li><p>kill -9杀掉redis进程，重新启动redis进程，发现数据被恢复回来了，就是从AOF文件中恢复回来的。</p>
</li>
</ol>
<p><strong>Redis进程启动的时候，直接就会从appendonly.aof中加载所有的日志，把内存中的数据恢复回来。</strong></p>
<h4 id="AOF-rewrite"><a href="#AOF-rewrite" class="headerlink" title="AOF rewrite"></a>AOF rewrite</h4><p>redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉。redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中。所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件就一个，会不断的膨胀，到很大很大。</p>
<p><strong>所以AOF会自动在后台每隔一定时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了; redis内存只剩下10万; 基于内存中当前的10万数据构建一套最新的日志，到AOF中; 覆盖之前的老日志; 确保AOF日志文件不会过大，保持跟redis内存数据量一致。</strong></p>
<p>redis2.4之前，还需要手动开发一些脚本、crontab，通过BGREWRITEAOF命令去执行AOF rewrite，但是redis2.4之后，会自动进行rewrite操作。</p>
<p>在<code>redis.conf</code>中，可以配置rewrite策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>比如说上一次AOF<strong>rewrite</strong>之后，是128mb，然后就会接着128mb继续写AOF的日志，如果发现增长的比例超过了之前的100%，有256mb了，就可能会去触发一次rewrite。</p>
<p>但是此时还要去跟<strong>auto-aof-rewrite-min-size</strong>，也就是64mb去比较，256mb &gt; 64mb，才会去触发rewrite。</p>
<p>rewrite过程：</p>
<ol>
<li>redis fork一个子进程</li>
<li>子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志</li>
<li>redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件</li>
<li>子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中</li>
<li>用新的日志文件替换掉旧的日志文件</li>
</ol>
<h4 id="AOF破损文件的修复"><a href="#AOF破损文件的修复" class="headerlink" title="AOF破损文件的修复"></a>AOF破损文件的修复</h4><p>如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损</p>
<p>用<code>redis-check-aof --fix</code>命令来修复破损的AOF文件</p>
<h4 id="AOF和RDB同时工作"><a href="#AOF和RDB同时工作" class="headerlink" title="AOF和RDB同时工作"></a>AOF和RDB同时工作</h4><ol>
<li>如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis再执行AOF rewrite，那么就不会执行RDB snapshotting</li>
<li>如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite</li>
<li>同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整</li>
</ol>
<h4 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h4><ol>
<li>在有rdb的dump和aof的appendonly的同时，rdb里也有部分数据，aof里也有部分数据，这个时候其实会发现，rdb的数据不会恢复到内存中</li>
<li>我们模拟让aof破损，然后fix，有一条数据会被fix删除</li>
<li>再次用fix的aof文件去重启redis，发现数据只剩下一条了</li>
</ol>
<p>数据恢复完全是依赖于底层的磁盘的持久化的，主要rdb和aof上都没有数据，那就没了</p>
]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战2-Redis企业级应用实战</title>
    <url>/2018/02/12/cache/cache02/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h1 id="Redis企业应用实战"><a href="#Redis企业应用实战" class="headerlink" title="Redis企业应用实战"></a>Redis企业应用实战</h1><p>上一篇说了redis的持久化的原理和操作，但是在企业中，持久化到底是怎么去用的呢？企业级的数据备份和各种灾难下的数据恢复，是怎么做的呢？</p>
<h2 id="企业级的持久化的配置策略"><a href="#企业级的持久化的配置策略" class="headerlink" title="企业级的持久化的配置策略"></a>企业级的持久化的配置策略</h2><p>在企业中，RDB的生成策略，用默认的配置也差不多。</p>
<p><code>save 60 10000</code>：如果你希望尽可能确保，RDB最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，但是低峰期数据量很少，也没必要这样设置。</p>
<p>1分内10000个key发生变更-&gt;生成RDB，1分内1000-&gt;RDB，这个根据应用和业务的数据量，自己去决定。</p>
<p>AOF一定要打开，fsync配置<code>everysec</code></p>
<p><code>auto-aof-rewrite-percentage 100</code>: 就是当前AOF大小膨胀到超过上次100%，上次的两倍就重写。<br><code>auto-aof-rewrite-min-size 64mb</code>: 至少64m才重写，根据你的数据量来定，可改成16mb，32mb等等。</p>
<a id="more"></a>

<h2 id="企业级的数据备份方案"><a href="#企业级的数据备份方案" class="headerlink" title="企业级的数据备份方案"></a>企业级的数据备份方案</h2><p>RDB非常适合做冷备，每次生成之后，就不会再有修改了</p>
<p>数据备份方案：</p>
<ol>
<li>写crontab定时调度脚本去做数据备份</li>
<li>每小时都copy一份rdb的备份，到一个目录中去，仅仅保留最近48小时的备份</li>
<li>每天都保留一份当日的rdb的备份，到一个目录中去，仅仅保留最近1个月的备份</li>
<li>每次copy备份的时候，都把太旧的备份给删了</li>
<li>每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去</li>
</ol>
<p>创建一个备份目录：<code>/usr/local/redis</code>，下面的脚本基于这个目录做备份。</p>
<h3 id="每小时copy一次备份，删除48小时前的数据"><a href="#每小时copy一次备份，删除48小时前的数据" class="headerlink" title="每小时copy一次备份，删除48小时前的数据"></a>每小时copy一次备份，删除48小时前的数据</h3><p><code>redis_rdb_copy_hourly.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"></span><br><span class="line">cur_date=`date +%Y%m%d%H`</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line">cp /var/redis/6379/dump.rdb /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line"></span><br><span class="line">del_date=`date -d -48hour +%Y%m%d%H`</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$del_date</span></span><br></pre></td></tr></table></figure>

<p>设置定时任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 redis_rdb_copy_hourly.sh</span><br><span class="line">crontab -e</span><br><span class="line">0 * * * * sh /usr/<span class="built_in">local</span>/redis/copy/redis_rdb_copy_hourly.sh</span><br></pre></td></tr></table></figure>


<h3 id="每天copy一次备份"><a href="#每天copy一次备份" class="headerlink" title="每天copy一次备份"></a>每天copy一次备份</h3><p><code>redis_rdb_copy_daily.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"></span><br><span class="line">cur_date=`date +%Y%m%d`</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line">cp /var/redis/6379/dump.rdb /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$cur_date</span></span><br><span class="line"></span><br><span class="line">del_date=`date -d -1month +%Y%m%d`</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/redis/snapshotting/<span class="variable">$del_date</span></span><br></pre></td></tr></table></figure>

<p>设置定时任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 redis_rdb_copy_daily.sh</span><br><span class="line">crontab -e</span><br><span class="line">0 0 * * * sh /usr/<span class="built_in">local</span>/redis/copy/redis_rdb_copy_daily.sh</span><br></pre></td></tr></table></figure>

<h3 id="数据恢复方案"><a href="#数据恢复方案" class="headerlink" title="数据恢复方案"></a>数据恢复方案</h3><ol>
<li>如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据，上一篇文章在AOF数据恢复那一块说过了，<code>fsync everysec</code>，最多就丢一秒的数据。</li>
</ol>
<ol start="2">
<li><p>如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复</p>
<blockquote>
<p>如果AOF没有破损，可以直接基于AOF恢复的。</p>
</blockquote>
<blockquote>
<p>AOF append-only，表示是顺序写入的，如果AOF文件破损，那么用redis-check-aof fix命令修复</p>
</blockquote>
</li>
<li><p>如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复，当前最新的AOF和RDB文件都出现了丢失/损坏到无法恢复，一般不是机器的故障，那可能是人为（不小心被删除）。</p>
<blockquote>
<p>找到RDB最新的一份备份，小时级的备份可以了，小时级的肯定是最新的，copy到redis里面去，就可以恢复到某一个小时的数据（注意如果存在<code>appendonly.aof</code>文件，会优先读取<code>appendonly.aof</code>文件）        </p>
</blockquote>
<blockquote>
<p>虽然删除了appendonly.aof，但是因为打开了aof持久化，redis就一定会优先基于aof去恢复，即使文件不在，那就会创建一个新的空的aof文件。正确的操作如下：停止redis，关闭aof，拷贝rdb备份，重启redis，确认数据恢复，直接在命令行热修改redis配置，打开aof，这个时候redis就会将内存中的数据对应的日志，写入aof文件中。此时aof和rdb两份数据文件的数据就同步了，在redis-cli中执行<code>config set appendonly yes</code>热修改配置参数，但是这个时候配置文件中的实际的参数没有被修改，再次停止redis，手动修改配置文件，打开aof的命令，再次重启redis。</p>
</blockquote>
</li>
<li><p>如果当前机器上的所有RDB文件全部损坏，那么从远程的云服务上拉取最新的RDB快照回来恢复数据</p>
</li>
<li><p>如果是发现有重大的数据错误，比如某个小时上线的程序一下子将数据全部污染了，数据全错了，那么可以选择某个更早的时间点，对数据进行恢复。</p>
</li>
</ol>
<h2 id="如何通过读写分离来承载读请求QPS超过10万-？"><a href="#如何通过读写分离来承载读请求QPS超过10万-？" class="headerlink" title="如何通过读写分离来承载读请求QPS超过10万+？"></a>如何通过读写分离来承载读请求QPS超过10万+？</h2><h3 id="redis高并发跟整个系统的高并发之间的关系"><a href="#redis高并发跟整个系统的高并发之间的关系" class="headerlink" title="redis高并发跟整个系统的高并发之间的关系"></a>redis高并发跟整个系统的高并发之间的关系</h3><p>做高并发的话，不可避免的是需要把底层的缓存做好。如果是用mysql来做高并发，即使做到了，那么也是通过一系列复杂的分库分表，而且mysql高并发一般用在订单系统，事务要求比较高的地方，QPS能到几万，就已经比较高了。</p>
<p>但是如果要做一些电商的商品详情页，真正的超高并发，QPS上十万，甚至是百万，一秒钟百万的请求量，光是redis是不够的，但是redis是整个大型的缓存架构、支撑高并发的架构中，非常重要的一个环节。</p>
<p>首先，底层的缓存中间件，缓存系统，必须能够支撑的起我们说的那种高并发，其次，再经过良好的整体的缓存架构的设计（多级缓存架构、热点缓存），支撑真正的上十万，甚至上百万的高并发。</p>
<h3 id="redis不能支撑高并发的瓶颈在哪里？"><a href="#redis不能支撑高并发的瓶颈在哪里？" class="headerlink" title="redis不能支撑高并发的瓶颈在哪里？"></a>redis不能支撑高并发的瓶颈在哪里？</h3><p>单机是不能支撑高并发的，单机能够承载的QPS大概在上万或者几万不等，根据业务复杂度决定。</p>
<h3 id="如果redis要支撑超过10万-的并发，那应该怎么做？"><a href="#如果redis要支撑超过10万-的并发，那应该怎么做？" class="headerlink" title="如果redis要支撑超过10万+的并发，那应该怎么做？"></a>如果redis要支撑超过10万+的并发，那应该怎么做？</h3><p>单机的redis几乎不太可能说QPS超过10万+，除非一些特殊情况，比如你的机器性能特别好，配置特别高，物理机，维护做的特别好，而且你的整体的操作不是太复杂。</p>
<p><strong>读写分离</strong>，一般都是用来支撑<strong>读高并发</strong>的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千，大量的请求都是读，比如一秒钟二十万次读。</p>
<p>读写分离：</p>
<pre><code>主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS的架构</code></pre>
<p>架构做成主从架构，一主多从，主负责写，并且将数据同步复制到其他的slave节点，从节点负责读，所有的读请求全部走从节点。</p>
<h3 id="Redis-Replication"><a href="#Redis-Replication" class="headerlink" title="Redis Replication"></a>Redis Replication</h3><p><img src="/img/cache/cache02_1.png"></p>
<p>Redis 支持简单且易用的主从复制（master-slave replication）功能，当主Redis服务器更新数据时能将数据同步到从Redis服务器。</p>
<h4 id="Redis-Replication的核心机制"><a href="#Redis-Replication的核心机制" class="headerlink" title="Redis Replication的核心机制"></a>Redis Replication的核心机制</h4><ol>
<li>redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量</li>
<li>一个master node是可以配置多个slave node的</li>
<li>slave node也可以连接其他的slave node</li>
<li>slave node做复制的时候，是不会block master node的正常工作的</li>
<li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</li>
</ol>
<h5 id="master持久化对于主从架构的安全保障的意义"><a href="#master持久化对于主从架构的安全保障的意义" class="headerlink" title="master持久化对于主从架构的安全保障的意义"></a>master持久化对于主从架构的安全保障的意义</h5><p>如果采用了主从架构，那么必须开启master node的持久化。不建议用slave node作为master node的数据热备，因为那样的话，如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了。</p>
<pre><code>master -&gt; RDB和AOF都关闭了 -&gt; 全部在内存中</code></pre>
<p>master宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己的数据是空的，master就会将空的数据集同步到slave上去，所有slave的数据全部清空，100%的数据丢失，所以master节点必须要使用持久化机制。</p>
<h5 id="主从架构的核心原理"><a href="#主从架构的核心原理" class="headerlink" title="主从架构的核心原理"></a>主从架构的核心原理</h5><p><img src="/img/cache/cache02_2.png"></p>
<ul>
<li><p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</p>
</li>
<li><p>如果这时slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization</p>
</li>
<li><p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
</li>
<li><p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
</li>
</ul>
<h5 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h5><p>从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p>master node会在内存中常见一个backlog，master和slave都会保存一个<code>replica offset</code>还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p>
<p>但是如果没有找到对应的offset，那么就会执行一次<code>full resynchronization</code></p>
<h5 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h5><pre><code>repl-diskless-sync no</code></pre>
<p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p>
<pre><code>repl-diskless-sync-delay 5</code></pre>
<p>会等待一定时长（上面是5秒）再开始复制，因为要等更多slave重新连接过来。</p>
<h5 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h5><p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>
<h4 id="深入理解复制机制"><a href="#深入理解复制机制" class="headerlink" title="深入理解复制机制"></a>深入理解复制机制</h4><p>再次深入了解一下Redis的配置和复制机制。</p>
<h5 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h5><ol>
<li><p>slave node启动，仅仅保存master node的信息，包括master node的host和ip，但是复制流程没开始。<br> master的host和ip信息配置：<code>redis.conf -&gt; slaveof</code>配置。</p>
</li>
<li><p>slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接。</p>
</li>
<li><p>slave node发送ping命令给master node。</p>
</li>
<li><p>口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证。</p>
</li>
<li><p>master node第一次执行全量复制，将所有数据发给slave node。</p>
</li>
<li><p>master node后续持续将写命令，异步复制给slave node</p>
</li>
</ol>
<h5 id="数据同步相关的核心机制"><a href="#数据同步相关的核心机制" class="headerlink" title="数据同步相关的核心机制"></a>数据同步相关的核心机制</h5><p>指的就是第一次slave连接master的时候，执行的全量复制过程里面的一些细节的机制。</p>
<ol>
<li><p>master和slave都会维护一个offset</p>
<p> master会在自身不断累加offset，slave也会在自身不断累加offset，slave每秒都会上报自己的offset给master，同时master也会保存每个slave的offset。这个倒不是说特定就用在全量复制，主要是master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况。</p>
</li>
<li><p>backlog</p>
<p> backlog主要是用来做全量复制中断后的增量复制的，master node有一个backlog，默认是1MB大小，master node给slave node复制数据时，也会将数据在backlog中同步写一份。</p>
</li>
<li><p>master run_id介绍</p>
<p> <code>info server</code>可以看到master run_id，如果是根据host+ip定位master node，是不靠谱的，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run_id区分，run_id不同就做全量复制，如果需要不更改run_id重启redis，可以使用<code>redis-cli debug reload</code>命令。</p>
</li>
<li><p>psync</p>
<p> 从节点使用psync从master node进行复制，psync runid offset，master node会根据自身的情况返回响应信息，可能是FULLRESYNC runid offset触发全量复制，可能是CONTINUE触发增量复制。</p>
</li>
</ol>
<h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p>rdb生成、rdb通过网络拷贝、slave旧数据的清理、slave aof rewrite，其实都很耗费时间，如果复制的数据量在4G~6G之间，那么很可能全量复制时间消耗到1分半到2分钟。</p>
<ol>
<li>master执行bgsave，在本地生成一份rdb快照文件</li>
<li>master node将rdb快照文件发送给salve node，如果rdb复制时间超过60秒（repl-timeout），那么slave node就会认为复制失败，可以适当调节大这个参数。</li>
<li>对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s。</li>
<li>master node在生成rdb时，会将所有新的写命令缓存在内存中，在salve node保存了rdb之后，再将新的写命令复制给salve node。</li>
<li>配置解释：<code>client-output-buffer-limit slave 256MB 64MB 60</code>，如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败。</li>
<li>slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于旧的数据版本对外提供服务。</li>
<li>如果slave node开启了AOF，那么会立即执行<code>BGREWRITEAOF</code>，重写AOF。</li>
</ol>
<h5 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h5><ol>
<li>如果全量复制过程中，master-slave网络连接断掉，那么slave重新连接master时，会触发增量复制。</li>
<li>master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB。</li>
<li>msater就是根据slave发送的psync中的offset来从backlog中获取数据的。</li>
</ol>
<h5 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h5><p>主从节点互相都会发送heartbeat信息，master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat。</p>
<h5 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h5><p>master每次接收到写命令之后，现在内部写入数据，然后异步发送给slave node。</p>
<h3 id="Redis读写分离架构实战"><a href="#Redis读写分离架构实战" class="headerlink" title="Redis读写分离架构实战"></a>Redis读写分离架构实战</h3><p>上面的内容都是在铺垫各种redis replication的原理和知识，主从架构，读写分离。接下来就跟随文章进行项目应用实战，搭建一个一主一从的架构，主节点去写，从节点去读。</p>
<p>配置从节点，需要在从节点的<code>redis.conf</code>配置文件中修改<code>slaveof ip port</code>。</p>
<p>我这里配置成<code>slaveof eshop-cache01 6379</code>。</p>
<p>强制读写分离配置：slave节点只读是默认开启的，<code>slave-read-only yes</code>，开启了只读的redis slave node，会拒绝所有的写操作，这样可以强制搭建成读写分离的架构。</p>
<p>如果master有密码，还需要配置<code>masterauth</code>，来授权从节点访问。</p>
<h4 id="读写分离架构的测试"><a href="#读写分离架构的测试" class="headerlink" title="读写分离架构的测试"></a>读写分离架构的测试</h4><p>先启动主节点，eshop-cache01上的redis实例，再启动从节点，eshop-cache02上的redis实例。（eshop-cache01和eshop-cache02是我配置的2台虚拟机。）</p>
<p><strong>!!千万要注意一点，redis的默认配置中，是处于开发模式的，从别的机器是无法访问的，所以要修改<code>bind</code>配置，把它先注释掉吧。</strong></p>
<pre><code>bind 127.0.0.1</code></pre>
<p>然后用<code>redis-cli</code>连接从节点，<code>info replication</code>可以看到当前节点集群的配置信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:eshop-cache01</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:6</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:84</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:081336e1355373b31908914d2a9ac195b0ca2622</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:84</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:84</span><br></pre></td></tr></table></figure>

<p>连接主节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.2.202,port=6379,state=online,offset=714,lag=1</span><br><span class="line">master_replid:081336e1355373b31908914d2a9ac195b0ca2622</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:714</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:714</span><br></pre></td></tr></table></figure>

<p>在主节点<code>set k1 v2</code>，从节点<code>get k1</code>，马上就能看到结果，数据已经同步过去了。</p>
<h4 id="QPS测试"><a href="#QPS测试" class="headerlink" title="QPS测试"></a>QPS测试</h4><p>如果想要对刚才搭建的Redis集群做一个基准的测试，测一下性能和QPS(query per second)。Redis自己提供了redis-benchmark压测工具，这是最快捷最方便的，当然了，这个工具比较简单，只能用一些简单的操作和场景去压测。</p>
<ol>
<li><p>对redis读写分离架构进行压测，单实例写QPS+单实例读QPS(我是1核1G的虚拟机)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-4.0.8/src/redis-benchmark -h localhost</span><br><span class="line">-c &lt;clients&gt;       Number of parallel connections (default 50)</span><br><span class="line">-n &lt;requests&gt;      Total number of requests (default 100000)</span><br><span class="line">-d &lt;size&gt;          Data size of SET/GET value <span class="keyword">in</span> bytes (default 2)</span><br><span class="line">====== PING_INLINE ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.05 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.81% &lt;= 1 milliseconds</span><br><span class="line">99.93% &lt;= 2 milliseconds</span><br><span class="line">100.00% &lt;= 2 milliseconds</span><br><span class="line">95602.30 requests per second</span><br><span class="line"></span><br><span class="line">====== PING_BULK ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.14 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.57% &lt;= 1 milliseconds</span><br><span class="line">99.87% &lt;= 2 milliseconds</span><br><span class="line">99.99% &lt;= 3 milliseconds</span><br><span class="line">100.00% &lt;= 3 milliseconds</span><br><span class="line">87489.06 requests per second</span><br><span class="line"></span><br><span class="line">====== SET ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.23 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.93% &lt;= 1 milliseconds</span><br><span class="line">99.75% &lt;= 2 milliseconds</span><br><span class="line">100.00% &lt;= 3 milliseconds</span><br><span class="line">81499.59 requests per second</span><br><span class="line"></span><br><span class="line">====== GET ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.30 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">96.70% &lt;= 1 milliseconds</span><br><span class="line">99.20% &lt;= 2 milliseconds</span><br><span class="line">99.78% &lt;= 3 milliseconds</span><br><span class="line">99.97% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds</span><br><span class="line">76863.95 requests per second</span><br><span class="line"></span><br><span class="line">====== INCR ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.51 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">95.39% &lt;= 1 milliseconds</span><br><span class="line">98.90% &lt;= 2 milliseconds</span><br><span class="line">99.73% &lt;= 3 milliseconds</span><br><span class="line">99.93% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 4 milliseconds</span><br><span class="line">66093.85 requests per second</span><br><span class="line"></span><br><span class="line">====== LPUSH ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.36 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">97.80% &lt;= 1 milliseconds</span><br><span class="line">99.54% &lt;= 2 milliseconds</span><br><span class="line">99.81% &lt;= 3 milliseconds</span><br><span class="line">99.86% &lt;= 4 milliseconds</span><br><span class="line">99.89% &lt;= 5 milliseconds</span><br><span class="line">99.90% &lt;= 6 milliseconds</span><br><span class="line">99.90% &lt;= 8 milliseconds</span><br><span class="line">99.93% &lt;= 9 milliseconds</span><br><span class="line">99.95% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.98% &lt;= 12 milliseconds</span><br><span class="line">100.00% &lt;= 12 milliseconds</span><br><span class="line">73260.07 requests per second</span><br><span class="line"></span><br><span class="line">====== RPUSH ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.21 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.79% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">82781.45 requests per second</span><br><span class="line"></span><br><span class="line">====== LPOP ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.24 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.19% &lt;= 1 milliseconds</span><br><span class="line">99.73% &lt;= 2 milliseconds</span><br><span class="line">99.92% &lt;= 3 milliseconds</span><br><span class="line">99.95% &lt;= 4 milliseconds</span><br><span class="line">99.99% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds</span><br><span class="line">80645.16 requests per second</span><br><span class="line"></span><br><span class="line">====== RPOP ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.15 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.67% &lt;= 1 milliseconds</span><br><span class="line">99.84% &lt;= 2 milliseconds</span><br><span class="line">99.91% &lt;= 3 milliseconds</span><br><span class="line">99.95% &lt;= 4 milliseconds</span><br><span class="line">99.97% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds</span><br><span class="line">86730.27 requests per second</span><br><span class="line"></span><br><span class="line">====== SADD ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.72 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">94.97% &lt;= 1 milliseconds</span><br><span class="line">98.39% &lt;= 2 milliseconds</span><br><span class="line">99.20% &lt;= 3 milliseconds</span><br><span class="line">99.50% &lt;= 4 milliseconds</span><br><span class="line">99.58% &lt;= 5 milliseconds</span><br><span class="line">99.59% &lt;= 6 milliseconds</span><br><span class="line">99.63% &lt;= 7 milliseconds</span><br><span class="line">99.67% &lt;= 8 milliseconds</span><br><span class="line">99.68% &lt;= 9 milliseconds</span><br><span class="line">99.74% &lt;= 10 milliseconds</span><br><span class="line">99.75% &lt;= 11 milliseconds</span><br><span class="line">99.75% &lt;= 12 milliseconds</span><br><span class="line">99.76% &lt;= 13 milliseconds</span><br><span class="line">99.78% &lt;= 14 milliseconds</span><br><span class="line">99.83% &lt;= 15 milliseconds</span><br><span class="line">99.83% &lt;= 16 milliseconds</span><br><span class="line">99.86% &lt;= 17 milliseconds</span><br><span class="line">99.89% &lt;= 23 milliseconds</span><br><span class="line">99.90% &lt;= 24 milliseconds</span><br><span class="line">99.93% &lt;= 25 milliseconds</span><br><span class="line">99.93% &lt;= 27 milliseconds</span><br><span class="line">99.93% &lt;= 31 milliseconds</span><br><span class="line">99.94% &lt;= 33 milliseconds</span><br><span class="line">99.95% &lt;= 41 milliseconds</span><br><span class="line">99.95% &lt;= 42 milliseconds</span><br><span class="line">99.95% &lt;= 43 milliseconds</span><br><span class="line">99.96% &lt;= 44 milliseconds</span><br><span class="line">99.99% &lt;= 46 milliseconds</span><br><span class="line">99.99% &lt;= 49 milliseconds</span><br><span class="line">100.00% &lt;= 52 milliseconds</span><br><span class="line">100.00% &lt;= 55 milliseconds</span><br><span class="line">100.00% &lt;= 56 milliseconds</span><br><span class="line">58038.30 requests per second</span><br><span class="line"></span><br><span class="line">====== HSET ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.26 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.09% &lt;= 1 milliseconds</span><br><span class="line">99.97% &lt;= 2 milliseconds</span><br><span class="line">100.00% &lt;= 2 milliseconds</span><br><span class="line">79617.84 requests per second</span><br><span class="line"></span><br><span class="line">====== SPOP ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.25 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.30% &lt;= 1 milliseconds</span><br><span class="line">99.97% &lt;= 2 milliseconds</span><br><span class="line">100.00% &lt;= 2 milliseconds</span><br><span class="line">80000.00 requests per second</span><br><span class="line"></span><br><span class="line">====== LPUSH (needed to benchmark LRANGE) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.27 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.56% &lt;= 1 milliseconds</span><br><span class="line">99.89% &lt;= 2 milliseconds</span><br><span class="line">99.97% &lt;= 3 milliseconds</span><br><span class="line">100.00% &lt;= 4 milliseconds</span><br><span class="line">78616.35 requests per second</span><br><span class="line"></span><br><span class="line">====== LRANGE_100 (first 100 elements) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.17 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.44% &lt;= 1 milliseconds</span><br><span class="line">99.83% &lt;= 2 milliseconds</span><br><span class="line">99.96% &lt;= 3 milliseconds</span><br><span class="line">99.99% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 4 milliseconds</span><br><span class="line">85616.44 requests per second</span><br><span class="line"></span><br><span class="line">====== LRANGE_300 (first 300 elements) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.24 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">97.47% &lt;= 1 milliseconds</span><br><span class="line">99.55% &lt;= 2 milliseconds</span><br><span class="line">99.76% &lt;= 3 milliseconds</span><br><span class="line">99.89% &lt;= 4 milliseconds</span><br><span class="line">99.95% &lt;= 5 milliseconds</span><br><span class="line">99.95% &lt;= 15 milliseconds</span><br><span class="line">99.95% &lt;= 16 milliseconds</span><br><span class="line">99.98% &lt;= 17 milliseconds</span><br><span class="line">100.00% &lt;= 18 milliseconds</span><br><span class="line">100.00% &lt;= 28 milliseconds</span><br><span class="line">100.00% &lt;= 28 milliseconds</span><br><span class="line">80906.15 requests per second</span><br><span class="line"></span><br><span class="line">====== LRANGE_500 (first 450 elements) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.16 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.01% &lt;= 1 milliseconds</span><br><span class="line">99.78% &lt;= 2 milliseconds</span><br><span class="line">99.88% &lt;= 3 milliseconds</span><br><span class="line">99.99% &lt;= 4 milliseconds</span><br><span class="line">100.00% &lt;= 4 milliseconds</span><br><span class="line">86355.79 requests per second</span><br><span class="line"></span><br><span class="line">====== LRANGE_600 (first 600 elements) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.08 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.17% &lt;= 1 milliseconds</span><br><span class="line">99.82% &lt;= 2 milliseconds</span><br><span class="line">99.90% &lt;= 3 milliseconds</span><br><span class="line">99.96% &lt;= 4 milliseconds</span><br><span class="line">99.98% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 8 milliseconds</span><br><span class="line">100.00% &lt;= 8 milliseconds</span><br><span class="line">92250.92 requests per second</span><br><span class="line"></span><br><span class="line">====== MSET (10 keys) ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.28 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">96.11% &lt;= 1 milliseconds</span><br><span class="line">98.95% &lt;= 2 milliseconds</span><br><span class="line">99.49% &lt;= 3 milliseconds</span><br><span class="line">99.70% &lt;= 4 milliseconds</span><br><span class="line">99.76% &lt;= 5 milliseconds</span><br><span class="line">99.86% &lt;= 6 milliseconds</span><br><span class="line">99.94% &lt;= 7 milliseconds</span><br><span class="line">99.96% &lt;= 8 milliseconds</span><br><span class="line">99.98% &lt;= 10 milliseconds</span><br><span class="line">100.00% &lt;= 10 milliseconds</span><br><span class="line">78369.91 requests per second</span><br></pre></td></tr></table></figure>

<p> 到了环境中，QPS就不一定能有这么高了，因为网络本身就有开销，还有QPS两大杀手，一个是lrange操作，还有就是如果value很大，也比较费时。</p>
</li>
<li><p>水平扩容redis读节点，提升度吞吐量</p>
<p> 再在其他服务器上搭建redis从节点，单个从节点读请QPS在5万左右，两个redis从节点，所有的读请求到两台机器上去，承载整个集群读QPS在10万+。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战5-缓存预热</title>
    <url>/2018/02/22/cache/cache05/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>系统刚上线的时候，redis里面是没有数据的，如果这个时候高并发的流量过来全部跑到mysql，那么mysql肯定就挂掉了。所以我们需要缓存预热</p>
<a id="more"></a>

<ol>
<li>提前给redis中灌入部分数据，再提供服务</li>
<li>肯定不可能将所有数据都写入redis，因为数据量太大了，第一耗费的时间太长了，第二根本redis容纳不下所有的数据</li>
<li>需要根据当天的具体访问情况，实时统计出访问频率较高的热数据</li>
<li>然后将访问频率较高的热数据写入redis中，肯定是热数据也比较多，我们也得多个服务并行读取数据去写，并行的分布式的缓存预热</li>
<li>然后将灌入了热数据的redis对外提供服务，这样就不至于冷启动，直接让数据库裸奔了</li>
</ol>
<p>缓存预热的方案和流程：</p>
<p>1、 nginx+lua将访问流量上报到kafka中</p>
<p>要统计出来当前最新的实时的热数据是哪些，我们就得将商品详情页访问的请求对应的流量，日志，实时上报到kafka中。</p>
<p>2、 storm从kafka中消费数据，实时统计出每个商品的访问次数，访问次数基于LRU内存数据结构的存储方案</p>
<p><a href="http://www.saily.top/2018/02/22/cache04-3/">如何使用storm？</a></p>
<p>优先用内存中的一个LRUMap去存放，这样做性能高，而且没有外部依赖。否则依赖redis的话，我们本就是要防止redis挂掉数据丢失的情况，就不合适了; 用mysql，扛不住高并发读写; 用hbase，hadoop生态系统，维护麻烦，太重了。其实我们只要统计出最近一段时间访问最频繁的商品，然后对它们进行访问计数，同时维护出一个前N个访问最多的商品list即可。计算好每个task大致要存放的商品访问次数的数量，计算出大小。然后构建一个LRUMap，apache commons collections有开源的实现，设定好map的最大大小，就会自动根据LRU算法去剔除多余的数据，保证内存使用限制。即使有部分数据被干掉了，然后下次来重新开始计数，也没关系，因为如果它被LRU算法干掉，那么它就不是热数据，说明最近一段时间都很少访问了。</p>
<p>3、每个storm task启动的时候，基于zk分布式锁，将自己的id写入zk同一个节点中</p>
<p>4、每个storm task负责完成自己这里的热数据的统计，每隔一段时间，就遍历一下这个map，然后维护一个前3个商品的list，更新这个list</p>
<p>5、写一个后台线程，每隔一段时间，比如1分钟，都将排名前3的热数据list，同步到zk中去，存储到这个storm task对应的一个znode中去</p>
<p>6、我们需要一个服务，比如说，代码可以跟缓存数据生产服务放一起，但是也可以放单独的服务，这个服务可能部署了很多个实例。每次服务启动的时候，就会去拿到一个storm task的列表，然后根据taskid，一个一个的去尝试获取taskid对应的znode的zk分布式锁。如果能获取到分布式锁的话，那么就将那个storm task对应的热数据的list取出来，然后将数据从mysql中查询出来，写入缓存中，进行缓存的预热。因为是多个服务实例，分布式的并行的去做，都基于zk分布式锁做了协调（没有并发冲突问题），分布式并行缓存的预热，效率很高。</p>
<h2 id="基于nginx-lua完成商品详情页访问流量实时上报kafka的开发"><a href="#基于nginx-lua完成商品详情页访问流量实时上报kafka的开发" class="headerlink" title="基于nginx+lua完成商品详情页访问流量实时上报kafka的开发"></a>基于nginx+lua完成商品详情页访问流量实时上报kafka的开发</h2><p>在nginx这一层，接收到访问请求的时候，就把请求的流量上报发送给kafka。这样的话，storm才能去消费kafka中的实时的访问日志，然后去进行缓存热数据的统计。用的技术方案非常简单，从lua脚本直接创建一个kafka producer，发送数据到kafka。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">wget https://github.com/doujiang24/lua-resty-kafka/archive/master.zip</span><br><span class="line">yum install -y unzip</span><br><span class="line">unzip master.zip</span><br><span class="line">cp -rf /usr/<span class="built_in">local</span>/lua-resty-kafka-master/lib/resty /usr/hello/lualib</span><br></pre></td></tr></table></figure>

<p>接着修改脚本，开始写记录日志并发送到kafka：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&quot;cjson&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> producer = <span class="built_in">require</span>(<span class="string">&quot;resty.kafka.producer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> broker_list = &#123;</span><br><span class="line">	&#123;host=<span class="string">&quot;192.168.2.201&quot;</span>, port=<span class="number">9092</span>&#125;,</span><br><span class="line">	&#123;host=<span class="string">&quot;192.168.2.202&quot;</span>, port=<span class="number">9092</span>&#125;,</span><br><span class="line">	&#123;host=<span class="string">&quot;192.168.2.203&quot;</span>, port=<span class="number">9092</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> log_json = &#123;&#125;</span><br><span class="line"><span class="comment">-- 商品详情页</span></span><br><span class="line">log_json[<span class="string">&quot;request_module&quot;</span>] = <span class="string">&quot;product_detail_info&quot;</span></span><br><span class="line">log_json[<span class="string">&quot;headers&quot;</span>] = ngx.req.get_headers()</span><br><span class="line">log_json[<span class="string">&quot;uri_args&quot;</span>] = ngx.req.get_uri_args()</span><br><span class="line">log_json[<span class="string">&quot;body&quot;</span>] = ngx.req.read_body()  </span><br><span class="line">log_json[<span class="string">&quot;http_version&quot;</span>] = ngx.req.http_version()  </span><br><span class="line">log_json[<span class="string">&quot;method&quot;</span>] =ngx.req.get_method() </span><br><span class="line">log_json[<span class="string">&quot;raw_reader&quot;</span>] = ngx.req.raw_header()  </span><br><span class="line">log_json[<span class="string">&quot;body_data&quot;</span>] = ngx.req.get_body_data()  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> message = cjson.encode(log_json);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"><span class="keyword">local</span> shopId = uri_args[<span class="string">&quot;shopId&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向kafka发送请求的记录</span></span><br><span class="line"><span class="keyword">local</span> async_producer = producer:new(broker_list, &#123;producer_type=<span class="string">&quot;async&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">local</span> ok, err = async_producer:send(<span class="string">&quot;access-log&quot;</span>, productId, message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接商品和缓存的key</span></span><br><span class="line"><span class="keyword">local</span> productCacheKey = <span class="string">&quot;product_info_&quot;</span>..productId</span><br><span class="line"><span class="keyword">local</span> shopCacheKey = <span class="string">&quot;shop_info_&quot;</span>..shopId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取cache</span></span><br><span class="line"><span class="keyword">local</span> productCache = cache_ngx:get(productCacheKey)</span><br><span class="line"><span class="keyword">local</span> shopCache = cache_ngx:get(shopCacheKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 没有就从后端查询</span></span><br><span class="line"><span class="keyword">if</span> productCache ==  <span class="string">&quot;&quot;</span> <span class="keyword">or</span> productCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">&quot;resty.http&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">&quot;http://192.168.2.171:8080&quot;</span>,&#123;</span><br><span class="line">	method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">	<span class="built_in">path</span> = <span class="string">&quot;/getProductInfo?productId=&quot;</span>..productId</span><br><span class="line">    &#125;)</span><br><span class="line">    productCache = resp.body</span><br><span class="line">    cache_ngx:set(productCacheKey, productCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shopCache == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> shopCache == <span class="literal">nil</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">&quot;resty.http&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">&quot;http://192.168.2.171:8080&quot;</span>,&#123;</span><br><span class="line">	method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">	<span class="built_in">path</span> = <span class="string">&quot;/getShopInfo?shopId=&quot;</span>..shopId</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    shopCache = resp.body</span><br><span class="line">    cache_ngx:set(shopCacheKey, shopCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCacheJSON = cjson.decode(productCache)</span><br><span class="line"><span class="keyword">local</span> shopCacheJSON = cjson.decode(shopCache)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">	productId = productCacheJSON.id,</span><br><span class="line">	productName = productCacheJSON.name,</span><br><span class="line">	productPrice = productCacheJSON.price,</span><br><span class="line">	productPictureList = productCacheJSON.pictureList,</span><br><span class="line">	productSpecification = productCacheJSON.specification,</span><br><span class="line">	productService = productCacheJSON.service,</span><br><span class="line">	productColor = productCacheJSON.color,</span><br><span class="line">	productSize = productCacheJSON.size,</span><br><span class="line">	shopId = shopCacheJSON.id,</span><br><span class="line">	shopName = shopCacheJSON.name,</span><br><span class="line">	shopLevel = shopCacheJSON.level,</span><br><span class="line">	shopGoodCommentRate = shopCacheJSON.goodCommentRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 渲染模板</span></span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)</span><br><span class="line">template.render(<span class="string">&quot;product.html&quot;</span>, context)</span><br></pre></td></tr></table></figure>

<p>两台机器上都这样做，才能统一上报流量到kafka</p>
<p>修改配置：</p>
<ol>
<li>在nginx.conf中，http部分，加入resolver 8.8.8.8;</li>
<li>在<code>/usr/local/kafka/config/server.properties</code>中加入<code>advertised.host.name = 192.168.2.201</code>(各kafka实例的ip)，杀掉并重启三个kafka进程。<code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></li>
<li>启动eshop-cache缓存服务，因为nginx中的本地缓存可能不在了</li>
</ol>
<p>下面试试消息是否上报成功，先创建kafka topic。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic access-log --replication-factor 1 --partitions 1 --create</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://192.168.2.203/product?productId=1&amp;requestPath=product&amp;shopId=1">http://192.168.2.203/product?productId=1&amp;requestPath=product&amp;shopId=1</a></p>
<p>启动consumer，订阅access-log主题可以看到消息已经发送过来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper 192.168.2.201:2181,192.168.2.202:2181,192.168.2.203:2181 --topic access-log --from-beginning</span><br></pre></td></tr></table></figure>



<p><img src="/img/cache/cache05_1.png" alt="cache05_1.png"></p>
<h2 id="基于Storm统计热数据"><a href="#基于Storm统计热数据" class="headerlink" title="基于Storm统计热数据"></a>基于Storm统计热数据</h2><ol>
<li>用Spout从kafka读取消息</li>
<li>Bolt提取productId发射到下一个Bolt</li>
<li>基于LRUMap统计热点访问的productId</li>
<li>将热点数据存入zookeeper</li>
</ol>
<p><a href="https://github.com/sail-y/eshop-storm">https://github.com/sail-y/eshop-storm</a></p>
<p>预热逻辑：</p>
<ol>
<li>服务启动的时候，进行缓存预热</li>
<li>从zk中读取taskid列表</li>
<li>依次遍历每个taskid，尝试获取分布式锁，如果获取不到，快速报错，不要等待，因为说明已经有其他服务实例在预热了</li>
<li>直接尝试获取下一个taskid的分布式锁</li>
<li>即使获取到了分布式锁，也要检查一下这个taskid的预热状态，如果已经被预热过了，就不再预热了</li>
<li>执行预热操作，遍历productid列表，查询数据，然后写ehcache和redis</li>
<li>预热完成后，设置taskid对应的预热状态</li>
</ol>
<p><a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a></p>
<h2 id="基于nginx-lua-storm的热点缓存的流量分发策略自动降级解决方案"><a href="#基于nginx-lua-storm的热点缓存的流量分发策略自动降级解决方案" class="headerlink" title="基于nginx+lua+storm的热点缓存的流量分发策略自动降级解决方案"></a>基于nginx+lua+storm的热点缓存的流量分发策略自动降级解决方案</h2><p>如果因为秒杀等或者抢购等原因，某一个商品访问量瞬间飙升，就算做了流量分发和缓存，因为hash策略所以同一个productId会被分发到同一个nginx服务器中。那么这就可能会导致nginx服务挂掉，这一台挂掉后别的服务上，然后也陆陆续续挂掉，导致整个系统不可用。</p>
<hr>
<p><strong>解决办法：</strong></p>
<p><strong>在storm中实时的计算出瞬间出现的热点</strong></p>
<p>我们可以基于storm来计算热点数据，比如我们将访问的次数排序，将后面95%的数据访问量取一个平均值。这个时候要设定一个阈值，如果超出95%平均值的n倍，例如5倍，我们就认为是瞬间出现的热点数据，判断其可能在短时间内继续扩大的访问量，甚至达到平均值几十倍，或者几百倍，当发现第一个商品的访问次数，小于平均值的5倍，就安全了，就break掉这个循环。</p>
<p><strong>流量分发nginx的分发策略降级</strong></p>
<p>流量分发nginx加一个逻辑：每次访问一个商品详情页的时候，如果发现它是个热点，那么立即做流量分发策略的降级。降级成对这个热点商品，流量分发采取随机负载均衡发送到所有的后端应用nginx服务器上去。瞬间将热点缓存数据的访问从hash分发全部到一台nginx，变成了负载均衡发送到多台nginx上。</p>
<p><strong>storm还需要保存下来上次识别出来的热点list</strong></p>
<p>保存上次的热点数据，跟这次计算出的热点数据进行比较，那么就需要对某些数据进行热点取消，删除nginx本地缓存。</p>
<h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p><a href="https://github.com/sail-y/eshop-storm">https://github.com/sail-y/eshop-storm</a></p>
<pre><code>HotProductFindThread.java</code></pre>
<p>新增的逻辑：</p>
<ol>
<li>将LRUMap中的数据按照访问次数进行全局的排序</li>
<li>计算95%的商品访问次数的平均值</li>
<li>遍历排序后的商品访问次数，降序</li>
<li>如果某个商品是平均访问量的10倍以上，就认为是缓存的热点</li>
<li>将缓存热点数据推送到流量分发的nginx中</li>
<li>将获取到的换成你数据推送到nginx服务上</li>
</ol>
<h3 id="lua接口开发"><a href="#lua接口开发" class="headerlink" title="lua接口开发"></a>lua接口开发</h3><p><strong>将热点数据进行标记接口开发</strong></p>
<p>之前流量分发的nginx服务是部署在192.168.2.203上面的，所以<code>vi /usr/hello/hello.conf</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  _;</span><br><span class="line"></span><br><span class="line">    location /hello &#123;</span><br><span class="line">        default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/hello.lua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /product &#123;</span><br><span class="line">        default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/distribute.lua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /hot &#123;</span><br><span class="line">        default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        content_by_lua_file /usr/hello/lua/hot.lua;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/hello/lua/hot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> hot_product_cache_key = <span class="string">&quot;hot_product_&quot;</span>..product_id</span><br><span class="line">cache_ngx:<span class="built_in">set</span>(hot_product_cache_key, <span class="string">&quot;true&quot;</span>, 60*60)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>设置缓存数据接口开发</strong></p>
<p><strong>分别在201和201的nginx应用增加一个hot的配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/hello/hello.conf</span><br><span class="line">location /hot &#123;</span><br><span class="line">	default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">	content_by_lua_file /usr/hello/lua/hot.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi /usr/hello/lua/hot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"><span class="built_in">local</span> product_info = uri_args[<span class="string">&quot;productInfo&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> product_cache_key = <span class="string">&quot;product_info_&quot;</span>..product_id</span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line">cache_ngx:<span class="built_in">set</span>(product_cache_key, product_info, 60*60)</span><br></pre></td></tr></table></figure>


<h3 id="自动降级代码开发"><a href="#自动降级代码开发" class="headerlink" title="自动降级代码开发"></a>自动降级代码开发</h3><p>下面在distribute.lua里面开发自动降级的逻辑</p>
<ol>
<li>取出之前在hot.lua中缓存的hot_product_cache_key</li>
<li>如果为<code>true</code>就不走hash算法进行流量分发了，走随机负载均衡算法。</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> hosts = &#123;<span class="string">&quot;192.168.2.201&quot;</span>, <span class="string">&quot;192.168.2.202&quot;</span>&#125;</span><br><span class="line"><span class="keyword">local</span> backend = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">local</span> hot_product_key = <span class="string">&quot;hot_product_&quot;</span>..productId</span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"><span class="keyword">local</span> hot_product_flag = cache_ngx:get(hot_product_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hot_product_flag == <span class="string">&quot;true&quot;</span> <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">tostring</span>(<span class="built_in">os</span>.<span class="built_in">time</span>()):<span class="built_in">reverse</span>():<span class="built_in">sub</span>(<span class="number">1</span>, <span class="number">7</span>))</span><br><span class="line">  <span class="keyword">local</span> index = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  backend = <span class="string">&quot;http://&quot;</span>..hosts[index]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">local</span> hash = ngx.crc32_long(productId)</span><br><span class="line">  <span class="keyword">local</span> index = (hash % <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">  backend = <span class="string">&quot;http://&quot;</span>..hosts[index]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="热点缓存消失自动识别和感知逻辑开发"><a href="#热点缓存消失自动识别和感知逻辑开发" class="headerlink" title="热点缓存消失自动识别和感知逻辑开发"></a>热点缓存消失自动识别和感知逻辑开发</h3><p><a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a></p>
<p><strong>HotProductFindThread.java</strong>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓存热点消失，发送一个一个http请求到nginx取消热点缓存的标识</span><br><span class="line">String url &#x3D; &quot;http:&#x2F;&#x2F;192.168.2.203&#x2F;cancelHot?productId&#x3D;&quot; + productId;</span><br><span class="line">HttpClientUtils.sendGetRequest(url);</span><br></pre></td></tr></table></figure>

<p><strong>203上nginx的lua接口开发</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi hello.conf </span><br><span class="line">location /cancelHot &#123;</span><br><span class="line">    default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    content_by_lua_file /usr/hello/lua/cancelHot.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cp lua/hot.lua lua/cancelHot.lua</span><br><span class="line"></span><br><span class="line">vi lua/cancelHot.lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> product_id = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> hot_product_cache_key = <span class="string">&quot;hot_product_&quot;</span>..product_id</span><br><span class="line"></span><br><span class="line">cache_ngx:<span class="built_in">set</span>(hot_product_cache_key, <span class="string">&quot;false&quot;</span>, 60)</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>手动将某个热点设置为热点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.2.203&#x2F;hot?productId&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.2.203&#x2F;product?productId&#x3D;1&amp;requestPath&#x3D;product&amp;shopId&#x3D;1</span><br></pre></td></tr></table></figure>

<p>可以看到当缓存变成热点以后，访问的服务是随机变化的。</p>
<p>因为代码里用了缓存，所以记得在203的上面<code>vi conf/nginx.conf</code>，在http模块下新增<code>lua_shared_dict my_cache 128m;</code>。</p>
<ol>
<li>多访问几次不同的商品ID</li>
<li>用storm运行topology，观察日志是否正确</li>
<li>观察zookeeper里面的数据是否正确</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkCli.sh</span><br><span class="line">get /task-hot-product-list-4</span><br><span class="line">[5,1,3]</span><br></pre></td></tr></table></figure>


<p>storm日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2018-03-03 21:12:56.627 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread计算出一份排序后的商品访问次数列表】 productCountListJSON=[&#123;1:11&#125;,&#123;3:1&#125;,&#123;5:1&#125;,&#123;9:1&#125;,&#123;7:1&#125;]</span><br><span class="line">2018-03-03 21:12:56.637 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread计算出一份top3热门商品列表】zk path=/task-hot-product-list-4, topnProductListJSON=[1,3,5]</span><br><span class="line">2018-03-03 21:12:56.677 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】计算出后95%访问次数的平均值 avgCount=1.0</span><br><span class="line">2018-03-03 21:12:56.821 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 发现一个新的热点 productId=1</span><br><span class="line">2018-03-03 21:12:58.754 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] http://192.168.2.201/hot?productId=1&amp;productInfo=%7B%22id%22%3A1%2C%22name%22%3A%22iphone7%E6%89%8B%E6%9C%BA%22%2C%22price%22%3A5599.0%2C%22pictureList%22%3A%22a.jpg%2Cb.jpg%22%2C%22specification%22%3A%22iphone7%E7%9A%84%E8%A7%84%E6%A0%BC%22%2C%22service%22%3A%22iphone7%E7%9A%84%E5%94%AE%E5%90%8E%E6%9C%8D%E5%8A%A1%22%2C%22color%22%3A%22%E7%BA%A2%E8%89%B2%2C%E7%99%BD%E8%89%B2%2C%E9%BB%91%E8%89%B2%22%2C%22size%22%3A%225.5%22%2C%22shopId%22%3A1%2C%22modifiedTime%22%3A%222017-01-01+12%3A00%3A00%22%7D%0A</span><br><span class="line">2018-03-03 21:12:58.787 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] http://192.168.2.202/hot?productId=1&amp;productInfo=%7B%22id%22%3A1%2C%22name%22%3A%22iphone7%E6%89%8B%E6%9C%BA%22%2C%22price%22%3A5599.0%2C%22pictureList%22%3A%22a.jpg%2Cb.jpg%22%2C%22specification%22%3A%22iphone7%E7%9A%84%E8%A7%84%E6%A0%BC%22%2C%22service%22%3A%22iphone7%E7%9A%84%E5%94%AE%E5%90%8E%E6%9C%8D%E5%8A%A1%22%2C%22color%22%3A%22%E7%BA%A2%E8%89%B2%2C%E7%99%BD%E8%89%B2%2C%E9%BB%91%E8%89%B2%22%2C%22size%22%3A%225.5%22%2C%22shopId%22%3A1%2C%22modifiedTime%22%3A%222017-01-01+12%3A00%3A00%22%7D%0A</span><br><span class="line">2018-03-03 21:12:58.807 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 保存上次热点数据 lastTimeHotProductList=[1]</span><br><span class="line">2018-03-03 21:13:01.637 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br></pre></td></tr></table></figure>

<p>然后访问几次别的商品，把平均数提高。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2018-03-03 21:15:01.948 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread计算出一份top3热门商品列表】zk path=/task-hot-product-list-4, topnProductListJSON=[1,3,5]</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread计算出一份排序后的商品访问次数列表】 productCountListJSON=[&#123;1:12&#125;,&#123;3:3&#125;,&#123;5:1&#125;,&#123;9:1&#125;,&#123;7:1&#125;]</span><br><span class="line">2018-03-03 21:15:03.839 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】计算出后95%访问次数的平均值 avgCount=1.5</span><br><span class="line">2018-03-03 21:15:03.866 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 发现一个热点消失了 productId=1</span><br><span class="line">2018-03-03 21:15:03.866 c.r.e.s.b.ProductCountBolt Thread-17 [INFO] 【HotProductFindThread】 保存上次热点数据 lastTimeHotProductList=[]</span><br><span class="line">2018-03-03 21:15:06.949 c.r.e.s.b.ProductCountBolt Thread-16 [INFO] 【ProductCountThread打印productCountMap的长度】size=5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>多级缓存架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战4-多级缓存架构.高并发读写方案.nginx流量分发方案.ZK分布式锁解决并发冲突方案</title>
    <url>/2018/02/18/cache/cache04/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h2 id="上亿流量的商品详情页系统的多级缓存架构"><a href="#上亿流量的商品详情页系统的多级缓存架构" class="headerlink" title="上亿流量的商品详情页系统的多级缓存架构"></a>上亿流量的商品详情页系统的多级缓存架构</h2><p>很多人以为做个缓存其实就是用一下redis访问一下就可以了，这只是简单的缓存使用方式。做复杂的缓存，支撑电商等复杂的场景下的高并发的缓存，遇到的问题非常非常之多，绝对不是说简单的访问一下redis就可以了。</p>
<a id="more"></a>
<p>通常采用三级缓存：<strong>nginx本地缓存+redis分布式缓存+tomcat堆缓存的多级缓存架构</strong></p>
<p><img src="/img/cache/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
<p>时效性要求非常高的数据：<strong>库存</strong></p>
<p>一般来说，显示的库存都是时效性要求会相对高一些，因为随着商品的不断的交易，库存会不断的变化。当然，我们就希望当库存变化的时候，尽可能更快将库存显示到页面上去，而不是说等了很长时间，库存才反应到页面上去。</p>
<p>时效性要求不高的数据：<strong>商品的基本信息（名称. 颜色. 版本. 规格参数，等等）</strong>，时效性要求不高的数据，就还好，比如说你现在改变了商品的名称，稍微晚个几分钟反应到商品页面上，也是可以接受的。</p>
<p>商品价格/库存等时效性要求高的数据，这种数据不多，相关的服务系统每次发生了变更的时候，直接采取数据库和redis缓存双写的方案，这样缓存的时效性最高。</p>
<p>商品基本信息等时效性不高的数据，而且种类繁多，来自多种不同的系统，采取MQ异步通知的方式，写一个数据生产服务，监听MQ消息，然后异步拉取服务的数据，更新tomcat jvm缓存+redis缓存。</p>
<p>流程：<strong>nginx+lua脚本做页面动态生成的工作</strong>，每次请求过来，优先从nginx本地缓存中提取各种数据，结合页面模板，生成需要的页面。如果nginx本地缓存过期了，那么就从nginx到<strong>redis</strong>中去拉取数据，更新到nginx本地。如果redis中也被LRU算法清理掉了，那么就从nginx走http接口到后端的服务中拉取数据，数据生产服务中，先在本地<strong>tomcat里的jvm堆缓存（ehcache）</strong>中找，如果也被LRU清理掉了，那么就重新发送请求到源头的服务中去拉取数据，然后<strong>再次更新tomcat堆内存缓存+redis缓存，并返回数据给nginx，nginx缓存到本地。</strong></p>
<h3 id="多级缓存架构中每一层的意义"><a href="#多级缓存架构中每一层的意义" class="headerlink" title="多级缓存架构中每一层的意义"></a>多级缓存架构中每一层的意义</h3><p><strong>nginx本地缓存</strong>，抗的是热数据的高并发访问，一般来说，商品的购买总是有热点的，比如每天购买iphone. nike. 海尔等知名品牌的东西的人，总是比较多的。这些热数据，由于经常被访问，利用nginx本地缓存，所以可以被锁定在nginx的本地缓存内。大量的热数据的访问，就会被保留在nginx本地缓存内，那么对这些热数据的大量访问，就直接走nginx就可以了。那么大量的访问，直接就可以走到nginx就行了，不需要走后续的各种网络开销了。</p>
<p><strong>redis分布式大规模缓存</strong>，抗的是很高的离散访问，支撑海量的数据，高并发的访问，高可用的服务。redis缓存最大量最完整的数据，可能1T+数据; 支撑高并发的访问，QPS最高到几十万; 可用性需要非常好，提供非常稳定的服务。nginx本地内存有限，也就能cache住部分热数据，除了各种iphone. nike等热数据，其他相对不那么热的数据，可能流量会经常走到redis那里。利用redis cluster的多master写入，横向扩容，1T+以上海量数据支持，几十万的读写QPS，99.99%高可用性都没有问题，那么就可以抗住大量的离散访问请求。</p>
<p><strong>tomcat jvm堆内存缓存</strong>，主要是抗redis大规模灾难的情况，如果redis出现了大规模的宕机，导致nginx大量流量直接涌入数据生产服务，那么最后的tomcat堆内存缓存至少可以再抗一下，不至于让数据库直接裸奔。同时tomcat jvm堆内存缓存，也可以抗住redis没有cache住的最后那少量的部分缓存。</p>
<h3 id="多级缓存架构项目实例源码"><a href="#多级缓存架构项目实例源码" class="headerlink" title="多级缓存架构项目实例源码"></a>多级缓存架构项目实例源码</h3><p>时效性要求不高的数据，采取的是异步更新缓存的策略。缓存数据生产服务，监听一个消息队列，然后数据源服务（商品信息管理服务）发生了数据变更之后，就将数据变更的消息推送到消息队列中。缓存数据生产服务可以去消费这个数据变更的消息，然后根据消息的指示提取一些参数，然后调用对应的数据源服务的接口拉取数据，这个时候一般是从mysql库中拉取的。</p>
<p>这里消息中间件，我们使用<code>kafka</code>，<a href="http://www.saily.top/2018/02/20/cache04-2/">zookeeper+kafka集群的安装部署</a></p>
<p>项目源码地址：<a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a></p>
<h3 id="Nginx层缓存"><a href="#Nginx层缓存" class="headerlink" title="Nginx层缓存"></a>Nginx层缓存</h3><p>前面三层缓存架构中的本地堆缓存+redis分布式缓存都做好了，接下来就要来做三级缓存中的nginx那一层的缓存了。一般默认会部署多个nginx，在里面都会放一些缓存，默认情况下，此时缓存命中率是比较低的，因为流量会均分。</p>
<p><strong>如何提升缓存命中率？</strong></p>
<p>分发层+应用层，双层nginx。</p>
<p>分发层nginx，负责流量分发的逻辑和策略，它可以用lua脚本开发一些规则，比如根据productId去进行hash，然后对后端的nginx数量取模，将某一个商品的访问的请求，就固定路由到一个nginx后端服务器上去，保证只会从redis中获取一次缓存数据，再次请求全都是走nginx本地缓存了。</p>
<p>后端的nginx服务器，就称之为应用服务器; 最前端的nginx服务器，被称之为分发服务器。看似很简单，其实很有用，在实际的生产环境中，可以大幅度提升你的nginx本地缓存这一层的命中率，大幅度减少redis后端的压力，提升性能。</p>
<p>这里会采用OpenResty的方式去部署nginx，而且会写一个nginx+lua开发的一个hello world。</p>
<h4 id="部署第一个nginx，作为应用层nginx"><a href="#部署第一个nginx，作为应用层nginx" class="headerlink" title="部署第一个nginx，作为应用层nginx"></a>部署第一个nginx，作为应用层nginx</h4><p>我这里部署到我机器上192.168.2.201，教程参考<a href="http://jinnianshilongnian.iteye.com/blog/2186270">http://jinnianshilongnian.iteye.com/blog/2186270</a></p>
<h4 id="部署openresty"><a href="#部署openresty" class="headerlink" title="部署openresty"></a>部署openresty</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y readline-devel pcre-devel openssl-devel gcc</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/servers  </span><br><span class="line"><span class="built_in">cd</span> /usr/servers/</span><br><span class="line"></span><br><span class="line">wget http://openresty.org/download/ngx_openresty-1.7.7.2.tar.gz  </span><br><span class="line">tar -xzvf ngx_openresty-1.7.7.2.tar.gz  </span><br><span class="line"><span class="built_in">cd</span> /usr/servers/ngx_openresty-1.7.7.2/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle/LuaJIT-2.1-20150120/  </span><br><span class="line">make clean &amp;&amp; make &amp;&amp; make install  </span><br><span class="line">ln -sf luajit-2.1.0-alpha /usr/<span class="built_in">local</span>/bin/luajit</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle  </span><br><span class="line">wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz  </span><br><span class="line">tar -xvf 2.3.tar.gz  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bundle  </span><br><span class="line">wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz  </span><br><span class="line">tar -xvf v0.3.0.tar.gz  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/servers/ngx_openresty-1.7.7.2  </span><br><span class="line">./configure --prefix=/usr/servers --with-http_realip_module  --with-pcre  --with-luajit --add-module=./bundle/ngx_cache_purge-2.3/ --add-module=./bundle/nginx_upstream_check_module-0.3.0/ -j2  </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/servers/  </span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">/usr/servers/luajit</span><br><span class="line">/usr/servers/lualib</span><br><span class="line">/usr/servers/nginx</span><br><span class="line">/usr/servers/nginx/sbin/nginx -v </span><br></pre></td></tr></table></figure>
<p>启动nginx: <code>/usr/servers/nginx/sbin/nginx</code></p>
<h4 id="nginx-lua开发的hello-world"><a href="#nginx-lua开发的hello-world" class="headerlink" title="nginx+lua开发的hello world"></a>nginx+lua开发的hello world</h4><pre><code>vi /usr/servers/nginx/conf/nginx.conf</code></pre>
<p>在http部分添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua_package_path &quot;&#x2F;usr&#x2F;servers&#x2F;lualib&#x2F;?.lua;;&quot;;  </span><br><span class="line">lua_package_cpath &quot;&#x2F;usr&#x2F;servers&#x2F;lualib&#x2F;?.so;;&quot;;  </span><br></pre></td></tr></table></figure>

<p><code>/usr/servers/nginx/conf</code>下，创建一个<code>lua.conf</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在nginx.conf的http部分添加：</p>
<pre><code>include lua.conf;</code></pre>
<p>验证配置是否正确：</p>
<pre><code>/usr/servers/nginx/sbin/nginx -t</code></pre>
<p>在lua.conf的server部分添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua &#123;  </span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">    content_by_lua &#39;ngx.say(&quot;hello world&quot;)&#39;;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>验证配置是否正确：</p>
<pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre>
<p>重新nginx加载配置</p>
<pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre>
<p>访问： <a href="http://192.168.2.201/lua">http://192.168.2.201/lua</a></p>
<p>成功输出 hello world</p>
<hr>
<p>接下来替换成lua脚本文件执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/servers/nginx/conf/lua/</span><br><span class="line">vi /usr/servers/nginx/conf/lua/test.lua</span><br><span class="line">ngx.say(<span class="string">&quot;hello world&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>修改lua.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua &#123;  </span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">    content_by_lua_file conf&#x2F;lua&#x2F;test.lua; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证配置是否正确：</p>
<pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre>
<p>重新nginx加载配置</p>
<pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre>
<hr>
<p>查看异常日志</p>
<pre><code>tail -f /usr/servers/nginx/logs/error.log</code></pre>
<h4 id="工程化的nginx-lua项目结构"><a href="#工程化的nginx-lua项目结构" class="headerlink" title="工程化的nginx+lua项目结构"></a>工程化的nginx+lua项目结构</h4><p>刚才只是写了一个hello world，在正式的项目中，脚本的目录结构一般是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">    hello.conf     </span><br><span class="line">    lua              </span><br><span class="line">      hello.lua</span><br><span class="line">    lualib            </span><br><span class="line">      *.lua</span><br><span class="line">      *.so</span><br></pre></td></tr></table></figure>

<p>放在/usr/hello目录下，不会放在nginx所在文件夹里。</p>
<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/hello/lua</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ngx.say(&quot;hello world&quot;);&#x27;</span> &gt;&gt; /usr/hello/lua/hello.lua</span><br><span class="line">cp -r /usr/servers/lualib /usr/hello</span><br><span class="line"></span><br><span class="line">vi /usr/hello/hello.conf</span><br><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">  </span><br><span class="line">    location /hello &#123;  </span><br><span class="line">        default_type <span class="string">&#x27;text/html&#x27;</span>;  </span><br><span class="line">        content_by_lua_file /usr/hello/lua/hello.lua;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>修改<code>nginx.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/servers/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">worker_processes  2;  </span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;  </span><br><span class="line"></span><br><span class="line">events &#123;  </span><br><span class="line">    worker_connections  1024;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">http &#123;  </span><br><span class="line">    include       mime.types;  </span><br><span class="line">    default_type  text/html;  </span><br><span class="line">  </span><br><span class="line">    lua_package_path <span class="string">&quot;/usr/hello/lualib/?.lua;;&quot;</span>;  </span><br><span class="line">    lua_package_cpath <span class="string">&quot;/usr/hello/lualib/?.so;;&quot;</span>; </span><br><span class="line">    include /usr/hello/hello.conf;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>验证配置是否正确：</p>
<pre><code>/usr/servers/nginx/sbin/nginx -t  </code></pre>
<p>重新nginx加载配置</p>
<pre><code>/usr/servers/nginx/sbin/nginx -s reload  </code></pre>
<p>如法炮制，在另外一个机器上，也用OpenResty部署一个nginx。</p>
<h4 id="开发和部署流量分发层"><a href="#开发和部署流量分发层" class="headerlink" title="开发和部署流量分发层"></a>开发和部署流量分发层</h4><p>我在eshop-cache02和eshop-cache03上都部署好了openresty。现在用eshop-cache01和eshop-cache02作为应用层nginx服务器，用eshop-cache03作为分发层nginx。</p>
<p>现在在eshop-cache03，也就是分发层nginx中，编写lua脚本，完成基于商品id的流量分发策略：</p>
<ol>
<li>获取请求参数，比如productId</li>
<li>对productId进行hash</li>
<li>hash值对应用服务器数量取模，获取到一个应用服务器</li>
<li>利用http发送请求到应用层nginx</li>
<li>获取响应后返回</li>
</ol>
<p>这个就是基于商品id的定向流量分发的策略，lua脚本来编写和实现。作为一个流量分发的nginx，会发送http请求到后端的应用nginx上面去，所以要先引入lua http lib包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http_headers.lua  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua </span><br></pre></td></tr></table></figure>

<p>然后我们编辑流量分发的代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> hosts = &#123;<span class="string">&quot;192.168.2.201&quot;</span>, <span class="string">&quot;192.168.2.202&quot;</span>&#125;</span><br><span class="line"><span class="keyword">local</span> hash = ngx.crc32_long(productId)</span><br><span class="line"><span class="keyword">local</span> index = (hash % <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">backend = <span class="string">&quot;http://&quot;</span>..hosts[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> requestPath = uri_args[<span class="string">&quot;requestPath&quot;</span>]</span><br><span class="line">requestPath = <span class="string">&quot;/&quot;</span>..requestPath..<span class="string">&quot;?productId=&quot;</span>..productId</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">&quot;resty.http&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> resp, err = httpc:request_uri(backend, &#123;</span><br><span class="line">    method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="built_in">path</span> = requestPath</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">   ngx.say(<span class="string">&quot;request error :&quot;</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ngx.say(resp.body)</span><br><span class="line"></span><br><span class="line">httpc:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

<p>访问测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br><span class="line">http://192.168.2.203/hello?productId=5&amp;requestPath=hello</span><br><span class="line">hello world. this is eshop-cache01</span><br></pre></td></tr></table></figure>

<p>基于商品id的定向流量分发策略的lua脚本就开发完了。经过测试可以看到，如果请求的是固定的某一个商品，那么就一定会将流量分到固定的一个应用nginx上面去。</p>
<h3 id="基于nginx-lua-java完成多级缓存架构的核心业务逻辑"><a href="#基于nginx-lua-java完成多级缓存架构的核心业务逻辑" class="headerlink" title="基于nginx+lua+java完成多级缓存架构的核心业务逻辑"></a>基于nginx+lua+java完成多级缓存架构的核心业务逻辑</h3><p>上面做了流量分发的demo测试，Java层级的缓存开发，接下来把他们对接起来，正式编写分发层和应用层的脚本。</p>
<p>eshop-cache03机器上修改流量分发层配置和lua脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi hello.conf</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">location /product &#123;</span><br><span class="line">    default_type <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    content_by_lua_file /usr/hello/lua/distribute.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> lua</span><br><span class="line">cp hello.lua distribute.lua</span><br><span class="line">vi distribute.lua</span><br><span class="line"><span class="comment"># 添加shopId</span></span><br><span class="line"><span class="built_in">local</span> shopId = uri_args[<span class="string">&quot;shopId&quot;</span>]</span><br><span class="line">requestPath = <span class="string">&quot;/&quot;</span>..requestPath..<span class="string">&quot;?productId=&quot;</span>..productId..<span class="string">&quot;&amp;shopId=&quot;</span>..shopId</span><br><span class="line"></span><br><span class="line">/usr/servers/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<hr>
<p>修改应用层配置和lua脚本：</p>
<ol>
<li><p>应用nginx的lua脚本接收到请求</p>
</li>
<li><p>获取请求参数中的商品id，以及商品店铺id</p>
</li>
<li><p>根据商品id和商品店铺id，在nginx本地缓存中尝试获取数据</p>
</li>
<li><p>如果在nginx本地缓存中没有获取到数据，那么就到redis分布式缓存中获取数据，如果获取到了数据，还要设置到nginx本地缓存中</p>
<p> 这里有个问题，建议不要用nginx+lua直接去获取redis数据。因为openresty没有太好的redis cluster的支持包，所以建议是发送http请求到缓存数据生产服务，由该服务提供一个http接口。缓存数生产服务可以基于redis cluster api从redis中直接获取数据，并返回给nginx。</p>
</li>
<li><p>如果缓存数据生产服务没有在redis分布式缓存中没有获取到数据，那么就在自己本地ehcache中获取数据，返回数据给nginx，也要设置到nginx本地缓存中</p>
</li>
<li><p>如果ehcache本地缓存都没有数据，那么就需要去原始的服务中拉去数据，该服务会从mysql中查询，拉去到数据之后，返回给nginx，并重新设置到ehcache和redis中</p>
</li>
<li><p>nginx最终利用获取到的数据，动态渲染网页模板</p>
<p> 因为应用层也要访问http接口，所以也需要部署http依赖和模板的依赖</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/	master/lib/resty/http_headers.lua  </span><br><span class="line">wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua </span><br><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/</span><br><span class="line">wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template.lua</span><br><span class="line">mkdir /usr/hello/lualib/resty/html</span><br><span class="line"><span class="built_in">cd</span> /usr/hello/lualib/resty/html</span><br><span class="line">wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template/html.lua</span><br></pre></td></tr></table></figure>
<p> 在hello.conf的server中配置模板位置</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="variable">$template_location</span> <span class="string">&quot;/templates&quot;</span>;  </span><br><span class="line"><span class="built_in">set</span> <span class="variable">$template_root</span> <span class="string">&quot;/usr/hello/templates&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> 编辑要显示的模板：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/hello/templates</span><br><span class="line"><span class="built_in">cd</span> /usr/hello/templates</span><br><span class="line">vi product.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">		&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">		&lt;title&gt;商品详情页&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">商品id: &#123;* productId *&#125;&lt;br/&gt;</span><br><span class="line">商品名称: &#123;* productName *&#125;&lt;br/&gt;</span><br><span class="line">商品图片列表: &#123;* productPictureList *&#125;&lt;br/&gt;</span><br><span class="line">商品规格: &#123;* productSpecification *&#125;&lt;br/&gt;</span><br><span class="line">商品售后服务: &#123;* productService *&#125;&lt;br/&gt;</span><br><span class="line">商品颜色: &#123;* productColor *&#125;&lt;br/&gt;</span><br><span class="line">商品大小: &#123;* productSize *&#125;&lt;br/&gt;</span><br><span class="line">店铺id: &#123;* shopId *&#125;&lt;br/&gt;</span><br><span class="line">店铺名称: &#123;* shopName *&#125;&lt;br/&gt;</span><br><span class="line">店铺评级: &#123;* shopLevel *&#125;&lt;br/&gt;</span><br><span class="line">店铺好评率: &#123;* shopGoodCommentRate *&#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>将渲染后的网页模板作为http响应，返回给分发层nginx</p>
<p> 在<code>nginx.conf</code>的http模块里添加：</p>
 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 添加nginx本地缓存的支持</span><br><span class="line">lua_shared_dict my_cache <span class="number">128</span>m;</span><br></pre></td></tr></table></figure>
<p> 修改<code>hello.conf</code>：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加路由</span><br><span class="line">location &#x2F;product &#123;</span><br><span class="line">  	 default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">   	content_by_lua_file &#x2F;usr&#x2F;hello&#x2F;lua&#x2F;product.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 修改lua/product.lua脚本，注意192.168.2.171是我本机的ip，启动了Java项目：</p>
 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vi lua/product.lua</span><br><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> productId = uri_args[<span class="string">&quot;productId&quot;</span>]</span><br><span class="line"><span class="keyword">local</span> shopId = uri_args[<span class="string">&quot;shopId&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCacheKey = <span class="string">&quot;product_info_&quot;</span>..productId</span><br><span class="line"><span class="keyword">local</span> shopCacheKey = <span class="string">&quot;shop_info_&quot;</span>..shopId</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> productCache = cache_ngx:get(productCacheKey)</span><br><span class="line"><span class="keyword">local</span> shopCache = cache_ngx:get(shopCacheKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> productCache == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> productCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">&quot;resty.http&quot;</span>)</span><br><span class="line">	<span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">&quot;http://192.168.2.171:8080&quot;</span>,&#123;</span><br><span class="line">  		method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  		<span class="built_in">path</span> = <span class="string">&quot;/getProductInfo?productId=&quot;</span>..productId</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	productCache = resp.body</span><br><span class="line">	cache_ngx:set(productCacheKey, productCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shopCache == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> shopCache == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">local</span> http = <span class="built_in">require</span>(<span class="string">&quot;resty.http&quot;</span>)</span><br><span class="line">	<span class="keyword">local</span> httpc = http.new()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">local</span> resp, err = httpc:request_uri(<span class="string">&quot;http://192.168.2.171:8080&quot;</span>,&#123;</span><br><span class="line">  		method = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  		<span class="built_in">path</span> = <span class="string">&quot;/getShopInfo?shopId=&quot;</span>..shopId</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	shopCache = resp.body</span><br><span class="line">	cache_ngx:set(shopCacheKey, shopCache, <span class="number">10</span> * <span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&quot;cjson&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> productCacheJSON = cjson.decode(productCache)</span><br><span class="line"><span class="keyword">local</span> shopCacheJSON = cjson.decode(shopCache)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">	productId = productCacheJSON.id,</span><br><span class="line">	productName = productCacheJSON.name,</span><br><span class="line">	productPrice = productCacheJSON.price,</span><br><span class="line">	productPictureList = productCacheJSON.pictureList,</span><br><span class="line">	productSpecification = productCacheJSON.specification,</span><br><span class="line">	productService = productCacheJSON.service,</span><br><span class="line">	productColor = productCacheJSON.color,</span><br><span class="line">	productSize = productCacheJSON.size,</span><br><span class="line">	shopId = shopCacheJSON.id,</span><br><span class="line">	shopName = shopCacheJSON.name,</span><br><span class="line">	shopLevel = shopCacheJSON.level,</span><br><span class="line">	shopGoodCommentRate = shopCacheJSON.goodCommentRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)</span><br><span class="line">template.render(<span class="string">&quot;product.html&quot;</span>, context)</span><br></pre></td></tr></table></figure>
<p> 写到这里，应该去把java项目里的2个接口给补充一下。还是之前的项目：<a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a></p>
</li>
</ol>
<h3 id="分布式重建缓存的并发冲突问题"><a href="#分布式重建缓存的并发冲突问题" class="headerlink" title="分布式重建缓存的并发冲突问题"></a>分布式重建缓存的并发冲突问题</h3><p>之前在Java代码里会先去redis里面取数据，如果redis取不到，就会去ehcache里面取，如果还是取不到，就需要重建缓存了。</p>
<p>但是重建缓存有一个问题，因为我们的服务可能是多实例的，虽然在nginx层我们通过流量分发将请求通过id分发到了不同的nginx应用层上。那么到了接口服务层，可能多次请求访问的是不同的实例，那么可能会导致多个机器去重建读取相同的数据，然后写入缓存中，这就有了<strong>分布式重建缓存的并发冲突问题。</strong></p>
<p>问题就是可能2个实例获取到的数据快照不一样，但是新数据先写入缓存，如果这个时候另外一个实例的缓存后写入，就有问题了。</p>
<p><img src="/img/cache/%E5%A4%9A%E4%B8%AA%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%87%8D%E5%BB%BA%E7%9A%84%E5%B9%B6%E5%8F%91%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98.png" alt="多个缓存服务实例分布式重建的并发冲突问题"></p>
<p>这个问题有好几种解决方案：</p>
<ol>
<li><p>一样的在应用层对id进行取模然后固定分发到不同的服务实例上</p>
</li>
<li><p>将更新缓存的请求发送到同一个分区的kafka消息中</p>
<p> 一般来讲，每个服务实例都会监听kafka一个topic的某一个分区，所以具体去哪一个分区也得取模，保证是同一个实例消费到更新的请求。但问题是在nginx算出来的hash取模可能与kafka生产者的hash策略算出来的分区可能并不一致，还是可能有并发冲突问题。</p>
</li>
<li><p>基于zookeeper分布式锁的解决方案</p>
<p> 分布式锁，如果你有多个机器在访问同一个共享资源，加个锁让多个分布式的机器在访问共享资源的时候串行起来。</p>
</li>
</ol>
<h4 id="zk分布式锁的解决并发冲突的方案"><a href="#zk分布式锁的解决并发冲突的方案" class="headerlink" title="zk分布式锁的解决并发冲突的方案"></a>zk分布式锁的解决并发冲突的方案</h4><p><img src="/img/cache/%E5%9F%BA%E4%BA%8Ezookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></p>
<ol>
<li>变更缓存重建以及空缓存请求重建，更新redis之前，都需要先获取对应商品id的分布式锁</li>
<li>拿到分布式锁之后，需要根据时间版本去比较一下，如果自己的版本新于redis中的版本，那么就更新，否则就不更新</li>
<li>如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获取到分布式的锁</li>
</ol>
<p>方案源码实现：<a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a></p>
<p><code>ZooKeeperSession.java</code></p>
<h2 id="经典的缓存-数据库读写的模式（cache-aside-pattern）"><a href="#经典的缓存-数据库读写的模式（cache-aside-pattern）" class="headerlink" title="经典的缓存+数据库读写的模式（cache aside pattern）"></a>经典的缓存+数据库读写的模式（cache aside pattern）</h2><ol>
<li><p>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应</p>
</li>
<li><p>更新的时候，先删除缓存，然后再更新数据库</p>
</li>
</ol>
<p><strong>为什么是删除缓存，而不是更新缓存呢？</strong></p>
<p>原因很简单，很多时候，复杂点的缓存的场景，因为缓存有的时候，不简单是数据库中直接取出来的值。比如商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要真正把这个影响的最终的库存计算出来，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出现在最新的库存是多少，然后才能将库存更新到缓存中去。</p>
<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据，并进行运算，才能计算出缓存最新的值的，更新缓存的代价是很高的。还有一个问题就是，是不是每次修改数据库的时候，都一定要将其对应的缓存去跟新一份？也许有的场景是这样的，但是对于比较复杂的缓存数据计算的场景，就不是这样了。举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次，100次; 但是这个缓存在1分钟内就被读取了1次，系统有大量的冷数据，28法则，20%的数据，占用了80%的访问量。实际上，如果你只是删除缓存的话，那么1分钟内，访问的时候再计算，这个缓存不过就重新计算一次而已，开销大幅度降低。每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在1分钟内只是被访问了1次，那么只有那1次，缓存是要被重新计算的，用缓存才去算缓存。其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<h2 id="缓存-数据库双写不一致问题分析"><a href="#缓存-数据库双写不一致问题分析" class="headerlink" title="缓存+数据库双写不一致问题分析"></a>缓存+数据库双写不一致问题分析</h2><h3 id="最初级的缓存不一致问题以及解决方案"><a href="#最初级的缓存不一致问题以及解决方案" class="headerlink" title="最初级的缓存不一致问题以及解决方案"></a>最初级的缓存不一致问题以及解决方案</h3><p>问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致</p>
<p>解决思路：</p>
<p>先删除缓存，再修改数据库，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p>
<h3 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h3><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中，数据变更的程序完成了数据库的修改，这个时候数据库和缓存中的数据不一样了。</p>
<p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况，高并发了以后，问题是很多的。</p>
<p>解决方案：</p>
<p><img src="/img/cache/%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93+%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E4%BF%9D%E9%9A%9C%E6%96%B9%E6%A1%88.png"></p>
<p><strong>数据库与缓存更新与读取操作进行异步串行化。</strong>更新数据的时候，根据数据的唯一标识（例如hash值取模），将操作路由之后，发送到一个jvm内部的队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中。一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p>
<p>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<p><strong>高并发的场景下，该解决方案要注意的问题</strong></p>
<ol>
<li><p>读请求长时阻塞</p>
<p> 由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。该解决方案，最大的风险点在于可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库，所以务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的。</p>
<p> 另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压100个商品的库存修改操作，每个库存修改操作要耗费10ms去完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据，这个时候就导致读请求的长时阻塞。</p>
<p> 一定要做根据实际业务系统的运行情况，去进行一些压力测试和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求会hang多少时间，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以。如果一个内存队列可能积压的更新操作特别多，那么就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p>
<p> 一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的，针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了。比如500/s的写操作，拆成5份，每200ms就是100个写操作，单机器一般20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成。如果写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列。</p>
<p> 大部分的情况下，应该是大量的读请求过来，都是直接走缓存取到数据的。少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面，等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据。</p>
</li>
<li><p>读请求并发量过高</p>
<p> 还必须做好压力测试，确保恰巧碰上上述情况的时候，还有另一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值。但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。按1:99的比例计算读和写的请求，每秒5万的读QPS，可能只有500次更新操作，如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条数据在缓存中失效后可能导致多少读请求发送读请求到库存服务来要求更新缓存。一般来说这个比例在1:1，1:2，1:3之内，例如500条缓存数据失效导致每秒钟有1000个读请求会hang在库存服务上，每个读请求最多hang200ms就会返回。在同一时间最多hang住的可能也就是单机200个读请求，单机hang200个读请求，还是ok的。</p>
</li>
<li><p>多服务实例部署的请求路由</p>
<p> 可能这个服务部署了多个实例，那么必须保证，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上。</p>
</li>
<li><p>热点商品的路由问题，导致请求的倾斜</p>
<p> 万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大。因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>
</li>
</ol>
<h3 id="复杂的数据库-缓存双写一致保障方案项目实例源码"><a href="#复杂的数据库-缓存双写一致保障方案项目实例源码" class="headerlink" title="复杂的数据库+缓存双写一致保障方案项目实例源码"></a>复杂的数据库+缓存双写一致保障方案项目实例源码</h3><p><a href="https://github.com/sail-y/eshop-inventory">https://github.com/sail-y/eshop-inventory</a></p>
]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>多级缓存架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战6-缓存雪崩及解决方案</title>
    <url>/2018/06/12/cache/cache06/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩这种场景，缓存架构中非常重要的一个环节，应对缓存雪崩的解决方案，避免缓存雪崩的时候，造成整个系统崩溃，带来巨大的经济损失</p>
<a id="more"></a>

<h2 id="缓存雪崩的过程和后果"><a href="#缓存雪崩的过程和后果" class="headerlink" title="缓存雪崩的过程和后果"></a>缓存雪崩的过程和后果</h2><p>缓存雪崩，一般首先是redis集群彻底崩溃，它导致崩溃的流程如下：</p>
<ol>
<li>redis集群彻底崩溃</li>
<li>缓存服务大量对redis的请求hang住，占用资源</li>
<li>缓存服务大量的请求打到源头服务去查询mysql，直接打死mysql</li>
<li>源头服务因为mysql被打死也崩溃，对源服务的请求也hang住，占用资源</li>
<li>缓存服务大量的资源全部耗费在访问redis和源服务无果，最后自己被拖死，无法提供服务</li>
<li>nginx无法访问缓存服务，redis和源服务，只能基于本地缓存提供服务，但是缓存过期后，没有数据提供</li>
<li>网站崩溃</li>
</ol>
<p><img src="/img/cache/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8E%E6%9E%9C.png" alt="缓存雪崩的过程和后果"></p>
<h1 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h1><p>相对来说，考虑的比较完善的一套方案，分为事前，事中，事后三个层次去思考怎么来应对缓存雪崩的场景</p>
<h2 id="事前解决方案"><a href="#事前解决方案" class="headerlink" title="事前解决方案"></a>事前解决方案</h2><p>所谓事前解决方案，就是发生缓存雪崩之前，事情之前，怎么去避免redis彻底挂掉。</p>
<p>那就是保证redis的高可用性，我们利用redis本身的高可用性，复制，主从架构等功能，操作主节点去读写，数据同步到从节点，一旦主节点挂掉，从节点就跟上。</p>
<p>一般是建议双机房部署，一套redis cluster，部分机器在一个机房，另一部分机器在另外一个机房。</p>
<p>还有一种部署方式，两套redis cluster，两套redis cluster之间做一个数据的同步，redis集群是可以搭建成树状的结构的。一旦单个机房出了故障，至少另外一个机房还能有些redis实例提供服务。</p>
<h2 id="事中解决方案"><a href="#事中解决方案" class="headerlink" title="事中解决方案"></a>事中解决方案</h2><p>如果redis cluster已经彻底崩溃了，已经开始大量的访问无法访问到redis了，那之前文章讲到过的多级缓存就起作用了。</p>
<p>ehcache缓存，第一应对零散的redis中数据被清除掉的现象，另外一个主要是预防redis彻底崩溃。这样多台机器上部署的缓存服务实例的内存中，还有一套ehcache的缓存，可以基于本地的ehcache的缓存提供一部分的数据。</p>
<p>一旦redis集群彻底崩溃了需要做以下几个步骤：</p>
<ol>
<li>对redis的访问做资源隔离，避免所有资源hang在访问redis上</li>
<li>对redis访问失败的情况做相应的熔断和降级策略</li>
<li>使用ehcache本地缓存</li>
<li>对源服务访问的限流以及资源隔离（mysql层）</li>
</ol>
<h2 id="事后解决方案"><a href="#事后解决方案" class="headerlink" title="事后解决方案"></a>事后解决方案</h2><p>如何恢复Redis Cluster，有两种情况</p>
<ol>
<li>redis数据可以恢复，做了备份，redis数据备份和恢复，redis重新启动起来</li>
<li>redis数据彻底丢失了，或者数据过旧，快速缓存预热，redis重新启动起来</li>
</ol>
<p>其实这套方案没什么东西，事前的Redis文章前面也说了，事中ehcache也做过了。但是，如何将缓存服务如何设计成高可用的架构，需要配合Hystrix来开发。我们的熔断，降级，限流等等操作都需要Hystrix的配合。</p>
<p><a href="http://www.saily.top/categories/hystrix/">Hystrix系列文章</a></p>
<p><img src="/img/cache/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E4%BA%8B%E5%89%8D%E4%BA%8B%E4%B8%AD%E4%BA%8B%E5%90%8E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="缓存雪崩的事前事中事后的解决方案"></p>
<h1 id="使用Hystrix对Redis进行资源隔离"><a href="#使用Hystrix对Redis进行资源隔离" class="headerlink" title="使用Hystrix对Redis进行资源隔离"></a>使用Hystrix对Redis进行资源隔离</h1><p>接下来就要对redis的访问这一块加上保护措施，给商品服务的访问加上限流的保护措施。redis这一块，全都用hystrix的command进行封装，做资源隔离，确保redis的访问只能在固定的线程池内的资源来进行访问，哪怕是redis访问的很慢，有等待和超时，也不要紧，只有少量额线程资源用来访问，缓存服务不会被拖垮。</p>
<p>找到之前的缓存项目<a href="https://github.com/sail-y/eshop-cache">https://github.com/sail-y/eshop-cache</a> ，引入Hystrix的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-metrics-event-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>在CacheServiceImpl里有几处用到redis的地方，我们就需要开发几个相应的command。</p>
<h2 id="SaveProductInfo2RedisCacheCommand"><a href="#SaveProductInfo2RedisCacheCommand" class="headerlink" title="SaveProductInfo2RedisCacheCommand"></a>SaveProductInfo2RedisCacheCommand</h2><p><strong>SaveProductInfo2RedisCacheCommand.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveProductInfo2RedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductInfo productInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveProductInfo2RedisCacheCommand</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;RedisGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.productInfo = productInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;product_info_&quot;</span> + productInfo.getId();</span><br><span class="line">        redisTemplate.opsForValue().set(key, JSON.toJSONString(productInfo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用command替换之前的实现</p>
<p><strong>CacheServiceImpl.saveProductInfo2RedisCache</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将商品信息保存到redis中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveProductInfo2RedisCache</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">    SaveProductInfo2RedisCacheCommand command = <span class="keyword">new</span> SaveProductInfo2RedisCacheCommand(productInfo);</span><br><span class="line">    command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="SaveShopInfo2RedisCacheCommand"><a href="#SaveShopInfo2RedisCacheCommand" class="headerlink" title="SaveShopInfo2RedisCacheCommand"></a>SaveShopInfo2RedisCacheCommand</h2><p><strong>SaveShopInfo2RedisCacheCommand.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存商品信息到Redis</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveShopInfo2RedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ShopInfo shopInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveShopInfo2RedisCacheCommand</span><span class="params">(ShopInfo shopInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;RedisGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.shopInfo = shopInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;shop_info_&quot;</span> + shopInfo.getId();</span><br><span class="line">        redisTemplate.opsForValue().set(key, JSONObject.toJSONString(shopInfo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用command替换之前的实现</p>
<p><strong>CacheServiceImpl.saveShopInfo2RedisCache</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将店铺信息保存到redis中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shopInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveShopInfo2RedisCache</span><span class="params">(ShopInfo shopInfo)</span> </span>&#123;</span><br><span class="line">    SaveShopInfo2RedisCacheCommand command = <span class="keyword">new</span> SaveShopInfo2RedisCacheCommand(shopInfo);</span><br><span class="line">    command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GetProductInfoFromRedisCacheCommand"><a href="#GetProductInfoFromRedisCacheCommand" class="headerlink" title="GetProductInfoFromRedisCacheCommand"></a>GetProductInfoFromRedisCacheCommand</h2><p><strong>GetProductInfoFromRedisCacheCommand.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis获取商品Command</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoFromRedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoFromRedisCacheCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;RedisGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;product_info_&quot;</span> + productId;</span><br><span class="line">        String json = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(json, ProductInfo.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后用command替换之前的实现</p>
<p><strong>CacheServiceImpl.getProductInfoFromRedisCache</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis从获取商品信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">getProductInfoFromRedisCache</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    GetProductInfoFromRedisCacheCommand command = <span class="keyword">new</span> GetProductInfoFromRedisCacheCommand(id);</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GetShopInfoFromRedisCacheCommand"><a href="#GetShopInfoFromRedisCacheCommand" class="headerlink" title="GetShopInfoFromRedisCacheCommand"></a>GetShopInfoFromRedisCacheCommand</h2><p><strong>GetShopInfoFromRedisCacheCommand.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis获取店铺信息Command</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetShopInfoFromRedisCacheCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ShopInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long shopId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetShopInfoFromRedisCacheCommand</span><span class="params">(Long shopId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;RedisGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.shopId = shopId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShopInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate redisTemplate = SpringContext.getApplicationContext().getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;shop_info_&quot;</span> + shopId;</span><br><span class="line">        String json = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(json, ShopInfo.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后用command替换之前的实现</p>
<p><strong>CacheServiceImpl.getShopInfoFromRedisCache</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Redis中获取商品店铺信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShopInfo <span class="title">getShopInfoFromRedisCache</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    GetShopInfoFromRedisCacheCommand command = <span class="keyword">new</span> GetShopInfoFromRedisCacheCommand(id);</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Hystrix对Redis访问进行降级"><a href="#使用Hystrix对Redis访问进行降级" class="headerlink" title="使用Hystrix对Redis访问进行降级"></a>使用Hystrix对Redis访问进行降级</h1><p>上面已经通过hystrix command对redis的访问进行了资源隔离，避免redis访问频繁失败，或者频繁超时的时候，耗尽大量的tomcat容器的资源去hang在redis的访问上。</p>
<p>这样就限定只有一部分线程资源可以用来访问redis，如果redis集群彻底崩溃了，这个时候，可能command对redis的访问大量的报错和timeout超时，熔断（短路），我们就需要对redis进行降级，用Hystrix的fallback机制。建议是使用fail silent模式，fallback里面直接返回一个空值，比如一个null，最简单。</p>
<p>在外面调用redis的代码（CacheService类），只要你把timeout、熔断、熔断恢复、降级，都做好了，是感知不到redis的访问异常的。可能会出现的情况是，当redis集群崩溃的时候，CacheService会获取到的是大量的null空值。</p>
<p>根据这个null空值，我们还可以去做多级缓存的降级访问，nginx本地缓存，redis分布式集群缓存，ehcache本地缓存等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便回顾一下之前CacheController的代码，在从redis里获取null值以后，会自动去别的地方一步步获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getProductInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">getProductInfo</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从Redis从获取数据</span></span><br><span class="line">    ProductInfo productInfo = cacheService.getProductInfoFromRedisCache(productId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=================从redis中获取缓存，商品信息=&quot;</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        productInfo = cacheService.getProductInfoFromLocalCache(productId);</span><br><span class="line">        System.out.println(<span class="string">&quot;================从ehcache从获取缓存，商品信息=&quot;</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 就需要从数据源重新拉取数据，重建缓存，模拟获取</span></span><br><span class="line">        String productInfoJSON = <span class="string">&quot;&#123;\&quot;id\&quot;: &quot;</span> + productId + <span class="string">&quot;, \&quot;name\&quot;: \&quot;iphone7手机\&quot;, \&quot;price\&quot;: 5599, \&quot;pictureList\&quot;:\&quot;a.jpg,b.jpg\&quot;, \&quot;specification\&quot;: \&quot;iphone7的规格\&quot;, \&quot;service\&quot;: \&quot;iphone7的售后服务\&quot;, \&quot;color\&quot;: \&quot;红色,白色,黑色\&quot;, \&quot;size\&quot;: \&quot;5.5\&quot;, \&quot;shopId\&quot;: 2, \&quot;modifiedTime\&quot;: \&quot;2018-02-21 22:11:34\&quot;&#125;&quot;</span>;</span><br><span class="line">        productInfo = JSONObject.parseObject(productInfoJSON, ProductInfo.class);</span><br><span class="line">        <span class="comment">// 将数据推送到一个内存队列中</span></span><br><span class="line">        RebuildCacheQueue rebuildCacheQueue = RebuildCacheQueue.getInstance();</span><br><span class="line">        rebuildCacheQueue.putProductInfo(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> productInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样一个简单的改造，我们使用Hystrix对redis的线程资源隔离和降级都很容易的完成了。</p>
<h1 id="Redis集群崩溃定制化熔断策略"><a href="#Redis集群崩溃定制化熔断策略" class="headerlink" title="Redis集群崩溃定制化熔断策略"></a>Redis集群崩溃定制化熔断策略</h1><p>缓存雪崩的事中解决方案</p>
<p>redis集群崩溃的时候，Hystrix会怎么样？</p>
<ol>
<li>大量的等待，超时，报错</li>
<li>如果是短时间内报错，会直接走fallback降级，直接返回null</li>
<li>超时控制，应该是判断redis访问超过了多长时间，就直接给报错timeout了</li>
</ol>
<p>不推荐用默认的值，一般不太精准，redis的访问先统计一下访问时长的百分比，hystrix dashboard里可以看到TP90，TP95，TP99的时间分别是多少。一般redis访问TP99在100ms以内，那么此时timeout时长稍微设置多一些，比如100ms。</p>
<h2 id="timeout设置"><a href="#timeout设置" class="headerlink" title="timeout设置"></a>timeout设置</h2><p>HystrixCommandProperties.Setter()<br>   .withExecutionTimeoutInMilliseconds(int value)</p>
<p>意义在于哪里？一旦redis出现了大面积的故障，此时肯定是访问的时候大量的超过100ms，大量的在等待和超时，这样就可以确保大量的请求不会hang住过长的时间，比如hang住个1s，500ms。如果100ms直接就报timeout，就会走fallback降级了。</p>
<h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>开启熔断有2个参数</p>
<h3 id="circuitBreaker-requestVolumeThreshold"><a href="#circuitBreaker-requestVolumeThreshold" class="headerlink" title="circuitBreaker.requestVolumeThreshold"></a>circuitBreaker.requestVolumeThreshold</h3><p>设置一个rolling window，滑动窗口中，最少要有多少个请求时，才触发开启短路。举例，如果设置为20（默认值），那么在一个10秒的滑动窗口内，如果只有19个请求，即使这19个请求都是异常的，也是不会触发开启短路器的。</p>
<p>HystrixCommandProperties.Setter()<br>   .withCircuitBreakerRequestVolumeThreshold(int value)</p>
<p>我们应该根据我们自己的平时的访问流量去设置，而不是用默认值，比如，我们认为平时一般的时候，流量也可以在每秒在QPS 100，10秒的滑动窗口就是1000，一般可以设置600或者800一个值，需要根据自己的系统的流量去设置。假如你设置的太少了，或者太多了，都不太合适。举个例子，你设置一个20，结果在晚上最低峰的时候，刚好是30，可能晚上的时候因为访问不频繁，大量的找不到缓存，可能超时频繁了一些，结果直接就给短路了。</p>
<h3 id="circuitBreaker-errorThresholdPercentage"><a href="#circuitBreaker-errorThresholdPercentage" class="headerlink" title="circuitBreaker.errorThresholdPercentage"></a>circuitBreaker.errorThresholdPercentage</h3><p>设置异常请求量的百分比，当异常请求达到这个百分比时，就触发打开短路器，默认是50，也就是50%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerErrorThresholdPercentage(<span class="keyword">int</span> value)   </span><br></pre></td></tr></table></figure>

<p>我们最好还是自己定制，自己设置，如果是要50%的时候才短路的话，会有什么情况呢?10%短路，也不太靠谱，90%异常，才短路也不行。这个值可以稍微高一些，如果redis集群彻底崩溃，那么基本上就是所有的请求，100%都会异常，所以一般设置60%，70%。也有可能偶然出现网络的抖动，导致比如就这10秒钟，访问延时高了一些，其实可能并不需要立即就短路，可能下个10秒马上就恢复了。</p>
<p>金融支付类的接口，可能这个比例就会设置的很低，因为对异常系统必须要很敏感，可能就是10%异常了，就直接短路了，不让继续访问了。金融支付类的接口是很重要的，而且必须是很稳定，我们不能容忍任何的延迟或者是报错。一旦支付类的接口，有10%的异常的话，我们基本就可以认为这个接口已经出问题了，再继续访问的话，也许访问的就是有问题的接口，可能造成资金的错乱，给公司造成损失。所以直接熔断吧，不让访问了，走降级策略，这就是对整个系统的一个安全性保障。</p>
<h3 id="circuitBreaker-sleepWindowInMilliseconds"><a href="#circuitBreaker-sleepWindowInMilliseconds" class="headerlink" title="circuitBreaker.sleepWindowInMilliseconds"></a>circuitBreaker.sleepWindowInMilliseconds</h3><p>设置在短路之后，需要在多长时间内直接reject请求，然后在这段时间之后，再重新导half-open状态，尝试允许请求通过以及自动恢复，默认值是5000毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerSleepWindowInMilliseconds(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<p>如果redis集群崩溃了，会在5s内就直接恢复。</p>
<h1 id="Hystrix保护源服务，防止Mysql崩溃"><a href="#Hystrix保护源服务，防止Mysql崩溃" class="headerlink" title="Hystrix保护源服务，防止Mysql崩溃"></a>Hystrix保护源服务，防止Mysql崩溃</h1><p>做缓存服务，redis集群彻底崩溃的时候，除了对redis本身做资源隔离、超时控制、熔断策略。还要保护源服务，因为Redis集群崩溃后，大量的请求会高并发会去访问源服务-商品服务（提供商品数据）。如果QPS10000去访问商品服务，基于mysql去查询，那mysql肯定会挂掉，商品服务也就死掉了。</p>
<p>所以要对商品服务这种源服务的访问施加限流的措施，限流怎么限，hystrix本身就是提供了两种机制，线程池（内部做了异步化处理，可以处理超时），semaphore（信号量，让tomcat线程执行运行逻辑，没有内部的异步化处理，一旦超时，会导致tomcat线程就hang住了）。</p>
<p>一般推荐线程池用来做有网络访问的这种资源隔离，因为涉及到网络，就很容易超时；sempahore是用来做对服务纯内存的一些复杂业务逻辑的操作进行限流，因为不涉及网络访问，就是纯粹为了避免对内存内的复杂业务逻辑进行太高并发的访问，造成系统本身的故障。semaphore在以下情况是很合适的：比如一些推荐、搜索，有部分算法，复杂的算法，是放在服务内部纯内存去运行的，一个服务暴露出来的就是某个算法的执行。</p>
<p>我们这里是访问外部的商品服务，所以还是用线程池做限流，需要算一下，要限多少，怎么限？</p>
<p>假设每次商品服务的访问性能在200ms，1个线程一秒可以执行5次访问，假设我们一个缓存服务实例对这个商品服务的访问每秒在150次。所以这个时候，我们就需要30个线程，每个线程每秒可以访问5次，总共每秒30个线程可以访问150次。</p>
<p>我们算的这个每秒150次访问时正常情况下，如果是非正常情况下，每秒1000次，甚至1w次，此时就可以自然限流，因为我们的线程池就30个。在非正常情况下，直接线程池+等待队列全满，此时就会出现大量的reject操作，然后就会去调用降级逻辑。接着我们要做限流，设置的就是线程池的大小，还有等待队列的大小，30个线程可以每秒处理150个请求，但是偶尔会多一些出来，同时30个线程处理150个请求会快一些，不用花费1秒钟，等待队列给一些buffer，不要偶尔1秒钟来了200条请求，50条直接给reject掉了。等待队列设置150个，30个线程直接500ms处理完了，等待队列中的50个请求就可以继续处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ProductInfoService&quot;</span>))</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;GetProductInfoPool&quot;</span>))</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">12</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">8</span>)</span><br><span class="line">                        .withMaximumSize(<span class="number">30</span>)</span><br><span class="line">                        .withAllowMaximumSizeToDivergeFromCoreSize(<span class="keyword">true</span>)</span><br><span class="line">                        .withKeepAliveTimeMinutes(<span class="number">1</span>)</span><br><span class="line">                        .withMaxQueueSize(<span class="number">50</span>)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(<span class="number">100</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        <span class="comment">// 多少个请求以上才会判断断路器是否需要开启。</span></span><br><span class="line">                        .withCircuitBreakerRequestVolumeThreshold(<span class="number">30</span>)</span><br><span class="line">                        <span class="comment">// 错误的请求达到40%的时候就开始断路。</span></span><br><span class="line">                        .withCircuitBreakerErrorThresholdPercentage(<span class="number">40</span>)</span><br><span class="line">                        <span class="comment">// 3秒以后尝试恢复</span></span><br><span class="line">                        .withCircuitBreakerSleepWindowInMilliseconds(<span class="number">4000</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String productInfoJSON = <span class="string">&quot;&#123;\&quot;id\&quot;: &quot;</span> + productId + <span class="string">&quot;, \&quot;name\&quot;: \&quot;iphone7手机\&quot;, \&quot;price\&quot;: 5599, \&quot;pictureList\&quot;:\&quot;a.jpg,b.jpg\&quot;, \&quot;specification\&quot;: \&quot;iphone7的规格\&quot;, \&quot;service\&quot;: \&quot;iphone7的售后服务\&quot;, \&quot;color\&quot;: \&quot;红色,白色,黑色\&quot;, \&quot;size\&quot;: \&quot;5.5\&quot;, \&quot;shopId\&quot;: 1, \&quot;modifiedTime\&quot;: \&quot;2017-01-01 12:01:00\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.parseObject(productInfoJSON, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源服务fallback降级机制"><a href="#源服务fallback降级机制" class="headerlink" title="源服务fallback降级机制"></a>源服务fallback降级机制</h2><p>现在nginx本地缓存没有，redis集群崩溃，ehcache也找不到这条数据对应的缓存，只能去源头服务里面查询，但是查询的请求又被限流了，现在请求到了这里，被限流了以后只能走降级逻辑。</p>
<p>这里的一种降级机制叫做<a href="http://www.saily.top/2018/04/15/hystrix03/">stubbed fallback降级机制</a>（残缺的降级），就是用请求参数中少量的数据，加上纯内存中缓存的少量的数据来提供残缺的数据服务。</p>
<h1 id="缓存雪崩预防和解决方案回顾"><a href="#缓存雪崩预防和解决方案回顾" class="headerlink" title="缓存雪崩预防和解决方案回顾"></a>缓存雪崩预防和解决方案回顾</h1><ol>
<li><p>事前，redis高可用性，redis cluster，sentinal，复制，主从，从-&gt;主，双机房部署</p>
</li>
<li><p>事中，ehcache可以扛一扛，redis挂掉之后的资源隔离、超时控制、熔断，商品服务的访问限流、多级降级，缓存服务在雪崩场景下存活下来，基于ehcache和存活的商品服务提供数据</p>
</li>
<li><p>事后，快速恢复Redis，备份+恢复，快速的缓存预热的方案</p>
</li>
</ol>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>如果一直访问的根本不存在的时候，那么就会导致缓存穿透，所有的这种请求都会直接到mysql这边来。</p>
<p><img src="/img/cache/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E7%8E%B0%E8%B1%A1.png" alt="缓存穿透的现象"></p>
<p>缓存穿透的解决方案其实非常简单，就是如果从源服务（商品服务）查询到的数据是空，就说明这个数据根本就不存在。那么如果这个数据不存在的话，我们也往redis和ehcache等缓存中写入一个数据，可以写入一个空的数据，比如空的productInfo的json串，给nginx也是，返回一个空的productInfo的json串。</p>
<p>我们有异步监听数据变更的机制在里面，如果数据变更的话，某个数据本来是没有的，可能会导致缓存穿透，所以我们给了个空数据，但是现在这个数据有了，我们接收到这个变更的消息过后，就可以将数据再次从源服务中查询出来，然后设置到各级缓存中去了。</p>
<h1 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h1><p>之前在nginx中设置本地的缓存的时候，给了一个过期的时间（10分钟）。10分钟以后自动过期，过期了以后，就会重新从redis中去获取数据。10分钟到期自动过期，就叫做缓存的失效。如果缓存失效以后，那么实际上此时，就会有大量的请求回到redis中去查询。</p>
<p>如果同一时间来了1000个请求，都将缓存cache在了nginx自己的本地，缓存失效的时间都设置了10分钟，那么是不是可能导致10分钟过后，这些数据，就自动全部在同一时间失效了。如果同一时间全部失效，会不会导致同一时间大量的请求过来，在nginx里找不到缓存数据，全部高并发走到redis上去了。加重大量的网络请求，网络负载也会加重。</p>
<p>解决方案很简单，就是把10分钟的时间改成一个随机数,随机一个失效的时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">math.randomseed(tostring(os.time()):reverse():sub(1, 7))</span><br><span class="line"><span class="built_in">local</span> expireTime = math.random(600, 1200)  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>多级缓存架构</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程5-基础构建模块</title>
    <url>/2016/12/08/concurrency/concurrency5/</url>
    <content><![CDATA[<h1 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h1><p>第4章介绍了构造线程安全类时采用的一些技术，例如将线程安全性委托给现有的线程安全类。委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。<br>下面将介绍一些JDK提供的工具类。</p>
<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p>
<h3 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h3><p>同步容器类都是线程安全的，但在某些情况下需要加锁来保护复合操作。例如2个线程都在进行「若没有，则添加」的运算，如果没有对这个复合操作加锁，就可能会出问题。</p>
<a id="more"></a>
<h3 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h3><p>无论是迭代还是foreach循环，当它们发现容器在迭代过程中被修改时，就会抛出ConcurrentModificationException异常。<br>如果不希望在迭代期间对容器加锁，有一种替代方法就是「克隆」容器，并在副本中进行迭代。</p>
<h3 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h3><p>虽然加锁可以防止迭代器抛出ConcurrentModificationException，但是必须在所有对共享容器进行迭代的地方都需要加锁。还有一个很隐蔽的迭代器，就是没有显式的迭代器，但是实际上也执行了迭代操作，那就是编译器会将字符串的连接操作转化为StringBuilder.append，而这个方法会调用容器的toString方法，标准容器的toString方法会迭代容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>
<p>如果在输出期间对容器进行了修改，就会抛出异常。</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK5提供了多种并发容器类来改进同步容器的性能。因为同步容器对所有容器状态的访问都串行化，降低了并发性，性能不太好。<br>通过并发容器来代替同步容器，可以极大的提高伸缩性并降低防线。例如ConcurentHashMap和CopyOnWriteArrayList。<br>BlockingQueue提供可阻塞的插入和获取操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>同步容器类在执行每个操作期间都持有一个锁，HashMap的键值对是通过单向链表来实现的，当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会耗费很长时间，而其他线程在这段时间内都不能访问该容器。<br>ConcurrentHashMap与HashMap一样也是一个基于散列的Map，它使用了一种<strong>分段锁</strong>的机制来实现更大程度的共享，而不是将每个方法都进行同步。这样执行写入操作的线程可以并发地访问Map。它提供的迭代器也不会抛出ConcurrentModificationException，因此不需要在迭代的时候加锁。</p>
<p>ConcurrentHashMap将一些常见的复合操作实现为了原子操作，例如putIfAbsent,remove,replace等。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。<br>CopyOnWriteArrayList底层用基础数组实现，不会被修改，可以随意并发的访问。不过显然每当修改容器的时候会复制底层数组，这会造成一定的开销。仅当迭代操作远远多余修改操作时，才应该使用这个容器。<br>这个容器适用于许多事件通知系统：分发通知时迭代监听器，并调用。而注册或者注销监听器的操作则较少。</p>
<h2 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式</h2><p>刚才提到BlockingQueue提供可阻塞的put和take操作。阻塞队列支持生产者-消费者这种设计模式。该模式将「找出需要完成的工作」与「执行工作」这两个过程分离开来，并把工作放入一个「待完成」的列表以便在随后处理。在基于阻塞队列构建的生产者-消费者设计中，当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;produce &quot;</span> + i++);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bq.put(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String take = bq.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;take &quot;</span> + take);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是我们应该用有界队列，因此如果消费者处理速度较慢，队列可能会将耗尽内存。在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况秀爱变得更加健壮。</p>
<h3 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h3><p>对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者缴费给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来「转移」所有权。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>JDK6还增加了两种容器类型，Deque和BlockingDeque。Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。</p>
<h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><p>线程可能会阻塞或者暂停执行，等待I/O操作，等待锁等。简单举例就是Thread.sleep()。<br>当某方法会抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。<br>Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个值。<br>我们看源码就知道，interrupt()只是将interrupt的标记设置一下而已，interrupt0()是一个native方法。具体什么时候中断，JDK并不保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/26 下午4:17.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>下面介绍一些并发包的同步工具类，它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态，这些类有CountDownLatch、Semaphore和Barrier等。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>Latch可以延迟线程的进度直到其到达终止状态。它的作用相当于一扇门：在条件达到之前，这扇门是关闭着的，并没有任何线程能通过，直到条件到达结束状态时，这扇门打开并允许所有线程通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/26 下午5:10.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * CountDownLatch主要提供的机制是当多个（具体数量等于初始化CountDownLatch时count参数的值）线程都达到了预期状态或完成预期工作时触发事件，</span></span><br><span class="line"><span class="comment"> * 其他线程可以等待这个事件来触发自己的后续工作。值得注意的是，CountDownLatch是可以唤醒多个等待的线程的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sleepSecond;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(String name, CountDownLatch countDownLatch, <span class="keyword">int</span> sleepSecond)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">            <span class="keyword">this</span>.sleepSecond = sleepSecond;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; start: &quot;</span> + LocalDateTime.now());</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleepSecond);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; end: &quot;</span> + LocalDateTime.now());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoneThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoneThread</span><span class="params">(String name, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; await start:&quot;</span> + LocalDateTime.now());</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot; await end:&quot;</span> + LocalDateTime.now());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CountDownLatch指定3次调用，无论前面有多少线程await，都需要等待CountDownLatch调用3次countDown()统一唤醒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        DoneThread d0 = <span class="keyword">new</span> DoneThread(<span class="string">&quot;DoneThread1&quot;</span>, countDownLatch);</span><br><span class="line">        DoneThread d1 = <span class="keyword">new</span> DoneThread(<span class="string">&quot;DoneThread2&quot;</span>, countDownLatch);</span><br><span class="line">        d0.start();</span><br><span class="line">        d1.start();</span><br><span class="line"></span><br><span class="line">        WorkThread w0 = <span class="keyword">new</span> WorkThread(<span class="string">&quot;WorkThread0&quot;</span>, countDownLatch, <span class="number">2</span>);</span><br><span class="line">        WorkThread w1 = <span class="keyword">new</span> WorkThread(<span class="string">&quot;WorkThread1&quot;</span>, countDownLatch, <span class="number">3</span>);</span><br><span class="line">        WorkThread w2 = <span class="keyword">new</span> WorkThread(<span class="string">&quot;WorkThread2&quot;</span>, countDownLatch, <span class="number">4</span>);</span><br><span class="line">        w0.start();</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask可以获得线程返回的结果，get方法取决于线程的状态，如果已经完成会直接返回，否则会一直阻塞直到任务执行完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/26 下午5:54.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future future = executorService.submit(<span class="keyword">new</span> CallableThread());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"><span class="comment">//        while (!future.isDone()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(future.get());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。Semaphore还可以用来实现某种资源池，或者对容器施加边界。<br>Semaphore管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在执行操作时可以先获得许可，并在使用后释放许可。如果没有许可，那么acquire()将阻塞直到有许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/26 下午5:23.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquire: &quot;</span> + LocalDateTime.now());</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release: &quot;</span> + LocalDateTime.now());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CountDownLatch是一次性对象，一旦结束进入终止状态，就不能被重置。CyclicBarrier能阻塞一组线程直到某个事件发生。CyclicBarrier和CountDownLatch的关键区别在于，所有线程必须同时达到CyclicBarrier的条件，才能继续执行。CountDownLatch是等待某个条件或者事件，CyclicBarrier是等待其他线程。例如CountDownLatch是指6点一到大家就可以下班了，而CyclicBarrier是要等大家到齐了才能开会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/10/26 下午5:43.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * CyclicBarrier从字面理解是指循环屏障，它可以协同多个线程，让多个线程在这个屏障前等待，直到所有线程都达到了这个屏障时，再一起继续执行后面的动作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sleepSecond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierThread</span><span class="params">(CyclicBarrier cyclicBarrier, <span class="keyword">int</span> sleepSecond)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.sleepSecond = sleepSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(sleepSecond);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; waiting &quot;</span> + LocalDateTime.now());</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end wait &quot;</span> + LocalDateTime.now());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CountDownLatch和CyclicBarrier都是用于多个线程间的协调的，它们二者的几个差别是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、CountDownLatch是在多个线程都进行了latch.countDown()后才会触发事件，唤醒await()在latch上的线程，而执行countDown()的线程，</span></span><br><span class="line"><span class="comment">执行完countDown()后会继续自己线程的工作；CyclicBarrier是一个栅栏，用于同步所有调用await()方法的线程，并且等所有线程都到了await()方法时，这些线程才一起返回继续各自的工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、另外CountDownLatch和CyclicBarrier的一个差别是，CountDownLatch不能循环使用，计数器减为0就减为0了，不能被重置，CyclicBarrier可以循环使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、CountDownLatch可以唤起多条线程的任务，CyclicBarrier只能唤起一条线程的任务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，因为使用CyclicBarrier的线程都会阻塞在await方法上，所以在线程池中使用CyclicBarrier时要特别小心，如果线程池的线程过少，那么就会发生死锁了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable command = () -&gt; System.out.println(<span class="string">&quot;I&#x27;m coming&quot;</span>);</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, command);</span><br><span class="line">        CyclicBarrierThread t1 = <span class="keyword">new</span> CyclicBarrierThread(cyclicBarrier, <span class="number">2</span>);</span><br><span class="line">        CyclicBarrierThread t0 = <span class="keyword">new</span> CyclicBarrierThread(cyclicBarrier, <span class="number">2</span>);</span><br><span class="line">        CyclicBarrierThread t2 = <span class="keyword">new</span> CyclicBarrierThread(cyclicBarrier, <span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(t1);</span><br><span class="line">        executorService.execute(t0);</span><br><span class="line">        executorService.execute(t2);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可变状态是至关重要的<br>  所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易保证线程安全性</li>
<li>尽量将域声明为final类型，除非需要它们是可变的。</li>
<li>不可变对象一定是线程安全的<br>  不可变对象能极大地降低并发编程的复杂性。它们更简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。</li>
<li>封装有助于管理复杂性。<br>  在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护同一个不变性中的所有变量时，要使用同一个锁。</li>
<li>在执行复合操作期间，要持有锁。</li>
<li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序就会出现问题。</li>
<li>不要故作聪明地推断出不需要使用同步。</li>
<li>在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。</li>
<li>将同步策略文档化。</li>
</ul>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch04-Document、Index详解和操作以及并发问题</title>
    <url>/2018/08/19/elasticsearch/elasticSearch04/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h1 id="Document元数据"><a href="#Document元数据" class="headerlink" title="Document元数据"></a>Document元数据</h1><h2 id="index元数据"><a href="#index元数据" class="headerlink" title="_index元数据"></a>_index元数据</h2><ol>
<li>代表一个document存放在哪个index中。</li>
<li>类似的数据放在一个索引，非类似的数据放不同索引：product index（包含了所有的商品），sales index（包含了所有的商品销售数据），inventory index（包含了所有库存相关的数据）。如果你把比如product，sales，human resource（employee），全都放在一个大的index里面，比如company index，就不合适。<a id="more"></a></li>
<li>index中包含了很多类似的document：类似是什么意思，其实指的就是这些document的fields很大一部分是相同的，比如你放了3个document，每个document的fields都完全不一样，这就不是类似了，就不太适合放到一个index里面去了。</li>
<li>索引名称必须是小写的，不能用下划线开头，不能包含逗号，例如：product，website，blog</li>
</ol>
<h2 id="type元数据"><a href="#type元数据" class="headerlink" title="_type元数据"></a>_type元数据</h2><ol>
<li>代表document属于index中的哪个类别（type）</li>
<li>一个索引通常会划分为多个type，逻辑上对index中有些许不同的几类数据进行分类：因为一批相同的数据，可能有很多相同的fields，但是还是可能会有一些轻微的不同，可能会有少数fields是不一样的，举个例子，比如商品，可能划分为电子商品，生鲜商品，日化商品，等等。</li>
<li>type名称可以是大写或者小写，但是同时不能用下划线开头，不能包含逗号</li>
</ol>
<h2 id="id元数据"><a href="#id元数据" class="headerlink" title="_id元数据"></a>_id元数据</h2><ol>
<li>代表document的唯一标识，与index和type一起，可以唯一标识和定位一个document</li>
<li>我们可以手动指定document的id（put /index/type/id），也可以不指定，由es自动为我们创建一个id</li>
</ol>
<h3 id="手动指定document-id"><a href="#手动指定document-id" class="headerlink" title="手动指定document id"></a>手动指定document id</h3><h4 id="根据应用情况看是否满足手动指定document-id的前提"><a href="#根据应用情况看是否满足手动指定document-id的前提" class="headerlink" title="根据应用情况看是否满足手动指定document id的前提"></a>根据应用情况看是否满足手动指定document id的前提</h4><p>一般来说，是从某些其他的系统中导入一些数据到es时，会采取这种方式，就是使用系统中已有数据的唯一标识，作为es中document的id。</p>
<blockquote>
<p>举个例子，我们现在在开发一个电商网站，做搜索功能，或者是OA系统的做员工检索功能。这个时候，数据首先会在网站系统或者IT系统内部的数据库中，会先有一份，此时就肯定会有一个数据库的primary key（自增长，UUID，或者是业务编号）。如果将数据导入到es中，此时就比较适合采用数据在数据库中已有的primary key。</p>
</blockquote>
<p>但是如果是在做一个系统，这个系统主要的数据存储就是es，也就是数据产生出来以后，可能就没有id，直接就存es。那么这个时候，可能就不太适合手动指定document id的形式了，因为你也不知道id应该是什么，此时可以采取下面的让es自动生成id的方式。</p>
<h4 id="put-index-type-id"><a href="#put-index-type-id" class="headerlink" title="put /index/type/id"></a>put /index/type/id</h4><p>手动指定ID的方式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_content&quot;</span>: <span class="string">&quot;my test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="自动生成document-id"><a href="#自动生成document-id" class="headerlink" title="自动生成document id"></a>自动生成document id</h3><h4 id="post-index-type"><a href="#post-index-type" class="headerlink" title="post /index/type"></a>post /index/type</h4><p>后面不加ID，ES会为我们自动生成ID</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test_index/test_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_content&quot;</span>: <span class="string">&quot;my test&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;AVp4RN0bhjxldOOnBxaE&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h4><p>自动生成的id，它的长度为20个字符，是URL安全的，基于base64编码。基于GUID的算法，分布式系统并行生成时不可能会发生冲突。</p>
<h2 id="source元数据"><a href="#source元数据" class="headerlink" title="_source元数据"></a>_source元数据</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field1&quot;</span>: <span class="string">&quot;test field1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;test field2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /test_index/test_type/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field1&quot;</span>: <span class="string">&quot;test field1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;test field2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_source元数据：在创建一个document的时候，传入的json传在默认情况下，在get的时候，会原封不动的给我们返回回来。</p>
<p>如果要定制返回的结果，可以加<code>_srouce</code>参数，指定返回哪些字段，多个字段用逗号分隔。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/1?_source=test_field1,test_field2</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;test field2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Document的创建、替换和删除"><a href="#Document的创建、替换和删除" class="headerlink" title="Document的创建、替换和删除"></a>Document的创建、替换和删除</h1><h2 id="document的全量替换"><a href="#document的全量替换" class="headerlink" title="document的全量替换"></a>document的全量替换</h2><ol>
<li>语法与创建文档是一样的，如果document id不存在，那么就是创建；如果document id已经存在，那么就是全量替换操作，替换document的json串内容。</li>
<li>其实document是不可变的，如果要修改document的内容，第一种方式就是全量替换，直接对document重新建立索引，替换里面所有的内容。</li>
<li>es会将老的document标记为deleted，然后新增我们给定的一个document，当我们创建越来越多的document的时候，es会在适当的时机在后台自动删除标记为deleted的document。</li>
</ol>
<h2 id="document的强制创建"><a href="#document的强制创建" class="headerlink" title="document的强制创建"></a>document的强制创建</h2><p>创建文档与全量替换的语法是一样的，有时我们只是想新建文档，不想替换文档，如果强制进行创建呢？</p>
<p><code>PUT /index/type/id?op_type=create，PUT /index/type/id/_create</code></p>
<p>但是强制创建一个已经存在的Document会得到一个冲突的错误。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][1]: version conflict, document already exists (current version [1])&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;arBg_MfmRWCMSKQHqGIrDw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index1&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][1]: version conflict, document already exists (current version [1])&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;arBg_MfmRWCMSKQHqGIrDw&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="document的删除"><a href="#document的删除" class="headerlink" title="document的删除"></a>document的删除</h2><p><code>DELETE /index/type/id</code></p>
<p>ES不会立即物理删除，只会将其标记为deleted，当数据越来越多的时候，在后台自动删除。</p>
<h1 id="Elasticsearch并发冲突问题"><a href="#Elasticsearch并发冲突问题" class="headerlink" title="Elasticsearch并发冲突问题"></a>Elasticsearch并发冲突问题</h1><p>多个线程去同时访问es中的一份数据，然后各自去修改之后更新到es，由于线程的先后顺序不同，可能会导致后续的修改覆盖掉之前的修改，显然一些场景下我们是不允许发生这种并发冲突的问题，例如电商库存的修改等</p>
<h2 id="悲观锁和乐观锁并发控制方案"><a href="#悲观锁和乐观锁并发控制方案" class="headerlink" title="悲观锁和乐观锁并发控制方案"></a>悲观锁和乐观锁并发控制方案</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li><p>如何理解悲观锁 </p>
<p>  它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。<br>  在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。<br>  如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>  如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>  其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p>
</li>
<li><p>优点与不足<br>  悲观锁的优点：方便，直接加锁，对应用程序来说透明，不需要额外的操作；<br>  悲观锁的缺点：并发能力很低，同一时间只能有一条线程操作数据。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3></li>
<li><p>如何理解乐观锁<br>  它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
</li>
<li><p>与悲观锁区别<br>  相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。<br>  <strong>数据版本</strong>是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。<br>  实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
</li>
<li><p>优点与不足<br>  乐观锁的优点：并发能力很高，不给数据加锁，可以进行大量线程并发操作；<br>  乐观锁的缺点：麻烦，每次更新的时候都要先比对版本号，然后可能需要重新加载数据，再次修改，在写；这个过程可能要重复好几次。</p>
</li>
</ul>
<h2 id="基于-version字段进行乐观锁并发控制"><a href="#基于-version字段进行乐观锁并发控制" class="headerlink" title="基于_version字段进行乐观锁并发控制"></a>基于_version字段进行乐观锁并发控制</h2><h3 id="version元数据"><a href="#version元数据" class="headerlink" title="_version元数据"></a>_version元数据</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/6</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次创建一个document的时候，它的_version内部版本号就是1；以后，每次对这个document执行修改或者删除操作，都会对这个_version版本号自动加1；哪怕是删除，也会对这条数据的版本号加1</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，在删除一个document之后，可以从一个侧面证明，它不是立即物理删除掉的，因为它的一些版本号等信息还是保留着的。先删除一条document，再重新创建这条document，其实会在delete version基础之上，再把version号加1。</p>
<blockquote>
<p>ES内部很多类似于副本集的同步请求，都是多线程异步的，也就意味着多个修改请求之间是乱序的，所以ES内部也是采用了乐观锁的方案，基于version版本号去进行并发控制。</p>
</blockquote>
<h2 id="并发控制方案"><a href="#并发控制方案" class="headerlink" title="并发控制方案"></a>并发控制方案</h2><h3 id="上机动手实战演练基于-version进行乐观锁并发控制"><a href="#上机动手实战演练基于-version进行乐观锁并发控制" class="headerlink" title="上机动手实战演练基于_version进行乐观锁并发控制"></a>上机动手实战演练基于_version进行乐观锁并发控制</h3><p>1、先模拟一条数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/7</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、模拟两个客户端，都获取到了同一条数据（开2个kibana的网页）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET test_index/test_type/7</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、其中一个客户端先更新了数据</p>
<p>更新时带上了数据的版本号，确保ES中数据的版本号跟客户端的版本号是相同的才能修改。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、另外一个客户端尝试基于version=1的数据去进行修改，也带上version版本号，进行乐观锁的并发控制</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;I8nYYk8URXmXpcx0SS7wyw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][7]: version conflict, current version [2] is different than the one provided [1]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;I8nYYk8URXmXpcx0SS7wyw&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本冲突，更新失败。</p>
<p>5、在乐观锁成功阻止并发问题之后，尝试正确的完成更新</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/7</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先去查询ES里当前数据的版本号，然后带上最新的版本号去修改数据，可能这个步骤会需要反复执行好几次才能成功，特别是在多线程并发更新同一条数据很频繁的情况下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/7?version=2 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上机动手实战演练基于external-version进行乐观锁并发控制"><a href="#上机动手实战演练基于external-version进行乐观锁并发控制" class="headerlink" title="上机动手实战演练基于external version进行乐观锁并发控制"></a>上机动手实战演练基于external version进行乐观锁并发控制</h3><p>ES提供了一个功能可以让我们不用它提供的内部_version版本号来进行并发控制，我们可以基于自己维护的一个本版好类进行并发控制。举个例子，假如你的数据在MYSQL里也有一份，然后在MYSQL里维护了一个版本号，无论是怎么生成的，这个时候进行乐观锁并发控制，可能并不是想要用es内部的_version来进行控制，而是用自己维护的那个version来进行控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?version&#x3D;1</span><br><span class="line">?version&#x3D;1&amp;version_type&#x3D;external</span><br></pre></td></tr></table></figure>

<blockquote>
<p>区别：只有当你提供的version与es中的_version一样的时候才能修改，否则就报错；当version_type=external的时候，只要你提供的version比es中的_version大，就能完成修改。</p>
</blockquote>
<p>1、先构造一条数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/8</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、模拟两个客户端同时查询到这条数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/8</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、第一个客户端先进行修改，此时客户端在自己的数据库中获取到了这条数据的最新版本号，比如说是3</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=3&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、模拟第二个客户端，同时拿到了自己数据库中维护的那个版本号，也是3，同时基于version=3发起了修改</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=3&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][8]: version conflict, current version [3] is higher or equal to the one provided [3]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;I8nYYk8URXmXpcx0SS7wyw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;version_conflict_engine_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[test_type][8]: version conflict, current version [3] is higher or equal to the one provided [3]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;I8nYYk8URXmXpcx0SS7wyw&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;test_index&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的，也是并发冲突，只不过这次是基于我们自己提供的version来控制的，而且报错的提示是必须大于等于3。</p>
<p>5、在并发冲突以后，重新基于新的版本号发起更新</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/8?version=6&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="partial-update"><a href="#partial-update" class="headerlink" title="partial update"></a>partial update</h1><p>partial update是修改文档的另一种方式</p>
<p>之前的PUT操作对应到应用程序中，每次的执行流程是这样的：</p>
<ol>
<li>应用程序先发起一个get请求，获取到document，展示到前台界面，供用户查看和修改</li>
<li>用户在前台界面修改数据，发送到后台</li>
<li>后台代码，会将用户修改的数据在内存中进行执行，然后封装好修改后的全量数据</li>
<li>然后发送PUT请求，到es中，进行全量替换</li>
<li>es将老的document标记为deleted，然后重新创建一个新的document</li>
</ol>
<p>partial update</p>
<p>post /index/type/id/_update<br>{<br>   “doc”: {<br>      “要修改的少数几个field即可，不需要全量的数据”<br>   }<br>}</p>
<p>看起来，好像就比较方便了，每次就传递少数几个发生修改的field即可，不需要将全量的document数据发送过去</p>
<h2 id="partial-update实现原理以及其优点"><a href="#partial-update实现原理以及其优点" class="headerlink" title="partial update实现原理以及其优点"></a>partial update实现原理以及其优点</h2><p>partial update直接将数据更新到document中就完成了修改，不用事先先发起一个GET请求数据进行修改然后在将修改后的数据发回去。</p>
<p>es内部：partial update的执行和全量替换一致。</p>
<ol>
<li>内部先get获取document</li>
<li>将更新的field更新到document的json中</li>
<li>将老的document标记为deleted</li>
<li>创建新的document</li>
</ol>
<p>优点：</p>
<ol>
<li>所有查询，修改和写回操作均发生在同一个shard内，避免了不必要的网络数据传输带来的开销，大大提升了性能（减少了两次请求，一次GET请求，一次回写请求）</li>
<li>减少修改和查询中的时间间隔，有效减少并发冲突的情况</li>
<li>内置乐观锁并发控制</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test_index/test_type/id/_update?retry_on_conflict=2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;num&quot;</span>:<span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果更新失败，则获取最新的版本号再次进行更新，最多重试retry_on_conflict指定的次数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test_index/test_type/11/_update?version=3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;num&quot;</span>:<span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test_index/test_type/10</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test_field1&quot;</span>: <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /test_index/test_type/10/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;updated test2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h1><h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><p>如果一条一条的查询100条数据，那么就要发送100次网络请求，这个开销还是很大的<br>如果进行批量查询的话，查询100条数据，就只要发送1次网络请求，网络请求的性能开销缩减100倍。</p>
<p>ES提供了批量查询的API，它的mget的语法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;docs&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_type&quot;</span> :  <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> :    <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_type&quot;</span> :  <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> :    <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;docs&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;found&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;found&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、如果查询的document是一个index下的不同type种的话</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;docs&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;_type&quot;</span> :  <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> :    <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">&quot;_type&quot;</span> :  <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;_id&quot;</span> :    <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果查询的数据都在同一个index下的同一个type下，最简单了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/_mget</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;ids&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量增删改"><a href="#批量增删改" class="headerlink" title="批量增删改"></a>批量增删改</h2><p>ES对于批量增删改，是提供的bulk api。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">&quot;delete&quot;</span>: &#123; <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>, <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">&quot;create&quot;</span>: &#123; <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>, <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;12&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test12&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:  &#123; <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>, <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;replaced test2&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;update&quot;</span>: &#123; <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>, <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">&quot;_retry_on_conflict&quot;</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">&quot;doc&quot;</span> : &#123;<span class="attr">&quot;test_field2&quot;</span> : <span class="string">&quot;bulk test1&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>上面是一些例子，它的语法是每一个操作有两个json，语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;action&quot;</span>: &#123;<span class="attr">&quot;metadata&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;data&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>举例，比如你现在要创建一个文档，放bulk里面，看起来会是这样子的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;, &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;test_field1&quot;</span>: <span class="string">&quot;test1&quot;</span>, <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;test2&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>bulk api提供了以下4种操作：</p>
<ol>
<li>delete：删除一个文档，只要1个json串就可以了</li>
<li>create：PUT /index/type/id/_create，强制创建</li>
<li>index：普通的put操作，可以是创建文档，也可以是全量替换文档</li>
<li>update：执行的partial update操作</li>
</ol>
<p>bulk api对json的语法，有严格的要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行。</p>
<p>bulk操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test_index/_bulk</span><br><span class="line">&#123; <span class="attr">&quot;delete&quot;</span>: &#123; <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">&quot;create&quot;</span>: &#123; <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;12&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>:    <span class="string">&quot;test12&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:  &#123; <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>:    <span class="string">&quot;auto-generate id test&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:  &#123; <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>:    <span class="string">&quot;replaced test2&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;update&quot;</span>: &#123; <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">&quot;_retry_on_conflict&quot;</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">&quot;doc&quot;</span> : &#123;<span class="attr">&quot;test_field2&quot;</span> : <span class="string">&quot;bulk test1&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /test_index/test_type/_bulk</span><br><span class="line">&#123; <span class="attr">&quot;delete&quot;</span>: &#123; <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span> &#125;&#125; </span><br><span class="line">&#123; <span class="attr">&quot;create&quot;</span>: &#123; <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;12&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>:    <span class="string">&quot;test12&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:  &#123; &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;auto-generate id test&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:  &#123; <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;replaced test2&quot;</span> &#125;</span><br><span class="line">&#123; <span class="attr">&quot;update&quot;</span>: &#123; <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">&quot;_retry_on_conflict&quot;</span> : <span class="number">3</span>&#125; &#125;</span><br><span class="line">&#123; <span class="attr">&quot;doc&quot;</span> : &#123;<span class="attr">&quot;test_field2&quot;</span> : <span class="string">&quot;bulk test1&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="bulk-size最佳大小"><a href="#bulk-size最佳大小" class="headerlink" title="bulk size最佳大小"></a>bulk size最佳大小</h3><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000<del>5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5</del>15MB之间。</p>
<h1 id="Document数据路由"><a href="#Document数据路由" class="headerlink" title="Document数据路由"></a>Document数据路由</h1><p>在ES中，一个index的数据会分散在多个分片(shard)中，所以当客户端创建Document的时候，需要决定这个Document放在ES的哪一个shard上，这个过程被称之为<strong>数据路由</strong>。</p>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p><code>shard = hash(routing) % number_of_primary_shards</code></p>
<p>举个例子，一个index有3个primary shard，P0，P1，P2。每次增删改查一个document的时候，都会带过来一个routing number，默认就是这个document的_id（可能是手动指定，也可能是自动生成）。所以routing = _id，假设_id=1，会将这个routing值，传入一个hash函数中，产出一个routing值的hash值，hash(routing) = 21。然后将hash函数产出的值对这个index的primary shard的数量求余数，21 % 3 = 0<br>就决定了，这个document就放在P0上。<strong>决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的</strong>。无论hash值是几，无论是什么数字，对<code>number_of_primary_shards</code>求余数，结果一定是在<code>0~number_of_primary_shards</code>-1之间这个范围内的，这里是0,1,2。</p>
<h2 id="id还是自定义routing值"><a href="#id还是自定义routing值" class="headerlink" title="_id还是自定义routing值"></a>_id还是自定义routing值</h2><p>默认的routing就是_id<br>也可以在发送请求的时候，手动指定一个routing值，比如<code>put /index/type/id?routing=user_id</code></p>
<p>手动指定routing value是很有用的，可以保证某一类document一定被路由到一个shard上去，那么在后续进行应用级别的负载均衡，以及提升批量读取的性能的时候，是很有帮助的。</p>
<blockquote>
<p>比如在实际的工作当中，如果大量的查询是基于某一个字段的查询，那么可以在添加数据的时候设置这个字段的ID为routing值，比如用户ID，这样在做查询和聚合的时候，ES只需要去一个shard里就能找到所有的数据，提升性能。</p>
</blockquote>
<h2 id="primary-shard数量不可变的谜底"><a href="#primary-shard数量不可变的谜底" class="headerlink" title="primary shard数量不可变的谜底"></a>primary shard数量不可变的谜底</h2><p>ES在创建index的时候设置了primary shard数量和replica shard数量，replica数量是可以修改的，但是primary shard的数量却不能修改。正是因为跟Document的路由公式有关，所以如果primary shard数量发生了变化，如果后面根据ID去查询一个数据，新的路由算法去计算分配，会发现根本找不到这个数据，间接导致数据丢失。</p>
<h1 id="Document增删改的内部原理"><a href="#Document增删改的内部原理" class="headerlink" title="Document增删改的内部原理"></a>Document增删改的内部原理</h1><p>客户端先选择一个节点发送请求，在一般的ES部署架构中，会有一个client节点，专门用来接收客户端的请求，它既不保存元数据，也不保存数据，只是协调请求转发和数据的聚合，分担master节点的压力。</p>
<p>节点对请求进行路由，将请求转发到路由以后的节点上，然后primary shard会在自己本地创建Document，建立索引，最后把响应结果返回给client。</p>
<p>所有的增删改操作，都只能由primary shard处理。</p>
<h1 id="写一致性原理"><a href="#写一致性原理" class="headerlink" title="写一致性原理"></a>写一致性原理</h1><p>我们在发送任何一个增删改操作的时候，比如说put /index/type/id，都可以带上一个consistency参数，指明我们想要的写一致性是什么？<br>put /index/type/id?consistency=quorum</p>
<ul>
<li>one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行</li>
<li>all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作</li>
<li>quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作</li>
</ul>
<h2 id="quorum机制"><a href="#quorum机制" class="headerlink" title="quorum机制"></a>quorum机制</h2><p>写之前必须确保大多数shard都可用，那么大多数是多少？这里有一个算法：</p>
<blockquote>
<p>quroum=<code>int( (primary + number_of_replicas) / 2 ) + 1</code>，当<code>number_of_replicas&gt;1</code>时才生效</p>
</blockquote>
<p>举个例子，3个primary shard，<code>number_of_replicas</code>=1，总共有3 + 3 * 1 = 6个shard。</p>
<p><code>quorum = int( (3 + 1) / 2 ) + 1 = 3</code></p>
<p>所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作。</p>
<p>如果节点数量少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作。</p>
<p>比如3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上(primary shard和replica shard不能放在一台机器上，同一个primary shard的replica shard也不能放在同一个机器上)，如果说只有1台机器的话，3个shard肯定都没法分配齐全，此时就可能会出现写操作无法执行的情况。</p>
<p>但是ES提供了一种特殊的处理场景，就是说当<code>number_of_replicas</code>&gt;1时才生效，因为假如说，你就一个primary shard，replica=1，此时就2个shard，套用公式算一下。</p>
<p>(1 + 1 / 2) + 1 = 2，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作。</p>
<p>quorum不齐全的时候，ES会等待，默认1分钟。等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout。</p>
<p>我们其实可以在写操作的时候，加一个timeout参数，比如说put /index/type/id?timeout=30，这个就是自己去设定quorum不齐全的时候，es的timeout时长，可以缩短，也可以增长。</p>
<h1 id="ES查询原理"><a href="#ES查询原理" class="headerlink" title="ES查询原理"></a>ES查询原理</h1><p>对于读请求，coordinate node（协作节点）不一定会将请求转发到primary节点上去，因为replica也是可以服务读请求的，而且在转发的时候会采用轮询的负载均衡算法，让读请求均匀的转发到replica shard上。</p>
<p>如果Document正在建立索引的过程中，只在primary shard上存在，此时replica shard上没有，但是协调节点可能将请求转发到replica shard上，此时就会找不到这个Document。</p>
<h1 id="bulk-api原理"><a href="#bulk-api原理" class="headerlink" title="bulk api原理"></a>bulk api原理</h1><p>上面在学bulk api的时候，ES对json格式要求非常严格，格式紧凑，对换行也有要求。</p>
<p>1、bulk中的每个操作都可能要转发到不同的node的shard去执行</p>
<p>2、如果采用比较良好的json数组格式</p>
<p>允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理</p>
<ol>
<li>将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象</li>
<li>解析json数组里的每个json，对每个请求中的document进行路由</li>
<li>为路由到同一个shard上的多个请求，创建一个请求数组</li>
<li>将这个请求数组序列化</li>
<li>将序列化后的请求数组发送到对应的节点上去</li>
</ol>
<p>3、耗费更多内存，更多的jvm gc开销</p>
<p>我们之前提到过bulk size最佳大小的那个问题，一般建议说在几千条，然后大小在10MB左右，所以可怕的事情来了。假设说现在100个bulk请求发送到了一个节点上去，然后每个请求是10MB，100个请求，就是1000MB = 1GB，然后每个请求的json都copy一份为jsonarray对象，此时内存中的占用就会翻倍，就会占用2GB的内存，甚至还不止。因为弄成jsonarray之后，还可能会多搞一些其他的数据结构，2GB+的内存占用。</p>
<p>占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。<br>另外的话，占用内存更多，就会导致java虚拟机的垃圾回收次数更多，跟频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多。</p>
<p>4、现在的奇特格式</p>
<p>{“action”: {“meta”}}\n<br>{“data”}\n<br>{“action”: {“meta”}}\n<br>{“data”}\n</p>
<ol>
<li>不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json</li>
<li>对每两个一组的json，读取meta，进行document路由</li>
<li>直接将对应的json发送到node上去</li>
</ol>
<p>5、最大的优势在于，不需要将json数组解析为一个JSONArray对象，形成一份大数据的拷贝，浪费内存空间，尽可能地保证性能</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch05-搜索详解</title>
    <url>/2018/09/19/elasticsearch/elasticSearch05/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<p>前面讲了Document的增删改查和集群原理，接下来就是ES的重头戏了，搜索。</p>
<h1 id="search结果解析"><a href="#search结果解析" class="headerlink" title="_search结果解析"></a>_search结果解析</h1><p>当发出一个搜索请求的时候，会拿到很多结果，下面说一下搜索结果里的各种数据，都代表了什么含义。</p>
<a id="more"></a>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET _search</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;.kibana&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;config&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;5.2.0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;buildNum&quot;</span>: <span class="number">14695</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;10&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test_field1&quot;</span>: <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;test_field2&quot;</span>: <span class="string">&quot;updated test2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jiajieshi yagao&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;youxiao fangzhu&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span>: <span class="number">25</span>,</span><br><span class="line">          <span class="attr">&quot;producer&quot;</span>: <span class="string">&quot;jiajieshi producer&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;fangzhu&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gaolujie yagao&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;gaoxiao meibai&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span>: <span class="number">30</span>,</span><br><span class="line">          <span class="attr">&quot;producer&quot;</span>: <span class="string">&quot;gaolujie producer&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;meibai&quot;</span>,</span><br><span class="line">            <span class="string">&quot;fangzhu&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;hello es&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;ecommerce&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;product&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;zhonghua yagao&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;caoben zhiwu&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span>: <span class="number">40</span>,</span><br><span class="line">          <span class="attr">&quot;producer&quot;</span>: <span class="string">&quot;zhonghua producer&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;qingxin&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>took</code>：整个搜索请求花费了多少毫秒</p>
</li>
<li><p><code>hits.total</code>：本次搜索，返回了几条结果</p>
</li>
<li><p><code>hits.max_score</code>：本次搜索的所有结果中，最大的相关度分数是多少，每一条document对于search的相关度，越相关，<code>_score</code>分数越大，排位越靠前</p>
</li>
<li><p><code>hits.hits</code>：默认查询前10条数据，包含完整数据，<code>_score</code>降序排序</p>
</li>
<li><p><code>shards</code>：shards fail的条件（primary和replica全部挂掉），不影响其他shard。默认情况下来说，一个搜索请求，会打到一个index的所有primary shard上去，当然了，每个primary shard都可能会有一个或多个replic shard，所以请求也可以到primary shard的其中一个replica shard上去。</p>
</li>
<li><p><code>timeout</code>：默认没有所谓的timeout，如果搜索特别慢每个shard都要好几分钟，那么搜索请求会一直等待结果返回。ES提供了timeout机制，指定每个shard在设置的timeout时间内马上已经搜索到的数据（可能是部分，也可能是全部），直接返回给client程序，而不是等到所有的数据全部搜索出来以后再返回。确保一次请求可以在用户指定的timeout时常内完成，为一些时间敏感的搜索应用提供良好支持。</p>
<p>  <code>GET /_search?timeout=10m</code></p>
</li>
</ul>
<h1 id="multi-index和multi-type搜索模式"><a href="#multi-index和multi-type搜索模式" class="headerlink" title="multi-index和multi-type搜索模式"></a>multi-index和multi-type搜索模式</h1><p>如何一次性搜索多个index和多个type下的数据</p>
<ul>
<li><code>/_search</code>：所有索引，所有type下的所有数据都搜索出来</li>
<li><code>/index1/_search</code>：指定一个index，搜索其下所有type的数据</li>
<li><code>/index1,index2/_search</code>：同时搜索两个index下的数据</li>
<li><code>/*1,*2/_search</code>：按照通配符去匹配多个索引</li>
<li><code>/index1/type1/_search</code>：搜索一个index下指定的type的数据</li>
<li><code>/index1/type1,type2/_search</code>：可以搜索一个index下多个type的数据</li>
<li><code>/index1,index2/type1,type2/_search</code>：搜索多个index下的多个type的数据</li>
<li><code>/_all/type1,type2/_search</code>：_all，可以代表搜索所有index下的指定type的数据</li>
</ul>
<h2 id="搜索基本原理"><a href="#搜索基本原理" class="headerlink" title="搜索基本原理"></a>搜索基本原理</h2><p>客户端发送一个搜索请求，会把请求分配到所有的primary shard上去执行，因为每个shard都包含部分数据，所以每个shard上都可能会包含搜索请求的结果。但是如果primary shard有replica shard，那么请求也可以分配到replica shard上去执行。</p>
<h1 id="分页搜索"><a href="#分页搜索" class="headerlink" title="分页搜索"></a>分页搜索</h1><h2 id="分页搜索语法"><a href="#分页搜索语法" class="headerlink" title="分页搜索语法"></a>分页搜索语法</h2><p>参数：</p>
<ul>
<li>size: 一页多少条</li>
<li>from：从多少条开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;0</span><br></pre></td></tr></table></figure>

<p>返回结果里面写了总共有多少条：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 8,</span><br></pre></td></tr></table></figure>

<h2 id="deep-paging问题"><a href="#deep-paging问题" class="headerlink" title="deep paging问题"></a>deep paging问题</h2><p>deep paging就是搜索特别深，比如总共有3w条数据，每页10条数据，搜索最后一页</p>
<p>请求先发到coordinate node（通常是client节点），然后请求会分配到不同的节点上去找数据，每个个shard都会把所有的数据找出来，排序后取最后10条，返回给客户端。</p>
<p>这个过程会耗费很大的网络带宽、内存和CPU，所以deep paging有较大的性能问题，应该尽量避免做出这种deep paging操作。</p>
<h1 id="query-string语法介绍"><a href="#query-string语法介绍" class="headerlink" title="query string语法介绍"></a>query string语法介绍</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;test_field:test</span><br><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;+test_field:test</span><br><span class="line">GET &#x2F;test_index&#x2F;test_type&#x2F;_search?q&#x3D;-test_field:test</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>test_field包含test</li>
</ul>
</li>
<li><ul>
<li>test_field不包含test</li>
</ul>
</li>
</ul>
<h1 id="all-metadata介绍"><a href="#all-metadata介绍" class="headerlink" title="_all metadata介绍"></a>_all metadata介绍</h1><pre><code>GET /test_index/test_type/_search?q=test</code></pre>
<p>直接可以搜索所有的field，任意一个field包含指定的关键字就可以搜索出来。我们在进行中搜索的时候，难道是对document中的每一个field都进行一次搜索吗？不是这样的。</p>
<p>es中的<code>_all</code>元数据，在建立索引的时候，我们插入一条document，它里面包含了多个field，此时es会自动将多个field的值，全部用字符串的方式串联起来，变成一个长的字符串，作为<code>_all</code> field的值，同时建立索引。</p>
<p>后面如果在搜索的时候，没有对某个field指定搜索，就默认搜索_all field，其中是包含了所有field的值的。</p>
<p>举个例子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;jack@sina.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;guamgzhou&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>jack 26 jack@sina.com guangzhou</code>，作为这一条document的<code>_all</code> field的值，同时进行分词后建立对应的倒排索引。</p>
<h1 id="mapping介绍"><a href="#mapping介绍" class="headerlink" title="mapping介绍"></a>mapping介绍</h1><p>先插入几条数据，让ES自动建立一个索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/article/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;post_date&quot;</span>: <span class="string">&quot;2017-01-01&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my first article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my first article in this website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">11400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /website/article/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;post_date&quot;</span>: <span class="string">&quot;2017-01-02&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my second article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my second article in this website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">11400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /website/article/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;post_date&quot;</span>: <span class="string">&quot;2017-01-03&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my third article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my third article in this website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">11400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进行搜索测试：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /website/article/_search?q=2017			3条结果             </span><br><span class="line">GET /website/article/_search?q=2017-01-01        	3条结果</span><br><span class="line">GET /website/article/_search?q=post_date:2017-01-01   	1条结果</span><br><span class="line">GET /website/article/_search?q=post_date:2017         	1条结果</span><br></pre></td></tr></table></figure>

<p>这个搜索结果，不太符合我们的期望，这里涉及到ES的mapping了，具体这个数字是怎么搜索出来的，后面<a href="#%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3">案例详解</a>会讲到。</p>
<p>自动或手动为index中的type建立的一种数据结构和相关配置，简称为mapping，<br><code>dynamic mapping</code>，就是ES自动为我们建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置。</p>
<p>如何查看mapping？</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/_mapping/article</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;website&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;author_id&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;post_date&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>搜索结果为什么不一致，因为es自动建立mapping的时候，为不同的field设置了不同的data type。不同的data type的分词、搜索等行为是不一样的。所以出现了_all field和post_date field的搜索表现完全不一样的结果。</p>
<h1 id="精确搜索和全文搜索对比"><a href="#精确搜索和全文搜索对比" class="headerlink" title="精确搜索和全文搜索对比"></a>精确搜索和全文搜索对比</h1><h2 id="精确搜索"><a href="#精确搜索" class="headerlink" title="精确搜索"></a>精确搜索</h2><p>2017-01-01，用精确值搜索的时候，必须输入2017-01-01，才能搜索出来<br>如果你输入一个01，是搜索不出来的</p>
<h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><ol>
<li>缩写 vs. 全称：cn vs. china</li>
<li>格式转化：like liked likes</li>
<li>大小写：Tom vs tom</li>
<li>同义词：like vs love</li>
</ol>
<p>2017-01-01，2017 01 01，搜索2017，或者01，都可以搜索出来</p>
<p>china，搜索cn，也可以将china搜索出来<br>likes，搜索like，也可以将likes搜索出来<br>Tom，搜索tom，也可以将Tom搜索出来<br>like，搜索love，同义词，也可以将like搜索出来        </p>
<p>就不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配</p>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p>
<p>先来两个文档：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">doc1：I really liked my small dogs, and I think my mom also liked them.</span><br><span class="line">doc2：He never liked any dogs, so I hope that my mom will not expect me to liked him.</span><br></pre></td></tr></table></figure>


<p>接下来分词，初步的倒排索引的建立。</p>
<p>演示一下倒排索引最简单的建立的一个过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word		doc1			doc2</span><br><span class="line"></span><br><span class="line">I			*				*</span><br><span class="line">really		*</span><br><span class="line">liked		*				*</span><br><span class="line">my			*				*</span><br><span class="line">small		*	</span><br><span class="line">dogs		*</span><br><span class="line">and			*</span><br><span class="line">think		*</span><br><span class="line">mom			*				*</span><br><span class="line">also		*</span><br><span class="line">them		*	</span><br><span class="line">He							*</span><br><span class="line">never						*</span><br><span class="line">any							*</span><br><span class="line">so							*</span><br><span class="line">hope						*</span><br><span class="line">that						*</span><br><span class="line">will						*</span><br><span class="line">not							*</span><br><span class="line">expect						*</span><br><span class="line">me							*</span><br><span class="line">to							*</span><br><span class="line">him							*</span><br></pre></td></tr></table></figure>


<p>如果用<code>mother like little dog</code>去搜索，是搜不到结果的，搜索的时候会被拆成4个单词去搜索，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mother</span><br><span class="line">like</span><br><span class="line">little</span><br><span class="line">dog</span><br></pre></td></tr></table></figure>

<p>但是，在我们看来mother和mom是同义词，like和liked也是一样的意思，little和small也一样，dog和dogs也一样。</p>
<p>所以在简历倒排所以的时候，会执行一个操作，对拆分出的各个单词进行相应的处理，以提升后面搜索的时候能够搜索到相关联的文档的概率，这个过程叫normalization。</p>
<p>比如时态的转换，单复数的转换，同义词的转换，大小写的转换等等</p>
<p>mom —&gt; mother<br>liked —&gt; like<br>small —&gt; little<br>dogs —&gt; dog        </p>
<p>重新建立倒排索引，加入normalization，再次用<code>mother liked little dog</code>搜索，doc1和doc2都会搜索出来。</p>
<h1 id="分词器介绍"><a href="#分词器介绍" class="headerlink" title="分词器介绍"></a>分词器介绍</h1><p>分词器，是将用户输入的一段文本，分析成符合逻辑的一种工具，给你一段文本，然后将这段句子拆分成一个一个的单个的单词，同时对每个单词进行normalization（时态转换，单复数转换），分词器<br>提升recall召回率（召回率：搜索的时候，增加能够搜索到的结果的数量）</p>
<ol>
<li>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签（<span>hello<span> –&gt; hello），&amp; –&gt; and（I&amp;you –&gt; I and you）</li>
<li>tokenizer：分词，hello you and me –&gt; hello, you, and, me</li>
<li>token filter：lowercase，stop word，synonymom，dogs –&gt; dog，liked –&gt; like，Tom –&gt; tom，a/the/an –&gt; 干掉，mother –&gt; mom，small –&gt; little</li>
</ol>
<p>分词器很重要，它将一段文本进行各种处理，最后处理好的结果才会拿去建立倒排索引。</p>
<h2 id="内置分词器介绍"><a href="#内置分词器介绍" class="headerlink" title="内置分词器介绍"></a>内置分词器介绍</h2><p><code>Set the shape to semi-transparent by calling set_trans(5)</code></p>
<ul>
<li>standard analyzer：set, the, shape, to, semi, transparent, by, calling, set_trans, 5（默认的是standard）</li>
<li>simple analyzer：set, the, shape, to, semi, transparent, by, calling, set, trans</li>
<li>whitespace analyzer：Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</li>
<li>language analyzer（特定的语言的分词器，比如说，english，英语分词器）：set, shape, semi, transpar, call, set_tran, 5</li>
</ul>
<h2 id="query-string分词"><a href="#query-string分词" class="headerlink" title="query string分词"></a>query string分词</h2><p><strong>query string必须以和index建立时相同的analyzer进行分词</strong></p>
<p>比如我们有一个document，其中有一个field，包含的value是：hello you and me。</p>
<p>我们要搜索这个document对应的index，搜索文本是hell me，这个搜索文本就是query string。<br>query string，默认情况下，es会使用它对应的field建立倒排索引时相同的分词器去进行分词和normalization，只有这样才能实现正确的搜索。</p>
<p>建立倒排索引的时候，将dogs –&gt; dog。结果搜索的时候用dogs去搜索，那不就搜索不到了吗？所以搜索的时候，那个dogs也必须变成dog才行。才能搜索到。</p>
<p><strong>query string对exact value（精确搜索）和full text（全文搜索）的区别对待</strong></p>
<blockquote>
<p>所以不同类型的field，可能有的就是full text，有的就是exact value。</p>
</blockquote>
<h2 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h2><p><code>GET /_search?q=2017</code></p>
<p>这个查询前面说了，搜索的是<code>_all</code> field，document所有的field都会拼接成一个大字符串，进行分词搜索。</p>
<p>拼接以后的字符串：2017-01-02 my second article this is my second article in this website 11400</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			doc1		doc2		doc3</span><br><span class="line">2017		*			*			*</span><br><span class="line">01			* 		</span><br><span class="line">02						*</span><br><span class="line">03									*</span><br></pre></td></tr></table></figure>

<p>所以用2017去搜索，自然会搜索到3个。</p>
<p>那么用<code>GET /_search?q=2017-01-01</code>去搜索呢</p>
<p>2017-01-01这个query string会用跟建立倒排索引一样的分词器去进行分词，所以搜索的条件会被分词成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017</span><br><span class="line">01</span><br><span class="line">01</span><br></pre></td></tr></table></figure>
<p>所以还是会搜索到3条。</p>
<p>接下来是<code>GET /_search?q=post_date:2017-01-01</code>，这里加了查询的字段了，这个字段的类型是date，es会用特别的方式进行处理，转换成时间去对这个字段进行搜索。</p>
<h2 id="测试分词器"><a href="#测试分词器" class="headerlink" title="测试分词器"></a>测试分词器</h2><p>给一段文本和指定分词器进行分词：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Text to analyze&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;to&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;analyze&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mapping详解"><a href="#mapping详解" class="headerlink" title="mapping详解"></a>mapping详解</h1><p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。这个信息包含在mapping中。</p>
<p>mapping就是index的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为。</p>
<ol>
<li>往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping。</li>
<li>mapping中定义了每个field的数据类型。</li>
<li>不同的数据类型（比如说text和date），可能有的是exact value，有的是full text。</li>
<li>exact value：在建立倒排索引、分词的时候，是将整个值一起作为一个关键词建立到倒排索引中的；full text：会经历各种各样的处理、分词、normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中。</li>
<li>同时呢，exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索。</li>
<li>可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为、分词器，等等。</li>
</ol>
<h2 id="mapping数据类型"><a href="#mapping数据类型" class="headerlink" title="mapping数据类型"></a>mapping数据类型</h2><p>Elasticsearch支持如下简单域类型：</p>
<ul>
<li>字符串: string</li>
<li>整数 : byte, short, integer, long</li>
<li>浮点数: float, double</li>
<li>布尔型: boolean</li>
<li>日期: date</li>
</ul>
<p>dynamic mapping：当你索引一个包含新域的文档–之前未曾出现– Elasticsearch 会使用 动态映射 ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p>
<p>true or false    –&gt;    boolean<br>123        –&gt;    long<br>123.45        –&gt;    double<br>2017-01-01    –&gt;    date<br>“hello world”    –&gt;    string/text        </p>
<blockquote>
<p>这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p>
</blockquote>
<h2 id="查看mapping"><a href="#查看mapping" class="headerlink" title="查看mapping"></a>查看mapping</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET website/_mapping/article</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;website&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;author_id&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;post_date&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义mapping"><a href="#自定义mapping" class="headerlink" title="自定义mapping"></a>自定义mapping</h2><p>mapping在建立以后，只能新增字段，不能修改字段类型。</p>
<p>先创建一个mapping：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;author_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;post_date&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;publisher_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试着修改mapping，比如<code>author_id</code>，会得到一个错误：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;author_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_already_exists_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [website/8KNSiw4wRq-67EVN20ll3A] already exists&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;8KNSiw4wRq-67EVN20ll3A&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;index_already_exists_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [website/8KNSiw4wRq-67EVN20ll3A] already exists&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;8KNSiw4wRq-67EVN20ll3A&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果是给已经存在的mapping新增一个field，就没问题了：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/_mapping/article</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;new_field&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> :    <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>:    <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试mapping"><a href="#测试mapping" class="headerlink" title="测试mapping"></a>测试mapping</h2><p>你可以使用 analyze API 测试字符串域的映射，下面测试某一个mapping的字段分词情况：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;content&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;my-dogs&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mapping复杂数据类型"><a href="#mapping复杂数据类型" class="headerlink" title="mapping复杂数据类型"></a>mapping复杂数据类型</h2><p>除了我们提到的简单标量数据类型， JSON 还有 null 值，数组，和对象，这些 Elasticsearch 都是支持的</p>
<h3 id="multivalue-field（多值域）"><a href="#multivalue-field（多值域）" class="headerlink" title="multivalue field（多值域）"></a>multivalue field（多值域）</h3><p>很有可能，我们希望 tag 域 包含多个标签。我们可以以数组的形式索引标签：</p>
<p><code>&#123; &quot;tag&quot;: [ &quot;search&quot;, &quot;nosql&quot; ]&#125;</code></p>
<p>对于数组，没有特殊的映射需求。任何域都可以包含0、1或者多个值，就像全文域分析得到多个词条。</p>
<p>这暗示 数组中所有的值必须是相同数据类型的 。你不能将日期和字符串混在一起。如果你通过索引数组来创建新的域，Elasticsearch 会用数组中第一个值的数据类型作为这个域的 类型。</p>
<h3 id="empty-field（空域）"><a href="#empty-field（空域）" class="headerlink" title="empty field（空域）"></a>empty field（空域）</h3><p>当然，数组可以为空。 这相当于存在零值。 事实上，在 Lucene 中是不能存储 null 值的，所以我们认为存在 null 值的域为空域。</p>
<p>下面三种域被认为是空的，它们将不会被索引：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;null_value&quot;:               null,</span><br><span class="line">&quot;empty_array&quot;:              [],</span><br><span class="line">&quot;array_with_null_value&quot;:    [ null ]</span><br></pre></td></tr></table></figure>
<h3 id="object-field（多层级对象）"><a href="#object-field（多层级对象）" class="headerlink" title="object field（多层级对象）"></a>object field（多层级对象）</h3><p>我们讨论的最后一个 JSON 原生数据类是 对象 – 在其他语言中称为哈希，哈希 map，字典或者关联数组。</p>
<p>内部对象 经常用于 嵌入一个实体或对象到其它对象中。例如，与其在 tweet 文档中包含 user_name 和 user_id 域，我们也可以这样写：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /tweet/tweet/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span>:            <span class="string">&quot;Elasticsearch is very flexible&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>:           <span class="string">&quot;@johnsmith&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;gender&quot;</span>:       <span class="string">&quot;male&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>:          <span class="number">26</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;full&quot;</span>:     <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;first&quot;</span>:    <span class="string">&quot;John&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;last&quot;</span>:     <span class="string">&quot;Smith&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /tweet/tweet/_mapping</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;tweet&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;age&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;gender&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;first&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">&quot;full&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">&quot;last&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部对象如何索引"><a href="#内部对象如何索引" class="headerlink" title="内部对象如何索引"></a>内部对象如何索引</h3><p>Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tweet&quot;</span>:            [elasticsearch, flexible, very],</span><br><span class="line">    <span class="attr">&quot;user.id&quot;</span>:          [@johnsmith],</span><br><span class="line">    <span class="attr">&quot;user.gender&quot;</span>:      [male],</span><br><span class="line">    <span class="attr">&quot;user.age&quot;</span>:         [<span class="number">26</span>],</span><br><span class="line">    <span class="attr">&quot;user.name.full&quot;</span>:   [john, smith],</span><br><span class="line">    <span class="attr">&quot;user.name.first&quot;</span>:  [john],</span><br><span class="line">    <span class="attr">&quot;user.name.last&quot;</span>:   [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch07-索引管理</title>
    <url>/2018/09/27/elasticsearch/elasticSearch07/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="手动创建索引"><a href="#手动创建索引" class="headerlink" title="手动创建索引"></a>手动创建索引</h2><p>之前都是直接插入document，ES为我们自动创建索引。其实在大部分情况下，我们是需要自己先手动创建mapping的，就像数据库建表一样，你可能需要设置primary shard的数量，字段的分词器，具体的数据类型等等。</p>
<a id="more"></a>

<p><strong>创建索引的语法</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_field&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p><code>number_of_shards</code>是不能修改的，修改一下<code>number_of_replicas</code>试试。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line">DELETE /index_one,index_two</span><br><span class="line">DELETE /index_*</span><br><span class="line">DELETE /_all</span><br></pre></td></tr></table></figure>


<p><code>DELETE /_all</code>是很危险的操作，可以在ES的配置文件里禁用掉。</p>
<p><strong>elasticsearch.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">action.destructive_requires_name:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="配置分词器"><a href="#配置分词器" class="headerlink" title="配置分词器"></a>配置分词器</h2><p>分词器是用于将全文字符串转换为适合搜索的倒排索引。</p>
<p>standard 分析器是用于全文字段的默认分析器， 对于大部分西方语系来说是一个不错的选择。 它包括了以下几点：</p>
<ul>
<li>standard tokenizer：以单词边界进行切分</li>
<li>standard token filter：什么都不做</li>
<li>lowercase token filter：将所有字母转换为小写</li>
<li>stop token filter（默认被禁用）：移除停用词，比如a the it等等</li>
</ul>
<h2 id="修改分词器"><a href="#修改分词器" class="headerlink" title="修改分词器"></a>修改分词器</h2><p>启用english停用词token filter</p>
<p>在下面的例子中，我们创建了一个新的分析器，叫做 <code>es_std</code> ， 并使用预定义的英语停用词列表：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;es_std&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;stopwords&quot;</span>: <span class="string">&quot;_english_&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;a dog is in the house&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;dog&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;is&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;in&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">9</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;the&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;house&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">16</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">21</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;es_std&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>:<span class="string">&quot;a dog is in the house&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;dog&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;house&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">16</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">21</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h2><p>虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p>
<p>一个分词器就是在一个包里面组合了三种函数的一个包装器， 三种函数按照顺序被执行:</p>
<ul>
<li><p>字符过滤器<br>  字符过滤器 用来 整理 一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像 <code>&lt;p&gt;</code> 或者 <code>&lt;div&gt;</code> 这样的HTML标签，这些标签是我们不想索引的。我们可以使用 html清除 字符过滤器 来移除掉所有的HTML标签，并且像把 <code>&amp;Aacute;</code> 转换为相对应的Unicode字符 Á 这样，转换HTML实体。</p>
<p>  一个分析器可能有0个或者多个字符过滤器。</p>
</li>
<li><p>分词器<br>  一个分析器 必须 有一个唯一的分词器。 分词器把字符串分解成单个词条或者词汇单元。 standard 分析器里使用的 standard 分词器 把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p>
</li>
<li><p>词单元过滤器<br>  经过分词，作为结果的 词单元流 会按照指定的顺序通过指定的词单元过滤器 。    </p>
</li>
<li><p>*举例**：</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;char_filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;&amp;_to_and&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapping&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;mappings&quot;</span>: [<span class="string">&quot;&amp;=&gt; and&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_stopwords&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;stopwords&quot;</span>: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;char_filter&quot;</span>: [<span class="string">&quot;html_strip&quot;</span>, <span class="string">&quot;&amp;_to_and&quot;</span>],</span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: [<span class="string">&quot;lowercase&quot;</span>, <span class="string">&quot;my_stopwords&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个<code>my_analyzer</code>分析器，分词用的standard，字符过滤器用了<code>html_strip</code>和<code>&amp;_to_and</code>，词过滤器用了<code>lowercase</code>和<code>my_stopwords</code>。</p>
<p>测试一下分词器的效果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;tom&amp;jerry are a friend in the house, &lt;a&gt;, HAHA!!&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;my_analyzer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;tomandjerry&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">9</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;are&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">13</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;friend&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">16</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;in&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">23</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">25</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;house&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">35</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;haha&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span>: <span class="number">42</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span>: <span class="number">46</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span>: <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何在索引中使用我们自定义的分词器？</strong></p>
<p>创建一个mapping，为content设置我们自定义的分词器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;my_analyzer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>type，是一个index中用来区分类似的文档。类似的文档可能有不同的fields，而且有不同的属性来控制索引建立、分词器。就像数据库中的 schema ，描述了文档可能具有的字段或 属性 、 每个字段的数据类型—比如 string, integer 或 date —以及Lucene是如何索引和存储这些字段的。</p>
<p>field的value，在底层的lucene中建立索引的时候，全部是opaque bytes类型，是不区分类型的。</p>
<p>Lucene 没有文档类型的概念，每个文档的类型名被存储在一个叫 <code>_type</code> 的元数据字段上。 当我们要检索某个类型的文档时, Elasticsearch 通过在 <code>_type</code> 字段上使用过滤器限制只返回这个类型的文档。</p>
<p>Lucene 也没有映射的概念。 映射是 Elasticsearch 将复杂 JSON 文档 映射 成 Lucene 需要的扁平化数据的方式。</p>
<p>一个index中的多个type，实际上是放在一起存储的，因此一个index下，不能有多个type重名，而类型或者其他设置不同的，因为那样是无法处理的。</p>
<p>比如有个映射和文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;ecommerce&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;elactronic_goods&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;double&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">	       <span class="attr">&quot;service_period&quot;</span>: &#123;</span><br><span class="line">		  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">	       &#125;			</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">&quot;fresh_goods&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">               <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;double&quot;</span></span><br><span class="line">               &#125;,</span><br><span class="line">	       <span class="attr">&quot;eat_period&quot;</span>: &#123;</span><br><span class="line">		  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">	       &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;geli kongtiao&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>: <span class="number">1999.0</span>,</span><br><span class="line">  <span class="attr">&quot;service_period&quot;</span>: <span class="string">&quot;one year&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;aozhou dalongxia&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>: <span class="number">199.0</span>,</span><br><span class="line">  <span class="attr">&quot;eat_period&quot;</span>: <span class="string">&quot;one week&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际在Lucene里的数据可能是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;ecommerce&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;price&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;double&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;service_period&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;eat_period&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;elactronic_goods&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;geli kongtiao&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>: <span class="number">1999.0</span>,</span><br><span class="line">  <span class="attr">&quot;service_period&quot;</span>: <span class="string">&quot;one year&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;eat_period&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;fresh_goods&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;aozhou dalongxia&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>: <span class="number">199.0</span>,</span><br><span class="line">  <span class="attr">&quot;service_period&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;eat_period&quot;</span>: <span class="string">&quot;one week&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最佳实践是，将类似结构的type放在一个index下，这些type应该有多个field是相同的。<br><strong>假如你将两个type的field完全不同，放在一个index下，那么就每条数据都至少有一半的field在底层的lucene中是空值，会有严重的性能问题</strong>。</p>
<h1 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h1><p>映射的最高一层被称为 根对象 ，它可能包含下面几项：</p>
<ul>
<li>一个 properties 节点，列出了文档中可能包含的每个字段的映射</li>
<li>各种元数据字段，它们都以一个下划线开头，例如 <code>_type</code> 、 <code>_id</code> 和 <code>_source</code></li>
<li>设置项，控制如何动态处理新的字段，例如 <code>analyzer</code> 、 <code>dynamic_date_formats</code> 和 <code>dynamic_templates</code></li>
<li>其他设置，可以同时应用在根对象和其他 <code>object</code> 类型的字段上，例如 <code>enabled</code> 、 <code>dynamic</code> 和 <code>include_in_all</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>文档的字段描述，包含type，index，analyzer</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>Elasticsearch 在 <code>_source</code> 字段存储代表文档体的JSON字符串。和所有被存储的字段一样， <code>_source</code> 字段在被写入磁盘之前先会被压缩。</p>
<p>好处：</p>
<ol>
<li>查询的时候，直接可以拿到完整的document，不需要先拿document id，再发送一次请求拿document</li>
<li>partial update基于_source实现</li>
<li>reindex时，直接基于_source实现，不需要从数据库（或者其他外部存储）查询数据再修改</li>
<li>可以基于_source定制返回field</li>
<li>debug query更容易，因为可以直接看到_source</li>
</ol>
<p>不需要的话，也可以禁用_source，不保存原始对象</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;<span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="all"><a href="#all" class="headerlink" title="_all"></a>_all</h2><p>前面说过，将所有field打包在一起，作为一个_all field，建立索引。没指定任何field进行搜索时，就是使用_all field在搜索。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_all&quot;</span>: &#123;<span class="attr">&quot;enabled&quot;</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在field级别设置<code>include_in_all</code> field，设置是否要将field的值包含在<code>_all</code> field中&gt;</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_field&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;include_in_all&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识性metadata"><a href="#标识性metadata" class="headerlink" title="标识性metadata"></a>标识性metadata</h2><ul>
<li>_id<br>  文档的 ID 字符串</li>
<li>_type<br>  文档的类型名</li>
<li>_index<br>  文档所在的索引</li>
<li>_uid<br>  <code>_type</code> 和 <code>_id</code> 连接在一起构造成 type#id</li>
</ul>
<h1 id="定制dynamic策略"><a href="#定制dynamic策略" class="headerlink" title="定制dynamic策略"></a>定制dynamic策略</h1><p>ES在数据遇到新的字段时候，会为我们自动mapping，但是我们也可以定制化这个策略：</p>
<ul>
<li>true：遇到陌生字段，就进行dynamic mapping</li>
<li>false：遇到陌生字段，就忽略</li>
<li>strict：遇到陌生字段，就报错</li>
</ul>
<p>修改策略为<code>strict</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic&quot;</span>: <span class="string">&quot;strict&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;dynamic&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试添加数据，这里多了一个mapping里没有的content字段，因为是<code>strict</code>策略，所以ES报错了：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;guangdong&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;guangzhou&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;strict_dynamic_mapping_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;mapping set to strict, dynamic introduction of [content] within [my_type] is not allowed&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;strict_dynamic_mapping_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;mapping set to strict, dynamic introduction of [content] within [my_type] is not allowed&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="date-detection"><a href="#date-detection" class="headerlink" title="date_detection"></a>date_detection</h2><p>默认会按照一定格式识别date，比如yyyy-MM-dd。但是如果某个field先过来一个2017-01-01的值，就会被自动dynamic mapping成date，后面如果再来一个”hello world”之类的值，就会报错。可以手动关闭某个type的date_detection，如果有需要，自己手动指定某个field为date类型。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;date_detection&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义dynamic-mapping-template（type-level）"><a href="#自定义dynamic-mapping-template（type-level）" class="headerlink" title="自定义dynamic mapping template（type level）"></a>自定义dynamic mapping template（type level）</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;en&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;match&quot;</span>: <span class="string">&quot;*_en&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;long_to_date&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;match&quot;</span>: <span class="string">&quot;*time&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;this is my first article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title_en&quot;</span>: <span class="string">&quot;this is my first article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;create_time&quot;</span>: <span class="number">1538031023000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看ES为我们创建的mapping，<code>create_time</code>成功被映射成了date类型，<code>title_en</code>设置了english为分词器。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_mapping</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;my_index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;en&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match&quot;</span>: <span class="string">&quot;*_en&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;long_to_date&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;match&quot;</span>: <span class="string">&quot;*time&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;not_analyzed&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;create_time&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;keyword&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignore_above&quot;</span>: <span class="number">256</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;title_en&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;english&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自定义dynamic-mapping-template（index-level）"><a href="#自定义dynamic-mapping-template（index-level）" class="headerlink" title="自定义dynamic mapping template（index level）"></a>自定义dynamic mapping template（index level）</h2><p><code>_default_</code>就是设置这个index下所有的模板，type自己的配置可以覆盖<code>_default_</code>的配置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;_default_&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;_all&quot;</span>: &#123; <span class="attr">&quot;enabled&quot;</span>:  <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;blog&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;_all&quot;</span>: &#123; <span class="attr">&quot;enabled&quot;</span>:  <span class="literal">true</span>  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>一个field的设置是不能被修改的，如果要修改一个Field，那么应该重新按照新的mapping，建立一个index，然后将数据批量查询出来，重新用bulk api写入index中。</p>
<p>批量查询的时候，建议采用scroll api，并且采用多线程并发的方式来reindex数据，每次scoll就查询指定日期的一段数据，交给一个线程即可。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>一开始，依靠dynamic mapping，插入数据，但是不小心有些数据是2017-01-01这种日期格式的，所以title这种field被自动映射为了date类型，实际上它应该是string类型的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;2017-01-03&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;my_index&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当后期向索引中加入string类型的title值的时候，就会报错</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my first article&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;failed to parse [title]&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapper_parsing_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;failed to parse [title]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;caused_by&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;illegal_argument_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;Invalid format: \&quot;my first article\&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时想修改title的类型，是不可能的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;illegal_argument_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;mapper [title] of different type, current_type [date], merged_type [text]&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;illegal_argument_exception&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;mapper [title] of different type, current_type [date], merged_type [text]&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，唯一的办法就是进行reindex。重新建立一个索引，将旧索引的数据查询出来，再导入新索引。</p>
<p>比如旧索引的名字，是<code>old_index</code>，新索引的名字是<code>new_index</code>，终端是java应用，已经在使用<code>old_index</code>在操作了，难道还要去停止java应用，修改使用的index为new_index，才重新启动java应用吗？这个过程中，就会导致java应用停机，可用性降低，这样肯定不好。</p>
<p>那么在我们的例子中先给旧索引一个别名，客户端先用<code>goods_index</code>这个别名来操作，此时实际指向的是旧的<code>my_index</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_alias/goods_index</span><br></pre></td></tr></table></figure>

<p>然后新建一个index，调整其title的类型为string</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index_new</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;my_type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用scroll api将数据批量查询出来</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: [<span class="string">&quot;_doc&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:  <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_scroll_id&quot;</span>: <span class="string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAwhlFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAAMIZhZMck94NXllVVFRYVliRjRMMTN6NVp3AAAAAAADCGQWTHJPeDV5ZVVRUWFZYkY0TDEzejVadwAAAAAAAwhnFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAAMIaBZMck94NXllVVFRYVliRjRMMTN6NVp3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;2017-01-02&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用bulk api将scoll查出来的一批数据，批量写入新索引。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">&quot;index&quot;</span>:&#123; <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;my_index_new&quot;</span>, <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;my_type&quot;</span>, <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;2017-01-02&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>反复循环，查询一批又一批的数据出来，采取bulk api将每一批数据批量写入新索引。</p>
<p>将goods_index alias切换到my_index_new上去，java应用会直接通过index别名使用新的索引中的数据，java应用程序不需要停机，零停机，高可用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;remove&quot;</span>: &#123; <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;my_index&quot;</span>, <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;goods_index&quot;</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;add&quot;</span>:    &#123; <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;my_index_new&quot;</span>, <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;goods_index&quot;</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>直接通过goods_index别名来查询，是否成功，这里只有一条，因为我只操作了一条。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /goods_index/my_type/_search</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;my_index_new&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;2017-01-02&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Fork/Join和CompletableFuture的使用</title>
    <url>/2017/09/28/java/jdk8-11/</url>
    <content><![CDATA[<p>随着多核处理器的出现，提升应用程序处理速度最有效的方式是编写能充分发挥多核能力的软件。可以通过切分大型的任务，让每个子任务并行运行，在Java中目前有直接使用线程的方式、使用Fork/Join框架和JDK8中的并行流来达到这一目的。</p>
<p>这段代码演示了分段求和用线程方式的实现。</p>
<p>分别开启2个线程，给予不同范围的数值进行求和，最后调用join()方法等到线程执行完毕，将2个线程的结果相加得到结果。</p>
<a id="more"></a>

<h2 id="Thread方式"><a href="#Thread方式" class="headerlink" title="Thread方式"></a>Thread方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> []array;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(<span class="keyword">int</span> []array , <span class="keyword">int</span> start , <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.array = array;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end ; i++) &#123;</span><br><span class="line">			result += array[i];</span><br><span class="line">			<span class="keyword">if</span>(result &lt; <span class="number">0</span>) result &amp;= Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> COUNTER = <span class="number">100000001</span>;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> []array = <span class="keyword">new</span> <span class="keyword">int</span>[COUNTER];</span><br><span class="line">	Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; COUNTER ; i++) &#123;</span><br><span class="line">		array[i] = Math.abs(random.nextInt());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">	Computer c1 = <span class="keyword">new</span> Computer(array , <span class="number">0</span> , COUNTER / <span class="number">2</span>);</span><br><span class="line">	Computer c2 = <span class="keyword">new</span> Computer(array , (COUNTER / <span class="number">2</span>) + <span class="number">1</span> , COUNTER);</span><br><span class="line">	c1.start();</span><br><span class="line">	c2.start();</span><br><span class="line">	c1.join();</span><br><span class="line">	c2.join();</span><br><span class="line">	System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">	<span class="comment">//System.out.println(c1.getResult());</span></span><br><span class="line">	System.out.println((c1.getResult() + c2.getResult()) &amp; Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>关于Fork/Join框架的介绍的详细介绍，还可以查看方腾飞老师的文章<a href="http://ifeve.com/talk-concurrency-forkjoin/%EF%BC%8C%E4%BB%8B%E7%BB%8D%E5%BE%97%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E3%80%82">http://ifeve.com/talk-concurrency-forkjoin/，介绍得非常详细。</a></p>
<p>Fork/Join的实现是要继承<strong>RecursiveTask</strong>类，实现<strong>compute()**方法，如例子所示，同样也是求和的计算，用继承的类，将要求和的范围传入，在</strong>compute()**方法内部进行任务拆分，最后将每个任务的结果进行相加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RecursiveTask来创建可以用于fork/join框架的任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要求和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="comment">// 子任务处理的数组的起始位置和终止位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHHOLD = <span class="number">10_100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(numbers, <span class="number">0</span>, numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该任务负责求和的部分的大小</span></span><br><span class="line">        <span class="keyword">int</span> length = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大小小于或等于阈值，顺序计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; THRESHHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> computeSequentially();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个子任务来为数组的前一半求和</span></span><br><span class="line">        ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start, start + length / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">// 创建一个任务为数组的后一半求和</span></span><br><span class="line">        ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start + length / <span class="number">2</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        Long rightResult = rightTask.compute();</span><br><span class="line">        <span class="comment">// 读取第一个子任务的结果，如果尚未完成就等待</span></span><br><span class="line">        Long leftResult = leftTask.join();</span><br><span class="line">        <span class="comment">// 该任务的结果是两个子任务结果的组合</span></span><br><span class="line">        <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">computeSequentially</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>).toArray();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line">        Long sum = <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Java8-parallelStream"><a href="#Java8-parallelStream" class="headerlink" title="Java8-parallelStream"></a>Java8-parallelStream</h2><p>Java8做这种求和的操作很简洁，一行代码就可以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">0</span>, <span class="number">100000000</span>).parallel().sum()</span><br></pre></td></tr></table></figure>
<p>之前在网上了解到说Java 8 并行流采用共享线程池，对性能造成了严重影响。可以包装流来调用自己的线程池解决性能问题。</p>
<p>如果要使用线程池，可采用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">3</span>);  </span><br><span class="line">forkJoinPool.submit(() -&gt; &#123;  </span><br><span class="line">    firstRange.parallelStream().forEach((number) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">ForkJoinPool forkJoinPool2 = <span class="keyword">new</span> ForkJoinPool(<span class="number">3</span>);  </span><br><span class="line">forkJoinPool2.submit(() -&gt; &#123;  </span><br><span class="line">    secondRange.parallelStream().forEach((number) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>在介绍<strong>CompletableFuture</strong>之前，必须要说一下<strong>Future</strong>接口，<strong>Future</strong>接口在Java5中被引入，它建模了一种**<em>异步计算**</em>，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。这样就不需要等到方法结果，调用线程可以接着去做其他事情，这样就完成了异步调用，方法结果只能通过get()方法获取，get()方法是阻塞的，会阻塞直到异步方法运行完成返回结果。打个比方，把衣服放进洗衣机清洗，这个时候我们可以去做点别的事情，等到洗衣机清洗完成后，我们才会去取干净的衣服。下面展示一个简单的示例，只需要将操作封装到<strong>Callable</strong>接口中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallImpl</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> String input;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CallImpl</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.input = input;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;<span class="comment">//延迟一点点</span></span><br><span class="line">				Random random = <span class="keyword">new</span> Random();</span><br><span class="line">				Thread.sleep((random.nextInt() + <span class="keyword">this</span>.input.hashCode()) &amp; <span class="number">10000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;输入参数:&quot;</span> + input;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">		List&lt;Future&lt;String&gt;&gt; list = Arrays.asList(</span><br><span class="line">			executorService.submit(<span class="keyword">new</span> CallImpl(<span class="string">&quot;t1&quot;</span>)) , </span><br><span class="line">			executorService.submit(<span class="keyword">new</span> CallImpl(<span class="string">&quot;t2&quot;</span>)) ,</span><br><span class="line">			executorService.submit(<span class="keyword">new</span> CallImpl(<span class="string">&quot;t3&quot;</span>))</span><br><span class="line">		);</span><br><span class="line">		<span class="comment">/*List&lt;Future&lt;String&gt;&gt; list = executorService.invokeAll(Arrays.asList(</span></span><br><span class="line"><span class="comment">			new CallImpl(&quot;t1&quot;),</span></span><br><span class="line"><span class="comment">			new CallImpl(&quot;t2&quot;),</span></span><br><span class="line"><span class="comment">			new CallImpl(&quot;t3&quot;)</span></span><br><span class="line"><span class="comment">		));*/</span></span><br><span class="line">		<span class="keyword">for</span>(Future&lt;String&gt; future : list) &#123;</span><br><span class="line">			String result = future.get();<span class="comment">//如果没返回，会阻塞</span></span><br><span class="line">			System.out.println(result + <span class="string">&quot;\t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">		&#125;</span><br><span class="line">		executorService.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Future接口的局限性"><a href="#Future接口的局限性" class="headerlink" title="Future接口的局限性"></a>Future接口的局限性</h3><p>Future提供了isDone()方法检测异步计算是否已经结束，get()方法等待异步操作结束，以及获取计算的结果。但是这些操作依然很难实现：<strong>等到所有Future任务完成，通知线程获取结果并合并</strong>。下面就一起来看看JDK8中新引入的<strong>CompletableFuture</strong>。</p>
<h3 id="使用CompletableFuture构建异步应用"><a href="#使用CompletableFuture构建异步应用" class="headerlink" title="使用CompletableFuture构建异步应用"></a>使用CompletableFuture构建异步应用</h3><p><strong>CompletableFuture</strong>实现了<strong>Future</strong>接口，它的<strong>complete()**方法就相当于结束</strong>CompletableFuture**对象的执行，并设置变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/04/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> price =  calculatePrice(product);</span><br><span class="line">        Discount.Code code = Discount.Code.values()[random.nextInt(Discount.Code.values().length)];</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%.2f:%s&quot;</span>, name, price, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync1</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建CompletableFuture对象，它会包含计算的结果</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在另一个线程中以异步方式执行计算</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">                <span class="comment">//  需长时间计算的任务结束并得出结果时，设置Future的返回值</span></span><br><span class="line">                futurePrice.complete(price);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//异常处理</span></span><br><span class="line">                futurePrice.completeExceptionally(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无需等待还没结束的计算，直接返回Future对象</span></span><br><span class="line">        <span class="keyword">return</span> futurePrice;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculatePrice</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        randomDelay();</span><br><span class="line">        <span class="keyword">return</span> random.nextDouble() * product.charAt(<span class="number">0</span>) + product.charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> delay = <span class="number">500</span> + random.nextInt(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop(<span class="string">&quot;BestShop&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="comment">// 查询商店，试图去的商品的价格</span></span><br><span class="line">        Future&lt;Double&gt; futurePrice = shop.getPriceAsync(<span class="string">&quot;my favorte product&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> invocationTime = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Invocation returned after &quot;</span> + invocationTime + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行更多任务，比如查询其他商店</span></span><br><span class="line">        <span class="comment">//doSomethingElse();</span></span><br><span class="line">        <span class="comment">// 在计算商品价格的同时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从Future对象中读取价格，如果价格未知，会发生阻塞</span></span><br><span class="line">            <span class="keyword">double</span> price = futurePrice.get();</span><br><span class="line">            System.out.printf(<span class="string">&quot;Price is %.2f%n&quot;</span>, price);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> retrievalTime = ((System.nanoTime() - start) / <span class="number">1_000_000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Price returned after &quot;</span> + retrievalTime + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的例子来自于《Java8实战》，模拟了一个耗时的操作，然后通过<strong>CompletableFuture</strong>包装成异步方法进行调用。注意代码里演示了两种方式，一种自己new一个线程再调用complete方法，还有就是用<strong>CompletableFuture</strong>自身提供的工厂方法，<strong>CompletableFuture.supplyAsync</strong>，它能更容易地完成整个流程，还不用担心实现的细节。</p>
<p>现在看来好像和<strong>Future</strong>方式也没有什么区别，都是包装一下最后通过<strong>get()**方法获取结果，但是</strong>CompletableFuture**配合Java8用起来就非常厉害了，它提供了很多方便的方法，下面进行一个演示。</p>
<p>同样是价格查询，我们现在接到一个需求，就是获取一个商品在不同商店的报价，一般来说用传统的方式就是写一个<code>for</code>循环，遍历商店然后获取价格，要想效率快一点我们也可以用并行流的方式来查询，但是并行流返回的结果是无序的。下面再将异步也引入，我们可以实现有序的并行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPrices_1</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream()</span><br><span class="line">            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getName() + <span class="string">&quot; price is &quot;</span> + shop.getPrice(product), executor)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> priceFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建<strong>CompletableFuture</strong>和调用**join()**方法是两个不同的流是有原因的，如果只在一个流里，那么就没有异步的效果了，下一个Future必须等到上一个完成后才会被创建和执行。上面的代码执行效率并不会比并行流的效率差。</p>
<p>默认情况下，并行流和CompletableFuture默认都是用固定数目的线程，都是取决于<strong>Runtime. getRuntime().availableProcessors()**的返回值。并行流的线程池并不好控制，其本质是内部隐含使用了ForkJoinPool线程池，最大并发数可以通过系统变量设置。所以</strong>CompletableFuture<strong>也就具有了优势，它允许配置自定义的线程池，这也可以为实际应用程序带来性能上的提升（并行流无法提供的API），</strong>CompletableFuture.supplyAsync(Supplier supplier,Executor executor)**提供了重载的方法来指定执行器使用自定义的线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池，线程池中线程的数目为100和商店数目二者中较小的一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        <span class="comment">// 使用守护线程---这种方式不会阻止程序关掉</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="并行–使用流还是CompletableFutures？"><a href="#并行–使用流还是CompletableFutures？" class="headerlink" title="并行–使用流还是CompletableFutures？"></a>并行–使用流还是CompletableFutures？</h3><p>现在我们知道对集合进行并行计算有两种方式：</p>
<ol>
<li>转化为并行流，利用map开展工作。</li>
<li>取出每一个元素，创建线程，在<strong>CompletableFuture</strong>内对其进行操作</li>
</ol>
<p>后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助我们确保整体的计算不会因为线程都在等待I/O而发生阻塞。</p>
<p>那么如何选择呢，建议如下：</p>
<ul>
<li>进行计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程）。</li>
<li>如果并行操作设计等到I/O的操作（网络连接，请求等），那么使用<strong>CompletableFuture</strong>灵活性更好，通过控制线程数量来优化程序的运行。</li>
</ul>
<p>CompletableFuture还提供了了一些非常有用的操作例如，thenApply(),thenCompose(),thenCombine()等</p>
<ul>
<li>thenApply()是操作完成后将结果传入进行转换</li>
<li>thenCompose()是对两个异步操作进行串联，第一个操作完成时，对第一个<strong>CompletableFuture</strong>对象调用thenCompose，并向其传递一个函数。当第一个<strong>CompletableFuture</strong>执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一个<strong>CompletableFuture</strong>的返回做输入计算出第二个<strong>CompletableFuture</strong>对象。</li>
<li>thenCombine()会异步执行两个<strong>CompletableFuture</strong>任务，然后等待它们计算出结果后再进行计算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream()</span><br><span class="line">            <span class="comment">// 以异步方式取得每个shop中指定产品的原始价格</span></span><br><span class="line">            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor))</span><br><span class="line">            <span class="comment">// Quote对象存在时，对其返回值进行转换</span></span><br><span class="line">            .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">            <span class="comment">// 使用另一个异步任务构造期望的Future，申请折扣</span></span><br><span class="line">            .map(future -&gt; future.thenCompose(quote -&gt; CompletableFuture.supplyAsync(() -&gt; Discount.applyDiscount(quote), executor)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> priceFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常而言，名称中不带Async的方法和它的前一个任务一样，在同一个线程中运行；而名称以Async结尾的方法会将后续的任务提交到一个线程池，所以每个任务都是由不同线程处理的，例如thenApplyAsync()，thenComposeAsync()等。</p>
<p>最后看一段利用**thenAccept()**来使用异步计算结果的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里演示获取最先返回的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) &#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream().map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor))</span><br><span class="line">            .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">            .map(future -&gt; future.thenCompose(quote -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; Discount.applyDiscount(quote), executor)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"><span class="comment">//        System.out.println(findPrices(&quot;myPhone27S&quot;));</span></span><br><span class="line">    CompletableFuture[] futures = findPricesStream(<span class="string">&quot;myPhone27S&quot;</span>)</span><br><span class="line">            .map(f -&gt; f.thenAccept(s -&gt; System.out.println(s + <span class="string">&quot; (done in &quot;</span> +</span><br><span class="line">                    ((System.nanoTime() - start) / <span class="number">1_000_000</span>) + <span class="string">&quot; msecs)&quot;</span>)))</span><br><span class="line">            .toArray(CompletableFuture[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//        CompletableFuture.allOf(futures).join();</span></span><br><span class="line">    CompletableFuture.anyOf(futures).join();</span><br><span class="line">    <span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Done in &quot;</span> + duration + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就几乎无需等待<strong>findPricesStream</strong>的调用，实现了一个真正的异步方法。</p>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8-Stream流底层原理和实现[转]</title>
    <url>/2017/04/08/java/jdk8-9/</url>
    <content><![CDATA[<p>这篇文章发现别人写的好货，直接转过来看看。<br><a href="http://www.cnblogs.com/CarpenterLee/archive/2017/03/28/6637118.html">http://www.cnblogs.com/CarpenterLee/archive/2017/03/28/6637118.html</a></p>
<h1 id="Stream-Pipelines"><a href="#Stream-Pipelines" class="headerlink" title="Stream Pipelines"></a>Stream Pipelines</h1><p>前面我们已经学会如何使用Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？比如Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。</p>
<p>首先回顾一下容器执行Lambda表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList.forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);<span class="comment">// 回调方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个<em>for</em>循环，在该<em>for</em>循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。</p>
<p>Stream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">        = strings.stream()</span><br><span class="line">              .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">              .mapToInt(String::length)</span><br><span class="line">              .max();</span><br></pre></td></tr></table></figure>

<p>上述代码求出以字母<em>A</em>开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（<em>Pipeline</em>）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。</p>
<table width="600"><tr><td colspan="3" align="center"  border="0">Stream操作分类</td></tr><tr><td rowspan="2"  border="1">中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip() </td></tr><tr><td rowspan="2"  border="1">结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></table>

<p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(<em>Stateless</em>)和有状态的(<em>Stateful</em>)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如<em>找到第一个满足条件的元素</em>。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>
<h2 id="一种直白的实现方式"><a href="#一种直白的实现方式" class="headerlink" title="一种直白的实现方式"></a>一种直白的实现方式</h2><img src="https://raw.githubusercontent.com/CarpenterLee/JavaLambdaInternals/master/Figures/Stream_pipeline_naive.png"  width="500px" align="right" alt="Stream_pipeline_naive"/>

<p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以<em>A</em>开头的字符串并放到一个列表list1中，之后让list1传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到list2中，最后遍历list2找出最大的数字作为最终结果。程序的执行流程如如所示：</p>
<p>这样做实现起来非常简单直观，但有两个明显的弊端：</p>
<ol>
<li>迭代次数多。迭代次数跟函数调用的次数相等。</li>
<li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li>
</ol>
<p>这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;A&quot;</span>))&#123;<span class="comment">// 1. filter(), 保留以A开头的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length();<span class="comment">// 2. mapToInt(), 转换成长度</span></span><br><span class="line">        longest = Math.max(len, longest);<span class="comment">// 3. max(), 保留最长的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p>
<h2 id="Stream流水线解决方案"><a href="#Stream流水线解决方案" class="headerlink" title="Stream流水线解决方案"></a>Stream流水线解决方案</h2><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p>
<ol>
<li>用户的操作如何记录？</li>
<li>操作如何叠加？</li>
<li>叠加之后的操作如何执行？</li>
<li>执行后的结果（如果有）在哪里？</li>
</ol>
<h3 id="gt-gt-操作如何记录"><a href="#gt-gt-操作如何记录" class="headerlink" title="&gt;&gt; 操作如何记录"></a>&gt;&gt; 操作如何记录</h3><img src="https://raw.githubusercontent.com/CarpenterLee/JavaLambdaInternals/master/Figures/Java_stream_pipeline_classes.png"  width="400px" align="right" hspace="10px" alt="Java_stream_pipeline_classes"/>

<p>注意这里使用的是“<em>操作(operation)<em>”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;*数据来源，操作，回调函数*&gt;构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的</em>PipelineHelper</em>来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。</p>
<p>还有<em>IntPipeline, LongPipeline, DoublePipeline</em>没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟<em>ReferencePipeline</em>是并列关系。图中<em>Head</em>用于表示第一个Stage，即调用调用诸如<em>Collection.stream()<em>方法产生的Stage，很显然这个Stage里不包含任何操作；</em>StatelessOp</em>和<em>StatefulOp</em>分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。</p>
<p>Stream流水线组织结构示意图如下：</p>
<img src="https://raw.githubusercontent.com/CarpenterLee/JavaLambdaInternals/master/Figures/Stream_pipeline_example.png"  width="700px" alt="Stream_pipeline_example"/>

<p>图中通过<code>Collection.stream()</code>方法得到<em>Head</em>也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。<strong>这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作</strong>。这就是Stream记录操作的方式。</p>
<h3 id="gt-gt-操作如何叠加"><a href="#gt-gt-操作如何叠加" class="headerlink" title="&gt;&gt; 操作如何叠加"></a>&gt;&gt; 操作如何叠加</h3><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。</p>
<p>这种协议由<em>Sink</em>接口完成，<em>Sink</em>接口包含的方法如下表所示：</p>
<table width="600px"><tr><td align="center">方法名</td><td align="center">作用</td></tr><tr><td>void begin(long size)</td><td>开始遍历元素之前调用该方法，通知Sink做好准备。</td></tr><tr><td>void end()</td><td>所有元素遍历完成之后调用，通知Sink没有更多的元素了。</td></tr><tr><td>boolean cancellationRequested()</td><td>是否可以结束操作，可以让短路操作尽早结束。</td></tr><tr><td>void accept(T t)</td><td>遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。</td></tr></table>

<p>有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个乘放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回<em>true</em>，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。<strong>实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法</strong>。</p>
<p>有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的Sink.accept()方法流程是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">    <span class="number">1.</span> 使用当前Sink包装的回调函数处理u</span><br><span class="line">    <span class="number">2.</span> 将处理结果传递给流水线下游的Sink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看Stream.map()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    R r = mapper.apply(u);<span class="comment">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class="line">                    downstream.accept(r);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<em>mapper</em>包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。</p>
<p>再来看一个复杂一点的例子。Stream.sorted()方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成Sink的呢？sorted()一种可能封装的Sink代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream.sort()方法用到的Sink实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;<span class="comment">// 存放用于排序的元素</span></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(downstream, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建一个存放排序元素的列表</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> ArrayList&lt;T&gt;((<span class="keyword">int</span>) size) : <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.sort(comparator);<span class="comment">// 只有元素全部接收之后才能开始排序</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;<span class="comment">// 下游Sink不包含短路操作</span></span><br><span class="line">            list.forEach(downstream::accept);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 下游Sink包含短路操作</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;<span class="comment">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);<span class="comment">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);<span class="comment">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码完美的展现了Sink的四个接口方法是如何协同工作的：</p>
<ol>
<li>首先beging()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；</li>
<li>之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li>
<li>最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；</li>
<li>如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。</li>
</ol>
<h3 id="gt-gt-叠加之后的操作如何执行"><a href="#gt-gt-叠加之后的操作如何执行" class="headerlink" title="&gt;&gt; 叠加之后的操作如何执行"></a>&gt;&gt; 叠加之后的操作如何执行</h3><img src="https://raw.githubusercontent.com/CarpenterLee/JavaLambdaInternals/master/Figures/Stream_pipeline_Sink.png"  width="300px" align="right" hspace="10px"  alt="Stream_pipeline_Sink"/>

<p>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</p>
<p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。</p>
<p>我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在<em>PipelineHelper</em>中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.wrapSink()</span></span><br><span class="line"><span class="comment">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class="line"><span class="comment">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class="comment">// 通知开始遍历</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);<span class="comment">// 迭代</span></span><br><span class="line">        wrappedSink.end();<span class="comment">// 通知遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda%20and%20Collections.md#spliterator">参阅</a>），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。</p>
<h3 id="gt-gt-执行后的结果在哪里"><a href="#gt-gt-执行后的结果在哪里" class="headerlink" title="&gt;&gt; 执行后的结果在哪里"></a>&gt;&gt; 执行后的结果在哪里</h3><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(<em>Side-effects</em>)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p>
<blockquote>
<p>特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams%20API(II).md">归约操作</a>更安全和有效的完成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的收集方式</span></span><br><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"><span class="comment">// 正确的收集方式</span></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">             .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure>

<p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。</p>
<table width="350px"><tr><td align="center">返回类型</td><td align="center">对应的结束操作</td></tr><tr><td>boolean</td><td>anyMatch() allMatch() noneMatch()</td></tr><tr><td>Optional</td><td>findFirst() findAny()</td></tr><tr><td>归约结果</td><td>reduce() collect()</td></tr><tr><td>数组</td><td>toArray()</td></tr></table>

<ol>
<li>对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于只返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。</li>
<li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams%20API(II).md#%E6%94%B6%E9%9B%86%E5%99%A8">收集器</a>指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams%20API(II).md#%E5%A4%9A%E9%9D%A2%E6%89%8Breduce">reduce()</a>方法实现的。</li>
<li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做<em>Node</em>的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文详细介绍了Stream流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的Stream代码，同时打消你对Stream API效率方面的顾虑。如你所见，Stream API实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。</p>
]]></content>
      <categories>
        <category>jdk8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM11-Java内存模型与线程</title>
    <url>/2016/11/25/jvm/JVM11/</url>
    <content><![CDATA[<p>「内存模型」可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一台平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不存在竞争问题。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的私有工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。（这很好的诠释了volatile关键字的作用和原理）</p>
<a id="more"></a>
<p><img src="http://images2015.cnblogs.com/blog/801753/201510/801753-20151007173838596-1678278825.png"></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是<strong>原子的、不可再分的</strong></p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把变量从主内存复制到工作内存，那就要顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。Java内存模型规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中字节使用一个未被初始化（load或assign的变量），换句话说就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<p>这8种内存访问操作以及上述规则的限定，再加上下面讲的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。</p>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，我们需要正确的理解并使用它。</p>
<p>当一个变量定义为volatile之后，它将具备两种特性：</p>
<p>1.保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。<br>Java里面的运算并非原子操作，导致volatile变量在并发下一样是不安全的，看一段例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/25 上午11:05.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * volatile变量自增预算测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结果每次可能都不一样，因为“race++”在虚拟机内部被分解成了很多指令，不同线程在自增的时候，这个值拿到的可能是过期的数据。</p>
<p>由于volatile变量值能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>下面的场景就很适用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shutdownRequested  = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!shutdownRequested) &#123;</span><br><span class="line">		<span class="comment">// do stuff</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，<strong>而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>。我们通过一个例子来看看为何指令重排序会干扰程序的并发执行。</p>
<blockquote>
<p>指令重排序优化是指为了使得处理内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会再计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map condigOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取信息配置，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWihtConfig();</span><br></pre></td></tr></table></figure>

<p>上面的代码如果有定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized = true;”被提前执行(重排序优化是机器级的优化操作，提前执行是说这句话对应的汇编代码被提前)，这样在线程B中的代码可能就会出错。</p>
<h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>因为double和long是64位数据，内存模型允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32为的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改的值代表了「半个变量」的数值。不过这很罕见，因为目前的商用虚拟机几乎都还是选择把64位数据的读写作为原子操作来对待，所以我们写代码一般也不需要对long和double变量专门声明为volatile。</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。</p>
<ul>
<li>原子性<br>  由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，不过也无须太在意这几乎不会发生的例外情况。）<br>  如果还需要更大范围的原子性保证，Java内存模型还提供了lock和unlock操作，也就是synchronized关键字。</li>
<li>可见性<br>  可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程时操作变量的可见性，而普通变量则不能保证这一点。<br>  synchronized和final关键字也能实现可见性，synchronized的可见性是由「对一个变量执行unlock操作之前，必须先把此变量同步回主内存中」这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。</li>
<li>有序性<br>  Java内存模型的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。<br>  Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么好像有一些操作将会变得很繁琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个「先行发生」的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于B，其实就是说发生在操作B之前，操作A产生的影响能被B观察到，「影响」包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>Java内存模型有有些天然的先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序行保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，这里「后面」是指时间上的先后顺序。</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里「后面」同样是指时间上的先后顺序。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手短检测到线程已经终止执行。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些。下面演示如何用这些规则来判定操作间是否具备顺序性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是很普通的getter/setter方法，假设存在线程A和B，线程A先(时间上的先后)调用了“setValue(1)”，然后线程B调用了同一个对象的“getValue()”，那么线程B的返回值是什么？<br>我们根据规则来分析一下：由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则不适用；由于没有同步块，就没有lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个使用的先行发生规则，所以最后一条传递性也无从谈起。<em>因此可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中的“getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的</em></p>
<p>那如何修复这个问题？至少有两种比较简单的方案：</p>
<ol>
<li>setter/getter都定义成synchronized的，这样可以套用管程锁定规则</li>
<li>value定义为volatile变量，由于setter方法对value的修改不依赖于value的原值，满足volatile关键字的使用场景，这样可以套用volatile变量规则</li>
</ol>
<p>我们也得出一个结论：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
<h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>Java的线程API基本都是Native方法，意味着这个方法没有使用或无法使用平台无关的手段来实现。实现线程有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p>
<ol>
<li><p>使用内核线程实现<br> 内核线程就是直接由操作系统支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。不过程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口–轻量级进程。这种方式系统调用代价较高，并且因为消耗内核资源，所以轻量级进程数量有限。轻量级进程与内核线程之间是1：1的关系。</p>
</li>
<li><p>使用用户线程实现<br> 从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种方式的操作可以是非常快速且低消耗的，劣势在于没有系统内核支持，实现起来非常的复杂。Java和Ruby都曾经使用过用户线程，最终又都放弃使用它。进程与用户线程之间是1：N的关系。</p>
</li>
<li><p>使用用户线程加轻量级进程混合实现<br> 线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进城被完全阻塞的风险。用户线程与轻量级进程之间是N：M的关系。</p>
</li>
<li><p>Java线程的实现<br> 1.2之前是用户线程实现的，1.2开始替换为基于操作系统原生线程模型来实现。因此在目前的JDK版本中，操作系统支持怎样的线程模型，很大程度上决定了Java虚拟机的线程是怎样映射的。对Sun JDK来说，它的Windows版和linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为windows和Linux系统提供的线程模型就是一对一的。</p>
</li>
</ol>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<p>协同式调度，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知切换到另外一个线程上。好处是实现简单，干完自己的事情后进行线程切换，没有什么同步问题，坏处是一旦程序出问题，将会阻塞下去。</p>
<p>抢占式调度的多线程系统，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。这种实现线程调度的方式下，线程的执行时间是系统可控的，不会出现什么阻塞问题。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程有5种状态</p>
<ul>
<li>新建：创建后尚未启动的线程处于这种状态</li>
<li>运行：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为他分配执行时间。</li>
<li>无限期等待：处于这种状态的线程不宜被分配CPU执行时间，她们要等待被其他线程显式的唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ul>
</li>
<li>限期等待：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在已定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li>Thread.sleep()方法。</li>
<li>设置了Timeout参数的Object.wait()方法。</li>
<li>设置了Timeout参数的Thread.join()方法。</li>
<li>LockSupport.parkNanos()方法。</li>
<li>LockSupport.parkUntil()方法</li>
</ul>
</li>
<li>阻塞：线程被阻塞了，「阻塞状态」与「等待状态」的区别是：「阻塞状态」在等待着获取一个到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而「等待状态」则是等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB1-安装和增删改查</title>
    <url>/2017/12/08/mongodb/mongo1/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.mongodb.com/download-center">https://www.mongodb.com/download-center</a></p>
<p>按照传统的方式，可以在这里下载mongo的安装包进行安装。</p>
<h3 id="OSX"><a href="#OSX" class="headerlink" title="OSX"></a>OSX</h3><p>如果是mac系统，并且按照了brew，可以直接执行<code>brew install mongodb</code>进行安装。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>现在用docker快速的搭建软件环境已经非常方便了，所以我在这里将使用docker下载mongo的镜像来部署mongo，方便随后的测试。</p>
<p><a href="https://hub.docker.com/_/mongo/">https://hub.docker.com/_/mongo/</a></p>
<a id="more"></a>

<p>dockerhub提供了官方镜像，我们选择好想要下载的版本，然后映射/data/db到我们本机的目录，<code>--auth</code>表示开启授权验证，mongo默认是不需要密码的，本机测试我们可以先不加这个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name my-mongo -v /Users/xiaomai/software/mongo:/data/db -d -p 27017:27017 -p 28017:28017 mongo:3.6.0 --auth </span><br></pre></td></tr></table></figure>


<p>因为是docker安装的，所以我们不能直接在本机上执行mongo命令来连接。</p>
<p>可以使用下面的命令来连接mongo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-mongo mongo <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>查看mongo的日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f my-mongo</span><br></pre></td></tr></table></figure>

<p>安装完毕。</p>
<h2 id="客户端连接工具"><a href="#客户端连接工具" class="headerlink" title="客户端连接工具"></a>客户端连接工具</h2><p>免费版：</p>
<p><a href="https://robomongo.org/download">https://robomongo.org/download</a></p>
<p>收费版：</p>
<p><a href="https://studio3t.com/download/">https://studio3t.com/download/</a></p>
<p>这是同一个公司开发的，目前是比较推荐这一款工具，非常好用。</p>
<p><img src="/img/mongo/mongo1-1.png"></p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; show dbs;</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; db</span><br><span class="line">test</span><br><span class="line">&gt; show dbs;</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure>

<p>查看数据库列表，切换了数据库，再次查看数据库列表，却发现没有新增的test数据库，这是mongo的特殊所在，现在的test只是一个临时数据库，再没有产生数据的时候，他不会被真正的创建只有当真正的插入数据的时候，数据库随之才会被创建。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.hello.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; show dbs;</span><br><span class="line">admin   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line">local   <span class="number">0.000</span>GB</span><br><span class="line">test    <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询一下刚才插入的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.hello.find(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2a3af1e2beff69d97c54c3&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2a3b3ae2beff69d97c54c4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>刚才插入的数据被查询出来了，mongodb用的就是JavaScript的语法，他们的数据也是用一种叫做bson的数据结构存储的，类似于json。</p>
<h4 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h4><p>这两条数据都有一个<strong>_id</strong>的字段，是mongo自动生成的主键/索引。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除数据的演示，{}里面可以加删除的过滤条件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.hello.remove(&#123;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : <span class="number">2</span> &#125;)</span><br><span class="line">&gt; db.hello.find(&#123;&#125;).limit(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>可以直接使用JS语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; use mytest;</span><br><span class="line">switched to db mytest</span><br><span class="line">&gt; <span class="keyword">var</span> info = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">10</span>, <span class="attr">city</span>: <span class="string">&#x27;chengdu&#x27;</span>, <span class="attr">street</span>: <span class="string">&#x27;gaoxin&#x27;</span>&#125;;</span><br><span class="line">&gt; db.personalinfo.insert(info);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f847dcdf5d844e48cddb7&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span>, <span class="string">&quot;city&quot;</span> : <span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;street&quot;</span> : <span class="string">&quot;gaoxin&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><p>先把数据查出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> info = db.personalinfo.findOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;);</span><br><span class="line">&gt; info</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f847dcdf5d844e48cddb7&quot;</span>),</span><br><span class="line">	<span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span> : <span class="number">10</span>,</span><br><span class="line">	<span class="string">&quot;city&quot;</span> : <span class="string">&quot;chengdu&quot;</span>,</span><br><span class="line">	<span class="string">&quot;street&quot;</span> : <span class="string">&quot;gaoxin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一样的用js语法对数据进行修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; info.address = &#123;<span class="string">&#x27;city&#x27;</span>:info.city, <span class="string">&#x27;street&#x27;</span>:info.street&#125;;</span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;street&quot;</span> : <span class="string">&quot;gaoxin&quot;</span> &#125;</span><br><span class="line">&gt; info.username = info.name;</span><br><span class="line">zhangsan</span><br><span class="line">&gt; info.userage = info.age;</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; <span class="keyword">delete</span> info.name;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">delete</span> info.age;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">delete</span> info.city;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">delete</span> info.street;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>完成修改，update有4个参数，第一个是查询条件，第二个是替换的对象，还有两个参数是可选的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;, info);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f847dcdf5d844e48cddb7&quot;</span>), <span class="string">&quot;address&quot;</span> : &#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;chengdu&quot;</span>, <span class="string">&quot;street&quot;</span> : <span class="string">&quot;gaoxin&quot;</span> &#125;, <span class="string">&quot;username&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;userage&quot;</span> : <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>


<h4 id="修改器演示"><a href="#修改器演示" class="headerlink" title="修改器演示"></a>修改器演示</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.remove(&#123;&#125;);</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">30</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">40</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br><span class="line">&gt; <span class="keyword">var</span> zhangsan = db.personalinfo.findOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;);</span><br><span class="line">&gt; zhangsan.age++;</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt; zhangsan.age</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;, zhangsan);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">11</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>


<p>这里看到第一条记录被修改成了11岁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> zhangsan = db.personalinfo.findOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">40</span>&#125;);</span><br><span class="line">&gt; zhangsan.age++;</span><br><span class="line"><span class="number">40</span></span><br><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;, zhangsan);</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	<span class="string">&quot;nMatched&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;nModified&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;writeError&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span> : <span class="number">66</span>,</span><br><span class="line">		<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;After applying the update, the (immutable) field &#x27;_id&#x27; was found to have been altered to _id: ObjectId(&#x27;5a2f8a32fd5fb3999c47142e&#x27;)&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这次我们查询出40岁的张三，然后再次进行修改，这里得到一个错误，说_id不能被修改，说明update默认是条件过滤到的第一条数据来进行修改。</p>
<h5 id="inc修改器"><a href="#inc修改器" class="headerlink" title="$inc修改器"></a>$inc修改器</h5><p>我们可以用_id字段来进行简便的修改，这里用了$inc修改器，来对数值进行修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$inc</span>: &#123;<span class="attr">age</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<h5 id="set修改器"><a href="#set修改器" class="headerlink" title="$set修改器"></a>$set修改器</h5><p>$set修改可以完成对属性的设定，如果属性不存在则添加，如果存在则修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">address</span>:<span class="string">&#x27;chengdu&#x27;</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span>, <span class="string">&quot;address&quot;</span> : <span class="string">&quot;chengdu&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>

<p>同样的，$unset修改器可以删除一个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$unset</span>: &#123;<span class="attr">address</span>:<span class="string">&#x27;chengdu&#x27;</span>&#125;&#125;);</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="push修改器"><a href="#push修改器" class="headerlink" title="$push修改器"></a>$push修改器</h5><p>$push修改器可以对数组进行操作，增加一个books的属性，是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$push</span>:&#123;<span class="attr">books</span>:<span class="string">&#x27;MongoDB&#x27;</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span>, <span class="string">&quot;books&quot;</span> : [ <span class="string">&quot;MongoDB&quot;</span> ] &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addToSet修改器"><a href="#addToSet修改器" class="headerlink" title="$addToSet修改器"></a>$addToSet修改器</h5><p>跟Java里的Set概念，如果是重复的数据，则不会被添加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;_id:ObjectId(&#39;5a2f8a2afd5fb3999c47142b&#39;)&#125;, &#123;$addToSet:&#123;books:&#39;MongoDB&#39;&#125;&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a2f8a2afd5fb3999c47142b&quot;), &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 12, &quot;books&quot; : [ &quot;MongoDB&quot; ] &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a2f8a2dfd5fb3999c47142c&quot;), &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 20 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a2f8a30fd5fb3999c47142d&quot;), &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 30 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a2f8a32fd5fb3999c47142e&quot;), &quot;name&quot; : &quot;zhangsan&quot;, &quot;age&quot; : 40 &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>我们再次为books属性添加了一个MongoDB的数据，跟我们期望的一样，重复的数据没有被添加。</p>
<h5 id="修改数组某一个值-（索引）"><a href="#修改数组某一个值-（索引）" class="headerlink" title="修改数组某一个值 （索引）"></a>修改数组某一个值 （索引）</h5><p>在需要修改数组中的某一个值的时候，还是可以用<code>$set</code>修改器来进行修改，只需要在key的后面加上一个索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$set</span>:&#123;<span class="string">&#x27;books.0&#x27;</span>:<span class="string">&#x27;Mongo&#x27;</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span>, <span class="string">&quot;books&quot;</span> : [ <span class="string">&quot;Mongo&quot;</span>, <span class="string">&quot;JVM&quot;</span> ] &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<h5 id="修改数组某一个值（根据查询条件）"><a href="#修改数组某一个值（根据查询条件）" class="headerlink" title="修改数组某一个值（根据查询条件）"></a>修改数组某一个值（根据查询条件）</h5><p>先把books改成一个对象的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">&#x27;5a2f8a2afd5fb3999c47142b&#x27;</span>)&#125;, &#123;<span class="attr">$push</span>:&#123;<span class="string">&#x27;books&#x27;</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;Mongo&#x27;</span>, <span class="attr">price</span>:<span class="number">20</span>&#125;&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2afd5fb3999c47142b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">12</span>, <span class="string">&quot;books&quot;</span> : &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Mongo&quot;</span>, <span class="string">&quot;price&quot;</span> : <span class="number">20</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a2dfd5fb3999c47142c&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a30fd5fb3999c47142d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">30</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a2f8a32fd5fb3999c47142e&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure>

<p>现在需要将books里mongo的价格改成30，但是不用索引。mongo为我们提供了一个$表示当前查询到的数据。<br>update的前两个参数&lt;查询条件&gt;和&lt;更新操作&gt;中，如果你在&lt;查询条件&gt;中查询的内容是array里的内容，&lt;更新操作&gt;中就可以使用”$”来引用前查询中匹配到的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.personalinfo.update(&#123;<span class="string">&#x27;books.name&#x27;</span>:<span class="string">&#x27;Mongo&#x27;</span>&#125;, &#123;<span class="attr">$set</span>:&#123;<span class="string">&#x27;books.$.price&#x27;</span>:<span class="number">30</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="update参数详解"><a href="#update参数详解" class="headerlink" title="update参数详解"></a>update参数详解</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">query, obj, upsert, multi</span>) </span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>query表示查询条件</li>
<li>obj表示修改的对象</li>
<li>upsert表示更新或者插入</li>
<li>multi表示批量更新</li>
</ol>
<h5 id="upsert演示"><a href="#upsert演示" class="headerlink" title="upsert演示"></a>upsert演示</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.remove(&#123;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : <span class="number">4</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a3130c1fd5fb3999c47142f&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span> &#125;</span><br><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;, &#123;<span class="attr">$inc</span>: &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a3130c1fd5fb3999c47142f&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;count&quot;</span> : <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<p>直接修改不存在的属性，会新增一个属性。</p>
<p>这里查询了一个<code>lisi</code>的数据，默认情况下是不存在的，但是如果把upsert设置为true之后，就成了有数据就更新，没有就insert一条。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>&#125;, &#123;<span class="attr">$inc</span>: &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">0</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>&#125;, &#123;<span class="attr">$inc</span>: &#123;<span class="attr">count</span>:<span class="number">3</span>&#125;&#125;, <span class="literal">true</span>);</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	<span class="string">&quot;nMatched&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;nUpserted&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;nModified&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a31313f7cb00d3f6c6c4591&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a3130c1fd5fb3999c47142f&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;count&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a31313f7cb00d3f6c6c4591&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;count&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<h5 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h5><p>先准备几条数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;guangzhou&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;shenzhen&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>把第4个参数设置成了true，表示执行批量更新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.update(&#123;<span class="attr">age</span>:<span class="number">10</span>&#125;, &#123;<span class="attr">$set</span>:&#123;<span class="attr">company</span>:<span class="string">&#x27;sap&#x27;</span>&#125;&#125;, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">3</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">3</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a48c6c9f0ec47e9f5ce2dac&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span>, <span class="string">&quot;address&quot;</span> : <span class="string">&quot;beijing&quot;</span>, <span class="string">&quot;company&quot;</span> : <span class="string">&quot;sap&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a48c6c9f0ec47e9f5ce2dad&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span>, <span class="string">&quot;address&quot;</span> : <span class="string">&quot;guangzhou&quot;</span>, <span class="string">&quot;company&quot;</span> : <span class="string">&quot;sap&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a48c6c9f0ec47e9f5ce2dae&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span>, <span class="string">&quot;address&quot;</span> : <span class="string">&quot;shanghai&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a48c6caf0ec47e9f5ce2daf&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span>, <span class="string">&quot;address&quot;</span> : <span class="string">&quot;shenzhen&quot;</span>, <span class="string">&quot;company&quot;</span> : <span class="string">&quot;sap&quot;</span> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>mongo提供了一个save操作，它的行为取决于你是否传入了_id参数，如果你没有传，会先造一个，如果你传了_id，则会进行修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;_id&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">0</span>, <span class="string">&quot;_id&quot;</span> : <span class="number">5</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.save(&#123;<span class="string">&#x27;_id&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.personalinfo.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">5</span>, <span class="string">&quot;username&quot;</span> : <span class="string">&quot;lisi&quot;</span> &#125;</span><br><span class="line">&gt; db.personalinfo.insert(&#123;<span class="string">&#x27;_id&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span>&#125;)</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	<span class="string">&quot;nInserted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;writeError&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span> : <span class="number">11000</span>,</span><br><span class="line">		<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;E11000 duplicate key error collection: mytest.personalinfo index: _id_ dup key: &#123; : 5.0 &#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="findAndModify"><a href="#findAndModify" class="headerlink" title="findAndModify"></a>findAndModify</h3><p>它是一种原子操作，正常情况下，查询并修改是两步操作，但是mongo为我们提供的这个函数，是原子性的，不会在多线程情况下出现并发问题。</p>
<blockquote>
<p>Modifies and returns a single document. By default, the returned document does not include the modifications made on the update. To return the document with the modifications made on the update, use the new option. </p>
</blockquote>
<p>修改并返回一个文档，默认是返回修改之前的文档，如果要返回修改之后的，设置<code>new</code>这个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.collection.findAndModify(&#123;</span><br><span class="line">    query: <span class="xml"><span class="tag">&lt;<span class="name">document</span>&gt;</span>,</span></span><br><span class="line">    sort: &lt;document&gt;,</span><br><span class="line">    remove: &lt;boolean&gt;,</span><br><span class="line">    update: &lt;document&gt;,</span><br><span class="line">    new: &lt;boolean&gt;,</span><br><span class="line">    fields: &lt;document&gt;,</span><br><span class="line">    upsert: &lt;boolean&gt;,</span><br><span class="line">    bypassDocumentValidation: &lt;boolean&gt;,</span><br><span class="line">    writeConcern: &lt;document&gt;,</span><br><span class="line">    collation: &lt;document&gt;,</span><br><span class="line">    arrayFilters: [ &lt;filterdocument1&gt;, ... ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>重要参数解释：</p>
<ul>
<li>query：查询参数</li>
<li>sort：排序的方式</li>
<li>remove：remove和update只能设置一个，删除查询条件筛选的内容</li>
<li>update：remove和update只能设置一个，修改查询条件筛选的内容</li>
<li>new：返回修改之后的文档</li>
<li>fields：表示返回的数据需要的字段</li>
</ul>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>数据准备：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.personalinfo.remove(&#123;&#125;);</span><br><span class="line">db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>&#125;)</span><br><span class="line">db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;guangzhou&#x27;</span>&#125;)</span><br><span class="line">db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;)</span><br><span class="line">db.personalinfo.save(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;shenzhen&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>传入必要的参数，对数据进行修改，返回了修改成功的那一条数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.personalinfo.findAndModify(&#123;</span><br><span class="line">...     query: &#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;,</span><br><span class="line">...     sort: &#123;<span class="attr">age</span>:<span class="number">-1</span>&#125;,</span><br><span class="line">...     remove: <span class="literal">false</span>,</span><br><span class="line">...     update:&#123;<span class="attr">$set</span>:&#123;<span class="attr">address</span>:<span class="string">&#x27;nanjing&#x27;</span>&#125;&#125;,</span><br><span class="line">...     new:<span class="literal">true</span></span><br><span class="line">... &#125;);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a48d102f0ec47e9f5ce2db0&quot;</span>),</span><br><span class="line">	<span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span> : <span class="number">10</span>,</span><br><span class="line">	<span class="string">&quot;address&quot;</span> : <span class="string">&quot;nanjing&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB3-三种聚合操作详解</title>
    <url>/2018/01/01/mongodb/mongo3/</url>
    <content><![CDATA[<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>聚合通常在mysql中是group by，例如统计sum等操作，MongoDB也为我们提供了聚合操作，但是实现却不一样。</p>
<h2 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h2><p>这次需要的数据会比较多，这次直接用js来准数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">30</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = i % <span class="number">5</span>;</span><br><span class="line">    db.mygroup.insert(&#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> + i, <span class="attr">count</span> : count&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>mongo3.4开始，这个方法已经被官方弃用了，用<a href="#%E8%81%9A%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88aggregation-framework%EF%BC%89">db.collection.aggregate()</a>替代了，不过这里的例子仍然以db.collection.group()进行讲解。</p>
<h3 id="实例-计数"><a href="#实例-计数" class="headerlink" title="实例-计数"></a>实例-计数</h3><p>我们需要按照count字段进行分组然后统计每个分组的数量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.mygroup.group(&#123;<span class="attr">key</span>: &#123;<span class="attr">count</span>:<span class="literal">true</span>&#125;, <span class="attr">initial</span>: &#123;<span class="attr">totalCount</span>:<span class="number">0</span>&#125;, <span class="attr">reduce</span>: <span class="function"><span class="keyword">function</span>(<span class="params">current, aggregator</span>)</span>&#123;</span><br><span class="line">...         aggregator.totalCount++;</span><br><span class="line">...     &#125;&#125;);</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>key： 需要分组的字段</li>
<li>initial：每一组初始化的值</li>
<li>reduce：计算</li>
<li>keyf：二次计算然后产生的key值</li>
<li>cond：查询条件</li>
<li>finalize：完成器，在返回之前对结果进行计算</li>
</ul>
<p>reduce的两个参数，就是分组后对数据的处理，current表示每次循环的当前对象，aggregator则每一组拥有一个共享对象，所以在这个例子里aggregator的totalCount每一组开始循环的时候都是0，最终统计出来每一组的总数。</p>
<p>关于这些的详细介绍，官网文档也给了非常好的介绍：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.group/index.html">https://docs.mongodb.com/manual/reference/method/db.collection.group/index.html</a></p>
<p><img src="/img/mongo/mongo3-1.png"></p>
<h3 id="实例-最大值"><a href="#实例-最大值" class="headerlink" title="实例-最大值"></a>实例-最大值</h3><p>重新准备数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.mygroup.drop()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">30</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = i % <span class="number">5</span>;</span><br><span class="line">    db.mygroup.insert(&#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> + i, <span class="attr">age</span>:i, <span class="attr">count</span> : count&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以count作为分组，取出每一组里age最大值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.mygroup.group(&#123;<span class="attr">key</span>: &#123;<span class="attr">count</span>:<span class="literal">true</span>&#125;, <span class="attr">initial</span>: &#123;<span class="attr">maxAge</span>:<span class="number">-1</span>&#125;, <span class="attr">reduce</span>: <span class="function"><span class="keyword">function</span>(<span class="params">current, aggregator</span>)</span>&#123;</span><br><span class="line">...         if(current.age &gt; aggregator.maxAge) &#123;</span><br><span class="line">...             aggregator.maxAge = current.age</span><br><span class="line">...         &#125;</span><br><span class="line">...     &#125;&#125;);</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;maxAge&quot;</span> : <span class="number">26</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;maxAge&quot;</span> : <span class="number">27</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;maxAge&quot;</span> : <span class="number">28</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">		<span class="string">&quot;maxAge&quot;</span> : <span class="number">29</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;maxAge&quot;</span> : <span class="number">25</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h3 id="实例-找最小值"><a href="#实例-找最小值" class="headerlink" title="实例-找最小值"></a>实例-找最小值</h3><p>找出年龄最小值，这里优化一下效率</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.mygroup.group(&#123;<span class="attr">key</span>: &#123;<span class="attr">count</span>:<span class="literal">true</span>&#125;, <span class="attr">initial</span>: &#123;<span class="attr">minAge</span>:<span class="number">0</span>, <span class="attr">count</span>:<span class="number">0</span>&#125;, <span class="attr">reduce</span>: <span class="function"><span class="keyword">function</span>(<span class="params">current, aggregator</span>)</span>&#123;</span><br><span class="line">...         if(aggregator.count == <span class="number">0</span>) &#123;</span><br><span class="line">...             aggregator.minAge = current.age;</span><br><span class="line">...             aggregator.count++;</span><br><span class="line">...         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.age &lt; aggregator.minAge) &#123;</span><br><span class="line">...             aggregator.minAge = current.age</span><br><span class="line">...             aggregator.count++;</span><br><span class="line">...         &#125;</span><br><span class="line">...     &#125;&#125;);</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">2</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">3</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">4</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="实例4-平均值"><a href="#实例4-平均值" class="headerlink" title="实例4-平均值"></a>实例4-平均值</h3><p>这个例子需要使用finalize完成器来做，先用reduce来完成计数和求和的操作，然后用finalize完成器来求平均值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; db.mygroup.group(&#123;<span class="attr">key</span>: &#123;<span class="attr">count</span>:<span class="literal">true</span>&#125;, <span class="attr">initial</span>: &#123;<span class="attr">minAge</span>:<span class="number">0</span>, <span class="attr">count</span>:<span class="number">0</span>, <span class="attr">totalAge</span>:<span class="number">0</span>,<span class="attr">totalCount</span>:<span class="number">0</span>&#125;, <span class="attr">reduce</span>: <span class="function"><span class="keyword">function</span>(<span class="params">current, aggregator</span>)</span>&#123;</span><br><span class="line">...         if(aggregator.count == <span class="number">0</span>) &#123;</span><br><span class="line">...             aggregator.minAge = current.age;</span><br><span class="line">...             aggregator.count++</span><br><span class="line">...         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.age &lt; aggregator.minAge) &#123;</span><br><span class="line">...             aggregator.minAge = current.age</span><br><span class="line">...             aggregator.count++</span><br><span class="line">...         &#125;</span><br><span class="line">...         aggregator.totalCount++;</span><br><span class="line">...         aggregator.totalAge += current.age;</span><br><span class="line">...     &#125;, <span class="attr">finalize</span>: <span class="function"><span class="keyword">function</span>(<span class="params">aggregator</span>) </span>&#123;</span><br><span class="line">...         aggregator.avgAge = aggregator.totalAge / aggregator.totalCount;</span><br><span class="line">...     &#125;&#125;);</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;totalAge&quot;</span> : <span class="number">81</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span>,</span><br><span class="line">		<span class="string">&quot;avgAge&quot;</span> : <span class="number">13.5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;totalAge&quot;</span> : <span class="number">87</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span>,</span><br><span class="line">		<span class="string">&quot;avgAge&quot;</span> : <span class="number">14.5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;totalAge&quot;</span> : <span class="number">93</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span>,</span><br><span class="line">		<span class="string">&quot;avgAge&quot;</span> : <span class="number">15.5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">4</span>,</span><br><span class="line">		<span class="string">&quot;totalAge&quot;</span> : <span class="number">99</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">6</span>,</span><br><span class="line">		<span class="string">&quot;avgAge&quot;</span> : <span class="number">16.5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;minAge&quot;</span> : <span class="number">5</span>,</span><br><span class="line">		<span class="string">&quot;totalAge&quot;</span> : <span class="number">75</span>,</span><br><span class="line">		<span class="string">&quot;totalCount&quot;</span> : <span class="number">5</span>,</span><br><span class="line">		<span class="string">&quot;avgAge&quot;</span> : <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h2 id="mapReduce"><a href="#mapReduce" class="headerlink" title="mapReduce"></a>mapReduce</h2><p>mapReduce主要分为两个阶段，mapReduce在mongodb中可以在分片的环境中运行，而group则不行。</p>
<ul>
<li>map阶段<br>  处理数据，例如分组，转换等</li>
<li>reduce阶段<br>  根据map的输出计算数据，得到想要的结果</li>
</ul>
<p><a href="https://docs.mongodb.com/manual/reference/command/mapReduce/index.html">https://docs.mongodb.com/manual/reference/command/mapReduce/index.html</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.runCommand(</span><br><span class="line">               &#123;</span><br><span class="line">                 mapReduce: <span class="xml"><span class="tag">&lt;<span class="name">collection</span>&gt;</span>,</span></span><br><span class="line">                 map: &lt;function&gt;,</span><br><span class="line">                 reduce: &lt;function&gt;,</span><br><span class="line">                 finalize: &lt;function&gt;,</span><br><span class="line">                 out: &lt;output&gt;,</span><br><span class="line">                 query: &lt;document&gt;,</span><br><span class="line">                 sort: &lt;document&gt;,</span><br><span class="line">                 limit: &lt;number&gt;,</span><br><span class="line">                 scope: &lt;document&gt;,</span><br><span class="line">                 jsMode: &lt;boolean&gt;,</span><br><span class="line">                 verbose: &lt;boolean&gt;,</span><br><span class="line">                 bypassDocumentValidation: &lt;boolean&gt;,</span><br><span class="line">                 collation: &lt;document&gt;</span><br><span class="line">               &#125;</span><br><span class="line">             )</span><br></pre></td></tr></table></figure>

<p><img src="https://docs.mongodb.com/manual/_images/map-reduce.bakedsvg.svg"></p>
<blockquote>
<p>For those keys that have multiple values, MongoDB applies the reduce phase, which collects and condenses the aggregated data. </p>
</blockquote>
<p>map的结果只有一个值的话，是不会运行reduce的。</p>
<h3 id="实例1-求长度"><a href="#实例1-求长度" class="headerlink" title="实例1-求长度"></a>实例1-求长度</h3><p>数据准备：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = i % <span class="number">3</span>;</span><br><span class="line">    db.student.insert(&#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> + i, <span class="attr">age</span>:i, <span class="attr">count</span> : count&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在用MapReduce来统计每一组数据长度。</p>
<p>map必须调用emit函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.getCollection(<span class="string">&#x27;student&#x27;</span>).mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;emit(<span class="built_in">this</span>.count, <span class="number">1</span>)&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;<span class="keyword">return</span> values.length;&#125;, &#123;<span class="attr">out</span>:<span class="string">&quot;length&quot;</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;result&quot;</span> : <span class="string">&quot;length&quot;</span>,</span><br><span class="line">	<span class="string">&quot;timeMillis&quot;</span> : <span class="number">58</span>,</span><br><span class="line">	<span class="string">&quot;counts&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;input&quot;</span> : <span class="number">9</span>,</span><br><span class="line">		<span class="string">&quot;emit&quot;</span> : <span class="number">9</span>,</span><br><span class="line">		<span class="string">&quot;reduce&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;output&quot;</span> : <span class="number">3</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意out指定的是一个collection，MapReduce会把结果生产到当前db的out属性指定的集合里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.length.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例2-求和"><a href="#实例2-求和" class="headerlink" title="实例2-求和"></a>实例2-求和</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.getCollection(<span class="string">&#x27;student&#x27;</span>).mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;emit(<span class="built_in">this</span>.count, <span class="built_in">this</span>.age)&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;<span class="keyword">var</span> totalAge = <span class="number">0</span>; <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; values.length; i++)&#123;totalAge += values[i]&#125; <span class="keyword">return</span> totalAge;&#125;, &#123;<span class="attr">out</span>:<span class="string">&quot;totalAge&quot;</span>&#125;);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;result&quot;</span> : <span class="string">&quot;totalAge&quot;</span>,</span><br><span class="line">	<span class="string">&quot;timeMillis&quot;</span> : <span class="number">53</span>,</span><br><span class="line">	<span class="string">&quot;counts&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;input&quot;</span> : <span class="number">9</span>,</span><br><span class="line">		<span class="string">&quot;emit&quot;</span> : <span class="number">9</span>,</span><br><span class="line">		<span class="string">&quot;reduce&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;output&quot;</span> : <span class="number">3</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.totalAge.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>, <span class="string">&quot;value&quot;</span> : <span class="number">18</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;value&quot;</span> : <span class="number">12</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;value&quot;</span> : <span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例3-求最大值"><a href="#实例3-求最大值" class="headerlink" title="实例3-求最大值"></a>实例3-求最大值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxFun = <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxAge = <span class="number">0</span>; </span><br><span class="line">    values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">current</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(current&gt;maxAge)&#123;</span><br><span class="line">           maxAge = current;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> maxAge;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">db.getCollection(<span class="string">&#x27;student&#x27;</span>).mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;emit(<span class="built_in">this</span>.count, <span class="built_in">this</span>.age)&#125;, maxFun, &#123;<span class="attr">out</span>:<span class="string">&quot;maxAge&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">&gt; db.getCollection(<span class="string">&#x27;maxAge&#x27;</span>).find(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>, <span class="string">&quot;value&quot;</span> : <span class="number">9</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;value&quot;</span> : <span class="number">7</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;value&quot;</span> : <span class="number">8</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h3 id="实例4-求平均数"><a href="#实例4-求平均数" class="headerlink" title="实例4-求平均数"></a>实例4-求平均数</h3><p>求平均数也很简单，就是把和除以长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> avgFun = <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;<span class="keyword">var</span> totalAge = <span class="number">0</span>; <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; values.length; i++)&#123;totalAge += values[i]&#125; <span class="keyword">return</span> totalAge / values.length;&#125;;</span><br><span class="line">&gt; db.getCollection(<span class="string">&#x27;student&#x27;</span>).mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;emit(<span class="built_in">this</span>.count, <span class="built_in">this</span>.age)&#125;, avgFun, &#123;<span class="attr">out</span>:<span class="string">&quot;avgAge&quot;</span>&#125;);</span><br><span class="line">&gt; db.avgAge.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>, <span class="string">&quot;value&quot;</span> : <span class="number">6</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;value&quot;</span> : <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例5-标签统计"><a href="#实例5-标签统计" class="headerlink" title="实例5-标签统计"></a>实例5-标签统计</h3><p>数据准备：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.getCollection(<span class="string">&#x27;article&#x27;</span>).insert(&#123;<span class="attr">name</span>:<span class="string">&quot;article1&quot;</span>, <span class="attr">tags</span>:[<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;mongodb&#x27;</span>,<span class="string">&#x27;ruby&#x27;</span>]&#125;);</span><br><span class="line">db.getCollection(<span class="string">&#x27;article&#x27;</span>).insert(&#123;<span class="attr">name</span>:<span class="string">&quot;article2&quot;</span>, <span class="attr">tags</span>:[<span class="string">&#x27;perl&#x27;</span>,<span class="string">&#x27;scala&#x27;</span>,<span class="string">&#x27;mongodb&#x27;</span>,<span class="string">&#x27;ruby&#x27;</span>]&#125;);</span><br><span class="line">db.getCollection(<span class="string">&#x27;article&#x27;</span>).insert(&#123;<span class="attr">name</span>:<span class="string">&quot;article3&quot;</span>, <span class="attr">tags</span>:[<span class="string">&#x27;perl&#x27;</span>,<span class="string">&#x27;kotlin&#x27;</span>,<span class="string">&#x27;mongodb&#x27;</span>,<span class="string">&#x27;ruby&#x27;</span>]&#125;);</span><br><span class="line">db.getCollection(<span class="string">&#x27;article&#x27;</span>).insert(&#123;<span class="attr">name</span>:<span class="string">&quot;article4&quot;</span>, <span class="attr">tags</span>:[<span class="string">&#x27;perl&#x27;</span>,<span class="string">&#x27;kotlin&#x27;</span>,<span class="string">&#x27;mongodb&#x27;</span>,<span class="string">&#x27;groovy&#x27;</span>]&#125;);</span><br><span class="line">db.getCollection(<span class="string">&#x27;article&#x27;</span>).insert(&#123;<span class="attr">name</span>:<span class="string">&quot;article5&quot;</span>, <span class="attr">tags</span>:[<span class="string">&#x27;perl&#x27;</span>,<span class="string">&#x27;kotlin&#x27;</span>,<span class="string">&#x27;redis&#x27;</span>,<span class="string">&#x27;groovy&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure>

<p>每个文章都有标签，现在要统计每一个标签出现的次数。</p>
<p>有思路吗？这个用mongodb来做实在是太方便了，如果是传统的sql，可能还要好好想想，我们在map的时候，就用每一个tag分组，得到我们要的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.article.mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currrnt</span>)</span>&#123;</span><br><span class="line">                emit(currrnt, <span class="number">1</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.length;</span><br><span class="line">    &#125;, &#123;<span class="attr">out</span>:<span class="string">&quot;aa&quot;</span>&#125;);</span><br><span class="line">&gt; db.aa.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalize使用"><a href="#finalize使用" class="headerlink" title="finalize使用"></a>finalize使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.article.mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currrnt</span>)</span>&#123;</span><br><span class="line">                emit(currrnt, <span class="number">1</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.length;</span><br><span class="line">    &#125;, &#123;<span class="attr">out</span>:<span class="string">&quot;aa&quot;</span>&#125;);</span><br><span class="line">&gt; db.getCollection(<span class="string">&#x27;aa&#x27;</span>).find(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;value&quot;</span> : &#123; <span class="string">&quot;count&quot;</span> : <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;value&quot;</span> : &#123; <span class="string">&quot;count&quot;</span> : <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;value&quot;</span> : &#123; <span class="string">&quot;count&quot;</span> : <span class="number">1</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;value&quot;</span> : &#123; <span class="string">&quot;count&quot;</span> : <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>为什么会出现这样的结果？有的是对象，有的是值，之前说过，如果map产出的values的结果只有一个，是不会执行reduce阶段的，这里可以用finalize来保证结果的统一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.article.mapReduce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.tags.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currrnt</span>)</span>&#123;</span><br><span class="line">                emit(currrnt, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">key, values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.length;</span><br><span class="line">    &#125;, &#123;<span class="attr">out</span>:<span class="string">&quot;aa&quot;</span>,<span class="attr">finalize</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key,reduced</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(reduced.count) &#123;</span><br><span class="line">                <span class="keyword">return</span> reduced.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reduced;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&gt; db.getCollection(<span class="string">&#x27;aa&#x27;</span>).find(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶，mapReduce过滤"><a href="#进阶，mapReduce过滤" class="headerlink" title="进阶，mapReduce过滤"></a>进阶，mapReduce过滤</h3><p>现在我们只统计发布了java标签的数据，可以用query参数来过滤，也可以用map阶段来用代码过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.article.mapReduce(function()&#123; </span><br><span class="line">    <span class="keyword">var</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i in <span class="keyword">this</span>.tags)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.tags[i] == <span class="string">&#x27;java&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tags.forEach(function(tag)&#123;</span><br><span class="line">            emit(tag, &#123;count:<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, function(key, values)&#123;</span><br><span class="line">        <span class="keyword">return</span> values.length;</span><br><span class="line">    &#125;, &#123;out:<span class="string">&quot;aa&quot;</span>,finalize: function(key,reduced)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reduced.count) &#123;</span><br><span class="line">                <span class="keyword">return</span> reduced.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reduced;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&gt; db.getCollection(<span class="string">&#x27;aa&#x27;</span>).find(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="聚合框架（aggregation-framework）"><a href="#聚合框架（aggregation-framework）" class="headerlink" title="聚合框架（aggregation framework）"></a>聚合框架（aggregation framework）</h2><p>聚合框架是mongo聚合操作的第三种方式，它与group()解决的问题是的一样的，group()和MapReduce都是需要写函数的，所以mongodb提供了聚合框架，简化聚合操作。</p>
<p>注意：只有MapReduce和聚合框架能分片的环境下使用。</p>
<p>聚合框架是不能自定义函数的，它帮我们实现了一些函数。</p>
<p><a href="https://docs.mongodb.com/manual/core/aggregation-pipeline/index.html">https://docs.mongodb.com/manual/core/aggregation-pipeline/index.html</a></p>
<p><img src="https://docs.mongodb.com/manual/_images/aggregation-pipeline.bakedsvg.svg"></p>
<p>聚合框架为我们提供了很多操作，aggregate参数是一个pipeline，每一个按操作按顺序执行。</p>
<p><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/">https://docs.mongodb.com/manual/reference/operator/aggregation/</a></p>
<p>常用的几个操作：</p>
<ul>
<li><p>$project 过滤需要用到的字段</p>
</li>
<li><p>$match 查询，过滤需要用到的数据</p>
</li>
<li><p>$unwind 用于将一个文档拆成多个文档</p>
<p>  {id:tags[‘java’,’python’,’ruby’]}<br>  $unwind<br>  {id:1,tags:’java’},{id:1,tags:’python’},{id:1,tags:’ruby’}</p>
</li>
<li><p>$group 分组，需要指定<code>_id</code>字段为分组的key</p>
<p>  $group本身又提供一些操作：<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulator-operator">https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulator-operator</a></p>
</li>
</ul>
<h3 id="实例1-长度"><a href="#实例1-长度" class="headerlink" title="实例1-长度"></a>实例1-长度</h3><p>数据准备：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.commodity.insert(&#123;<span class="attr">category</span>:<span class="number">1</span>, <span class="attr">price</span>:<span class="number">200</span>, <span class="attr">name</span>: <span class="string">&#x27;name1&#x27;</span>&#125;);</span><br><span class="line">db.commodity.insert(&#123;<span class="attr">category</span>:<span class="number">1</span>, <span class="attr">price</span>:<span class="number">300</span>, <span class="attr">name</span>: <span class="string">&#x27;name2&#x27;</span>&#125;);</span><br><span class="line">db.commodity.insert(&#123;<span class="attr">category</span>:<span class="number">2</span>, <span class="attr">price</span>:<span class="number">100</span>, <span class="attr">name</span>: <span class="string">&#x27;name3&#x27;</span>&#125;);</span><br><span class="line">db.commodity.insert(&#123;<span class="attr">category</span>:<span class="number">2</span>, <span class="attr">price</span>:<span class="number">500</span>, <span class="attr">name</span>: <span class="string">&#x27;name4&#x27;</span>&#125;);</span><br><span class="line">db.commodity.insert(&#123;<span class="attr">category</span>:<span class="number">3</span>, <span class="attr">price</span>:<span class="number">200</span>, <span class="attr">name</span>: <span class="string">&#x27;name5&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>按照category分组并统计每一组的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.commodity.aggregate(&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$category&#x27;</span>, <span class="attr">totalCount</span>: &#123;<span class="attr">$sum</span>:<span class="number">1</span>&#125;&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">3</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="实例2-求和-1"><a href="#实例2-求和-1" class="headerlink" title="实例2-求和"></a>实例2-求和</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.commodity.aggregate(&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$category&#x27;</span>, <span class="attr">totalCount</span>: &#123;<span class="attr">$sum</span>:<span class="number">1</span>&#125;, <span class="attr">totalPrice</span>: &#123;<span class="attr">$sum</span>: <span class="string">&#x27;$price&#x27;</span>&#125;&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">3</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">600</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">500</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在没有指定排序规则的时候，aggregate是不保证排序的，需要用<code>$sort</code>指定排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.commodity.aggregate(&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$category&#x27;</span>, <span class="attr">totalCount</span>: &#123;<span class="attr">$sum</span>:<span class="number">1</span>&#125;, <span class="attr">totalPrice</span>: &#123;<span class="attr">$sum</span>: <span class="string">&#x27;$price&#x27;</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>: &#123;<span class="string">&#x27;totalPrice&#x27;</span>:<span class="number">-1</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">600</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">500</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">3</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">200</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例3-求平均值"><a href="#实例3-求平均值" class="headerlink" title="实例3-求平均值"></a>实例3-求平均值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.commodity.aggregate(&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$category&#x27;</span>, <span class="attr">totalCount</span>: &#123;<span class="attr">$sum</span>:<span class="number">1</span>&#125;, <span class="attr">totalPrice</span>: &#123;<span class="attr">$sum</span>: <span class="string">&#x27;$price&#x27;</span>&#125;, <span class="attr">avgPrice</span>: &#123;<span class="attr">$avg</span>:<span class="string">&#x27;$price&#x27;</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>: &#123;<span class="string">&#x27;totalPrice&#x27;</span>:<span class="number">-1</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">600</span>, <span class="string">&quot;avgPrice&quot;</span> : <span class="number">300</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">2</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">500</span>, <span class="string">&quot;avgPrice&quot;</span> : <span class="number">250</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">3</span>, <span class="string">&quot;totalCount&quot;</span> : <span class="number">1</span>, <span class="string">&quot;totalPrice&quot;</span> : <span class="number">200</span>, <span class="string">&quot;avgPrice&quot;</span> : <span class="number">200</span> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="实例4-标签统计"><a href="#实例4-标签统计" class="headerlink" title="实例4-标签统计"></a>实例4-标签统计</h3><p>之前在演示MapReduce的时候，用MapReduce对article的tags统计tag出现的次数，这里用聚合框架来达到同样的效果，当然想到的就是之前介绍到的<code>$unwind</code>操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例5-标签过滤"><a href="#实例5-标签过滤" class="headerlink" title="实例5-标签过滤"></a>实例5-标签过滤</h3><p>找出打了java标签的文章并进行统计</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$match</span>:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;<span class="attr">$in</span>:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;python&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;java&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="实例6-各种操作"><a href="#实例6-各种操作" class="headerlink" title="实例6-各种操作"></a>实例6-各种操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$match</span>:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;<span class="attr">$nin</span>:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>:&#123;<span class="string">&#x27;total&#x27;</span>:<span class="number">-1</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>取前三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$match</span>:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;<span class="attr">$nin</span>:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>:&#123;<span class="string">&#x27;total&#x27;</span>:<span class="number">-1</span>&#125;&#125;, &#123;<span class="attr">$limit</span>:<span class="number">3</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>取第二到到第四：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$match</span>:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;<span class="attr">$nin</span>:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>:&#123;<span class="string">&#x27;total&#x27;</span>:<span class="number">-1</span>&#125;&#125;,&#123;<span class="attr">$skip</span>:<span class="number">1</span>&#125; ,&#123;<span class="attr">$limit</span>:<span class="number">3</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;kotlin&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;groovy&quot;</span>, <span class="string">&quot;total&quot;</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>只显示total：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;<span class="attr">$match</span>:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;<span class="attr">$nin</span>:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;<span class="attr">$unwind</span>: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">&#x27;$tags&#x27;</span>, <span class="attr">total</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;&#125;&#125;, &#123;<span class="attr">$sort</span>:&#123;<span class="string">&#x27;total&#x27;</span>:<span class="number">-1</span>&#125;&#125;,&#123;<span class="attr">$skip</span>:<span class="number">1</span>&#125; ,&#123;<span class="attr">$limit</span>:<span class="number">3</span>&#125;, &#123;<span class="attr">$project</span>:&#123;<span class="attr">_id</span>:<span class="number">0</span>&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;total&quot;</span> : <span class="number">3</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;total&quot;</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>把total加100</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; db.article.aggregate(&#123;$match:&#123;<span class="string">&#x27;tags&#x27;</span> : &#123;$nin:[<span class="string">&#x27;java&#x27;</span>]&#125;&#125;&#125;, &#123;$unwind: <span class="string">&#x27;$tags&#x27;</span>&#125;, &#123;$group: &#123;_id:<span class="string">&#x27;$tags&#x27;</span>, total:&#123;$sum: <span class="number">1</span>&#125;&#125;&#125;, &#123;$sort:&#123;<span class="string">&#x27;total&#x27;</span>:-<span class="number">1</span>&#125;&#125;,&#123;$skip:<span class="number">1</span>&#125; ,&#123;$limit:<span class="number">3</span>&#125;, &#123;$project:&#123;_id:<span class="number">0</span>,hello:&#123;$add:[<span class="string">&#x27;$total&#x27;</span>,<span class="number">100</span>]&#125;&#125;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;hello&quot;</span> : <span class="number">103</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;hello&quot;</span> : <span class="number">103</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;hello&quot;</span> : <span class="number">102</span> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB4-GridFS、Capped Collections、索引与查询计划</title>
    <url>/2018/01/07/mongodb/mongo4/</url>
    <content><![CDATA[<h1 id="GridFS"><a href="#GridFS" class="headerlink" title="GridFS"></a>GridFS</h1><p><a href="https://docs.mongodb.com/manual/core/gridfs/index.html#use-gridfs">https://docs.mongodb.com/manual/core/gridfs/index.html#use-gridfs</a></p>
<p>GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。</p>
<p>GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。</p>
<p>GridFS 可以更好的存储大于16M的文件。</p>
<p>GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>
<p>GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。</p>
<p>每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>
<a id="more"></a>
<p>以下是简单的 fs.files 集合文档：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test.txt&quot;</span>,</span><br><span class="line">   <span class="string">&quot;chunkSize&quot;</span>: NumberInt(<span class="number">261120</span>),</span><br><span class="line">   <span class="string">&quot;uploadDate&quot;</span>: ISODate(<span class="string">&quot;2014-04-13T11:32:33.557Z&quot;</span>),</span><br><span class="line">   <span class="string">&quot;md5&quot;</span>: <span class="string">&quot;7b762939321e146569b07f72c62cca4f&quot;</span>,</span><br><span class="line">   <span class="string">&quot;length&quot;</span>: NumberInt(<span class="number">646</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是简单的 fs.chunks 集合文档：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;files_id&quot;</span>: ObjectId(<span class="string">&quot;534a75d19f54bfec8a2fe44b&quot;</span>),</span><br><span class="line">   <span class="string">&quot;n&quot;</span>: NumberInt(<span class="number">0</span>),</span><br><span class="line">   <span class="string">&quot;data&quot;</span>: <span class="string">&quot;Mongo Binary Data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mongofiles"><a href="#mongofiles" class="headerlink" title="mongofiles"></a>mongofiles</h2><p>mongodb提供了一个<code>mongofiles</code>命令来管理GridFS。</p>
<p><code>mongofiles &lt;options&gt; &lt;commands&gt; &lt;filename&gt;</code></p>
<p>它的参数在文档都有详细的解释</p>
<p><a href="https://docs.mongodb.com/manual/reference/program/mongofiles/index.html">https://docs.mongodb.com/manual/reference/program/mongofiles/index.html</a></p>
<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>上传一个东西测试一下，<code>-d</code>指定数据库，<code>-l</code>指定要上传的文件地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ mongofiles -d mytest -l /Users/xiaomai/Desktop/WXWork_2.4.5.213.dmg put wxwork.dmg</span><br><span class="line">2018-01-07T11:59:51.831+0800	connected to: localhost</span><br><span class="line">added file: wxwork.dmg</span><br></pre></td></tr></table></figure>

<p>可以查一下fs.files和fs.chunks这两个数据库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.fs.files.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;chunkSize&quot;</span> : <span class="number">261120</span>, <span class="string">&quot;uploadDate&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T03:59:52.285Z&quot;</span>), <span class="string">&quot;length&quot;</span> : <span class="number">22230276</span>, <span class="string">&quot;md5&quot;</span> : <span class="string">&quot;b0c833f7325342227ddff80e03462000&quot;</span>, <span class="string">&quot;filename&quot;</span> : <span class="string">&quot;wxwork.dmg&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>由于chunks里保存的二进制数据，特别多，所以查询的时候把data字段给忽略一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.fs.chunks.find(&#123;&#125;,&#123;data:0&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca9&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 0 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecaa&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 1 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecab&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 2 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecac&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 3 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecad&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 4 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecae&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 5 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8ecaf&quot;</span>), <span class="string">&quot;files_id&quot;</span> : ObjectId(<span class="string">&quot;5a519b37e59cf07feeb8eca8&quot;</span>), <span class="string">&quot;n&quot;</span> : 6 &#125;</span><br><span class="line">Type <span class="string">&quot;it&quot;</span> <span class="keyword">for</span> more</span><br></pre></td></tr></table></figure>

<p>当然，这个数据也不少，chunkSize是261120，除以1024，一块是255k。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ mongofiles -d mytest search w</span><br><span class="line">2018-01-07T12:44:41.433+0800	connected to: localhost</span><br><span class="line">wxwork.dmg	22230276</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ mongofiles -d mytest delete wxwork.dmg </span><br><span class="line">2018-01-07T12:45:46.190+0800	connected to: localhost</span><br><span class="line">successfully deleted all instances of <span class="string">&#x27;wxwork.dmg&#x27;</span> from GridFS</span><br></pre></td></tr></table></figure>


<h1 id="Capped-Collections"><a href="#Capped-Collections" class="headerlink" title="Capped Collections"></a>Capped Collections</h1><p><a href="https://docs.mongodb.com/manual/core/capped-collections/index.html">https://docs.mongodb.com/manual/core/capped-collections/index.html</a></p>
<blockquote>
<p>Capped collections are fixed-size collections that support high-throughput operations that insert and retrieve documents based on insertion order. Capped collections work in a way similar to circular buffers: once a collection fills its allocated space, it makes room for new documents by overwriting the oldest documents in the collection.</p>
</blockquote>
<p>MongoDB 固定集合（Capped Collections）是性能出色且有着固定大小的集合，对于大小固定，我们可以想象其就像一个环形队列，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！</p>
<p>一般只新增不更新，更新要求更新后的集合大小不能超过之前的大小，否则会出错。</p>
<p>2.2版本之后，_id就自带索引了，在2.2之前，需要显式的在_id字段上创建索引。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p><a href="https://docs.mongodb.com/manual/core/capped-collections/index.html#create-a-capped-collection">https://docs.mongodb.com/manual/core/capped-collections/index.html#create-a-capped-collection</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.createCollection(<span class="string">&quot;log&quot;</span>,&#123;<span class="attr">capped</span>:<span class="literal">true</span>,<span class="attr">size</span>:<span class="number">1000</span>&#125;)</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>mongodb会先判断size的大小是否超过限制，然后再判断集合里文档的数量是否超过了max设定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.createCollection(<span class="string">&quot;log&quot;</span>, &#123; <span class="attr">capped</span> : <span class="literal">true</span>, <span class="attr">size</span> : <span class="number">100</span>, <span class="attr">max</span> : <span class="number">2</span> &#125; )</span><br><span class="line">&gt; db.log.insert(&#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.log.insert(&#123;<span class="attr">count</span>:<span class="number">2</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.log.insert(&#123;<span class="attr">count</span>:<span class="number">3</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.log.insert(&#123;<span class="attr">count</span>:<span class="number">4</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.log.insert(&#123;<span class="attr">count</span>:<span class="number">5</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.log.find(&#123;&#125;);</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51aec1fef2eb6e769d4f36&quot;</span>), <span class="string">&quot;count&quot;</span> : <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51aec5fef2eb6e769d4f37&quot;</span>), <span class="string">&quot;count&quot;</span> : <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这也印证了之前的说法，在超过2条以后，新插入的会覆盖最早的记录。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><a href="https://docs.mongodb.com/manual/core/capped-collections/index.html#query-a-capped-collection">https://docs.mongodb.com/manual/core/capped-collections/index.html#query-a-capped-collection</a></p>
<p>如果没有指定排序，mongodb会保证查询的结果就是插入的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.log.find().sort(&#123;<span class="attr">$natural</span>: <span class="number">-1</span>&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51aec5fef2eb6e769d4f37&quot;</span>), <span class="string">&quot;count&quot;</span> : <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51aec1fef2eb6e769d4f36&quot;</span>), <span class="string">&quot;count&quot;</span> : <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure>

<p>判断一个集合是否是capped：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.log.isCapped();</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>转换一个普通的集合成固定集合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.runCommand(&#123;<span class="string">&#x27;convertToCapped&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">size</span>:<span class="number">1000</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; db.hello.isCapped()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="索引与查询计划"><a href="#索引与查询计划" class="headerlink" title="索引与查询计划"></a>索引与查询计划</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p>
<p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>
<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p><img src="https://docs.mongodb.com/manual/_images/index-for-sort.bakedsvg.svg"></p>
<p>mongodb默认会给每一个集合的<code>_id</code>字段上创建一个索引。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>数据准备：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;);</span><br><span class="line">&gt; db.myindex.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;);</span><br><span class="line">&gt; db.myindex.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;wangwu&#x27;</span>, <span class="attr">age</span>:<span class="number">14</span>&#125;);</span><br><span class="line">&gt; db.myindex.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51c3d1a893e40faf1670cb&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">10</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51c3e5a893e40faf1670cc&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51c404a893e40faf1670cd&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>

<p>查询一下现有索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给age和name创建一个索引，1和-1表示升序还是降序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.createIndex(&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;createdCollectionAutomatically&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesBefore&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesAfter&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.createIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;createdCollectionAutomatically&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesBefore&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesAfter&quot;</span> : <span class="number">3</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;age&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;age_1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>给索引起个别名，并将创建索引的操作后台运行，意思不会阻塞当前的线程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.createIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">&#x27;helloIndex&#x27;</span>, <span class="attr">background</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;createdCollectionAutomatically&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesBefore&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesAfter&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;helloIndex&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span>,</span><br><span class="line">		<span class="string">&quot;background&quot;</span> : <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>删除单个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.dropIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>删除所有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.dropIndexes();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;nIndexesWas&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;msg&quot;</span> : <span class="string">&quot;non-_id indexes dropped for collection&quot;</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>指定unique参数创建一个唯一索引，插入字段有相同的值，会执行失败。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.dropIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;);</span><br><span class="line">&#123; <span class="string">&quot;nIndexesWas&quot;</span> : <span class="number">2</span>, <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; db.myindex.createIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">unique</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;createdCollectionAutomatically&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesBefore&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesAfter&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;unique&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line">&gt; db.myindex.insert(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;);</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	<span class="string">&quot;nInserted&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;writeError&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span> : <span class="number">11000</span>,</span><br><span class="line">		<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;E11000 duplicate key error collection: test.myindex index: name_1 dup key: &#123; : \&quot;zhangsan\&quot; &#125;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h2><p>虽然设置了索引，我们在做查询的时候，可能并不是很确定到底用到了索引没有。跟传统sql一样，mongo提供了查询计划来检测。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;).explain();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;queryPlanner&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;plannerVersion&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;namespace&quot;</span> : <span class="string">&quot;test.myindex&quot;</span>,</span><br><span class="line">		<span class="string">&quot;indexFilterSet&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;parsedQuery&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;$eq&quot;</span> : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;winningPlan&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;FETCH&quot;</span>,</span><br><span class="line">			<span class="string">&quot;inputStage&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;IXSCAN&quot;</span>,</span><br><span class="line">				<span class="string">&quot;keyPattern&quot;</span> : &#123;</span><br><span class="line">					<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="string">&quot;indexName&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">				<span class="string">&quot;isMultiKey&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">				<span class="string">&quot;multiKeyPaths&quot;</span> : &#123;</span><br><span class="line">					<span class="string">&quot;name&quot;</span> : [ ]</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="string">&quot;isUnique&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">				<span class="string">&quot;isSparse&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">				<span class="string">&quot;isPartial&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">				<span class="string">&quot;indexVersion&quot;</span> : <span class="number">2</span>,</span><br><span class="line">				<span class="string">&quot;direction&quot;</span> : <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">				<span class="string">&quot;indexBounds&quot;</span> : &#123;</span><br><span class="line">					<span class="string">&quot;name&quot;</span> : [</span><br><span class="line">						<span class="string">&quot;[\&quot;zhangsan\&quot;, \&quot;zhangsan\&quot;]&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;rejectedPlans&quot;</span> : [ ]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;serverInfo&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;host&quot;</span> : <span class="string">&quot;2dd4d04418b1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;port&quot;</span> : <span class="number">27017</span>,</span><br><span class="line">		<span class="string">&quot;version&quot;</span> : <span class="string">&quot;3.6.0&quot;</span>,</span><br><span class="line">		<span class="string">&quot;gitVersion&quot;</span> : <span class="string">&quot;a57d8e71e6998a2d0afde7edc11bd23e5661c915&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是看<code>indexBounds</code>，可以确定是用了name的索引。</p>
<p>因为之前把age上的索引删除了，所以查询age&gt;5的数据，则没有用到索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">5</span>&#125;&#125;).explain();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;queryPlanner&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;plannerVersion&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;namespace&quot;</span> : <span class="string">&quot;test.myindex&quot;</span>,</span><br><span class="line">		<span class="string">&quot;indexFilterSet&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;parsedQuery&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;age&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;$gt&quot;</span> : <span class="number">5</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;winningPlan&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;COLLSCAN&quot;</span>,</span><br><span class="line">			<span class="string">&quot;filter&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;age&quot;</span> : &#123;</span><br><span class="line">					<span class="string">&quot;$gt&quot;</span> : <span class="number">5</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;direction&quot;</span> : <span class="string">&quot;forward&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;rejectedPlans&quot;</span> : [ ]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;serverInfo&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;host&quot;</span> : <span class="string">&quot;2dd4d04418b1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;port&quot;</span> : <span class="number">27017</span>,</span><br><span class="line">		<span class="string">&quot;version&quot;</span> : <span class="string">&quot;3.6.0&quot;</span>,</span><br><span class="line">		<span class="string">&quot;gitVersion&quot;</span> : <span class="string">&quot;a57d8e71e6998a2d0afde7edc11bd23e5661c915&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.reIndex();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;nIndexesWas&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;nIndexes&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;indexes&quot;</span> : [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;unique&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">			<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p><a href="https://docs.mongodb.com/manual/indexes/index.html#compound-index">https://docs.mongodb.com/manual/indexes/index.html#compound-index</a></p>
<p><img src="https://docs.mongodb.com/manual/_images/index-compound-key.bakedsvg.svg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.myindex.createIndex(&#123;<span class="attr">age</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">&#x27;myNameAndAge&#x27;</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;createdCollectionAutomatically&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesBefore&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">&quot;numIndexesAfter&quot;</span> : <span class="number">3</span>,</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; db.myindex.getIndexes();</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;_id_&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;unique&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;v&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;age&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;name&quot;</span> : <span class="string">&quot;myNameAndAge&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;test.myindex&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h1><p>mysql里面有一个慢查询日志，记录了查询比较慢的一些查询，可以让开发人员分析。</p>
<p>mongodb也提供了profiling，它默认是没有开启的，需要手动开启，0表示没有开启。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.getProfilingLevel();</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个值为1的时候，大于100毫秒的的查询会被记录，如果为2，所有的查询记录都会被记录。</p>
<p>数据准备:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.post.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line">&gt; db.post.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>, <span class="attr">age</span>:<span class="number">21</span>&#125;)</span><br><span class="line">&gt; db.post.save(&#123;<span class="attr">name</span>:<span class="string">&#x27;wangwu&#x27;</span>, <span class="attr">age</span>:<span class="number">22</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>改变profilingLevel，开启profiling，为了演示，设置成2，记录所有的查询。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.setProfilingLevel(<span class="number">2</span>);</span><br><span class="line">&#123; <span class="string">&quot;was&quot;</span> : <span class="number">0</span>, <span class="string">&quot;slowms&quot;</span> : <span class="number">100</span>, <span class="string">&quot;sampleRate&quot;</span> : <span class="number">1</span>, <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到多了一个集合，实际上查询记录就会被记录到system.profile集合当中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; show collections;</span><br><span class="line">post</span><br><span class="line">system.profile</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; db.post.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51cef5a893e40faf1670cf&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51cf00a893e40faf1670d0&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">21</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a51cf0aa893e40faf1670d1&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">22</span> &#125;</span><br><span class="line">&gt; db.system.profile.find().pretty();</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;op&quot;</span> : <span class="string">&quot;query&quot;</span>,</span><br><span class="line">	<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;mytest.post&quot;</span>,</span><br><span class="line">	<span class="string">&quot;command&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;find&quot;</span> : <span class="string">&quot;post&quot;</span>,</span><br><span class="line">		<span class="string">&quot;filter&quot;</span> : &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;$db&quot;</span> : <span class="string">&quot;mytest&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;keysExamined&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;docsExamined&quot;</span> : <span class="number">3</span>,</span><br><span class="line">	<span class="string">&quot;cursorExhausted&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;numYield&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;locks&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;Global&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Database&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Collection&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;nreturned&quot;</span> : <span class="number">3</span>,</span><br><span class="line">	<span class="string">&quot;responseLength&quot;</span> : <span class="number">249</span>,</span><br><span class="line">	<span class="string">&quot;protocol&quot;</span> : <span class="string">&quot;op_msg&quot;</span>,</span><br><span class="line">	<span class="string">&quot;millis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;planSummary&quot;</span> : <span class="string">&quot;COLLSCAN&quot;</span>,</span><br><span class="line">	<span class="string">&quot;execStats&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;COLLSCAN&quot;</span>,</span><br><span class="line">		<span class="string">&quot;nReturned&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;executionTimeMillisEstimate&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;works&quot;</span> : <span class="number">5</span>,</span><br><span class="line">		<span class="string">&quot;advanced&quot;</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="string">&quot;needTime&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;needYield&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;saveState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;restoreState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;isEOF&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;invalidates&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;direction&quot;</span> : <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">		<span class="string">&quot;docsExamined&quot;</span> : <span class="number">3</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ts&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T07:58:31.109Z&quot;</span>),</span><br><span class="line">	<span class="string">&quot;client&quot;</span> : <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">	<span class="string">&quot;appName&quot;</span> : <span class="string">&quot;MongoDB Shell&quot;</span>,</span><br><span class="line">	<span class="string">&quot;allUsers&quot;</span> : [ ],</span><br><span class="line">	<span class="string">&quot;user&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>profile的内容有点多，docsExamined扫描过3个文档，nreturned表示返回了3个文档。接着给name创建一个索引，再查询一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.post.createIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;)</span><br><span class="line">db.post.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;);</span><br><span class="line">db.system.profile.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;op&quot;</span> : <span class="string">&quot;query&quot;</span>,</span><br><span class="line">	<span class="string">&quot;ns&quot;</span> : <span class="string">&quot;mytest.post&quot;</span>,</span><br><span class="line">	<span class="string">&quot;command&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;find&quot;</span> : <span class="string">&quot;post&quot;</span>,</span><br><span class="line">		<span class="string">&quot;filter&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span> : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;$db&quot;</span> : <span class="string">&quot;mytest&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;keysExamined&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;docsExamined&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;cursorExhausted&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;numYield&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;locks&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;Global&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Database&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Collection&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;acquireCount&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;r&quot;</span> : NumberLong(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;nreturned&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	<span class="string">&quot;responseLength&quot;</span> : <span class="number">141</span>,</span><br><span class="line">	<span class="string">&quot;protocol&quot;</span> : <span class="string">&quot;op_msg&quot;</span>,</span><br><span class="line">	<span class="string">&quot;millis&quot;</span> : <span class="number">4</span>,</span><br><span class="line">	<span class="string">&quot;planSummary&quot;</span> : <span class="string">&quot;IXSCAN &#123; name: 1 &#125;&quot;</span>,</span><br><span class="line">	<span class="string">&quot;execStats&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;FETCH&quot;</span>,</span><br><span class="line">		<span class="string">&quot;nReturned&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;executionTimeMillisEstimate&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;works&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;advanced&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;needTime&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;needYield&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;saveState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;restoreState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;isEOF&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;invalidates&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;docsExamined&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;alreadyHasObj&quot;</span> : <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;inputStage&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;stage&quot;</span> : <span class="string">&quot;IXSCAN&quot;</span>,</span><br><span class="line">			<span class="string">&quot;nReturned&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;executionTimeMillisEstimate&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;works&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;advanced&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;needTime&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;needYield&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;saveState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;restoreState&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;isEOF&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;invalidates&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;keyPattern&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;name&quot;</span> : <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;indexName&quot;</span> : <span class="string">&quot;name_1&quot;</span>,</span><br><span class="line">			<span class="string">&quot;isMultiKey&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">			<span class="string">&quot;multiKeyPaths&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;name&quot;</span> : [ ]</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;isUnique&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">			<span class="string">&quot;isSparse&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">			<span class="string">&quot;isPartial&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">			<span class="string">&quot;indexVersion&quot;</span> : <span class="number">2</span>,</span><br><span class="line">			<span class="string">&quot;direction&quot;</span> : <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">			<span class="string">&quot;indexBounds&quot;</span> : &#123;</span><br><span class="line">				<span class="string">&quot;name&quot;</span> : [</span><br><span class="line">					<span class="string">&quot;[\&quot;zhangsan\&quot;, \&quot;zhangsan\&quot;]&quot;</span></span><br><span class="line">				]</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;keysExamined&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;seeks&quot;</span> : <span class="number">1</span>,</span><br><span class="line">			<span class="string">&quot;dupsTested&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;dupsDropped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">			<span class="string">&quot;seenInvalidated&quot;</span> : <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;ts&quot;</span> : ISODate(<span class="string">&quot;2018-01-07T08:04:05.695Z&quot;</span>),</span><br><span class="line">	<span class="string">&quot;client&quot;</span> : <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">	<span class="string">&quot;appName&quot;</span> : <span class="string">&quot;MongoDB Shell&quot;</span>,</span><br><span class="line">	<span class="string">&quot;allUsers&quot;</span> : [ ],</span><br><span class="line">	<span class="string">&quot;user&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为post的name字段是加了索引的，所以这次的查询记录，indexName显示用到的索引名称，keysExamined为1，表示扫描了1条索引，这次docsExamined为1，只扫描了一条文档。</p>
<p>索引和查询计划就说到这里，下面的文章，讲解最后一部分，也就是副本集。</p>
]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-介绍和入门例子</title>
    <url>/2017/05/07/netty/netty1/</url>
    <content><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://netty.io/">http://netty.io</a></p>
<p>Netty is an asynchronous event-driven network application framework<br>for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p>本系列源码在<br><a href="https://github.com/sail-y/netty">https://github.com/sail-y/netty</a></p>
<h2 id="Netty能做什么？"><a href="#Netty能做什么？" class="headerlink" title="Netty能做什么？"></a>Netty能做什么？</h2><ol>
<li>可以像tomcat一样做一个http服务器。</li>
<li>socket开发。</li>
<li>支持长连接开发，例如websocket。</li>
</ol>
<a id="more"></a>

<h2 id="例子1-Http"><a href="#例子1-Http" class="headerlink" title="例子1: Http"></a>例子1: Http</h2><p>先忘记以前学过的servlet框架，netty并没有实现servlet的规范。</p>
<p>不多说，我们用netty先来写第一个例子，先跑起来试试看，后面再细说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.firstexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分发任务</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// 实际处理的</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动服务</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.firstexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="string">&quot;httpServerCodec&quot;</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="string">&quot;testHttpServerHandler&quot;</span>, <span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.firstexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;Hello World&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看起来复杂，但是几乎所有的netty程序的代码流程都是这样的。<br>定义好boss和worker的group-&gt;在childHandler定义ServerInitializer-&gt;在initChannel中定义通道处理器-&gt;实现通道处理器相应的回调方法。</p>
<p>注意loop group是死循环，必须手动停止，接下来我们来测试。</p>
<p>运行TestServer.</p>
<p>命令行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl localhost:8899</span><br></pre></td></tr></table></figure>

<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-20%20%E4%B8%8B%E5%8D%889.35.25.png"></p>
<p>接着我们看一下netty处理器的生命周期，改一下<code>TestHttpServerHandler</code>的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.firstexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请求方法名：&quot;</span> + httpRequest.method().name());</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求favicon.ico&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;Hello World&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码用<code>curl</code>和浏览器访问得到的结果是不一样的，因为netty没有遵循servlet的规范，所以有些地方我们得自己处理。</p>
<p>这是<code>curl</code>工具的输出：<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-20%20%E4%B8%8B%E5%8D%8810.00.07.png"></p>
<p>这是浏览器第一次访问的输出：<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-20%20%E4%B8%8B%E5%8D%8810.04.29.png"></p>
<p>这是浏览器第二次访问的输出：<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-20%20%E4%B8%8B%E5%8D%8810.06.08.png"></p>
<p>那是因为<code>curl</code>每次请求完之后就断了。而在http1.1协议下，浏览器有一个keep-alive功能来决定服务端收到请求什么时候关闭这个连接。所以我在多等了一会后，服务器还是自动关闭了连接，控制台还是输出了<code>channelInactive</code>和<code>channelUnregistered</code></p>
<h2 id="例子2-Socket"><a href="#例子2-Socket" class="headerlink" title="例子2: Socket"></a>例子2: Socket</h2><p>代码演示</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>先写server端代码</p>
<p><code>MyServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和第一个例子并没有太大的区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyServerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;, &quot;</span> + msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from server: &quot;</span> + UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果出现异常，关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyServerInitializer .java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对socket开发，我们处理的方式发生了一些变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">// 最后添加我们自己的处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>客户端代码</p>
<p><code>MyClient.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个EventLoopGroup</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> MyClientInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyClientHandler </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;client output: &quot;</span> + msg);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;from clinet: &quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果不重写这个方法，运行程序后并不会触发数据的传输，因为双方都在等待read，所以要先发送一次消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyClientInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.secondexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了最后一行，跟服务端代码是一样的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">// 最后添加我们自己的处理器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子3：聊天"><a href="#例子3：聊天" class="headerlink" title="例子3：聊天"></a>例子3：聊天</h2><p>下面做一个简单的消息广播，服务端1个，客户端3个，每个客户端上线的时候，服务端就对每个客户端广播上线的消息，下线同理。客户端发送消息的时候，服务端也会对每一个客户端进行广播。</p>
<p><code>MyChatServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChatServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyChatServerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != ch) &#123;</span><br><span class="line">                ch.writeAndFlush(channel.remoteAddress() + <span class="string">&quot; 发送的消息：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;【自己】 &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果出现异常，关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一个客户端连接的时候，就保存它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在添加之前做一个广播</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;【服务器】 - &quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在移除之前做一个广播</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;【服务器】 - &quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个代码在handlerRemoved的时候会自动的从group中移除，所以我们不用写。</span></span><br><span class="line">        <span class="comment">// channelGroup.remove(channel);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(channel.remoteAddress() + <span class="string">&quot; 上线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(channel.remoteAddress() + <span class="string">&quot; 下线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyChatServerInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyChatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyChatClient.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sail.netty.secondexample.MyClientInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个EventLoopGroup</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> MyChatClientInitializer());</span><br><span class="line"></span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8899</span>).sync().channel();</span><br><span class="line">            <span class="comment">// channel.closeFuture().sync();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写一个死循环不断的去读取用户在控制台的输入</span></span><br><span class="line"></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                channel.writeAndFlush(br.readLine() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyChatClientHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyChatClientInitializer.java </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.thirdexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyChatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例子4：heartbeat（心跳）"><a href="#例子4：heartbeat（心跳）" class="headerlink" title="例子4：heartbeat（心跳）"></a>例子4：heartbeat（心跳）</h2><p>下面演示一个集群中常见的心跳用netty的实现方式。</p>
<p><code>MyServer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.forthexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 心跳检测的Netty实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// handler是针对于bossGroup的</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// childHandler是针对于workerGroup的</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyServerHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.forthexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 超时事件： &quot;</span> + eventType);</span><br><span class="line"></span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyServerInitializer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sail.netty.forthexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/05/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IdleStateHandler可以检测连接的3种状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-源码分析(一)</title>
    <url>/2017/09/13/netty/netty6/</url>
    <content><![CDATA[<h1 id="Netty源码分析"><a href="#Netty源码分析" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h1><p>跟着代码的编写和运行流程来看看Netty的源码和原理，这里面包含了大量NIO的知识，所以我们要对NIO的基础知识要有掌握，不然看Netty的源码是很难受的。那么我们从哪里开始阅读源码呢，既然不知道从何下手，就从运行的例子一个一个往下看吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">		            .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.WARN))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h2><p>还记得我们编写Netty服务端的时候，第一行代码就是<code>EventLoopGroup bossGroup = new NioEventLoopGroup();</code>，bossGroup是作为转发、分发任务的，而workerGroup才是真正执行任务的。</p>
<p>EventLoopGroup底层是一个死循环，它会不停的去侦测输入输出的事件进行处理，处理完成后进行任务的执行。</p>
<p>EventLoopGroup有一个参数，表示线程数量，如果不传的话，在<code>MultithreadEventLoopGroup</code>里有设置它的默认值是<code>Math.max(1, SystemPropertyUtil.getInt(                 &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</code>的计算结果，像bossGroup一般都会设置成1，因为分配任务的group，只需要一个线程就足以。</p>
<p>最后创建线程的代码在<code>MultithreadEventExecutorGroup</code>的构造方法里面。<br><code>children[i] = newChild(executor, args);</code></p>
<p>所以NioEventLoopGroup在初始化的时候就只是赋值和初始化属性，什么操作也没有做。</p>
<h2 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h2><p>Bootstrap sub-class which allows easy bootstrap of ServerChannel。<br>意思就是ServerBootstrap就是用来启动ServerChannel的一个类。</p>
<h3 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h3><p>接下来看ServerBootstrap.group()方法，先把父类AbstractBootstrap的group属性设置了，然后再设置自己的childGroup属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel()"></a>channel()</h3><p>用于通过Class对象创建一个channel对象，源码是通过<strong>ReflectiveChannelFactory</strong>的反射代码调用无参构造方法创建的对象。<br>实际上是设置了一个channelFactory属性，只有在调用bind()方法的时候才会真正创建对象。</p>
<h3 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h3><p>ServerSocketChannel implementation which uses NIO selector based implementation to accept new connections.</p>
<p>ServerSocketChannel的实现，使用了基于NIO selector的实现接受连接。</p>
<p>这个就是说NIO使用Selector基于事件的连接是一样的。</p>
<h3 id="childHandler"><a href="#childHandler" class="headerlink" title="childHandler()"></a>childHandler()</h3><p>服务于用channel的请求，实现为赋值到childHandler的属性中。</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>在这个方法里才真正创建了一个新的channel，并且绑定到上面。</p>
<p><img src="/img/netty/netty6-7.png"></p>
<p>最后调用到doBind方法，在netty中，do开头的基本都是私有方法。</p>
<p><code>final ChannelFuture regFuture = initAndRegister();</code></p>
<p>在initAndRegister()里就调用了<code>channelFactory.newChannel()</code>（<em>ReflectiveChannelFactory</em>）来创建Channel对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们传入的是<strong>NioServerSocketChannel</strong>,构造方法就调用到了<code>provider.openServerSocketChannel();</code>，这个就是Java NIO的代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newSocket方法还提到了在github上的一个问题 <a href="https://github.com/netty/netty/issues/2308">https://github.com/netty/netty/issues/2308</a> 。这里就出现了Netty调用了NIO的方法，像SelectionKey注册了OP_ACCEPT事件，表示可以接受连接了。并且在父类中调用了<code>ch.configureBlocking(false);</code>设置为非阻塞。<strong>AbstractNioChannel</strong>也包含了一个<strong>SelectableChannel</strong>的引用，这个其实就是对NIO的Channel的一个包装就体现出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在获得Channel对象后，马上调用了init方法进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel = channelFactory.newChannel();</span><br><span class="line">init(channel);</span><br></pre></td></tr></table></figure>

<p>init方法本身也是做了很多事情，其中有一些option和attr的设置，还有就是Netty在这里也加了一个Handler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个有没有眼熟，我们自己写的childHanlder()注册的不就是<strong>ChannelInitializer</strong>的子类吗。还有<code>ChannelHandler handler = config.handler();</code>实际上就是serverBootstrap.handler()注册的自定义的Handler，是提供给bossGroup使用的，在这里被添加到ChannelPipeline的末端。</p>
<p>bind(8899)返回了一个ChannelFuture，ChannelFuture最终是继承了<code>java.util.concurrent.Future</code>，返回Future的都是异步方法，结果只能通过get()方法获取，get()方法是阻塞的，会阻塞直到异步方法运行完成返回结果。</p>
<p>netty自己写了一个Future，并加了几个方法来区别JDK只有isDone的不足，在JDK中，异步任务完成、取消、异常，isDone方法都会返回true，而netty为了更加细化这个状态，做了如下处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                      | Completed successfully    |</span><br><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() &#x3D; true      |</span><br><span class="line">* +--------------------------+    |    |   isSuccess() &#x3D; true      |</span><br><span class="line">* |        Uncompleted       |    |    +&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">* +--------------------------+    |    | Completed with failure    |</span><br><span class="line">* |      isDone() &#x3D; false    |    |    +---------------------------+</span><br><span class="line">* |   isSuccess() &#x3D; false    |----+----&gt;      isDone() &#x3D; true      |</span><br><span class="line">* | isCancelled() &#x3D; false    |    |    |       cause() &#x3D; non-null  |</span><br><span class="line">* |       cause() &#x3D; null     |    |    +&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">* +--------------------------+    |    | Completed by cancellation |</span><br><span class="line">*                                 |    +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() &#x3D; true      |</span><br><span class="line">*                                      | isCancelled() &#x3D; true      |</span><br><span class="line">*                                      +---------------------------+</span><br></pre></td></tr></table></figure>


<p>除了状态的处理，还添加了<code>addListener</code>方法，这个方法会在任务运行完成的时候通知并回调，所以用户能更加准确的判断何时调用get()方法。</p>
<p>Netty建议我们使用addListener，而不要使用await()，因为addListener是非阻塞的，await()会阻塞直到I/O完成。不要在<strong>ChannelHanlder</strong>中调用await()方法，因为<strong>ChannelHanlder</strong>的方法通常是被事件处理器调用的，如果await()被I/O操作线程的事件处理器调用，那么I/O操作就会一直阻塞造成死锁。比如在channelRead()中调用await()方法，等待I/O操作完成，而I/O操作又在等待channelRead()完成，就成了死锁，这种情况应该调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(<span class="keyword">new</span>  ChannelFutureListener() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Perform post-closure operation</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><h3 id="Doug-Lea"><a href="#Doug-Lea" class="headerlink" title="Doug Lea"></a>Doug Lea</h3><p>反应器模式，Netty整体架构是Reactor模式的完整体现。提到Reactor模式，就不得不拿出大神Doug Lea(Java并发包的作者)的文档：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">《Scalable IO in Java》</a>，内容不多，里面涉及到传统IO的写法，NIO的设计思想。这个文档非常重要，一定要熟读。</p>
<p><img src="/img/netty/netty6-1.png"></p>
<p>大多数的网络服务都是下面的流程：</p>
<ol>
<li>读取请求</li>
<li>对请求进行解码</li>
<li>处理服务（业务逻辑）</li>
<li>编码相应</li>
<li>发送响应</li>
</ol>
<p><img src="/img/netty/netty6-2.png"></p>
<p>传统的网络服务设计方式如上图所示：客户端有多个，服务端每接受到一个请求就创建一个线程进行一系列的处理….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Handler(ss.accept())).start();</span><br><span class="line">            <span class="comment">// or, single-threaded, or a thread pool</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        Handler(Socket s) &#123;</span><br><span class="line">            socket = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_INPUT];</span><br><span class="line">                socket.getInputStream().read(input);</span><br><span class="line">                <span class="keyword">byte</span>[] output = process(input);</span><br><span class="line">                socket.getOutputStream().write(output);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] process(<span class="keyword">byte</span>[] cmd) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式最大的问题就是线程太多了，如果线程持续上升，线程之间的切换非常耗费资源，服务器就支撑不了。</p>
<ul>
<li>Reactor通过分发恰当的处理器来响应IO事件（类似于AWT）</li>
<li>handler是非阻塞的</li>
<li>通过将handler绑定到事件上来管理（类似于AWT的addActionListener）</li>
</ul>
<p><img src="/img/netty/netty6-3.png" alt="单线程版Reactor模式"></p>
<p>客户端保持不变，这里多了一个Reactor角色，它去检测客户端发起的请求和连接，将客户端的请求派发给特定的handler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">final</span> ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">    Reactor(<span class="keyword">int</span> port) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        SelectionKey sk =</span><br><span class="line">                serverSocket.register(selector,</span><br><span class="line">                        SelectionKey.OP_ACCEPT);</span><br><span class="line">        sk.attach(<span class="keyword">new</span> Acceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Alternatively, use explicit SPI provider: </span></span><br><span class="line"><span class="comment">    SelectorProvider p = SelectorProvider.provider(); </span></span><br><span class="line"><span class="comment">    selector = p.openSelector();</span></span><br><span class="line"><span class="comment">    serverSocket = p.openServerSocketChannel();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">// normally in a new Thread</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator it = selected.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                    dispatch((SelectionKey) (it.next()); selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey k)</span> </span>&#123;</span><br><span class="line">        Runnable r = (Runnable) (k.attachment());</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">        	r.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// inner</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SocketChannel c = serverSocket.accept();</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">new</span> Handler(selector, c);</span><br><span class="line">      <span class="keyword">catch</span>(IOException ex)&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sk.attach(obj)可以放一个对象进去，在后面可以用attachment()取出来，这里放进去的是<strong>Acceptor</strong>。</p>
<p>Reactor本身是不做任何处理的，run()方法里事件发生的时候，调用了dispatch()方法，交由<strong>Acceptor</strong>来分发，Handler实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">    ByteBuffer input = ByteBuffer.allocate(MAXIN);</span><br><span class="line">    ByteBuffer output = ByteBuffer.allocate(MAXOUT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, SENDING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> state = READING;</span><br><span class="line"></span><br><span class="line">    Handler(Selector sel, SocketChannel c) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        socket = c;</span><br><span class="line">        c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// Optionally try first read now</span></span><br><span class="line">        sk = socket.register(sel, <span class="number">0</span>);</span><br><span class="line">        sk.attach(<span class="keyword">this</span>);</span><br><span class="line">        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        sel.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inputIsComplete</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">outputIsComplete</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == READING) read();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (state == SENDING) send();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socket.read(input);</span><br><span class="line">        <span class="keyword">if</span> (inputIsComplete()) &#123;</span><br><span class="line">            process();</span><br><span class="line">            state = SENDING;</span><br><span class="line">			  <span class="comment">// Normally also do first write now </span></span><br><span class="line">			  sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socket.write(output);</span><br><span class="line">        <span class="keyword">if</span> (outputIsComplete()) sk.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个handler可以对应到Netty中Netty提供的handler或者我们自己写的handler。因为最早注册的是OP_ACCEPT，所以这个handler要注册OP_READ。其中<code>sel.wakeup();</code>的意思是如果之前有select()方法阻塞了，那么让select()方法立即返回，如果当前没有select()方法阻塞的话，那么下一次调用select()会立即返回。然后执行run()方法，是通过判断状态的方式来决定是写还是读 ，这个在Netty3中就是需要这样实现handler代码的，需要自己判断状态来决定业务逻辑。Netty4已经改成各种回调了，比如channelRead，channelActive等。</p>
<p>文档接着又描述了多线程版本的设计，增加多个Reactor线程，提高Reactor分发的速度，以及使用线程池来处理请求</p>
<p><img src="/img/netty/netty6-4.png" alt="多线程版Reactor模式"></p>
<p>下图是多个Reactor的图示，这个图对应到Netty我们可以理解为mainReactor对应bossGroup，subReactor对应workerGroup。</p>
<p><img src="/img/netty/netty6-5.png" alt="多个Reactor"></p>
<h3 id="reactor-siemens"><a href="#reactor-siemens" class="headerlink" title="reactor-siemens"></a>reactor-siemens</h3><p><strong>《reactor-siemens》</strong>是发布于1995年的论文，。这个理论也现在也没有过时。</p>
<p><img src="/img/netty/netty6-6.png" alt="Reactor"></p>
<p>这是论文里面的一张图，跟Doug Lea的图实际上是一个意思，虽然名字不一样，下面解释一下这个图里面的元素的意思。</p>
<p>Reactor模式一共有5种角色构成：</p>
<ol>
<li><strong>Handle</strong>（句柄或是描述符）：本质上表示一种资源，是由操作系统提供的；该资源用于表示一个个的事件，比如说文件描述符，针对网络编程中的Socket描述符。事件既可以来自于外部，也可以来自于内部；外部事件比如说客户端的连接请求，客户端发送过来的数据等；内部事件比如说操作系统产生的定时器事件等。它本质上就是一个文件描述符。Handle是事件产生的发源地。</li>
<li><strong>Synchronous Event Demultiplexer（</strong>同步事件分离器）：它本身是一个系统调用，用于等待事件的发生（事件可能是一个，也可能是多个）。调用方在调用它的时候以后会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I/O多路复用的机制，比如说select，poll，epoll等。在Java NIO领域中，同步事件分离器对应的组件就是<strong>Selector</strong>；对应的阻塞方法就是select方法。</li>
<li><strong>Event Hanlder</strong>（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生的时候实现相应的业务方法进行业务逻辑的处理。</li>
<li><strong>Contrete Event Handler</strong>（具体事件处理器）：是事件处理器的实现。它本身实现了事件处理器所提供的各个回调方法，从而实现了特定于业务的逻辑。它本质上就是我们所编写的一个个的处理器实现。</li>
<li><strong>Initiation Dispatcher</strong>（初始分发器）：它实际上就是Reactor角色。它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册、删除、等设施。它本身是整个时间处理器的核心所在，Initiation Dispatcher会通过同步事件分离器来等待时间的发生。一旦事件发生，Initiation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。</li>
</ol>
<hr>
<p>Reactor模式的流程：</p>
<ol>
<li>当应用向<strong>Initiation Dispatcher</strong>注册具体的事件处理器时，应用会标识出该事件处理器希望<strong>Initiation Dispatcher</strong>在某个事件发生时向其通知的该事件，该事件与Handle关联。</li>
<li><strong>Initiation Dispatcher</strong>会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。</li>
<li>当所有的事件处理器注册完毕后，应用会调用<code>handle_events</code>方法来启动<strong>Initiation Dispatcher</strong>的事件循环。这时，<strong>Initiation Dispatcher</strong>会将每个注册的事件管理器的Handle合并起来，并使用同步事件分离器等待这些事件的发生。比如说，TCP协议层会使用select同步事件分离器操作来等待客户端发送的数据到达已经连接的socket handle上。</li>
<li>当与某个事件源对应的Handle变为ready状态时（比如说，TCP socket变为等待读状态时），同步事件分离器就会通知<strong>Initiation Dispatcher</strong>。</li>
<li><strong>Initiation Dispatcher</strong>会触发事件处理器的回调方法，从而相应这个处于ready状态的Handle。当事件发生时，<strong>Initiation Dispatcher</strong>会将事件源激活的Handle作为[key]来寻找并分发恰当的事件处理器回调方法。</li>
<li><strong>Initiation Dispatcher</strong>会回调事件处理器的handle_events回调方法来执行特定于应用的功能（开发者自己所编写的功能），从而响应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。</li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-编解码器&amp;处理器</title>
    <url>/2017/12/12/netty/netty9/</url>
    <content><![CDATA[<h1 id="Netty处理器"><a href="#Netty处理器" class="headerlink" title="Netty处理器"></a>Netty处理器</h1><p>编解码器本质上也是ChannelHandler的特殊实现，Netty本身为我们提供了很多处理器。</p>
<p>Netty处理器重要概念：</p>
<ol>
<li>Netty的处理器可以分为两类：入站处理器与出站处理器。</li>
<li>入站处理器的顶层是ChannelInboundHandler，出站处理器的顶层是ChannelOutboundHandler。</li>
<li>数据处理时常用的各种编解码器本质上都是处理器。</li>
<li>编解码器：无论我们向网络中写入的数据是什么类型（int、char、String、二进制等），数据在网络中传递时，其都是以字节流的形式呈现的；将数据由原本的形式转换为字节流的操作称为编码（encode），将数据由字节转换为它原本的格式或是其他格式的操作称为解码（decode），编解码统一称为codec。</li>
<li>编码：本质上是一种出站处理器，因此，编码是一种ChannelOutboundHandler。</li>
<li>解码：本质上是一种入站处理器，因此，解码是一种ChannelInboundHandler。</li>
<li>在Netty中，编码器通常以XXXEncoder命名；解码器通常以XXXDecoder命名。</li>
</ol>
<a id="more"></a>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾一个之前写的<a href="https://github.com/sail-y/netty/blob/master/src/main/java/com/sail/netty/secondexample/MyServerInitializer.java">例子</a>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">    <span class="comment">// 最后添加我们自己的处理器</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习到现在，我们已经很清楚的知道ChannelInitializer的职责，他本身是一个特殊的ChannelHandler，是用来初始化添加处理器的，在添加完成后，它自己会被销毁。</p>
<p>在这个例子中，根据命名或者他的继承类可以看出来，这里一共有4个入站处理器，1个出站处理器，虽然添加的时候代码都写在一起，实际上数据的流向却是两条线，从上往下进行解码，最后我们自定义的处理器拿到的时候就已经是字符串了，写出数据的时候也一样，写出的是String，但是通过StringEncoder转换成了字节。</p>
<h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>在io.netty.handler.codec包中，包含了Netty为我们提供的很多编解码器。</p>
<p>下面我们自己实现一个。</p>
<p>要实现的效果：当客户端的channelActive事件触发的时候，客户端向服务端发送一个Long类型的数据，服务端也返回一个Long类型的数据。</p>
<p><strong>MyServerInitializer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 需要将字节转换为Long</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们需要一个解码器，来将字节转换Long类型的数据，然后MyServerHandler才能处理。</p>
<p>Netty为我们提供了一个抽象类<strong>ByteToMessageDecoder</strong>，它是一个ChannelInboundHandlerAdapter，它的作用是将ByteBuf转换成另外一种消息类型，这个消息类型是我们自己来定的。</p>
<h2 id="MessageToByteEncoder-amp-ByteToMessageDecoder"><a href="#MessageToByteEncoder-amp-ByteToMessageDecoder" class="headerlink" title="MessageToByteEncoder&amp;ByteToMessageDecoder"></a>MessageToByteEncoder&amp;ByteToMessageDecoder</h2><p>Netty为我们提供了一个<strong>MessageToByteEncoder</strong>，基本大多数的解码器都直接或间接的实现了这个抽象类，我们也实现这个类，是需要实现它的encode方法。<br>相对应的，编码器是<strong>ByteToMessageDecoder</strong>，需要实现它的decode方法。</p>
<h3 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h3><p>将字节转换成一个Long类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;decode invoked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Long是8个字节</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;=<span class="number">8</span> ) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义编码器"><a href="#自定义编码器" class="headerlink" title="自定义编码器"></a>自定义编码器</h3><p>将Long转换为字节写入，编码器是有泛型的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上完整实例代码在：<a href="https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler">https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler</a></p>
<p>数据执行流程：</p>
<p>客户端先编码发送数据，然后服务端解码，收到数据后再编码写出一个数据，客户端最后再解码。</p>
<p>客户端MyLongToByteEncoder -&gt; 服务端MyByteToLongDecoder -&gt; 服务端MyServerHandler -&gt; 服务端MyLongToByteEncoder -&gt; 客户端MyByteToLongDecoder -&gt; 客户端MyClientHandler</p>
<p>如果客户端再返回一个字符串，那么客户端的MyLongToByteEncoder就已经执行失败了，所以数据不会发送给服务端。</p>
<h2 id="ReplayingDecoder"><a href="#ReplayingDecoder" class="headerlink" title="ReplayingDecoder"></a>ReplayingDecoder</h2><p>ReplayingDecoder 是 byte-to-message 解码的一种特殊的抽象基类，读取缓冲区的数据之前需要检查缓冲区是否有足够的字节，使用ReplayingDecoder就无需自己检查；若ByteBuf中有足够的字节，则会正常读取；若没有足够的字节则会停止解码。</p>
<blockquote>
<p>The biggest difference between ReplayingDecoder and ByteToMessageDecoder is that ReplayingDecoder allows you to implement the decode() and decodeLast() methods just like all required bytes were received already, rather than checking the availability of the required bytes. </p>
</blockquote>
<p>意思是我们在使用ReplayingDecoder的时候，就像数据已经全部接受到了一样，不用再去检测数据是否已经接受足够可以解码了。如果数据够了，它就直接读取，如果数据不够，它就抛出一个Error，ReplayingDecoder会捕获这个错误，然后ReplayingDecoder继续处理，并重置buffer的readerIndex，直到处理成功为止。</p>
<p>ReplayingDecoder的限制：</p>
<ol>
<li>某些buffer操作是被禁止的</li>
<li>如果网络很慢，消息也很复杂，可能性能比较差</li>
<li>一个消息的decode方法可能会被调用很多次</li>
</ol>
<h3 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h3><p>继承<strong>ReplayingDecoder</strong>实现一个解码器，替换之前的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;decode invoked&quot;</span>);</span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MessageToMessageDecoder"><a href="#MessageToMessageDecoder" class="headerlink" title="MessageToMessageDecoder"></a>MessageToMessageDecoder</h2><p>用于从一种消息解码为另外一种消息（例如，POJO 到 POJO）,将 Integer 转为 String，我们提供了 IntegerToStringDecoder，继承自 MessageToMessageDecoder。</p>
<p><img src="https://waylau.gitbooks.io/essential-netty-in-action/images/Figure%207.2%20IntegerToStringDecoder.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Long msg, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        out.add(msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h2><p>LengthFieldBasedFrameDecoder是一个非常常用的解码器，它会将ByteBuf根据消息里长度的值进行分割，这对有消息头里有长度的二进制消息特别有用。</p>
<p>关于LengthFieldBasedFrameDecoder的具体使用，和它的应用场景在文章后面的<a href="#TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85">TCP粘包和拆包</a>有演示。</p>
<h2 id="关于Netty编解码器的重要结论："><a href="#关于Netty编解码器的重要结论：" class="headerlink" title="关于Netty编解码器的重要结论："></a>关于Netty编解码器的重要结论：</h2><ol>
<li>无论是编码器还是解码器，其所接收的消息类型必须要与待处理的参数类型一致，否则该编码器或解码器并不会被执行。</li>
<li>在解码器进行数据解码时，一定要记得判断缓冲（ByteBuf）中的数据是否足够，否则将会产生一些问题。</li>
</ol>
<h2 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h2><p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p>
<h3 id="粘包演示"><a href="#粘包演示" class="headerlink" title="粘包演示"></a>粘包演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到的消息内容：&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到的消息数量：&quot;</span> + ++count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果不重写这个方法，运行程序后并不会触发数据的传输，因为双方都在等待read，所以要先发送一次消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">&quot;send from client&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">客户端接收到的消息内容：496faaef-6ed7-4802-bdd7-d4e9</span><br><span class="line">客户端接收到的消息数量：1</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line"></span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接收到的消息内容：&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到的消息数量：&quot;</span> + (++count));</span><br><span class="line"></span><br><span class="line">        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString(), CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(responseByteBuf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果出现异常，关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制条输出的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：1</span><br></pre></td></tr></table></figure>

<p>如果再重启几次客户端，服务端的结果还会发生如下变化，这是没有什么规律的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：1</span><br><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：2</span><br><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：3</span><br><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：1</span><br><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：2</span><br><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：3</span><br><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：4</span><br><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：1</span><br><span class="line">服务端接收到的消息内容：send from client</span><br><span class="line">服务器接收到的消息数量：2</span><br><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：3</span><br><span class="line">服务端接收到的消息内容：send from clientsend from client</span><br><span class="line">服务器接收到的消息数量：4</span><br><span class="line">服务端接收到的消息内容：send from clientsend from clientsend from client</span><br><span class="line">服务器接收到的消息数量：5</span><br></pre></td></tr></table></figure>

<p>完整可运行的代码在这里：<a href="https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler2">https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler2</a></p>
<h3 id="解决粘包-gt-拆包演示"><a href="#解决粘包-gt-拆包演示" class="headerlink" title="解决粘包-&gt;拆包演示"></a>解决粘包-&gt;拆包演示</h3><p>自定义一个协议，它包含了长度和内容两个字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器继承自ReplayingDecoder，好处是不需要去判断消息长度是否已经足够。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPersonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyPersonDecoder decode invoked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        PersonProtocol personProtocol = <span class="keyword">new</span> PersonProtocol();</span><br><span class="line">        personProtocol.setLength(length);</span><br><span class="line">        personProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(personProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码器就要简单很多了，需要将PersonProtocol输出为bytes。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPersonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">PersonProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, PersonProtocol msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyPersonEncoder encode invoked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        out.writeInt(msg.getLength());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及ServerHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">PersonProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, PersonProtocol msg)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = msg.getLength();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接收到的数据：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度；&quot;</span> + length);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + <span class="keyword">new</span> String(content, CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接受到的消息数量：&quot;</span> + ++count);</span><br><span class="line"></span><br><span class="line">        String responseMessage = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> responseLength = responseMessage.getBytes(<span class="string">&quot;utf-8&quot;</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[] responseContent = responseMessage.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        PersonProtocol personProtocol = <span class="keyword">new</span> PersonProtocol();</span><br><span class="line">        personProtocol.setLength(responseLength);</span><br><span class="line">        personProtocol.setContent(responseContent);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(personProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>篇幅有限，剩余的代码文章就不贴完了，代码都在：<a href="https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler3">https://github.com/sail-y/netty/tree/master/src/main/java/com/sail/netty/handler3</a></p>
<p>客户端输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：3726cb1a-163f-498c-82b2-9731aeff94e0</span><br><span class="line">客户端接受到的消息数量：1</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：7cbb68f4-bdfd-4cf8-8de6-e18f78d58770</span><br><span class="line">客户端接受到的消息数量：2</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：463d503d-873f-4a4e-8a62-f3c1ccedd6ce</span><br><span class="line">客户端接受到的消息数量：3</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：6d8b8361-18e5-402c-8977-3ba4316633f4</span><br><span class="line">客户端接受到的消息数量：4</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：eccdc204-d589-4e24-8585-36d4c07f8ce8</span><br><span class="line">客户端接受到的消息数量：5</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：3dd02117-3a8b-4d2e-8c9c-e0a356cb54e1</span><br><span class="line">客户端接受到的消息数量：6</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：5db00fcc-1e07-4ac1-bb61-f514049d1643</span><br><span class="line">客户端接受到的消息数量：7</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：b306c7f5-790e-45f8-8031-f7fd74a54b07</span><br><span class="line">客户端接受到的消息数量：8</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：386acc20-986a-441a-a265-849a45c28119</span><br><span class="line">客户端接受到的消息数量：9</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">客户端接收到的数据：</span><br><span class="line">长度；36</span><br><span class="line">内容：24c13a50-60c4-4d34-9d8e-fde19beda657</span><br><span class="line">客户端接受到的消息数量：10</span><br></pre></td></tr></table></figure>


<p>先是发送了10条消息，然后再接收到了10条消息。</p>
<p>服务端也是收到了10条消息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：1</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：2</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：3</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：4</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：5</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：6</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：7</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：8</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：9</span><br><span class="line">MyPersonEncoder encode invoked!</span><br><span class="line">MyPersonDecoder decode invoked!</span><br><span class="line">服务端接收到的数据：</span><br><span class="line">长度；17</span><br><span class="line">内容：sent from client </span><br><span class="line">服务端接受到的消息数量：10</span><br><span class="line">MyPersonEncoder encode invoked!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud项目实践(二)</title>
    <url>/2016/03/21/springcloud/Spring-cloud%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="配置中心和服务注册中心"><a href="#配置中心和服务注册中心" class="headerlink" title="配置中心和服务注册中心"></a>配置中心和服务注册中心</h1><p>我们先把配置中心和服务注册中心跑起来，这个先照着之前的教程做，很简单没什么变动。<br>就是git仓库需要密码的话加入下面的配置就好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: configserver</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;config.host:192.168.99.100&#125;:8761&#x2F;eureka&#x2F;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: yourgiturl</span><br><span class="line">          password: ****</span><br><span class="line">          username: ****</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的<code>$&#123;config.host:192.168.99.100&#125;</code>表示没有读到config.host就用192.168.99.100这个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar cloud-simple-service-1.0.0.jar --config.host&#x3D;localhost</span><br></pre></td></tr></table></figure>

<p>这个用法就很灵活了，后面配合Dockerfile可以根据不同的环境来启动不同的配置。</p>
<a id="more"></a>

<h1 id="微服务应用"><a href="#微服务应用" class="headerlink" title="微服务应用"></a>微服务应用</h1><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p><a href="http://www.cnblogs.com/skyblog/p/5129603.html">http://www.cnblogs.com/skyblog/p/5129603.html</a><br>这篇文章讲了如何配置一个使用myabtis的项目，我们照着他的做就可以了。</p>
<h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>我这里说一下配置mongodb遇到的问题。<br>首先在<strong>pom.xml</strong>中加入mongodb的依赖。因为我是用的<em>mongodb3</em>，spring-boot-starter-data-mongodb依赖的驱动是2.0版本的，需要修改一下，加入3.0驱动的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--mongo驱动版本过低--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.mongodb&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mongo-java-driver&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mongodb&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mongo-java-driver&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&#96;&#96;&#96;     </span><br><span class="line"></span><br><span class="line">不过还是认证会出错，解决方案参考下面的文章。	</span><br><span class="line">[http:&#x2F;&#x2F;zjumty.iteye.com&#x2F;blog&#x2F;2198432](http:&#x2F;&#x2F;zjumty.iteye.com&#x2F;blog&#x2F;2198432)</span><br><span class="line"></span><br><span class="line">照着这个文章做完依然还是有错误，所以我这里还有一些额外的改动，一共自建了3个类。</span><br><span class="line">首先在&#96;Application.java&#96;里新加上&#96;MongoAutoConfiguration.class&#96;，&#96;MongoDataAutoConfiguration.class&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class, MongoAutoConfiguration.class, MongoDataAutoConfiguration.class})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义的3个类如下		</span><br><span class="line">&#96;MongoProperties.java&#96;		</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;spring.data.mongodb&quot;)</span><br><span class="line">public class MongoProperties &#123;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_PORT &#x3D; 27017;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Mongo server host.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String host;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Mongo server port.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer port &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Mongo database URI. When set, host and port are ignored.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String uri &#x3D; &quot;mongodb:&#x2F;&#x2F;localhost&#x2F;test&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Database name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Authentication database name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String authenticationDatabase;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * GridFS database name.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String gridFsDatabase;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Login user of the mongo server.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Login password of the mongo server.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private char[] password;</span><br><span class="line"></span><br><span class="line">    public String getHost() &#123;</span><br><span class="line">        return this.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHost(String host) &#123;</span><br><span class="line">        this.host &#x3D; host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDatabase() &#123;</span><br><span class="line">        return this.database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDatabase(String database) &#123;</span><br><span class="line">        this.database &#x3D; database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthenticationDatabase() &#123;</span><br><span class="line">        return this.authenticationDatabase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthenticationDatabase(String authenticationDatabase) &#123;</span><br><span class="line">        this.authenticationDatabase &#x3D; authenticationDatabase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return this.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public char[] getPassword() &#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(char[] password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clearPassword() &#123;</span><br><span class="line">        if (this.password &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; this.password.length; i++) &#123;</span><br><span class="line">            this.password[i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUri() &#123;</span><br><span class="line">        return this.uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUri(String uri) &#123;</span><br><span class="line">        this.uri &#x3D; uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPort() &#123;</span><br><span class="line">        return this.port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPort(Integer port) &#123;</span><br><span class="line">        this.port &#x3D; port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGridFsDatabase() &#123;</span><br><span class="line">        return this.gridFsDatabase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGridFsDatabase(String gridFsDatabase) &#123;</span><br><span class="line">        this.gridFsDatabase &#x3D; gridFsDatabase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMongoClientDatabase() &#123;</span><br><span class="line">        if (this.database !&#x3D; null) &#123;</span><br><span class="line">            return this.database;</span><br><span class="line">        &#125;</span><br><span class="line">        return new MongoClientURI(this.uri).getDatabase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MongoClient createMongoClient(MongoClientOptions options)</span><br><span class="line">            throws UnknownHostException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hasCustomAddress() || hasCustomCredentials()) &#123;</span><br><span class="line">                if (options &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    options &#x3D; MongoClientOptions.builder().build();</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;MongoCredential&gt; credentials &#x3D; null;</span><br><span class="line">                if (hasCustomCredentials()) &#123;</span><br><span class="line">                    String database &#x3D; this.authenticationDatabase &#x3D;&#x3D; null</span><br><span class="line">                            ? getMongoClientDatabase() : this.authenticationDatabase;</span><br><span class="line">                    credentials &#x3D; Arrays.asList(MongoCredential.createScramSha1Credential(</span><br><span class="line">                            this.username, database, this.password));</span><br><span class="line">                &#125;</span><br><span class="line">                String host &#x3D; this.host &#x3D;&#x3D; null ? &quot;localhost&quot; : this.host;</span><br><span class="line">                int port &#x3D; this.port &#x3D;&#x3D; null ? DEFAULT_PORT : this.port;</span><br><span class="line">                return new MongoClient(Arrays.asList(new ServerAddress(host, port)),</span><br><span class="line">                        credentials, options);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; The options and credentials are in the URI</span><br><span class="line">            return new MongoClient(new MongoClientURI(this.uri, builder(options)));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clearPassword();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean hasCustomAddress() &#123;</span><br><span class="line">        return this.host !&#x3D; null || this.port !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean hasCustomCredentials() &#123;</span><br><span class="line">        return this.username !&#x3D; null &amp;&amp; this.password !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MongoClientOptions.Builder builder(MongoClientOptions options) &#123;</span><br><span class="line">        MongoClientOptions.Builder builder &#x3D; MongoClientOptions.builder();</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            builder.alwaysUseMBeans(options.isAlwaysUseMBeans());</span><br><span class="line">            builder.connectionsPerHost(options.getConnectionsPerHost());</span><br><span class="line">            builder.connectTimeout(options.getConnectTimeout());</span><br><span class="line">            builder.cursorFinalizerEnabled(options.isCursorFinalizerEnabled());</span><br><span class="line">            builder.dbDecoderFactory(options.getDbDecoderFactory());</span><br><span class="line">            builder.dbEncoderFactory(options.getDbEncoderFactory());</span><br><span class="line">            builder.description(options.getDescription());</span><br><span class="line">            builder.maxWaitTime(options.getMaxWaitTime());</span><br><span class="line">            builder.readPreference(options.getReadPreference());</span><br><span class="line">            builder.socketFactory(options.getSocketFactory());</span><br><span class="line">            builder.socketKeepAlive(options.isSocketKeepAlive());</span><br><span class="line">            builder.socketTimeout(options.getSocketTimeout());</span><br><span class="line">            builder.threadsAllowedToBlockForConnectionMultiplier(</span><br><span class="line">                    options.getThreadsAllowedToBlockForConnectionMultiplier());</span><br><span class="line">            builder.writeConcern(options.getWriteConcern());</span><br><span class="line">        &#125;</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里跟上面的文章是一样的，就是<code>MongoCredential.createScramSha1Credential</code>这一句不一样而已。而且<code>MongoCredential.createScramSha1Credential</code>这个方法是在3.0的驱动里面才有的。</p>
<p>然后是<code>MongoConfiguration.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(MongoProperties.class)</span><br><span class="line">public class MongoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MongoProperties properties;</span><br><span class="line"></span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    private MongoClientOptions options;</span><br><span class="line"></span><br><span class="line">    private Mongo mongo;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        if (this.mongo !&#x3D; null) &#123;</span><br><span class="line">            this.mongo.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Mongo mongo() throws UnknownHostException &#123;</span><br><span class="line">        this.mongo &#x3D; this.properties.createMongoClient(this.options);</span><br><span class="line">        return this.mongo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就引用我们刚才自建的MongoProperties，这样spring在链接mngodb的时候就不会认证出错了。不过我还遇到了了另外一个问题，MongoDataAutoConfiguration引用的MongoProperties也得换成我们自己的，而且升级成3.0的驱动以后，MongoDataAutoConfiguration里面的代码还得修改一下才能正常运行。下面是我修改以后的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123;Mongo.class, MongoTemplate.class&#125;)</span><br><span class="line">@EnableConfigurationProperties(MongoProperties.class)</span><br><span class="line">@AutoConfigureAfter(MongoConfiguration.class)</span><br><span class="line">public class MongoDataConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MongoProperties properties;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public MongoDbFactory mongoDbFactory(Mongo mongo) throws Exception &#123;</span><br><span class="line">        String database &#x3D; this.properties.getMongoClientDatabase();</span><br><span class="line">&#x2F;&#x2F;        String authDatabase &#x3D; this.properties.getAuthenticationDatabase();</span><br><span class="line">&#x2F;&#x2F;        if (StringUtils.hasLength(authDatabase)) &#123;</span><br><span class="line">&#x2F;&#x2F;            String username &#x3D; this.properties.getUsername();</span><br><span class="line">&#x2F;&#x2F;            String password &#x3D; new String(this.properties.getPassword());</span><br><span class="line">&#x2F;&#x2F;            UserCredentials credentials &#x3D; new UserCredentials(username, password);</span><br><span class="line">&#x2F;&#x2F;            return new SimpleMongoDbFactory(mongo, database, credentials, authDatabase);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        return new SimpleMongoDbFactory(mongo, database);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public MongoTemplate mongoTemplate(MongoDbFactory mongoDbFactory,</span><br><span class="line">                                       MongoConverter converter) throws UnknownHostException &#123;</span><br><span class="line">        return new MongoTemplate(mongoDbFactory, converter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(MongoConverter.class)</span><br><span class="line">    public MappingMongoConverter mappingMongoConverter(MongoDbFactory factory,</span><br><span class="line">                                                       MongoMappingContext context, BeanFactory beanFactory) &#123;</span><br><span class="line">        DbRefResolver dbRefResolver &#x3D; new DefaultDbRefResolver(factory);</span><br><span class="line">        MappingMongoConverter mappingConverter &#x3D; new MappingMongoConverter(dbRefResolver,</span><br><span class="line">                context);</span><br><span class="line">        try &#123;</span><br><span class="line">            mappingConverter</span><br><span class="line">                    .setCustomConversions(beanFactory.getBean(CustomConversions.class));</span><br><span class="line">        &#125; catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; Ignore</span><br><span class="line">        &#125;</span><br><span class="line">        return mappingConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public MongoMappingContext mongoMappingContext(BeanFactory beanFactory)</span><br><span class="line">            throws ClassNotFoundException &#123;</span><br><span class="line">        MongoMappingContext context &#x3D; new MongoMappingContext();</span><br><span class="line">        context.setInitialEntitySet(getInitialEntitySet(beanFactory));</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Set&lt;Class&lt;?&gt;&gt; getInitialEntitySet(BeanFactory beanFactory)</span><br><span class="line">            throws ClassNotFoundException &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; entitySet &#x3D; new HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner &#x3D; new ClassPathScanningCandidateComponentProvider(</span><br><span class="line">                false);</span><br><span class="line">        scanner.setEnvironment(this.environment);</span><br><span class="line">        scanner.setResourceLoader(this.resourceLoader);</span><br><span class="line">        scanner.addIncludeFilter(new AnnotationTypeFilter(Document.class));</span><br><span class="line">        scanner.addIncludeFilter(new AnnotationTypeFilter(Persistent.class));</span><br><span class="line">        for (String basePackage : getMappingBasePackages(beanFactory)) &#123;</span><br><span class="line">            if (StringUtils.hasText(basePackage)) &#123;</span><br><span class="line">                for (BeanDefinition candidate : scanner</span><br><span class="line">                        .findCandidateComponents(basePackage)) &#123;</span><br><span class="line">                    entitySet.add(ClassUtils.forName(candidate.getBeanClassName(),</span><br><span class="line">                            MongoDataConfiguration.class.getClassLoader()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return entitySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Collection&lt;String&gt; getMappingBasePackages(BeanFactory beanFactory) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return AutoConfigurationPackages.get(beanFactory);</span><br><span class="line">        &#125; catch (IllegalStateException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; no auto-configuration package registered yet</span><br><span class="line">            return Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public GridFsTemplate gridFsTemplate(MongoDbFactory mongoDbFactory,</span><br><span class="line">                                         MongoTemplate mongoTemplate) &#123;</span><br><span class="line">        return new GridFsTemplate(</span><br><span class="line">                new GridFsMongoDbFactory(mongoDbFactory, this.properties),</span><br><span class="line">                mongoTemplate.getConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#123;@link MongoDbFactory&#125; decorator to respect</span><br><span class="line">     * &#123;@link MongoProperties#getGridFsDatabase()&#125; if set.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class GridFsMongoDbFactory implements MongoDbFactory &#123;</span><br><span class="line"></span><br><span class="line">        private final MongoDbFactory mongoDbFactory;</span><br><span class="line"></span><br><span class="line">        private final MongoProperties properties;</span><br><span class="line"></span><br><span class="line">        public GridFsMongoDbFactory(MongoDbFactory mongoDbFactory,</span><br><span class="line">                                    MongoProperties properties) &#123;</span><br><span class="line">            Assert.notNull(mongoDbFactory, &quot;MongoDbFactory must not be null&quot;);</span><br><span class="line">            Assert.notNull(properties, &quot;Properties must not be null&quot;);</span><br><span class="line">            this.mongoDbFactory &#x3D; mongoDbFactory;</span><br><span class="line">            this.properties &#x3D; properties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public DB getDb() throws DataAccessException &#123;</span><br><span class="line">            String gridFsDatabase &#x3D; this.properties.getGridFsDatabase();</span><br><span class="line">            if (StringUtils.hasText(gridFsDatabase)) &#123;</span><br><span class="line">                return this.mongoDbFactory.getDb(gridFsDatabase);</span><br><span class="line">            &#125;</span><br><span class="line">            return this.mongoDbFactory.getDb();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public DB getDb(String dbName) throws DataAccessException &#123;</span><br><span class="line">            return this.mongoDbFactory.getDb(dbName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public PersistenceExceptionTranslator getExceptionTranslator() &#123;</span><br><span class="line">            return this.mongoDbFactory.getExceptionTranslator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MongoTemplate syslogMongoTemplate(Mongo mongo) &#123;</span><br><span class="line">        return new MongoTemplate(mongo, &quot;syslog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我注释掉了一些代码，然后授权就正常了，估计3.0以后认证方式改了，这些API已经完全被弃用了，使用的话会直接抛异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserCredentials credentials &#x3D; new UserCredentials(username, password);</span><br><span class="line">return new SimpleMongoDbFactory(mongo, database, credentials, authDatabase);</span><br></pre></td></tr></table></figure>
<p>点进去看看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create an instance of SimpleMongoDbFactory given the Mongo instance, database name, and username&#x2F;password</span><br><span class="line"> * </span><br><span class="line"> * @param mongo Mongo instance, must not be &#123;@literal null&#125;.</span><br><span class="line"> * @param databaseName Database name, must not be &#123;@literal null&#125; or empty.</span><br><span class="line"> * @param credentials username and password.</span><br><span class="line"> * @param authenticationDatabaseName the database name to use for authentication</span><br><span class="line"> * @deprecated since 1.7. The credentials used should be provided by &#123;@link MongoClient#getCredentialsList()&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Deprecated</span><br><span class="line">public SimpleMongoDbFactory(Mongo mongo, String databaseName, UserCredentials credentials,</span><br><span class="line">        String authenticationDatabaseName) &#123;</span><br><span class="line">    this(mongo, databaseName, credentials, false, authenticationDatabaseName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是针对不同DB不同MongoTemplate的配置了，以后使用的话只需要在相应的类里注入就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MongoTemplate syslogMongoTemplate(Mongo mongo) &#123;</span><br><span class="line">    return new MongoTemplate(mongo, &quot;syslog&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private MongoTemplate syslogMongoTemplate;</span><br></pre></td></tr></table></figure>

<h3 id="Mongodb配置信息"><a href="#Mongodb配置信息" class="headerlink" title="Mongodb配置信息"></a>Mongodb配置信息</h3><p>可以看到在<code>MongoProperties</code>中有一个注解是<code>@ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;)</code>。spring-boot会默认读取这些配置，由于我们使用了配置中心。所以它也能从配置中心的配置文件中读取到，不需要配置在本地。(我把示例demo中的properties换成了yml的配置方式)        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldb:</span><br><span class="line">    datasource:</span><br><span class="line">        url: jdbc\:mysql\:&#x2F;&#x2F;localhost\:3306&#x2F;test?useUnicode\&#x3D;true&amp;characterEncoding\&#x3D;utf-8</span><br><span class="line">        username: csst</span><br><span class="line">        password: csst</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    data:</span><br><span class="line">      mongodb:</span><br><span class="line">        host: 10.168.248.36</span><br><span class="line">        port: 27017</span><br><span class="line">        username: test</span><br><span class="line">        password: test</span><br><span class="line">        authenticationDatabase: admin</span><br></pre></td></tr></table></figure>

<p>就这样加在之前配置文件中就好。如果在调试的过程中发现配置没有读取到，可以用下面的方式来查看配置中心是否配置正确并且已经开启服务。<br><code>http://10.168.248.36:8888/user-dev.yml</code><br><code>http://10.168.248.36:8888/user-dev.properties</code><br>在配置中心的后面加上配置文件的名字可以直接在浏览器中查看。在调试配置中心的时候也可以采取这样的操作，这样你能看到你的git地址和授权错误信息等。</p>
<p>spring-data-mongo提供了一个<code>MongoRepository</code>实现增删改查和复杂查询，在spring-boot中如何指定它使用哪个db呢？如果不配置他默认是使用的test。我测试了一下，加入下面的配置类就可以了。可以扫描一个包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMongoRepositories(basePackageClasses &#x3D; ApiLogRepository.class)</span><br><span class="line">@AutoConfigureAfter(MongoDataAutoConfiguration.class)</span><br><span class="line">public class SysLogDB extends AbstractMongoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Mongo mongo;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getDatabaseName() &#123;</span><br><span class="line">        return &quot;syslog&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mongo mongo() throws Exception &#123;</span><br><span class="line">        return mongo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里服务应用项目的mybatis和mongodb都配置好了，可以进行业务代码开发了。没有一个xml配置文件的感觉是不是很爽？下一篇文章讲解如何通过jenkins进行持续集成开发。</p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码04-服务心跳、下线、故障和服务自我保护机制流程分析</title>
    <url>/2020/03/22/springcloud/eureka04/</url>
    <content><![CDATA[<h1 id="服务心跳流程分析"><a href="#服务心跳流程分析" class="headerlink" title="服务心跳流程分析"></a>服务心跳流程分析</h1><p>eureka client每隔一定的时间，会给eureka server发送心跳，保持心跳，让eureka server认为自己还活着。</p>
<p>心跳在代码里，叫做续约。</p>
<ol>
<li><p>还是在DiscoveryClient初始化的时候，有一个心跳的定时任务，由<code>HeartbeatThread</code>执行。</p>
</li>
<li><p>默认值是每隔30秒去发送一个心跳。DEFAULT_LEASE_RENEWAL_INTERVAL</p>
</li>
<li><p>接下来是用jersy去给eureka server发送心跳的http请求。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>请求的地址是：<code>PUT apps/&#123;appName&#125;/&#123;id&#125;</code></p>
</li>
<li><p>我们根据这个接口去找下是什么类处理的请求，这个又是让我好一顿找：在ApplicationsResource里有个<code>@Path(&quot;&#123;appId&#125;&quot;)</code>，这里已经组成了路径<code>apps/&#123;appId&#125;</code>，然后在ApplicationsResource里边又有一个``@Path(“{id}”)<code>方法，到这里就是</code>apps/{appId}/{id}`，是不是刚好符合客户端的请求路径，但是还是没有定位到PUT方法在哪里，继续看InstanceResource里的renewLease方法，配合参数看下，终于才找到了server端处理心跳逻辑的代码。<em>不得不说这个隐藏的真是比较深，你看那个getInstanceInfo方法，你很难想到这个get方法只是一个路径的节点，具体的处理还得继续往里跟。应该是也因为我不熟悉jersy这个框架，不知道怎么快速定位一个mvc路径的执行代码。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ApplicationsResource</span></span><br><span class="line"><span class="meta">@Path(&quot;&#123;appId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@PathParam(&quot;version&quot;)</span> String version,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@PathParam(&quot;appId&quot;)</span> String appId)</span> </span>&#123;</span><br><span class="line">    CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ApplicationResource</span></span><br><span class="line"><span class="meta">@Path(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InstanceResource <span class="title">getInstanceInfo</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceResource(<span class="keyword">this</span>, id, serverConfig, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstanceResource</span></span><br><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;overriddenstatus&quot;)</span> String overriddenStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;status&quot;)</span> String status,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@QueryParam(&quot;lastDirtyTimestamp&quot;)</span> String lastDirtyTimestamp)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过注册表的renew方法，完成服务续约的逻辑。registry.renew，实际还是进入AbstractInstanceRegistry.renew这个方法里。</p>
</li>
<li><p>用appName获取服务注册表那个map，做了一些检查。最后执行续约的逻辑（leaseToRenew.renew();）其实就是更新了一下lastUpdateTimestamp的时间，加上了duration。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line"><span class="comment">// 一些代码</span></span><br><span class="line">leaseToRenew.renew();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="服务下线流程分析"><a href="#服务下线流程分析" class="headerlink" title="服务下线流程分析"></a>服务下线流程分析</h1><p>下面看一下DiscoveryClient的shutdown方法的逻辑。</p>
<ol>
<li><p>在eureka client里，得自己调用一下eurekaClient.shutodwn()方法来进行服务下线。关注里边的unregister();方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</span><br></pre></td></tr></table></figure>

<p>对应的路径是，<code>DELETE apps/&#123;appName&#125;/&#123;id&#125;</code>，和上面一样，是在InstanceResource类里的cancelLease方法。</p>
</li>
<li><p>最后跟着源码里走，执行的的逻辑是AbstractInstanceRegistry.internalCancel方法。</p>
</li>
<li><p>取到注册表的map，直接调用remove从map里给移除了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">....</span><br><span class="line">gMap.remove(id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后调用了leaseToCancel.cancel();，设置了evictionTimestamp时间。</p>
</li>
<li><p>在recentlyChangedQueue里新增了一条服务实例变更记录，保留3分钟。（用于在客户端进行增量更新的时候进行合并）</p>
</li>
<li><p>调用invalidateCache，让缓存失效，从readWriteCacheMap里全部清理掉。会有定时任务每隔30秒让readOnlyCacheMap和readWriteCacheMap进行同步。这部分逻辑在上一篇文章有分析到。</p>
</li>
<li><p><strong>下次所有的eureka client来拉取增量注册表的时候，就会返回recentlyChangedQueue里的数据，然后在本地进行合并，比对hash值，再决定是否重新拉取全量注册表的逻辑。</strong></p>
</li>
</ol>
<p><img src="/img/spring-cloud/image-20200322230318802.png" alt="image-20200322230318802"></p>
<p>这里再一次体现了，无论是服务注册、故障、还是下线了，都会将变更记录放进<strong>recentlyChangedQueue</strong>里，eureka client在30秒的增量更新定时任务里，去合并新的服务列表。readOnlyCacheMap从readWriteCacheMap同步的时间也是30秒。所以服务最长可能60秒才能感知到服务的下线。</p>
<h1 id="服务故障流程分析"><a href="#服务故障流程分析" class="headerlink" title="服务故障流程分析"></a>服务故障流程分析</h1><p>如果客户端在故障后，没有通知eureka server服务下线。那么就需要用到eureka server自己的故障感应机制，以及服务实例摘除的机制。</p>
<p>eureka server是靠心跳来感知服务是否存活，如果在一定时间内没有收到心跳，那么就认为服务已经宕机了，此时会修改服务状态，并进行摘除。</p>
<p>可以判定，肯定是有一个定时任务，在定时的判断。就是EurekaBootStrap初始化方法里的这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line">AbstractInstanceRegistry.postInit()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    renewsLastMin.start();</span><br><span class="line">    <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        evictionTaskRef.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">    evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每隔60秒，会执行一次任务，判断服务实例的租约是否已经过期了，虽然定时任务是60秒一次，这里有个getCompensationTimeMs();方法，计算上次心跳，到这次任务执行的时间差到底是多少，从而保证准确的计算过期时间，因为可能jvm gc原因或者时钟原因，并没有刚好60秒执行这次的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前时间</span></span><br><span class="line">  <span class="keyword">long</span> currNanos = getCurrentTimeNano();</span><br><span class="line">  <span class="comment">// 上次任务的时间</span></span><br><span class="line">  <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</span><br><span class="line">  <span class="keyword">if</span> (lastNanos == <span class="number">0l</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0l</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 间隔时间是和配置的时间间隔，getEvictionIntervalTimerInMs默认是60秒</span></span><br><span class="line">  <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</span><br><span class="line">  <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</span><br><span class="line">  <span class="keyword">return</span> compensationTime &lt;= <span class="number">0l</span> ? <span class="number">0l</span> : compensationTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line"><span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line"><span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">  Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">  <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">      Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        expiredLeases.add(lease);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否过期</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if the lease of a given &#123;<span class="doctag">@link</span> com.netflix.appinfo.InstanceInfo&#125; has expired or not.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that due to renew() doing the &#x27;wrong&quot; thing and setting lastUpdateTimestamp to +duration more than</span></span><br><span class="line"><span class="comment">     * what it should be, the expiry will actually be 2 * duration. This is a minor bug and should only affect</span></span><br><span class="line"><span class="comment">     * instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will</span></span><br><span class="line"><span class="comment">     * not be fixed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalLeaseMs any additional lease time to add to the lease evaluation in ms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lastUpdateTimestamp上次心跳时间+90秒+比预期的任务时间晚了多少秒。</span></span><br><span class="line">  <span class="comment">// 看似这里的逻辑是，在不计算预期任务执行的时间情况下，90s没有收到过心跳就认为已经过期</span></span><br><span class="line">  <span class="comment">// 但是看上面的注释，其实这里是有一个bug，因为在心跳的时候，时间就已经+了duration，比如上次心跳的时间 22:47:44，那么lastUpdateTimestamp就是22:49:14</span></span><br><span class="line">  <span class="comment">// 所以在这里判断的时候，真正判断的过期时间是22:50:44，相比上次心跳，已经是过去了180s的时间。</span></span><br><span class="line">  <span class="comment">// 并且这个bug不打算修复</span></span><br><span class="line">  <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，要3分钟没有收到心跳，才会剔除一个服务的实例。</p>
<p>接着后面就是拆除服务实例的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性不能摘除太多的实例，因为有可能是eureka server节点自己的网络故障原因，导致没有心跳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line"><span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line"><span class="comment">// 所以想下面计算了一个比例，比如当前注册表的大小是20，getRenewalPercentThreshold的默认值是0.85，</span></span><br><span class="line"><span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line"><span class="comment">// 这里是17</span></span><br><span class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line"><span class="comment">// 所以限制最多只能是3个</span></span><br><span class="line"><span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设expiredLeases过期了6个，和3个里选个最小值，这里是3，随机再从6个里选3个摘除，最后调用internalCancel（服务下线的方法）</span></span><br><span class="line"><span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line"><span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)&quot;</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line"></span><br><span class="line">  Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">    <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">    <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br></pre></td></tr></table></figure>



<p>最后调用internalCancel（服务下线的方法）。所以说一个服务如果没有心跳了，可能需要定时任务60秒+心跳时间90秒+过期判断90s，也许要4分钟以上，才能感知一个服务下线了，再加上客户端同步的间隔时间，时间就会更长。</p>
<h1 id="服务自我保护机制"><a href="#服务自我保护机制" class="headerlink" title="服务自我保护机制"></a>服务自我保护机制</h1><p>下面看一下eureka server自我保护机制。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>如果有20个服务实例，在1分钟以内，只有8个服务保持了心跳，那么eureka server会将剩余的12个没有心跳的服务实例全部摘除吗？其实不是的，有可能是由于eureka server自己的机器所在的网络故障了，导致那些服务心跳发送不过来，导致eureka server一直没有更新心跳的时间。</p>
<p>进入自我保护机制以后，就不会摘除任何实例了。</p>
<p>还是看上面一节的evict方法，第一行就有一个判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否允许主动删除实例，和自我保护机制有关</span></span><br><span class="line"><span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;DS: lease expiration is currently disabled.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码命名其实也是非常奇怪的，你光看名字，永远也想不到isLeaseExpirationEnabled方法里会包含自我保护机制的触发代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果关闭自我保护机制，随时可以清理实例</span></span><br><span class="line">  <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">    <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 会触发自我保护机制</span></span><br><span class="line">  <span class="comment">// numberOfRenewsPerMinThreshold 期望所有服务实例1分钟要有发送多少次心跳过来</span></span><br><span class="line">  <span class="comment">// getNumOfRenewsInLastMin() 上1分钟所有服务实例一共发送多少次心跳</span></span><br><span class="line">  <span class="comment">// 如果上一分钟的心跳次数（假设是102次） &gt; 我所期望的心跳次数，那么返回true，就可以清理服务实例</span></span><br><span class="line">  <span class="comment">// 如果上次心跳次数（假设20次） &lt; 我期望的100次，此时返回false，表示不清理服务实例。</span></span><br><span class="line">  <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="isLeaseExpirationEnabled方法判断自我保护机制开启"><a href="#isLeaseExpirationEnabled方法判断自我保护机制开启" class="headerlink" title="isLeaseExpirationEnabled方法判断自我保护机制开启"></a>isLeaseExpirationEnabled方法判断自我保护机制开启</h3><p>在evict服务故障的定时任务中，有个isLeaseExpirationEnabled方法会判断<strong>上一分钟的心跳次数</strong>是否小于<strong>期望的一分钟内心跳次数</strong>，如果小于，那么不会清理服务实例。</p>
<h3 id="如何计算期望的一分钟心跳次数"><a href="#如何计算期望的一分钟心跳次数" class="headerlink" title="如何计算期望的一分钟心跳次数"></a>如何计算期望的一分钟心跳次数</h3><p><strong>numberOfRenewsPerMinThreshold的值是如何设定的？</strong></p>
<ol>
<li><p>EurekaBootStrap是启动初始化的类，有一行registry.openForTraffic（开启故障检查）的代码，完成了numberOfRenewsPerMinThreshold的初始化。<br>首先调用sync方法，从相邻的eureka server节点拷贝注册表（调用服务实例列表后注册到本地），拿到服务实例的数量。服务实例数量 * 2 * getRenewalPercentThreshold(0.85)。得到numberOfRenewsPerMinThreshold。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></span><br><span class="line"><span class="comment">// 如果心跳时间间隔修改了怎么办？这里不应该硬编码，应该用心跳间隔时间作来计算。</span></span><br><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// count * 2 * 0.85</span></span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">  (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上这里的*2的操作，是很迷的一种写法，首先他这个地方硬编码了。然后他想表达的意思是，如果有10个实例，那么就在1分钟以内，要收到20次心跳，因为30秒一次心跳嘛。可是如果用户自己修改了心跳的间隔2时间，那这个地方不就BUG了吗？</p>
</blockquote>
</li>
<li><p>在注册、下线、故障的时候，肯定也会更新值，这里有个小技巧，我们要查找一个变量在哪些地方赋值过。可以在IDEA里按快捷 <code>ALT+F7</code>，在看源码的时候非常有用，如截图所示，在前边有红色一根笔的小图标，可以看得出来是写操作，绿色一本书是读操作。<br><img src="/img/spring-cloud/image-20200329171857177.png" alt="image-20200329171857177"><br>AbstractInstanceRegistry.register方法中，这里再一次做了硬编码，新注册一个实例后，每分钟期望的心跳次数就会 <code>+ 2</code>。一样的，下线就是<code>-2</code>。<strong>那么故障的时候有更新这个值吗？我反正是没有找到，直接调用internalCancel方法不会去更新这个值，所以这应该是一个BUG！！！因为如果都是因为故障下线的，这个期望的心跳值并没有更新，实际的心跳次数又变少。那么每次在清除实例的时候，可能导致快速的开启了自我保护机制，而不再去清理任何的实例了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">(<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时更新，根据<code>ALT+F7</code>的方式，PeerAwareInstanceRegistryImpl初始化的时候，启了定时调度任务，默认是15分钟执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      updateRenewalThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span><br><span class="line">                 serverConfig.getRenewalThresholdUpdateIntervalMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在updateRenewalThreshold任务中，从别的服务同步并合并注册表。然后计算出一个服务实例的数量。如果拉取到的服务实例数量，大于本地的期望的服务实例数量<em>0.85。**我觉得这里是不是写错了，numberOfRenewsPerMinThreshold本来就是count\</em>2*0.85，这里判断再*0.85？？？**接着再次计算了一下服务实例列表的count，count * 2 * 0.85。这个代码也是骚的很，刚计算了<code>expectedNumberOfRenewsPerMin=count * 2</code>，下面却不用这个变量，又写了一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">  <span class="comment">// Update threshold only if the threshold is greater than the</span></span><br><span class="line">  <span class="comment">// current expected threshold of if the self preservation is disabled.</span></span><br><span class="line">  <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</span><br><span class="line">      || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span><br><span class="line">    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="实际的上一分钟心跳次数是如何计算的？"><a href="#实际的上一分钟心跳次数是如何计算的？" class="headerlink" title="实际的上一分钟心跳次数是如何计算的？"></a>实际的上一分钟心跳次数是如何计算的？</h3><p>回到前面判断是否开启自我保护的代码，实际的上一分钟心跳次数getNumOfRenewsInLastMin()，用到了MeasuredRate，我们可以用<code>ALT + F7</code>去找increment方法的调用处，直接定位到了renew(心跳)的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际的上一分钟心跳次数 + 1</span></span><br><span class="line">renewsLastMin.increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部实现细节----如何计算并保持上1分钟的数据？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每分钟一次，设置到lastBucket中，currentBucket设置为0</span></span><br><span class="line"><span class="comment">// lastBucket是用来读的，currentBucket是用来写的</span></span><br><span class="line"><span class="comment">// Zero out the current bucket.</span></span><br><span class="line">lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h3 id="自我保护机制的触发"><a href="#自我保护机制的触发" class="headerlink" title="自我保护机制的触发"></a>自我保护机制的触发</h3><p>如果上一分钟，实际的心跳次数少于了期望的心跳次数，那么就会开启自我保护机制，不允许摘除任何服务实例。此时认为自己的eureka server出现网络故障，大量的服务实例无法发送心跳过来。</p>
<p><img src="/img/spring-cloud/image-20200329182748663.png" alt="image-20200329182748663"></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix介绍和简单使用</title>
    <url>/2018/03/11/springcloud/hystrix01/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h1 id="Hystrix是什么？"><a href="#Hystrix是什么？" class="headerlink" title="Hystrix是什么？"></a>Hystrix是什么？</h1><p>在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。</p>
<p>Hystrix可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。</p>
<a id="more"></a>
<p>Hystrix通过将依赖服务进行资源隔离，进而组织某个依赖服务出现故障的时候，这种故障在整个系统所有的依赖服务调用中进行蔓延，同时Hystrix还提供故障时的fallback降级机制</p>
<p>总而言之，Hystrix通过这些方法帮助我们提升分布式系统的可用性和稳定性。</p>
<p><img src="/img/hystrix/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%B8%AD%E7%9A%84%E6%95%85%E9%9A%9C%E5%92%8Chystrix.png" alt="什么是分布式系统以及其中的故障和hystrix"></p>
<h1 id="Hystrix的历史"><a href="#Hystrix的历史" class="headerlink" title="Hystrix的历史"></a>Hystrix的历史</h1><p>hystrix就是一种高可用保障的一个框架，预先封装好的为了解决某个特定领域的特定问题的一套代码库。用了框架之后，来解决这个领域的特定的问题，就可以大大减少我们的工作量，提升我们的工作质量和工作效率。</p>
<p>Netflix（可以认为是国外的优酷或者爱奇艺之类的视频网站），API团队从2011年开始做一些提升系统可用性和稳定性的工作，Hystrix就是从那时候开始发展出来的。</p>
<p>在2012年的时候，Hystrix就变得比较成熟和稳定了，Netflix中，除了API团队以外，很多其他的团队都开始使用Hystrix。</p>
<p>时至今日，Netflix中每天都有数十亿次的服务间调用，通过Hystrix框架在进行，而Hystrix也帮助Netflix网站提升了整体的可用性和稳定性</p>
<h1 id="Hystrix的设计原则"><a href="#Hystrix的设计原则" class="headerlink" title="Hystrix的设计原则"></a>Hystrix的设计原则</h1><p>hystrix为了实现高可用性的架构，它的设计原则:</p>
<ol>
<li>对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护</li>
<li>在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延，服务A-&gt;服务B-&gt;服务C，服务C故障了，服务B也故障了，服务A故障了，整套分布式系统全部故障，整体宕机</li>
<li>提供fail-fast（快速失败）和快速恢复的支持</li>
<li>提供fallback优雅降级的支持</li>
<li>支持近实时的监控、报警以及运维操作</li>
</ol>
<h1 id="Hystrix要解决的问题"><a href="#Hystrix要解决的问题" class="headerlink" title="Hystrix要解决的问题"></a>Hystrix要解决的问题</h1><p>在复杂的分布式系统架构中，每个服务都有很多的依赖服务，而每个依赖服务都可能会故障。如果服务没有和自己的依赖服务进行隔离，那么可能某一个依赖服务的故障就会拖垮当前这个服务。</p>
<p>举例来说，某个服务有30个依赖服务，每个依赖服务的可用性非常高，已经达到了99.99%的高可用性，那么该服务的可用性就是99.99%的30次方，也就是99.7%的可用性，99.7%的可用性就意味着0.3%的请求可能会失败，因为0.3%的时间内系统可能出现了故障导致系统不可用。对于1亿次访问来说，0.3%的请求失败，也就意味着30万次请求会失败，也意味着每个月有2个小时的时间系统是不可用的。</p>
<p>在真实生产环境中，可能更加糟糕，也就是说，即使你每个依赖服务都是99.99%高可用性，但是一旦你有几十个依赖服务，还是会导致你每个月都有几个小时是不可用的。</p>
<p><img src="/img/hystrix/%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%85%E9%9A%9C%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E8%A2%AB%E6%8B%96%E5%9E%AE%E4%BB%A5%E5%8F%8A%E6%95%85%E9%9A%9C%E7%9A%84%E8%94%93%E5%BB%B6.png" alt="依赖服务的故障导致服务被拖垮以及故障的蔓延"></p>
<h1 id="Hystrix的更加细节的设计原则"><a href="#Hystrix的更加细节的设计原则" class="headerlink" title="Hystrix的更加细节的设计原则"></a>Hystrix的更加细节的设计原则</h1><ol>
<li>阻止任何一个依赖服务耗尽所有的资源，比如tomcat中的所有线程资源</li>
<li>避免请求排队和积压，采用限流和fail fast来控制故障</li>
<li>提供fallback降级机制来应对故障</li>
<li>使用资源隔离技术，比如bulkhead（舱壁隔离技术），swimlane（泳道技术），circuit breaker（短路技术），来限制任何一个依赖服务的故障的影响</li>
<li>通过近实时的统计/监控/报警功能，来提高故障发现的速度</li>
<li>通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度</li>
<li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况</li>
</ol>
<h1 id="Hystrix的实现"><a href="#Hystrix的实现" class="headerlink" title="Hystrix的实现"></a>Hystrix的实现</h1><ol>
<li>通过HystrixCommand或者HystrixObservableCommand来封装对外部依赖的访问请求，这个访问请求一般会运行在独立的线程中，资源隔离</li>
<li>对于超出我们设定阈值的服务调用，直接进行超时，不允许其耗费过长时间阻塞住。这个超时时间默认是99.5%的访问时间，但是一般我们可以自己设置一下</li>
<li>为每一个依赖服务维护一个独立的线程池，或者是semaphore，当线程池已满时，直接拒绝对这个服务的调用</li>
<li>对依赖服务的调用的成功次数，失败次数，拒绝次数，超时次数，进行统计</li>
<li>如果对一个依赖服务的调用失败次数超过了一定的阈值，自动进行熔断，在一定时间内对该服务的调用直接降级，一段时间后再自动尝试恢复</li>
<li>当一个服务调用出现失败，被拒绝，超时，短路等异常情况时，自动调用fallback降级机制</li>
<li>对属性和配置的修改提供近实时的支持</li>
</ol>
<p><img src="/img/hystrix/%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%BE%9D%E8%B5%96%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%85%E9%9A%9C%E4%B8%8D%E8%A6%81%E6%8B%96%E5%9E%AE%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F.png" alt="资源隔离如何保护依赖服务的故障不要拖垮整个系统"></p>
<h1 id="Hystrix项目实战"><a href="#Hystrix项目实战" class="headerlink" title="Hystrix项目实战"></a>Hystrix项目实战</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>商品详情页服务和缓存服务，模拟缓存更新时如何使用hystrix。</p>
<p><strong>缓存服务</strong></p>
<p><a href="https://github.com/sail-y/eshop-cache-ha">https://github.com/sail-y/eshop-cache-ha</a></p>
<p><strong>商品服务</strong></p>
<p><a href="https://github.com/sail-y/eshop-product-ha">https://github.com/sail-y/eshop-product-ha</a></p>
<h2 id="商品服务接口导致缓存服务资源耗尽的问题"><a href="#商品服务接口导致缓存服务资源耗尽的问题" class="headerlink" title="商品服务接口导致缓存服务资源耗尽的问题"></a>商品服务接口导致缓存服务资源耗尽的问题</h2><p><img src="/img/hystrix/%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%AF%BC%E8%87%B4%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E8%B5%84%E6%BA%90%E8%80%97%E5%B0%BD%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="商品服务接口导致缓存服务资源耗尽的问题"></p>
<h2 id="基于线程池的资源隔离"><a href="#基于线程池的资源隔离" class="headerlink" title="基于线程池的资源隔离"></a>基于线程池的资源隔离</h2><p>hystrix进行资源隔离，其实是提供了一个command抽象。把对某一个依赖服务的所有调用请求全部隔离在同一份资源池内，对这个依赖服务的所有调用请求，全部走这个资源池内的资源，不会去用其他的资源了，这个就叫做资源隔离。</p>
<p>hystrix最最基本的资源隔离的技术，<strong>线程池隔离技术</strong>。对某一个依赖服务，商品服务，所有的调用请求，全部隔离到一个线程池内，对商品服务的每次调用请求都封装在一个command里面。每个command（每次服务调用请求）都是使用线程池内的一个线程去执行的，所以哪怕是对这个依赖服务（商品服务）同时发起的调用量已经到了1000了，但是线程池内就10个线程，最多就只会用这10个线程去执行。</p>
<p>不会出现对商品服务的请求，因为接口调用延迟将tomcat内部所有的线程资源全部耗尽。目的是为了保护不要因为某一个依赖服务的故障，导致耗尽了缓存服务中的所有的线程资源去执行。</p>
<h3 id="HystrixCommand：是用来获取一条数据的"><a href="#HystrixCommand：是用来获取一条数据的" class="headerlink" title="HystrixCommand：是用来获取一条数据的"></a>HystrixCommand：是用来获取一条数据的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;GetProductInfoCommandGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">&quot;http://localhost:8082/getProductInfo?productId=&quot;</span> + productId;</span><br><span class="line">        String response = HttpUtil.get(url);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test:</p>
<p><a href="http://localhost:8081/getProductInfo?productId=1">http://localhost:8081/getProductInfo?productId=1</a></p>
<h3 id="HystrixObservableCommand：是设计用来获取多条数据的"><a href="#HystrixObservableCommand：是设计用来获取多条数据的" class="headerlink" title="HystrixObservableCommand：是设计用来获取多条数据的"></a>HystrixObservableCommand：是设计用来获取多条数据的</h3><p>controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getProductInfos&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProductInfos</span><span class="params">(String productIds)</span> </span>&#123;</span><br><span class="line">    HystrixObservableCommand&lt;ProductInfo&gt; getProductInfosCommand = <span class="keyword">new</span> GetProductInfosCommand(productIds.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    Observable&lt;ProductInfo&gt; observable = getProductInfosCommand.observe();</span><br><span class="line">    observable.subscribe(<span class="keyword">new</span> Observer&lt;ProductInfo&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取完了所有的商品数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">            log.info(productInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>command:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfosCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] productIds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfosCommand</span><span class="params">(String[] productIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;GetProductInfoCommandGroup&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.productIds = productIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;ProductInfo&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Observable.&lt;ProductInfo&gt;create(observer -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String productId : productIds) &#123;</span><br><span class="line">                        String url = <span class="string">&quot;http://localhost:8082/getProductInfo?productId=&quot;</span> + productId;</span><br><span class="line">                        String response = HttpUtil.get(url);</span><br><span class="line">                        ProductInfo productInfo = JSON.parseObject(response, ProductInfo.class);</span><br><span class="line">                        observer.onNext(productInfo);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    observer.onCompleted();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                observer.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>test:</p>
<p><a href="http://localhost:8081/getProductInfos?productId=1,2,3">http://localhost:8081/getProductInfos?productId=1,2,3</a></p>
<h3 id="command的四种调用方式"><a href="#command的四种调用方式" class="headerlink" title="command的四种调用方式"></a>command的四种调用方式</h3><p>同步：new CommandHelloWorld(“World”).execute()，new ObservableCommandHelloWorld(“World”).toBlocking().toFuture().get()</p>
<p>异步：new CommandHelloWorld(“World”).queue()，new ObservableCommandHelloWorld(“World”).toBlocking().toFuture()</p>
<p>立即执行： observe()：hot，已经执行过了</p>
<p>订阅： toObservable(): cold，还没执行过</p>
<h2 id="基于信号量的资源隔离"><a href="#基于信号量的资源隔离" class="headerlink" title="基于信号量的资源隔离"></a>基于信号量的资源隔离</h2><p><img src="/img/hystrix/%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E6%B5%81%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="信号量的资源隔离与限流的说明"></p>
<p>信号量跟线程池两种资源隔离的技术的区别：</p>
<p><img src="/img/hystrix/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB.png" alt="线程池隔离和信号量隔离的原理以及区别"></p>
<h2 id="线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用"><a href="#线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用" class="headerlink" title="线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用?"></a>线程池隔离技术和信号量隔离技术，分别在什么样的场景下去使用?</h2><p>线程池：适合99%场景，线程池一般处理对依赖服务的网络请求的调用和访问，timeout这种问题。</p>
<p>信号量：适合不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，但是像这种访问系统内部的代码，其实不涉及任何的网络请求。那么只要做信号量的普通限流就可以了，因为不需要去捕获timeout类似的问题，如果算法+数据结构的效率不是太高，并发量突然太高，因为这里稍微耗时一些，导致很多线程卡在这里的话是不太好的。所以进行一个基本的资源隔离和访问，避免内部复杂的低效率的代码，导致大量的线程被hang住。</p>
<p><strong>采用信号量技术进行资源隔离与限流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ExampleGroup&quot;</span>))</span><br><span class="line">        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">               .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));</span><br></pre></td></tr></table></figure>


<h2 id="资源隔离策略配置"><a href="#资源隔离策略配置" class="headerlink" title="资源隔离策略配置"></a>资源隔离策略配置</h2><p>现在我们知道有线程池（THREAD）和信号量（SEMAPHORE）两种隔离方式。除了选择隔离方式，hystrix还支持对隔离策略进行一些细粒度的配置。</p>
<p>默认的策略就是线程池</p>
<p>线程池其实最大的好处就是对于网络访问请求，如果有超时的话，可以避免调用线程阻塞住</p>
<p>而使用信号量的场景，通常是针对超大并发量的场景下，每个服务实例每秒都几百的QPS，那么此时你用线程池的话，线程一般不会太多，可能撑不住那么高的并发，如果要撑住，可能要耗费大量的线程资源，那么就是用信号量，来进行限流保护</p>
<p>一般用信号量常见于那种基于纯内存的一些业务逻辑服务，而不涉及到任何网络访问请求</p>
<p>netflix有100+的command运行在40+的线程池中，只有少数command是不运行在线程池中的，就是从纯内存中获取一些元数据，或者是对多个command包装起来的facacde command，是用信号量限流的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to use thread isolation</span></span><br><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)</span><br><span class="line"><span class="comment">// to use semaphore isolation</span></span><br><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)</span><br></pre></td></tr></table></figure>



<h3 id="command名称和command组"><a href="#command名称和command组" class="headerlink" title="command名称和command组"></a>command名称和command组</h3><p>每个command都可以设置一个自己的名称，同时可以设置一个自己的组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Setter cachedSetter = </span><br><span class="line">    Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ExampleGroup&quot;</span>))</span><br><span class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;HelloWorld&quot;</span>));    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(cachedSetter);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>command group，是一个非常重要的概念，默认情况下，因为就是通过command group来定义一个线程池的，而且还会通过command group来聚合一些监控和报警信息。同一个command group中的请求，都会进入同一个线程池中。</p>
<h3 id="command线程池"><a href="#command线程池" class="headerlink" title="command线程池"></a>command线程池</h3><p>threadpool key代表了一个HystrixThreadPool，用来进行统一监控，统计，缓存。默认的threadpool key就是command group名称。每个command都会跟它的threadpool key对应的thread pool绑定在一起。如果不想直接用command group，也可以手动设置thread pool name。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommandHelloWorld</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ExampleGroup&quot;</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;HelloWorldPool&quot;</span>)));</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>command threadpool -&gt; command group -&gt; command key</p>
<ul>
<li>command key：代表了一类command，一般来说代表了底层的依赖服务的一个接口。</li>
<li>command group：代表了某一个底层的依赖服务，一个依赖服务可能会暴露出来多个接口，每个接口就是一个command key。在逻辑上去组织起来一堆command key的调用，统计信息、成功次数、timeout超时次数、失败次数等等，可以看到某一个服务整体的一些访问情况。一般推荐是根据一个服务去划分出一个线程池，command key默认都是属于同一个线程池的。</li>
</ul>
<p>比如以一个服务为粒度，估算出来这个服务每秒的所有接口加起来的整体QPS在100左右。调用目标服务的当前服务部署了10个服务实例，每个服务实例上给一个线程池，线程数量大概在10个左右，就可以满足对目标服务的整体的访问QPS大概在每秒100左右需求了。</p>
<p>还有一种场景，就是command group对应的服务的接口访问量差别很大。然后就希望做一些细粒度的资源隔离，针对同一个服务的不同接口，使用不同的线程池。</p>
<p>之前的模式是： command key -&gt; command group</p>
<p>我们可以针对每个command单独设置threadpool key：command key -&gt; 自己的threadpool key</p>
<p>这样从逻辑上来说多个command key是属于一个command group的，在做统计的时候会放在一起统计。但是每个command key有自己的线程池，每个接口有自己的线程池去做资源隔离和限流。</p>
<h3 id="设置线程池大小"><a href="#设置线程池大小" class="headerlink" title="设置线程池大小"></a>设置线程池大小</h3><p>Hystrix默认的线程池大小是10，可以通过下面的代码进行设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter()</span><br><span class="line">   .withCoreSize(<span class="keyword">int</span> value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般来说默认的10个已经够了。</p>
<h3 id="queueSizeRejectionThreshold"><a href="#queueSizeRejectionThreshold" class="headerlink" title="queueSizeRejectionThreshold"></a>queueSizeRejectionThreshold</h3><p>线程池是10个，如果还有请求过来，默认可以排队的线程是5个。超过5个以后多余的请求进来，就会被线程池拒绝掉，抛出异常。</p>
<p>默认值是5，可以通过下面代码修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter()</span><br><span class="line">   .withQueueSizeRejectionThreshold(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<h3 id="execution-isolation-semaphore-maxConcurrentRequests"><a href="#execution-isolation-semaphore-maxConcurrentRequests" class="headerlink" title="execution.isolation.semaphore.maxConcurrentRequests"></a>execution.isolation.semaphore.maxConcurrentRequests</h3><p>设置使用SEMAPHORE隔离策略的时候，允许访问的最大并发量，超过这个最大并发量，请求直接被reject。这个并发量的设置跟线程池大小的设置应该是类似的，但是基于信号量的话性能会好很多，而且hystrix框架本身的开销会小很多。</p>
<p>默认值是10，不能设置得太大，因为信号量是基于调用线程去执行command的，而且不能从timeout中抽离，因此一旦设置的太大，而且有延时发生，可能瞬间导致tomcat本身的线程资源本占满。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<p>Hystrix的基本使用已经差不多是这样了，后面再有一篇文章，分析hystrix的流程和原理。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix流程和原理讲解</title>
    <url>/2018/03/26/springcloud/hystrix02/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h2 id="Hystrix流程讲解"><a href="#Hystrix流程讲解" class="headerlink" title="Hystrix流程讲解"></a>Hystrix流程讲解</h2><h3 id="创建Command"><a href="#创建Command" class="headerlink" title="创建Command"></a>创建Command</h3><p>一个HystrixCommand或一个HystrixObservableCommand对象，代表了对某个依赖服务发起的一次请求或者调用，构造的时候，可以在构造函数中传入任何需要的参数。</p>
<a id="more"></a>
<p>HystrixCommand主要用于仅仅会返回一个结果的调用<br>HystrixObservableCommand主要用于可能会返回多条结果的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommand command = <span class="keyword">new</span> HystrixCommand(arg1, arg2);</span><br><span class="line">HystrixObservableCommand command = <span class="keyword">new</span> HystrixObservableCommand(arg1, arg2);</span><br></pre></td></tr></table></figure>


<h3 id="执行Command"><a href="#执行Command" class="headerlink" title="执行Command"></a>执行Command</h3><p>执行Command就可以发起一次对依赖服务的调用</p>
<p>要执行Command，需要在4个方法中选择其中的一个：execute()，queue()，observe()，toObservable()</p>
<p>其中execute()和queue()仅仅对HystrixCommand适用</p>
<p>execute()：调用后直接block住，属于同步调用，直到依赖服务返回单条结果，或者抛出异常<br>queue()：返回一个Future，属于异步调用，后面可以通过Future获取单条结果<br>observe()：订阅一个Observable对象，Observable代表的是依赖服务返回的结果，获取到一个那个代表结果的Observable对象的拷贝对象<br>toObservable()：返回一个Observable对象，如果我们订阅这个对象，就会执行command并且获取返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">K             value   = command.execute();</span><br><span class="line">Future&lt;K&gt;     fValue  = command.queue();</span><br><span class="line">Observable&lt;K&gt; ohValue = command.observe();         </span><br><span class="line">Observable&lt;K&gt; ocValue = command.toObservable();    </span><br></pre></td></tr></table></figure>

<p>execute()实际上会调用queue().get().queue()，接着会调用toObservable().toBlocking().toFuture()</p>
<p>也就是说，无论是哪种执行command的方式，最终都是依赖toObservable()去执行的。</p>
<h3 id="检查是否开启请求缓存"><a href="#检查是否开启请求缓存" class="headerlink" title="检查是否开启请求缓存"></a>检查是否开启请求缓存</h3><p>如果这个command开启了请求缓存，而且这个调用的结果在缓存中存在，那么直接从缓存中返回结果。</p>
<h3 id="检查是否开启了断路器"><a href="#检查是否开启了断路器" class="headerlink" title="检查是否开启了断路器"></a>检查是否开启了断路器</h3><p>检查这个command对应的依赖服务是否开启了断路器</p>
<p>如果断路器被打开了，那么hystrix就不会执行这个command，而是直接去执行fallback降级机制。</p>
<h3 id="检查线程池-队列-semaphore是否已经满了"><a href="#检查线程池-队列-semaphore是否已经满了" class="headerlink" title="检查线程池/队列/semaphore是否已经满了"></a>检查线程池/队列/semaphore是否已经满了</h3><p>如果command对应的线程池/队列/semaphore已经满了，那么也不会执行command，而是直接去调用fallback降级机制。</p>
<h3 id="执行command"><a href="#执行command" class="headerlink" title="执行command"></a>执行command</h3><p>调用HystrixObservableCommand.construct()或HystrixCommand.run()来实际执行这个command</p>
<p>HystrixCommand.run()是返回一个单条结果，或者抛出一个异常<br>HystrixObservableCommand.construct()是返回一个Observable对象，可以获取多条结果</p>
<p>如果HystrixCommand.run()或HystrixObservableCommand.construct()的执行，超过了timeout时长的话，那么command所在的线程就会抛出一个TimeoutException。</p>
<p>如果timeout了，也会去执行fallback降级机制，而且就不会管run()或construct()返回的值了。</p>
<h3 id="断路健康检查"><a href="#断路健康检查" class="headerlink" title="断路健康检查"></a>断路健康检查</h3><p>Hystrix会将每一个依赖服务的调用成功，失败，拒绝，超时，等事件，都会发送给circuit breaker断路器。断路器就会对调用成功/失败/拒绝/超时等事件的次数进行统计。断路器会根据这些统计次数来决定，是否要进行断路，如果打开了断路器，那么在一段时间内就会直接断路，然后如果在之后第一次检查发现调用成功了，就关闭断路器。</p>
<h3 id="调用fallback降级机制"><a href="#调用fallback降级机制" class="headerlink" title="调用fallback降级机制"></a>调用fallback降级机制</h3><p>在以下几种情况中，hystrix会调用fallback降级机制：<strong>run()或construct()抛出一个异常，断路器打开，线程池/队列/semaphore满了，command执行超时了。</strong></p>
<p>一般在降级机制中，都建议给出一些默认的返回值，比如静态的一些代码逻辑，或者从内存中的缓存中提取一些数据，尽量在这里不要再进行网络请求了</p>
<p>即使在降级中，一定要进行网络调用，也应该将那个调用放在一个HystrixCommand中，进行隔离</p>
<p>在HystrixCommand中，上线getFallback()方法，可以提供降级机制</p>
<p>在HystirxObservableCommand中，实现一个resumeWithFallback()方法，返回一个Observable对象，可以提供降级结果</p>
<p>如果fallback返回了结果，那么hystrix就会返回这个结果</p>
<p>对于HystrixCommand，会返回一个Observable对象，其中会发返回对应的结果<br>对于HystrixObservableCommand，会返回一个原始的Observable对象</p>
<p>如果没有实现fallback，或者是fallback抛出了异常，Hystrix会返回一个Observable，但是不会返回任何数据</p>
<p>不同的command执行方式，其fallback为空或者异常时的返回结果不同</p>
<p>对于execute()，直接抛出异常<br>对于queue()，返回一个Future，调用get()时抛出异常<br>对于observe()，返回一个Observable对象，但是调用subscribe()方法订阅它时，立即抛出调用者的onError方法<br>对于toObservable()，返回一个Observable对象，但是调用subscribe()方法订阅它时，立即抛出调用者的onError方法。</p>
<h3 id="不同执行方式走的流程"><a href="#不同执行方式走的流程" class="headerlink" title="不同执行方式走的流程"></a>不同执行方式走的流程</h3><p>execute()，获取一个Future.get()，然后拿到单个结果<br>queue()，返回一个Future<br>observer()，立即订阅Observable，然后启动8大执行步骤，返回一个拷贝的Observable，订阅时立即回调给你结果<br>toObservable()，返回一个原始的Observable，必须手动订阅才会去执行8大步骤</p>
<p><img src="/img/hystrix/hystrix%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%848%E5%A4%A7%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.png" alt="hystrix执行时的8大流程以及内部原理"></p>
<h2 id="Request-Cache"><a href="#Request-Cache" class="headerlink" title="Request Cache"></a>Request Cache</h2><p>首先有一个概念，叫做reqeust context–请求上下文，一般来说在一个web应用中，会使用hystrix在一个filter里面，对每一个请求都施加一个请求上下文，在tomcat容器内，每一次请求就是一次请求上下文。</p>
<p>然后在这次请求上下文中，我们会去执行N多代码，调用N多依赖服务，有的依赖服务可能还会调用好几次，在一次请求上下文中，如果有多个command，参数都是一样的，调用的接口也是一样的，其实结果可以认为也是一样的。</p>
<p>那么这个时候，我们就可以让第一次command执行返回的结果被缓存在内存中，然后这个请求上下文中后续的其他对这个依赖的调用全部从内存中取用缓存结果就可以了。不用在一次请求上下文中反复多次的执行一样的command，提升整个请求的性能。</p>
<p>HystrixCommand和HystrixObservableCommand都可以指定一个缓存key，然后hystrix会自动进行缓存，接着在同一个request context内，再次访问的时候，就会直接取用缓存。用请求缓存，可以避免重复执行网络请求，多次调用一个command，那么只会执行一次，后面都是直接取缓存。</p>
<p>指定缓存key，只需要实现一个<code>getCacheKey </code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getCacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;product_info_&quot;</span> + productId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对于请求缓存（request caching），请求合并（request collapsing），请求日志（request log），等等技术，都必须自己管理HystrixReuqestContext的生命周期。</p>
<p>在一个请求执行之前，都必须先初始化一个request context</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br></pre></td></tr></table></figure>

<p>然后在请求结束之后，需要关闭request context</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.shutdown();</span><br></pre></td></tr></table></figure>


<p>一般在Java Web应用中，都是通过filter过滤器来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRequestContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> HystrixRequestContextFilter());</span><br><span class="line">    registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动清理缓存"><a href="#手动清理缓存" class="headerlink" title="手动清理缓存"></a>手动清理缓存</h3><p>有时候可能需要手动清理缓存，Hystrix提供了方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flushCache</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">    HystrixRequestCache.getInstance(KEY,</span><br><span class="line">            HystrixConcurrencyStrategyDefault.getInstance()).clear(String.valueOf(productId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FallBack降级"><a href="#FallBack降级" class="headerlink" title="FallBack降级"></a>FallBack降级</h2><p>hystrix在3种情况下会调用降级方法。</p>
<ol>
<li>运行的程序报错了，error。</li>
<li>线程池/信号量满了，reject。</li>
<li>超时了，timeout。</li>
</ol>
<p>如果路器发现异常事件的占比达到了一定的比例，直接开启断路，circuit breaker。降级方法可以返回一个自定义的结果，或者一个过期的数据。</p>
<p>降级是通过实现HystrixCommand.getFallBack()方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;从本地缓存获取过期的品牌数据，brandId=&quot;</span> + brandId);</span><br><span class="line">    <span class="keyword">return</span> BrandCache.getBrandName(brandId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="断路器工作原理"><a href="#断路器工作原理" class="headerlink" title="断路器工作原理"></a>断路器工作原理</h2><ol>
<li>如果经过短路器的流量超过了一定的阈值，HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</li>
<li>如果断路器统计到的异常调用的占比超过了一定的阈值，HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</li>
<li>然后断路器从close状态转换到open状态</li>
<li>断路器打开的时候，所有经过该断路器的请求全部被短路，不调用后端服务，直接走fallback降级</li>
<li>经过了一段时间之后，HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()，会half-open，让一条请求经过短路器，看能不能正常调用。如果调用成功了，那么就自动恢复，转到close状态。</li>
</ol>
<h3 id="断路器配置"><a href="#断路器配置" class="headerlink" title="断路器配置"></a>断路器配置</h3><ul>
<li><p>circuitBreaker.enabled</p>
<p>  控制断路器是否允许工作，包括跟踪依赖服务调用的健康状况，以及对异常情况过多时是否允许触发短路，默认是true。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerEnabled(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>circuitBreaker.requestVolumeThreshold</p>
<p>  设置一个rolling window，滑动窗口中，最少要有多少个请求时，才触发开启短路。举例来说，如果设置为20（默认值），那么在一个sleepWindowInMilliseconds秒的滑动窗口内，如果只有19个请求，即使这19个请求都是异常的，也是不会触发开启短路器的。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerRequestVolumeThreshold(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>circuitBreaker.sleepWindowInMilliseconds</p>
<p>  设置在断路之后，需要在多长时间内直接reject请求，然后在这段时间之后，再重新到holf-open状态，尝试允许请求通过以及自动恢复，默认值是5000毫秒。这个值也是设置滑动窗口长度的一个值。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerSleepWindowInMilliseconds(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>circuitBreaker.errorThresholdPercentage</p>
<p>  设置异常请求量的百分比，当异常请求达到这个百分比时，就触发打开短路器，默认是50，也就是50%。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerErrorThresholdPercentage(<span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>circuitBreaker.forceOpen</p>
<p>  如果设置为true的话，直接强迫打开短路器，相当于是手动短路了，手动降级，默认false。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerForceOpen(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>circuitBreaker.forceClosed</p>
<p>  如果设置为ture的话，直接强迫关闭短路器，相当于是手动停止短路了，手动升级，默认false。</p>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">   .withCircuitBreakerForceClosed(<span class="keyword">boolean</span> value)</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="配置实战"><a href="#配置实战" class="headerlink" title="配置实战"></a>配置实战</h3><p>配置一个断路器，流量要求是20，异常比例是50%，短路时间是5s。在command内加入一个判断，如果是productId=-1，那么就直接报错，触发异常执行。</p>
<p>写一个client测试程序，写入50个请求，前20个是正常的，但是后30个是productId=-1，然后继续请求，会发现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircuitBreakerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求，结果为：&quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=-1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求，结果为：&quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待几秒钟，统计到最近30次请求超过40%次，开启断路&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待五秒后，时间窗口统计了（withCircuitBreakerSleepWindowInMilliseconds），发现异常比例太多，这个时候才会去开启断路器。直接走断路器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求，结果为：&quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器有一个时间窗口，我们必须要等到那个个时间窗口过了以后，hystrix才会看一下最近的时间窗口</span></span><br><span class="line">        <span class="comment">// 比如说最近的10秒内有多少条数据其中一场的数据有没有到一定的比例，如果到了一定的比例，才会去断路</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;尝试等待5秒钟，等待恢复&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String response = HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次请求，结果为：&quot;</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="断路器设计原则"><a href="#断路器设计原则" class="headerlink" title="断路器设计原则"></a>断路器设计原则</h3><ol>
<li>每个服务都会调用几十个后端依赖服务，那些后端依赖服务通常是由很多不同的团队开发的</li>
<li>每个后端依赖服务都会提供它自己的client调用库，比如说用thrift的话，就会提供对应的thrift依赖</li>
<li>client调用库随时会变更</li>
<li>client调用库随时可能会增加新的网络请求的逻辑</li>
<li>client调用库可能会包含诸如自动重试，数据解析，内存中缓存等逻辑</li>
<li>client调用库一般都对调用者来说是个黑盒，包括实现细节，网络访问，默认配置，等等</li>
<li>在真实的生产环境中，经常会出现调用者，突然间惊讶的发现，client调用库发生了某些变化</li>
<li>即使client调用库没有改变，依赖服务本身可能有会发生逻辑上的变化</li>
<li>有些依赖的client调用库可能还会拉取其他的依赖库，而且可能那些依赖库配置的不正确</li>
<li>大多数网络请求都是同步调用的</li>
<li>调用失败和延迟，也有可能会发生在client调用库本身的代码中，不一定就是发生在网络请求中</li>
</ol>
<p>线程池机制的优点如下：</p>
<ol>
<li>任何一个依赖服务都可以被隔离在自己的线程池内，即使自己的线程池资源填满了，也不会影响任何其他的服务调用</li>
<li>服务可以随时引入一个新的依赖服务，因为即使这个新的依赖服务有问题，也不会影响其他任何服务的调用</li>
<li>当一个故障的依赖服务重新变好的时候，可以通过清理掉线程池，瞬间恢复该服务的调用，而如果是tomcat线程池被占满，再恢复就很麻烦</li>
<li>如果一个client调用库配置有问题，线程池的健康状况随时会报告，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机</li>
<li>如果一个服务本身发生了修改，需要重新调整配置，此时线程池的健康状况也可以随时发现，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机</li>
<li>基于线程池的异步本质，可以在同步的调用之上，构建一层异步调用层</li>
</ol>
<p>线程池机制的缺点：</p>
<ol>
<li>线程池机制最大的缺点就是增加了cpu的开销</li>
<li>每个command的执行都依托一个独立的线程，会进行排队，调度，还有上下文切换</li>
<li>Hystrix官方自己做了一个多线程异步带来的额外开销，通过对比多线程异步调用+同步调用得出，Netflix API每天通过hystrix执行10亿次调用，每个服务实例有40个以上的线程池，每个线程池有10个左右的线程</li>
<li>最后，用hystrix的额外开销，就是给请求带来了3ms左右的延时，最多延时在10ms以内，相比于可用性和稳定性的提升，这是可以接受的</li>
</ol>
<h3 id="限流测试"><a href="#限流测试" class="headerlink" title="限流测试"></a>限流测试</h3><p>限流的目的是为了保护过多的请求导致服务并发量过高而宕机。</p>
<p>withCoreSize：设置你的线程池的大小<br>withMaxQueueSize：设置的是你的等待队列，缓冲队列的大小<br>withQueueSizeRejectionThreshold：如果withMaxQueueSize&lt;withQueueSizeRejectionThreshold，那么取的是withMaxQueueSize，反之，取得是withQueueSizeRejectionThreshold</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(<span class="number">10</span>)</span><br><span class="line">                    .withMaxQueueSize(<span class="number">12</span>)</span><br><span class="line">                    .withQueueSizeRejectionThreshold(<span class="number">15</span>))</span><br></pre></td></tr></table></figure>

<p>基于线程池的限流测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 限流测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/03/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// GetProductInfoCommand配置线程池大小10，队列长度为12，超过8以后会被拒。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先进去线程池的是10个请求，然后有8个请求进入等待队列，线程池里有空闲，等待队列中的请求如果还没有timeout，那么就进去线程池去执行</span></span><br><span class="line">        <span class="comment">// withExecutionTimeoutInMilliseconds(20000)：timeout也设置大一些，否则如果请求放等待队列中时间太长了，直接就会timeout，等不到去线程池里执行了</span></span><br><span class="line">        <span class="comment">// withFallbackIsolationSemaphoreMaxConcurrentRequests(30)：fallback，sempahore限流，30个，避免太多的请求同时调用fallback被拒绝访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                String response = HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfo?productId=-2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + (finalI + <span class="number">1</span>) + <span class="string">&quot;次请求，结果为：&quot;</span> + response);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>我们在调用一些第三方服务或者分布式系统的一些其他服务的时候，如果别的服务不稳定，导致大量超时，我们没有处理好，可能会导致我们自己的服务也会出问题，大量的线程卡死。所以我们必须做超时的控制，给我们的服务提供安全保护的措施。</p>
<ol>
<li><p>execution.isolation.thread.timeoutInMilliseconds</p>
<p> 手动设置timeout时长，一个command运行超出这个时间，就被认为是timeout，然后将hystrix command标识为timeout，同时执行fallback降级逻辑</p>
<p> 默认是1000，也就是1000毫秒</p>
<pre><code> `HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(int value)`</code></pre>
</li>
<li><p>execution.timeout.enabled</p>
</li>
</ol>
<pre><code>控制是否要打开timeout机制，默认是true

`HystrixCommandProperties.Setter().withExecutionTimeoutEnabled(boolean value)`</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hystrix的核心知识</p>
<ol>
<li>hystrix内部工作原理：8大执行步骤和流程</li>
<li>资源隔离：你如果有很多个依赖服务，高可用性，先做资源隔离，任何一个依赖服务的故障不会导致你的服务的资源耗尽，不会崩溃</li>
<li>请求缓存：对于一个request context内的多个相同command，使用request cache，提升性能</li>
<li>熔断：基于短路器，采集各种异常事件，报错，超时，reject，短路，熔断，一定时间范围内就不允许访问了，直接降级，自动恢复的机制</li>
<li>降级：报错，超时，reject，熔断，降级，服务提供容错的机制</li>
<li>限流：在你的服务里面，通过线程池，或者信号量，限制对某个后端的服务或资源的访问量，避免从你的服务这里过去太多的流量，打死某个资源</li>
<li>超时：避免某个依赖服务性能过差，导致大量的线程hang住去调用那个服务，会导致你的服务本身性能也比较差</li>
</ol>
<p>hystrix的高阶知识</p>
<ol>
<li>request collapser，请求合并技术</li>
<li>fail-fast和fail-slient，高阶容错模式</li>
<li>static fallback和stubbed fallback，高阶降级模式</li>
<li>嵌套command实现的发送网络请求的降级模式</li>
<li>基于facade command的多级降级模式</li>
<li>request cache的手动清理</li>
<li>生产环境中的线程池大小以及timeout配置优化经验</li>
<li>线程池的自动化动态扩容与缩容技术</li>
<li>hystrix的metric高阶配置</li>
<li>基于hystrix dashboard的可视化分布式系统监控</li>
<li>生产环境中的hystrix工程运维经验</li>
</ol>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix高级进阶</title>
    <url>/2018/04/15/springcloud/hystrix03/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<h2 id="请求合并技术"><a href="#请求合并技术" class="headerlink" title="请求合并技术"></a>请求合并技术</h2><p>前面的两篇文章讲解了hystrix的入门，以及它的原理和执行流程。</p>
<p>之前我们有提到<a href="http://www.saily.top/2018/03/26/hystrix02/#Request-Cache">Request Cache</a>，在一次请求上下文中，如果有多个command，参数都是一样的，调用的接口也是一样的，其实结果可以认为也是一样的。</p>
<a id="more"></a>

<p>但是如果获取多个商品，需要发送多次网络请求，调用多次接口才能拿到结果。Hystrix还为我们提供了一种叫做请求合并的技术，可以使用HystrixCollapser将多个HystrixCommand合并到一起，多个command放在一个command里面去执行，发送一次网络请求，就拉取到多条数据。用请求合并技术，将多个请求合并起来，可以减少高并发访问下需要使用的线程数量以及网络连接数量，可以提升性能。</p>
<h3 id="请求合并有多种级别"><a href="#请求合并有多种级别" class="headerlink" title="请求合并有多种级别"></a>请求合并有多种级别</h3><ol>
<li>global context，tomcat所有调用线程，对一个依赖服务的任何一个command调用都可以被合并在一起，hystrix就传递一个HystrixRequestContext</li>
<li>user request context，tomcat内某一个调用线程，将某一个tomcat线程对某个依赖服务的多个command调用合并在一起</li>
<li>object modeling，基于对象的请求合并，如果有几百个对象，遍历后依次调用每个对象的某个方法，可能导致发起几百次网络请求，基于hystrix可以自动将对多个对象模型的调用合并到一起</li>
</ol>
<h3 id="请求合并技术的开销有多大"><a href="#请求合并技术的开销有多大" class="headerlink" title="请求合并技术的开销有多大"></a>请求合并技术的开销有多大</h3><p>使用请求合并技术的开销就是导致延迟大幅度增加，因为需要一定的时间将多个请求合并起来。比如发送过来10个请求，每个请求本来大概是2ms可以返回，要把10个请求合并在一个command内，统一一起执行，先后等待一下，可能就需要5ms（延时翻N倍了）。</p>
<p>所以说，要考量一下使用请求合并技术是否合适，如果一个请求本来耗费的时间就比较长，那么进行请求合并，增加一些延迟影响并不大，这样可以大幅度削减你的线程池的资源耗费，也可以减少后端服务的网络资源开销。如果一个请求本来就很快，用请求合并后反而还变慢了很多倍了，那就没有必要了。</p>
<blockquote>
<p>每个请求就2ms，batch，8<del>10ms，延迟增加了4</del>5倍</p>
</blockquote>
<blockquote>
<p>每个请求本来就30ms<del>50ms，batch，35ms</del>55ms，延迟增加不太明显</p>
</blockquote>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>批量查询本质上我们还是采用HystrixObservableCommand，HystrixCommand+request cache，依然每个商品发起一次网络请求。</p>
<p>什么意思？就是一个批量的商品过来以后，我们还是多个command的方式去执行，request collapser+request cache，相同的商品还是就查询一次，不同的商品合并到一起通过一个网络请求得到结果，我们结合之前的request cache开发。</p>
<p>我们需要开发合并请求的命令，还需要开发一个批量查询商品的接口。</p>
<h4 id="collapser开发"><a href="#collapser开发" class="headerlink" title="collapser开发"></a>collapser开发</h4><p><a href="https://github.com/sail-y/eshop-cache-ha/blob/master/src/main/java/com/roncoo/eshop/cache/ha/hystrix/command/GetProductInfosCollapser.java">https://github.com/sail-y/eshop-cache-ha/blob/master/src/main/java/com/roncoo/eshop/cache/ha/hystrix/command/GetProductInfosCollapser.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfosCollapser</span> <span class="keyword">extends</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">List</span>&lt;<span class="title">ProductInfo</span>&gt;, <span class="title">ProductInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfosCollapser</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getRequestArgument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HystrixCommand&lt;List&lt;ProductInfo&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests) &#123;</span><br><span class="line">        String params = requests.stream().map(CollapsedRequest::getArgument).map(Object::toString).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;createCommand方法执行，params=&quot;</span> + params);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BatchCommand(requests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(List&lt;ProductInfo&gt; batchResponse, Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (CollapsedRequest&lt;ProductInfo, Long&gt; request : requests) &#123;</span><br><span class="line">            request.setResponse(batchResponse.get(count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">List</span>&lt;<span class="title">ProductInfo</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BatchCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ProductInfo, Long&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ProductInfoService&quot;</span>))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;GetProductInfosCollapserBatchCommand&quot;</span>)));</span><br><span class="line">            <span class="keyword">this</span>.requests = requests;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> List&lt;ProductInfo&gt; <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将一个批次内的商品id给拼接到了一起</span></span><br><span class="line">            String params = requests.stream().map(CollapsedRequest::getArgument).map(Object::toString).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将多个商品id合并到一个batch内，直接发送一次网络请求，获取所有的商品</span></span><br><span class="line">            String url = <span class="string">&quot;http://localhost:8082/getProductInfos?productIds=&quot;</span> + params;</span><br><span class="line"></span><br><span class="line">            String response = HttpUtil.get(url);</span><br><span class="line"></span><br><span class="line">            List&lt;ProductInfo&gt; productInfos = JSONArray.parseArray(response, ProductInfo.class);</span><br><span class="line">            <span class="keyword">for</span> (ProductInfo productInfo : productInfos) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BatchCommand内部， productInfo=&quot;</span> + JSON.toJSONString(productInfo));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> productInfos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="批量查询接口开发"><a href="#批量查询接口开发" class="headerlink" title="批量查询接口开发"></a>批量查询接口开发</h4><p><a href="https://github.com/sail-y/eshop-product-ha/blob/master/src/main/java/com/roncoo/esjop/product/ha/controller/ProductController.java">https://github.com/sail-y/eshop-product-ha/blob/master/src/main/java/com/roncoo/esjop/product/ha/controller/ProductController.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getProductInfos&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProductInfos</span><span class="params">(String productIds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;getProductInfos接收到一次请求，productIds=&quot;</span> + productIds);</span><br><span class="line"></span><br><span class="line">    JSONArray jsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String productId : productIds.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;id\&quot;: &quot;</span> + productId + <span class="string">&quot;, \&quot;name\&quot;: \&quot;iphone7手机\&quot;, \&quot;price\&quot;: 5599, \&quot;pictureList\&quot;:\&quot;a.jpg,b.jpg\&quot;, \&quot;specification\&quot;: \&quot;iphone7的规格\&quot;, \&quot;service\&quot;: \&quot;iphone7的售后服务\&quot;, \&quot;color\&quot;: \&quot;红色,白色,黑色\&quot;, \&quot;size\&quot;: \&quot;5.5\&quot;, \&quot;shopId\&quot;: 2, \&quot;modifiedTime\&quot;: \&quot;2018-02-21 21:11:34\&quot;, \&quot;cityId\&quot;: 1&#125;&quot;</span>;</span><br><span class="line">        jsonArray.add(JSON.parse(json));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonArray.toJSONString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请求合并测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpUtil.get(<span class="string">&quot;http://localhost:8081/getProductInfos?productIds=1,2,3,4,5,6,7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CacheController#getProductInfos</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Future&lt;ProductInfo&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String productId : productIds.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">    GetProductInfosCollapser getProductInfosCollapser = <span class="keyword">new</span> GetProductInfosCollapser(Long.valueOf(productId));</span><br><span class="line">    futures.add(getProductInfosCollapser.queue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Future&lt;ProductInfo&gt; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CacheController结果：&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把所有需要查询的商品通过HystrixCollapser发送，HystrixCollapser会为自动为我们讲请求合并以后访问。可能第一次访问的时候会超时，因为开发环境项目刚启动，第一次访问比较慢，第二次就好了。</p>
<p><strong>输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createCommand方法执行，params&#x3D;1,2,3,4,5,6,7</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:1,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:2,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:3,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:4,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:5,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:6,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">BatchCommand内部， productInfo&#x3D;&#123;&quot;cityId&quot;:1,&quot;color&quot;:&quot;红色,白色,黑色&quot;,&quot;id&quot;:7,&quot;modifiedTime&quot;:&quot;2018-02-21 21:11:34&quot;,&quot;name&quot;:&quot;iphone7手机&quot;,&quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;,&quot;price&quot;:5599.0,&quot;service&quot;:&quot;iphone7的售后服务&quot;,&quot;shopId&quot;:2,&quot;size&quot;:&quot;5.5&quot;,&quot;specification&quot;:&quot;iphone7的规格&quot;&#125;</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;1, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;2, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;3, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;4, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;5, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;6, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">CacheController结果：ProductInfo(id&#x3D;7, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;2, modifiedTime&#x3D;2018-02-21 21:11:34, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br></pre></td></tr></table></figure>


<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>HystrixCollapser提供了一些配置：</p>
<ol>
<li><p>maxRequestsInBatch</p>
<p> 控制一个Batch中最多允许多少个request被合并，然后才会触发一个batch的执行</p>
</li>
<li><p>timerDelayInMilliseconds</p>
<p> 控制一个batch创建之后，多长时间以后就自动触发batch的执行，默认是10毫秒</p>
</li>
</ol>
<h2 id="fail-fast和fail-silent"><a href="#fail-fast和fail-silent" class="headerlink" title="fail-fast和fail-silent"></a>fail-fast和fail-silent</h2><p>HystrixCommand如果命令执行执行中出错了，或者抛异常了它有两种方式后续逻辑：</p>
<ul>
<li>fail-fast，就是不给fallback降级逻辑，HystrixCommand.run()，会直接从Hystrix的线程池中抛出异常，打印出日志，无法在调用方捕获</li>
<li>fail-silent，给一个fallback降级逻辑，如果HystrixCommand.run()，报错了，会走fallback降级，但是降级逻辑返回一个null值</li>
</ul>
<p>很少会用fail-fast模式，比较常用的可能还是fail-silent，不过既然都到了fallback里面，肯定要做点降级的事情。</p>
<h3 id="stubbed-fallback"><a href="#stubbed-fallback" class="headerlink" title="stubbed fallback"></a>stubbed fallback</h3><p>stubbed fallback: 残缺的降级</p>
<p>用请求中的部分数据拼装成结果，然后再填充一些默认值返回。比如说你发起了一个请求，然后请求中可能本身就附带了一些信息，如果主请求失败了，走到降级逻辑。在降级逻辑里面，可以将这个请求中的数据，以及部分本地缓存有的数据拼装在一起，再给数据填充一些简单的默认值<br>然后尽可能将自己有的数据返回到请求方。</p>
<h3 id="多级降级"><a href="#多级降级" class="headerlink" title="多级降级"></a>多级降级</h3><p>先降一级，尝试用一个备用方案去执行，如果备用方案失败了，再用最后下一个备用方案去执行。</p>
<p>hystrix command fallback语义，很容易就可以实现多级降级的策略，command嵌套command就可以达到多级降级的效果，第二个command其实是第一级降级策略。常见的多级降级的做法有一个操作，如果访问MySQL数据库，mysql数据库访问报错，降级，去redis中获取数据，如果说redis又挂了，然后就去从本地ehcache缓存中获取数据。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FirstLevelFallbackCommand(productId).execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstLevelFallbackCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long productId;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FirstLevelFallbackCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 第一级的降级策略，因为这个command是运行在fallback中的</span></span><br><span class="line">		<span class="comment">// 所以至关重要的一点是，在做多级降级的时候，要将降级command的线程池单独做一个出来</span></span><br><span class="line">		<span class="comment">// 如果主流程的command都失败了，可能线程池都已经被占满了</span></span><br><span class="line">		<span class="comment">// 降级command必须用自己的独立的线程池</span></span><br><span class="line">		<span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ProductInfoService&quot;</span>))</span><br><span class="line">					.andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;FirstLevelFallbackCommand&quot;</span>))</span><br><span class="line">					.andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">&quot;FirstLevelFallbackPool&quot;</span>))</span><br><span class="line">		);  </span><br><span class="line">		<span class="keyword">this</span>.productId = productId;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 这里，因为是第一级降级的策略，所以说呢，其实是要从备用机房的机器去调用接口</span></span><br><span class="line">		<span class="comment">// 但是，我们这里没有所谓的备用机房，所以说还是调用同一个服务来模拟</span></span><br><span class="line">		<span class="keyword">if</span>(productId.equals(-<span class="number">2L</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">		&#125;</span><br><span class="line">		String url = <span class="string">&quot;http://127.0.0.1:8082/getProductInfo?productId=&quot;</span> + productId;</span><br><span class="line">		String response = HttpClientUtils.sendGetRequest(url);</span><br><span class="line">		<span class="keyword">return</span> JSONObject.parseObject(response, ProductInfo.class);  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 第二级降级策略，第一级降级策略，都失败了</span></span><br><span class="line">		ProductInfo productInfo = <span class="keyword">new</span> ProductInfo();</span><br><span class="line">		<span class="comment">// 从请求参数中获取到的唯一条数据</span></span><br><span class="line">		productInfo.setId(productId); </span><br><span class="line">		<span class="comment">// 从本地缓存中获取一些数据</span></span><br><span class="line">		productInfo.setBrandId(BrandCache.getBrandId(productId));</span><br><span class="line">		productInfo.setBrandName(BrandCache.getBrandName(productInfo.getBrandId()));  </span><br><span class="line">		productInfo.setCityId(LocationCache.getCityId(productId)); </span><br><span class="line">		productInfo.setCityName(LocationCache.getCityName(productInfo.getCityId()));  </span><br><span class="line">		<span class="comment">// 手动填充一些默认的数据</span></span><br><span class="line">		productInfo.setColor(<span class="string">&quot;默认颜色&quot;</span>);  </span><br><span class="line">		productInfo.setModifiedTime(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">		productInfo.setName(<span class="string">&quot;默认商品&quot;</span>);  </span><br><span class="line">		productInfo.setPictureList(<span class="string">&quot;default.jpg&quot;</span>);  </span><br><span class="line">		productInfo.setPrice(<span class="number">0.0</span>);  </span><br><span class="line">		productInfo.setService(<span class="string">&quot;默认售后服务&quot;</span>);  </span><br><span class="line">		productInfo.setShopId(-<span class="number">1L</span>);  </span><br><span class="line">		productInfo.setSize(<span class="string">&quot;默认大小&quot;</span>);  </span><br><span class="line">		productInfo.setSpecification(<span class="string">&quot;默认规格&quot;</span>);   </span><br><span class="line">		<span class="keyword">return</span> productInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="手动降级"><a href="#手动降级" class="headerlink" title="手动降级"></a>手动降级</h3><ul>
<li>手动降级实现方式是写一个command，在这个command它的主流程中，根据一个标识位，判断要执行哪个流程，可以执行主流程，也可以执行一个备用降级的command。</li>
</ul>
<ul>
<li><p>它的使用场景：一般来说都是去执行一个主流程的command，如果说你现在知道主流程有问题了，希望能够手动降级的话，动态给服务发送个请求。在请求中修改标识位，自动就让command以后都直接过来执行备用command。</p>
</li>
<li><p>一般会嵌套3个command，套在最外面的command，是用semaphore信号量做限流和资源隔离的，因为这个command不用去care timeout的问题，嵌套调用的command会自己去管理timeout超时的</p>
</li>
</ul>
<p>代码片段如下，通过<code>IsDegrade.isDegrade()</code>可以设置是否手动降级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangfan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetProductInfoFacadeCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">ProductInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetProductInfoFacadeCommand</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;ProductInfoService&quot;</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">&quot;GetProductInfoFacadeCommand&quot;</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">15</span>)));</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!IsDegrade.isDegrade()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GetProductInfoCommand(productId).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GetProductInfoFromMySQLCommand(productId).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProductInfo <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了这么多Hystrix的配置和使用方式，我们在生产环境里最需要关注的点是什么？</p>
<ol>
<li>线程池大小设置</li>
<li>timeout时长设置</li>
</ol>
<p>这个配置也没有说固定是多少，但是有一些规律可循。一般一开始需要将一些关键配置设置的大一些，比如timeout超时时长，线程池大小，或信号量容量。然后逐渐优化这些配置，直到在一个生产系统中运作良好。</p>
<ol>
<li>一开始先不要设置timeout超时时长，默认就是1000ms，也就是1s</li>
<li>一开始也不要设置线程池大小，默认就是10</li>
<li>直接部署hystrix到生产环境，如果运行的很良好，那么就让它这样运行好了</li>
<li>让hystrix应用，24小时运行在生产环境中</li>
<li>依赖标准的监控和报警机制来捕获到系统的异常运行情况</li>
<li>在24小时之后，看一下调用延迟的占比，以及流量，来计算出让短路器生效的最小的配置数字</li>
<li>直接对hystrix配置进行热修改，然后继续在hystrix dashboard上监控</li>
<li>看看修改配置后的系统表现有没有改善</li>
</ol>
<p><strong>最佳方案：</strong></p>
<ol>
<li>线程池大小：假设一个请求200ms，QPS30。那么每秒的高峰访问次数 * 99%的访问延时 + buffer = 30 * 0.2 + 4 = 10线程，10个线程每秒处理30次访问应该足够了，每个线程处理3次访问。</li>
<li>timeout：合理的timeout设置应该为300ms，也就是99.5%的访问延时，计算方法是，因为判断每次访问延时最多在250ms（TP99如果是200ms的话），再加一次重试时间50ms，就是300ms，感觉也应该足够了</li>
</ol>
<p>如果线程池设置得比较死，那么如果某个服务高峰期来了线程不够用，别的服务又占着线程池不用，这样就很不合理了，所以Hystrix也为我们提供了动态调整线程池的方案。</p>
<ol>
<li><p>coreSize</p>
<p> 设置线程池的大小，默认是10</p>
<p> HystrixThreadPoolProperties.Setter()</p>
<pre><code>.withCoreSize(int value)</code></pre>
</li>
<li><p>maximumSize</p>
<p> 设置线程池的最大大小，只有在设置<code>allowMaximumSizeToDivergeFromCoreSize</code>的时候才能生效</p>
<p> 默认是10</p>
<p> <code>HystrixThreadPoolProperties.Setter().withMaximumSize(int value) </code></p>
</li>
<li><p>keepAliveTimeMinutes</p>
<p> 设置保持存活的时间，单位是分钟，默认是1</p>
<p> 如果设置<code>allowMaximumSizeToDivergeFromCoreSize</code>为true，那么coreSize就不等于maxSize，此时线程池大小是可以动态调整的，可以获取新的线程，也可以释放一些线程</p>
<p> 如果coreSize &lt; maxSize，那么这个参数就设置了一个线程多长时间空闲之后，就会被释放掉</p>
<p> <code>HystrixThreadPoolProperties.Setter().withKeepAliveTimeMinutes(int value)</code></p>
</li>
<li><p>allowMaximumSizeToDivergeFromCoreSize</p>
<p> 允许线程池大小自动动态调整，设置为true之后，maxSize就生效了，此时如果一开始是coreSize个线程，随着并发量上来，那么就会自动获取新的线程，但是如果线程在keepAliveTimeMinutes内空闲，就会被自动释放掉</p>
<p> 默认是false</p>
<p> <code>HystrixThreadPoolProperties.Setter().withAllowMaximumSizeToDivergeFromCoreSize(boolean value)</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign和Hystrix的结合使用</title>
    <url>/2020/04/19/springcloud/hystrix05/</url>
    <content><![CDATA[<h1 id="Feign和Hystrix结合使用"><a href="#Feign和Hystrix结合使用" class="headerlink" title="Feign和Hystrix结合使用"></a>Feign和Hystrix结合使用</h1><p>在@FeignClient中增加fallback配置，指定降级方法的执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user&quot;,url = &quot;$&#123;user.url&#125;&quot;,fallback = UserFeignFallback.class</span></span><br><span class="line"><span class="meta">        /*fallbackFactory = UserFeignFactory.class*/)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>降级方法的编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFeignFallback</span> <span class="keyword">implements</span> <span class="title">UserFeign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByID</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;fallback 回调用户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Feign和Hystrix整合的配置"><a href="#Feign和Hystrix整合的配置" class="headerlink" title="Feign和Hystrix整合的配置"></a>Feign和Hystrix整合的配置</h2><p>超时时间设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure>

<p>如果要特定某个服务的配置，就不写default，这个user是FeignClient的服务名，对应一个HystrixGroup，具体的key就是方法名。</p>
<p>那么如果想针对服务的某一个方法配置怎么办？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="string">ServiceA#sayHello(Long,String):</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure>



<h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><p>hystrix.threadpool.default.coreSize：线程池大小，默认10</p>
<p>hystrix.threadpool.default.maximumSize：线程池最大大小，默认10</p>
<p>hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize：是否允许动态调整线程数量，默认false，只有设置为true了，上面的maximumSize才有效</p>
<p>hystrix.threadpool.default.keepAliveTimeMinutes ：默认是1，超出coreSize的线程，空闲1分钟后释放掉</p>
<p>hystrix.threadpool.default.maxQueueSize 默认－1，不能动态修改</p>
<p>hystrix.threadpool.default.queueSizeRejectionThreshold 可以动态修改，默认是5，先进入请求队列，然后再由线程池执行</p>
<h3 id="如何计算线程池数量？"><a href="#如何计算线程池数量？" class="headerlink" title="如何计算线程池数量？"></a>如何计算线程池数量？</h3><h4 id="高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间"><a href="#高峰期每秒的请求数量-1000毫秒-TP99请求延时-buffer空间" class="headerlink" title="高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间"></a>高峰期每秒的请求数量 / 1000毫秒 / TP99请求延时 + buffer空间</h4><p>比如说处理一个请求，要50ms，那么TP99，也就是99%的请求里处理一个请求耗时最长是50ms。</p>
<p>我们给一点缓冲空间10ms，那就是处理请求接口耗时60ms。</p>
<p> 所以一秒钟一个线程可以处理：1000 / 60 = 16，一个线程一秒钟可以处理16个请求。</p>
<p> 假设高峰期，每秒最多1200个请求，一个线程每秒可以处理16个请求，需要多少个线程才能处理每秒1200个请求呢？1200 / 16 = 75，最多需要75个线程，每个线程每秒处理16个请求，75个线程每秒才可以处理1200个请求。</p>
<p>最多需要多少个线程数量，就是这样子算出来</p>
<h4 id="如果是服务B-gt-服务A的话，服务B线程数量怎么设置"><a href="#如果是服务B-gt-服务A的话，服务B线程数量怎么设置" class="headerlink" title="如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置"></a>如果是服务B -&gt; 服务A的话，服务B线程数量怎么设置</h4><p>服务B调用服务A的线程池需要多少个线程呢？</p>
<p>高峰期，服务B最多要调用服务A每秒钟1200次，服务A处理一个请求是60ms，服务B每次调用服务A的时候，用一个线程发起一次请求，那么这个服务B的这个线程，要60ms才能返回。</p>
<p>服务B而言，一个线程对服务A发起一次请求需要60ms，一个线程每秒钟可以请求服务A达到16次，但是现在服务B每秒钟需要请求服务A达到1200次，那么服务B就需要75个线程，在高峰期并发请求服务A，才可以完成每秒1200次的调用。</p>
<p>服务B，部署多台机器，每台机器调用服务A的线程池有10个线程，比如说搞个10个线程，一共部署10台机器，那么服务B调用服务A的线程数量，一共有100个线程，轻轻松松可以支撑高峰期调用服务A的1200次的场景</p>
<p>每个线程调用服务A一次，耗时60ms，每个线程每秒可以调用服务A一共是16次，100个线程，每秒最多可以调用服务A是1600次，高峰的时候只要支持调用服务A的1200次就可以了，所以这个机器部署就绰绰有余了</p>
<h2 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h2><p>hystrix.command.default.execution.isolation.strategy：隔离策略，默认Thread，可以选择Semaphore信号量 </p>
<p>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：超时时间，默认1000ms</p>
<p>hystrix.command.default.execution.timeout.enabled：是否启用超时，默认ture</p>
<p>hystrix.command.default.execution.isolation.thread.interruptOnTimeout：超时的时候是否中断执行，默认true  </p>
<p>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests：信号量隔离策略下，允许的最大并发请求数量，默认10</p>
<h2 id="降级配置"><a href="#降级配置" class="headerlink" title="降级配置"></a>降级配置</h2><p>hystrix.command.default.fallback.enabled 默认true</p>
<h2 id="熔断配置"><a href="#熔断配置" class="headerlink" title="熔断配置"></a>熔断配置</h2><p>hystrix.command.default.circuitBreaker.enabled：是否启用熔断器默认true</p>
<p>hystrix.command.default.circuitBreaker.requestVolumeThreshold：10秒钟内，请求数量达到多少才能去尝试触发熔断，默认20</p>
<p>hystrix.command.default.circuitBreaker.errorThresholdPercentage：10秒钟内，请求数量达到20，同时异常比例达到50%，就会触发熔断，默认50</p>
<p>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：触发熔断之后，5s内直接拒绝请求，走降级逻辑，5s后尝试half-open放过少量流量试着恢复，默认5000</p>
<p>hystrix.command.default.circuitBreaker.forceOpen：强制打开熔断器</p>
<p>hystrix.command.default.circuitBreaker.forceClosed：强制关闭熔断器</p>
<h2 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h2><p>hystrix.threadpool.default.metrics.rollingStats.timeInMillisecond：线程池统计指标的时间，默认10000，就是10s</p>
<p>hystrix.threadpool.default.metrics.rollingStats.numBuckets：将rolling window划分为n个buckets，默认10</p>
<p>hystrix.command.default.metrics.rollingStats.timeInMilliseconds：command的统计时间，熔断器是否打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</p>
<p>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</p>
<p>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</p>
<p>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</p>
<p>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</p>
<p>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</p>
<p>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</p>
<h2 id="高阶特性配置"><a href="#高阶特性配置" class="headerlink" title="高阶特性配置"></a>高阶特性配置</h2><p>hystrix.command.default.requestCache.enabled 默true </p>
<p>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true </p>
<p>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</p>
<p>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</p>
<p>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</p>
<h1 id="Feign和Hystrix结合的原理"><a href="#Feign和Hystrix结合的原理" class="headerlink" title="Feign和Hystrix结合的原理"></a>Feign和Hystrix结合的原理</h1><p>Feign在和Hystrix整合的时候，feign动态代理里面有一些Hystrix相关的代码，请求走feign动态代理的时候，就会基于Hystrix Command发送请求，实现服务间调用的隔离、限流、超时、降级、熔断、统计等。</p>
<p><img src="/img/spring-cloud/Feign%E5%92%8CHystrix%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="Feign和Hystrix的核心原理"></p>
<h2 id="Feign中基于Hystrix的动态代理"><a href="#Feign中基于Hystrix的动态代理" class="headerlink" title="Feign中基于Hystrix的动态代理"></a>Feign中基于Hystrix的动态代理</h2><p>在Feign的动态代理代码中，HystrixTargeter默认情况下，在没有开启Hystrix的时候，会使用自带的Feign.Builder。在启用Hystrix走，就使用HystrixFeign.Builder。</p>
<p><strong>HystrixFeign.Builder是在这里创建的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FeignClientsConfiguration.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">   <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HystrixTargeter中，用Hystrix构造动态代理的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">               Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 没有开启Hystrix的话，走这个逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">      <span class="keyword">return</span> feign.target(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在有Hystrix的条件下，就开始往这下面走。</span></span><br><span class="line">   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">   <span class="comment">// 用于读取yaml文件中的Hystrix相关的配置，在执行命令的时候会用到</span></span><br><span class="line">   SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">      SetterFactory.class);</span><br><span class="line">   <span class="keyword">if</span> (setterFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.setterFactory(setterFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 有降级的话，就用降级包装下</span></span><br><span class="line">   Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">   <span class="keyword">if</span> (fallback != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">   <span class="keyword">if</span> (fallbackFactory != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建一个fallback的实例，从和服务相关联的Spring上下文里获取ServiceAClient的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallback</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HystrixFeign.Builder builder, Class&lt;?&gt; fallback)</span> </span>&#123;</span><br><span class="line">   T fallbackInstance = getFromContext(<span class="string">&quot;fallback&quot;</span>, feignClientName, context, fallback, target.type());</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用工厂创建一个实例，并校验是否是ServiceAClient接口的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixTargeter.java</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">targetWithFallbackFactory</span><span class="params">(String feignClientName, FeignContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Target.HardCodedTarget&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                              HystrixFeign.Builder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Class&lt;?&gt; fallbackFactoryClass)</span> </span>&#123;</span><br><span class="line">   FallbackFactory&lt;? extends T&gt; fallbackFactory = (FallbackFactory&lt;? extends T&gt;)</span><br><span class="line">      getFromContext(<span class="string">&quot;fallbackFactory&quot;</span>, feignClientName, context, fallbackFactoryClass, FallbackFactory.class);</span><br><span class="line">   <span class="comment">/* We take a sample fallback from the fallback factory to check if it returns a fallback</span></span><br><span class="line"><span class="comment">   that is compatible with the annotated feign interface. */</span></span><br><span class="line">   <span class="comment">// 创建一个对象出来看看，检测一下创建出来的对象是否符合要求</span></span><br><span class="line">   Object exampleFallback = fallbackFactory.create(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">   Assert.notNull(exampleFallback,</span><br><span class="line">      String.format(</span><br><span class="line">      <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory may not produce null!&quot;</span>,</span><br><span class="line">         feignClientName));</span><br><span class="line">   <span class="keyword">if</span> (!target.type().isAssignableFrom(exampleFallback.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         String.format(</span><br><span class="line">            <span class="string">&quot;Incompatible fallbackFactory instance for feign client %s. Factory produces instances of &#x27;%s&#x27;, but should produce instances of &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">            feignClientName, exampleFallback.getClass(), target.type()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> builder.target(target, fallbackFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在确认fallbackFactory创建出来的对象没有问题后，调用HystrixFeign的target方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target, T fallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build(fallback != <span class="keyword">null</span> ? <span class="keyword">new</span> FallbackFactory.Default&lt;T&gt;(fallback) : <span class="keyword">null</span>)</span><br><span class="line">      .newInstance(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要注意build方法，里面就包含了两局关键的代码，他重新设置了invocationHandlerFactory和contract</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixFeign.java</span></span><br><span class="line"><span class="function">Feign <span class="title">build</span><span class="params">(<span class="keyword">final</span> FallbackFactory&lt;?&gt; nullableFallbackFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.invocationHandlerFactory(<span class="keyword">new</span> InvocationHandlerFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 关键代码 HystrixInvocationHandler，包含了基于HystrixCommand的封装，实际还是调用dispatch</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HystrixInvocationHandler(target, dispatch, setterFactory, nullableFallbackFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 关键代码HystrixDelegatingContract，用于解析Hystrix相关的注解</span></span><br><span class="line">  <span class="keyword">super</span>.contract(<span class="keyword">new</span> HystrixDelegatingContract(contract));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/img/spring-cloud/%E5%90%AF%E7%94%A8Hystrix%E4%B9%8B%E5%90%8Efeign%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="启用Hystrix之后feign生成动态代理的过程"></p>
<p>再往后的代码就和Hystrix没有关系了，就在feign的动态代理那一套东西，下面继续看HystrixInvocationHandler封装的细节。</p>
<h2 id="Feign中HystrixCommand的执行细节"><a href="#Feign中HystrixCommand的执行细节" class="headerlink" title="Feign中HystrixCommand的执行细节"></a>Feign中HystrixCommand的执行细节</h2><p>HystrixInvocationHandler，作为一个动态代理的接口，看下它的invoke方法，他构造了一个HystrixCommand，利用Hystrix包装了请求的执行，在HystrixCommand的run方法里，就包含了执行调用的代码（SynchronousMethodHandler）。如果执行请求的时候报错的话，就会调用getFallbac方法，就会执行之前配置的降级方法，执行降级的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixInvocationHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// early exit if the invoked method is from java.lang.Object</span></span><br><span class="line">  <span class="comment">// code is the same as ReflectiveFeign.FeignInvocationHandler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object otherHandler =</span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造一个HystrixCommand匿名内部类,每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的配置，例如超时时间等</span></span><br><span class="line">  HystrixCommand&lt;Object&gt; hystrixCommand = <span class="keyword">new</span> HystrixCommand&lt;Object&gt;(setterMethodMap.get(method)) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用SynchronousMethodHandler,也就是发起Http请求的代码</span></span><br><span class="line">        <span class="keyword">return</span> HystrixInvocationHandler.<span class="keyword">this</span>.dispatch.get(method).invoke(args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果降级方法不存在的话，父类会直接报错UnsupportedOperationException。</span></span><br><span class="line">      <span class="keyword">if</span> (fallbackFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFallback();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建fallback</span></span><br><span class="line">        Object fallback = fallbackFactory.create(getExecutionException());</span><br><span class="line">        <span class="comment">// 调用之前定义的fallback方法</span></span><br><span class="line">        Object result = fallbackMethodMap.get(method).invoke(fallback, args);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((HystrixCommand) result).execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable</span></span><br><span class="line">          <span class="keyword">return</span> ((Observable) result).toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">          <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">          <span class="keyword">return</span> ((Single) result).toObservable().toBlocking().first();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">          ((Completable) result).await();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// shouldn&#x27;t happen as method is public due to being an interface</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// Exceptions on fallback are tossed by Hystrix</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</span></span><br><span class="line">  <span class="keyword">if</span> (isReturnsHystrixCommand(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsObservable(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsSingle(method)) &#123;</span><br><span class="line">    <span class="comment">// Create a cold Observable as a Single</span></span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toSingle();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReturnsCompletable(method)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hystrixCommand.toObservable().toCompletable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hystrixCommand.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在HystrixInvocationHandler构造的时候，构造了一个setterMethodMap，每一个Method对象，都对应了一个HystrixCommand.Setter，也就是说每一个方法都对应了一个HystrixCommand的key和groupkey的配置，例如超时时间等，线程池配置等，Setter被创建的时候，用的就是@FeignClient的name作为groupKey，也就是ServiceA，commandKey用于是类名+方法名（ServiceA#sayHello(Long,String)），这个groupKey就对应了一个线程池的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetterFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HystrixCommand.<span class="function">Setter <span class="title">create</span><span class="params">(Target&lt;?&gt; target, Method method)</span> </span>&#123;</span><br><span class="line">  String groupKey = target.name();</span><br><span class="line">  String commandKey = Feign.configKey(target.type(), method);</span><br><span class="line">  <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))</span><br><span class="line">      .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>基于Method对象对应的setterMethodMap，构造一个HystrixCommand匿名内部类</li>
<li>内部类实现了run方法和getFallback方法</li>
<li>run方法直接调用调用SynchronousMethodHandler发起http请求</li>
<li>如果run方法执行异常，getFallback方法调用之前在FeignClient中定义的降级方法</li>
<li>检查Feign方法的返回类型，可以拿到Hystrix的相关的返回类型，比如HystrixCommand、Observable、Single、Completable。</li>
</ol>
<p>到这里已经看到调用了HystrixCommand的execute方法，所以接下来的内容，将会进入到Hystrix的源码中，下一篇文章细说。</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud微服务-2-SpringBoot起步</title>
    <url>/2019/04/12/springcloud/microservices-2/</url>
    <content><![CDATA[<p>微服务学习笔记</p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p><a href="https://spring.io/projects/spring-boot#learn">https://spring.io/projects/spring-boot#learn</a></p>
<p>要创建一个Spring Boot项目，可以去<a href="https://start.spring.io/%EF%BC%8C%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BA%E3%80%82">https://start.spring.io/，一键创建。</a></p>
<p><img src="/img/spring-cloud/sc02-1.png"></p>
<p>依赖中加入Web，然后点击<code>Generate Project</code>，就会下载一个压缩包。</p>
<a id="more"></a>
<p>解压后看看目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-lecture tree</span><br><span class="line">.</span><br><span class="line">├── HELP.md</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── test</span><br><span class="line">    │   │           └── springlecture</span><br><span class="line">    │   │               └── SpringLectureApplication.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.properties</span><br><span class="line">    │       ├── static</span><br><span class="line">    │       └── templates</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── test</span><br><span class="line">                    └── springlecture</span><br><span class="line">                        └── SpringLectureApplicationTests.java</span><br><span class="line"></span><br><span class="line">16 directories, 10 files</span><br></pre></td></tr></table></figure>

<p>在build.gradle中包含了依赖的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.1.4.RELEASE&#x27;</span></span><br><span class="line">	id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">&#x27;io.spring.dependency-management&#x27;</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.test&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">	testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到引入了spring-boot-starter-web的依赖，因为<code>io.spring.dependency-management</code>插件的关系，所以在配置文件里不需要写版本号，就像maven里的dependencyManagement一样。</p>
<p>源码地址：</p>
<p><a href="https://github.com/sail-y/spring-cloud-lecture">https://github.com/sail-y/spring-cloud-lecture</a></p>
<p>执行命令<code>gradle bootRun</code>，就能启动，访问 <a href="http://127.0.0.1:9090/api/test">http://127.0.0.1:9090/api/test</a></p>
<p>返回</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: 18,</span><br><span class="line">  name: &quot;zhangsan&quot;,</span><br><span class="line">  birthday: &quot;2019-04-10T12:15:53.666+0000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几乎所有的配置都可以在<code>application.properties</code>文件里完成，这里用<code>server.port</code>配置了一个端口号，Spring Boot也支持yml格式的配置文件。这也是我自己在项目中一直使用的格式。</p>
<h2 id="bootJar"><a href="#bootJar" class="headerlink" title="bootJar"></a>bootJar</h2><p>执行<code>gradle task</code>，可以看到Spring Boot插件为我们提供了几个任务，其中一个是bootRun，可以直接启动应用。bootJar，可以把应用打包成一个<strong>fat jar</strong>。用<code>java -jar spring-lecture-0.0.1-SNAPSHOT.jar</code>就可以启动应用，这跟普通的jar包不一样。</p>
<p>现在解压这个jar包来看看里面的内容，跟传统的jar或者war包不一样，解压后并没有看到我们自己的代码编译后的文件在哪里，在根目录下的org里的class文件却并不是我们自己写的，下面分析一下解压后的目录结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -xvf spring-lecture-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> libs (master✔)ls</span><br><span class="line">BOOT-INF  META-INF  org </span><br><span class="line">➜  libs (master✔)tree BOOT-INF -d</span><br><span class="line">BOOT-INF</span><br><span class="line">├── classes</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── <span class="built_in">test</span></span><br><span class="line">│   │       └── springlecture</span><br><span class="line">│   │           ├── controller</span><br><span class="line">│   │           └── domain</span><br><span class="line">│   ├── static</span><br><span class="line">│   └── templates</span><br><span class="line">└── lib</span><br><span class="line"></span><br><span class="line">9 directories</span><br></pre></td></tr></table></figure>


<p><code>BOOT-INF</code>里包含了我们自己项目里编译后的配置文件和class文件，以及<code>lib</code>里包含的项目依赖的三方jar。</p>
<p>接下来看META-INF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜  libs (master✔)cat META-INF/MANIFEST.MF </span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Start-Class: com.test.springlecture.SpringLectureApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Spring-Boot-Version: <span class="number">2.1</span>.<span class="number">4.</span>RELEASE</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Main-Class是打包的jar包含main方法的启动类，Start-Class是Spring Boot自定义的属性。</p>
<p><strong>注意Main-Class最后有一个回车换行，这个是必须的，不然无法使用。</strong></p>
<p>接下来看另外一个文件夹<code>org</code>，这里面的类是Spring Boot打包插件在打jar包的时候自动放进去的，Spring Boot这些类功能很巧妙的解决了fat jar是如何打包出来的，以及BOOT-INF下面的类和jar包是如何被加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org</span><br><span class="line">└── springframework</span><br><span class="line">    └── boot</span><br><span class="line">        └── loader</span><br><span class="line">            ├── ExecutableArchiveLauncher.class</span><br><span class="line">            ├── JarLauncher.class</span><br><span class="line">            ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">            ├── LaunchedURLClassLoader.class</span><br><span class="line">            ├── Launcher.class</span><br><span class="line">            ├── MainMethodRunner.class</span><br><span class="line">            ├── PropertiesLauncher$<span class="number">1.</span>class</span><br><span class="line">            ├── PropertiesLauncher$ArchiveEntryFilter.class</span><br><span class="line">            ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class</span><br><span class="line">            ├── PropertiesLauncher.class</span><br><span class="line">            ├── WarLauncher.class</span><br><span class="line">            ├── archive</span><br><span class="line">            ├── data</span><br><span class="line">            ├── jar</span><br><span class="line">            └── util</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> directories, <span class="number">50</span> files</span><br></pre></td></tr></table></figure>


<p>这都是SpringBoot提供的类，发现没有？org.springframework.boot.loader.JarLauncher就在这里。这样的文件结构，和这些类都是什么意思呢？</p>
<p>如果我们要查看org.springframework.boot.loader.JarLauncher的源码，需要引入以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;org.springframework.boot:spring-boot-loader&#39;</span><br></pre></td></tr></table></figure>

<p>这是插件的一个依赖，在实际开发中，我们并不需要引入这个依赖，现在我们可以查看这个类的源码。</p>
<p><img src="/img/spring-cloud/sc02-2.png"></p>
<p>javadoc解释了，Launcher假设依赖包在/BOOT-INF/lib文件夹中，应用的class文件在/BOOT-INF/classes中。</p>
<p><code>ExecutableArchiveLauncher</code>的子类除了<code>JarLauncher</code>，还有一个<code>WarLauncher</code>。从名字就能看出来，是分别用于启动Jar包和War包的启动类。</p>
<p>main方法：</p>
<p><code>new JarLauncher().launch(args);</code></p>
<p>launch方法doc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application. This method is the initial entry point that should be</span></span><br><span class="line"><span class="comment"> * called by a subclass &#123;<span class="doctag">@code</span> public static void main(String[] args)&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the incoming arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the application fails to launch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	JarFile.registerUrlProtocolHandler();</span><br><span class="line">	ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">	launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里构建了一个类加载器。</p>
<blockquote>
<p>它会找到类当前路径所在的jar包，得到一个archive对象。因为jar包的标准是只能加载根目录下的class文件，无法加载jar包里面的jar包，所以spring boot自己实现了类加载器来加载我们应用的第三方依赖和classes文件。</p>
</blockquote>
<blockquote>
<p><code>JarLauncher.isNestedArchive</code>就包含了这部分的判断逻辑。处理了BOOT-INF/classes/的目录和以BOOT-INF/lib/开头的文件，此方法在getClassPathArchives内部被调用。</p>
</blockquote>
<p><code>ClassLoader classLoader = createClassLoader(getClassPathArchives());</code>则是为了加载这2个目录下的class和jar包，最后代码跟踪到<code>new LaunchedURLClassLoader(urls, getClass().getClassLoader());</code>。LaunchedURLClassLoader就是Spring Boot提供的全新的类加载器了。</p>
<blockquote>
<p>URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。</p>
</blockquote>
<p>再来关注<code>launch(args, getMainClass(), classLoader);</code>这行代码，getMainClass()从Manifest文件里读取了<code>Start-Class</code>，也就是我们自己的应用的启动类。</p>
<p>然后是<code>launch</code>方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br></pre></td></tr></table></figure>

<p>把SpringBoot提供的类加载器，设置成线程上下文类加载器。</p>
<p>createMainMethodRunner创建main方法的执行器。这里有关键代码，我们的启动类是如何被加载和启动的。</p>
<p>MainMethodRunner.run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">			.loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">	Method mainMethod = mainClass.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">	mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得之前设置的类加载器，进行类加载，然后用反射的方式调用main方法。</p>
<p><code>mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</code>这行代码反射，前面是null，是因为main方法是静态的，所以不需要传对象进去。</p>
<p>以上就解释了jar包里的文件夹结构，以及加载启动类的流程。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>增加一行代码打印SpringLectureApplication这个类的类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringLectureApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(SpringLectureApplication.class.getClassLoader());</span><br><span class="line">		SpringApplication.run(SpringLectureApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一下，用java -jar启动，和在IDE里右键启动，打印出来的内容会是一样的吗？</p>
<p>右键启动输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@58644d46</span><br></pre></td></tr></table></figure>

<p>jar包启动输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader@17a7cec2</span><br></pre></td></tr></table></figure>

<h2 id="JDWP远程调试"><a href="#JDWP远程调试" class="headerlink" title="JDWP远程调试"></a>JDWP远程调试</h2><p>Java Debug Wire Protocol，Java调试协议</p>
<p>我们可以用远程的方式去调试一个正在运行的应用，比如打断点什么的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ java -agentlib:jdwp=<span class="built_in">help</span></span><br><span class="line">               Java Debugger JDWP Agent Library</span><br><span class="line">               --------------------------------</span><br><span class="line"></span><br><span class="line">  (see http://java.sun.com/products/jpda <span class="keyword">for</span> more information)</span><br><span class="line"></span><br><span class="line">jdwp usage: java -agentlib:jdwp=[<span class="built_in">help</span>]|[&lt;option&gt;=&lt;value&gt;, ...]</span><br><span class="line">Option Name and Value            Description                       Default</span><br><span class="line">---------------------            -----------                       -------</span><br><span class="line"><span class="built_in">suspend</span>=y|n                      <span class="built_in">wait</span> on startup?                  y</span><br><span class="line">transport=&lt;name&gt;                 transport spec                    none</span><br><span class="line">address=&lt;listen/attach address&gt;  transport spec                    <span class="string">&quot;&quot;</span></span><br><span class="line">server=y|n                       listen <span class="keyword">for</span> debugger?              n</span><br><span class="line">launch=&lt;<span class="built_in">command</span> line&gt;            run debugger on event             none</span><br><span class="line">onthrow=&lt;exception name&gt;         debug on throw                    none</span><br><span class="line">onuncaught=y|n                   debug on any uncaught?            n</span><br><span class="line">timeout=&lt;timeout value&gt;          <span class="keyword">for</span> listen/attach <span class="keyword">in</span> milliseconds n</span><br><span class="line">mutf8=y|n                        output modified utf-8             n</span><br><span class="line">quiet=y|n                        control over terminal messages    n</span><br><span class="line"></span><br><span class="line">Obsolete Options</span><br><span class="line">----------------</span><br><span class="line">strict=y|n</span><br><span class="line">stdalloc=y|n</span><br><span class="line"></span><br><span class="line">Examples</span><br><span class="line">--------</span><br><span class="line">  - Using sockets connect to a debugger at a specific address:</span><br><span class="line">    java -agentlib:jdwp=transport=dt_socket,address=localhost:8000 ...</span><br><span class="line">  - Using sockets listen <span class="keyword">for</span> a debugger to attach:</span><br><span class="line">    java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y ...</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">  - A timeout value of 0 (the default) is no timeout.</span><br><span class="line"></span><br><span class="line">Warnings</span><br><span class="line">--------</span><br><span class="line">  - The older -Xrunjdwp interface can still be used, but will be removed <span class="keyword">in</span></span><br><span class="line">    a future release, <span class="keyword">for</span> example:</span><br><span class="line">        java -Xdebug -Xrunjdwp:[<span class="built_in">help</span>]|[&lt;option&gt;=&lt;value&gt;, ...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>有一些参数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  spring-lecture (master) ✗)java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5050 -jar build/libs/spring-lectListening <span class="keyword">for</span> transport dt_socket at address: 5050</span><br></pre></td></tr></table></figure>

<p>调试器的服务端已经启动，等待调试器连接，现在我们去用idea的调试器去调试。</p>
<p>选择Remote类型，选择Attach to remote JVM，设置端口为5050，可以看到idea自动为我们生产了参数：<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5050</code>。</p>
<p><img src="/img/spring-cloud/sc02-3.png"></p>
<p>这样的话，点击debug按钮，IDEA就能走到我们断点的地方。</p>
<p>这样就可以在启动的时候用debug的方式去跟踪SpringBoot启动的流程。</p>
<p>通过这个图就可以看到，这里是archives对象里包含的就是应用里依赖的所有第三方jar包。</p>
<p><img src="/img/spring-cloud/sc02-4.png"></p>
<p>在获取到jar的url以后，会创建一个LaunchedURLClassLoader，用于加载这些jar包，同时这里也指定了父加载器。</p>
<p><img src="/img/spring-cloud/sc02-5.png"><br><img src="/img/spring-cloud/sc02-6.png"></p>
<p>继续往下走，就能验证上一节说的读取Start-Class具体的类名。</p>
<p><img src="/img/spring-cloud/sc02-7.png"></p>
<p>在设置上下文类加载器之前，它的值是AppClassLoader</p>
<p><img src="/img/spring-cloud/sc02-8.png"></p>
<p>再往下，就是根据找到的MainClass创建一个MainMethodRunner，通过之前设置的线程上下文类加载获取之前设置的类加载器，来加载MainClass，然后用反射的方式执行。</p>
<p><img src="/img/spring-cloud/sc02-9.png"></p>
<h2 id="SpringBotApplication"><a href="#SpringBotApplication" class="headerlink" title="@SpringBotApplication"></a>@SpringBotApplication</h2><p>接下来回到源代码上，SpringLectureApplication上面的@SpringBootApplication，标识了一个SpringBoot应用，他会自动扫描这个类，以及这个类以下的子包。</p>
<p>如果不加这个注解，会怎么样？试试看，会得到一个错误missing ServletWebServerFactory bean，没有这个注解，SpringBoot是无法启动的，除了SpringBootApplication注解，各种注解在SpringBoot项目中扮演着很重要的角色。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.</span><br></pre></td></tr></table></figure>

<p>现在是SpringApplication的静态方法启动的应用，实际上我们可以手动一步一步的启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(SpringLectureApplication.class.getClassLoader());</span><br><span class="line"><span class="comment">//		SpringApplication.run(SpringLectureApplication.class, args);</span></span><br><span class="line"></span><br><span class="line">	SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(SpringLectureApplication.class);</span><br><span class="line">	springApplication.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">	springApplication.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实对于使用者来讲，SpringBoot和传统的Spring MVC应用差别并不是很大，都是通过注解的方式来写Controller，Controller里面持有service变量，再层层调用。那么SpringBoot的便利之处就在于配置变少了，约定优于配置。</p>
<p>看一下<code>SpringBootApplication</code>注解的源码，相当于同时声明了3个注解@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan。@SpringBootConfiguration里面又包含了@Configuration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">				classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure>


<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:</span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	  </span><br><span class="line">	   <span class="meta">@Bean</span></span><br><span class="line">	   <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	       <span class="comment">// instantiate, configure and return bean ...</span></span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">Via AnnotationConfigApplicationContext</span><br><span class="line"><span class="meta">@Configuration</span> classes are typically bootstrapped using either AnnotationConfigApplicationContext or its web-capable variant, AnnotationConfigWebApplicationContext. A simple example with the former follows:</span><br><span class="line">   AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">   <span class="comment">// use myBean ...</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>@Configuration是通过AnnotationConfigApplicationContext或者AnnotationConfigWebApplicationContext启动的，通过AnnotationConfigApplicationContext将AppConfig注册到上下文中，就能从上下文获取MyBean的实例了。</p>
<p>JDK源码里的文档，详细介绍了@Configuration注解相关的另外内容，其中包括：</p>
<ul>
<li>@ComponentScan </li>
<li>@Autowired Environment env</li>
<li>@PropertySource</li>
<li>@Import</li>
<li>@Profile</li>
<li>@ImportResource</li>
<li>@Lazy </li>
<li>@RunWith</li>
<li>@ContextConfiguration</li>
<li>等等</li>
</ul>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined</p>
<p>it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you’re not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched.</p>
<p>Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations).</p>
<p>自动装配，注解扫描当前包及以下的@Configuration类，所以建议放在到根目录下。自动装配的bean通常用@Conditional一类的注解修饰。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>配置扫描@Configuration组件的目录。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>分析Ribbon源码，Ribbon在底层如何拉取服务列表、进行负载均衡选择并发起Http请求</title>
    <url>/2020/03/31/springcloud/ribbon01/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><strong>服务注册</strong>，就是在分布式系统中，将注册的ip和端口号等信息告诉注册中心。</p>
<p><strong>服务发现</strong>就是客户端去注册中心获取服务列表，知道每一个服务实例的ip和端口是什么。</p>
<p><strong>负载均衡</strong>就是在拿到了这个服务列表以后，从中要选取一个实例来进行调用，这里就需要用到负载均衡算法。在Spring Cloud中，Ribbon就是做负载均衡用的一个组件，在这边叫做客户端负载均衡。具体的概念咋回事和如何使用我这里就不介绍了，网上文章很多，用过SpringCloud的人也应该都用过，下面开始进入源码探索。</p>
<a id="more"></a>

<h1 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h1><p>Spring Cloud Ribbon组件，也是基于Netflix Ribbon做的封装。</p>
<p>Ribbon包含几个核心组件：</p>
<ul>
<li><p>IRule:负载均衡规则组件，轮询，随机，权重等。</p>
</li>
<li><p>IPing: 用于检测服务是否存活，剔除宕机的服务。</p>
</li>
<li><p>ServerList: 针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及eureka的DomainExtractingServerList。</p>
</li>
<li><p>ILoadBalancer:负载均衡器，选择服务用，包含了IRule、IPing和ServerList。</p>
</li>
<li><p>LoadBalancerClient: 这是SpringCloud二次封装的一层组件，基于以上组件进行服务列表更新，过滤，选择并发起http调用。</p>
</li>
</ul>
<p>大体流程如下图所示：</p>
<p><img src="/img/spring-cloud/image-20200331230023575.png" alt="image-20200331230023575"></p>
<ol>
<li>自动装配LoadBalancerAutoConfiguration</li>
<li>在自动配置类中，会为RestTemplate添加拦截器LoadBalancerInterceptor</li>
<li>调用请求后，拦截器中获取host，并在LoadBalancerClient中对host信息进行转换，得到真正的服务器地址。</li>
<li>LoadBalancerClient中从Eureka client得到服务实例列表，然后通过包含了负载均衡规则IRule，选出要发起调用的server。</li>
<li>交给负责Http通讯的组件LoadBalancerRequest执行真正的http请求。</li>
</ol>
<h2 id="RestTemplate如何拥有负载均衡的能力"><a href="#RestTemplate如何拥有负载均衡的能力" class="headerlink" title="RestTemplate如何拥有负载均衡的能力"></a>RestTemplate如何拥有负载均衡的能力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@LoadBalanced的源码： 标记RestTemplate被配置为使用LoadBalancerClient。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient</span><br></pre></td></tr></table></figure>

<p>定位在这个注解所在的jar包，可以发现有如下的类：</p>
<p><img src="/img/spring-cloud/image-20200402225210595.png" alt="image-20200402225210595"></p>
<p>根据SpringBoot的命名习惯，自动装配的类一般都是XXXAutoConfiguration，所以我们应该重点关注LoadBalancerAutoConfiguration这个类，进去看看，我省略掉部分代码，找到我们最应该关注的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto configuration for Ribbon (client side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will Tran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gang Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RestTemplate.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancerClient.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  .....省略部分代码</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> RestTemplateCustomizer() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">					List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">							restTemplate.getInterceptors());</span><br><span class="line">					list.add(loadBalancerInterceptor);</span><br><span class="line">					restTemplate.setInterceptors(list);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ....省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，这里给系统里的RestTemplate添加了拦截器，LoadBalancerInterceptor。在声明了LoadBalancerInterceptor后，用RestTemplateCustomizer定制化了拦截器<code>restTemplate.setInterceptors(list);</code>。</p>
<p>去LoadBalancerInterceptor看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">	<span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">		<span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// for backwards compatibility</span></span><br><span class="line">		<span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 原来是在这个方法里替换了host，将host通过loadBalancer转换成了实际要访问的ip:port</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    <span class="comment">// 这里是serviceA</span></span><br><span class="line">		String serviceName = originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);</span><br><span class="line">    <span class="comment">// 通过拦截器处理后，将serviceA转换为ip:port，在拦截器里去执行了真正的http请求</span></span><br><span class="line">    <span class="comment">// cmd + option + B 可以在IDEA直接定位到实现类RibbonLoadBalancerClient的源码</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个源码打开一看，我们一下就明朗了，原来SpringCloud是这样通过拦截器实现了restTeplate.getForObject(“<a href="http://servicea/hello&quot;">http://serviceA/hello&quot;</a>) 到restTeplate.getForObject(“<a href="http://192.168.21.100:8080/hello&quot;)%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">http://192.168.21.100:8080/hello&quot;)的转换。</a></p>
<p>在RibbonLoadBalancerClient的类上按option(alt) + F7，可以迅速的找到在哪里声明创建的这个类的实例，如下图所示，也就是在RibbonAutoConfiguration类里。</p>
<p><img src="/img/spring-cloud/image-20200404224238571.png" alt="image-20200404224238571"></p>
<p>接着看一下RibbonLoadBalancerClient的execute方法具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RibbonLoadBalancerClient，execute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找服务对应的负载均衡器，因为每个服务ribbon配置可能不一样</span></span><br><span class="line">  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">  <span class="comment">// getServer方法里，会调用loadBalancer.chooseServer方法。</span></span><br><span class="line">  <span class="comment">// 这个server就已经包含了具体的ip和port</span></span><br><span class="line">  Server server = getServer(loadBalancer);</span><br><span class="line">  <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">                                                                           serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行真正的http请求</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....省略部分代码</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// chooseServer方法会去执行真正的IRule实现逻辑，利用负载均衡规则筛选出适合的服务实例</span></span><br><span class="line">  <span class="keyword">return</span> loadBalancer.chooseServer(<span class="string">&quot;default&quot;</span>); <span class="comment">// <span class="doctag">TODO:</span> better handling of key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="负载均衡器ILoadBalancer"><a href="#负载均衡器ILoadBalancer" class="headerlink" title="负载均衡器ILoadBalancer"></a>负载均衡器ILoadBalancer</h2><p>那么看到上面有个ILoadBalancer，ILoadBalancer维护了一份服务列表，并提供了过滤服务和用负载均衡选择server等功能。这个ILoadBalancer在SpringCloud中默认是用的什么实现呢，这里的实例是用SpringClientFactory.getLoadBalancer方法获取的，<strong>这个SpringClientFactory是SpringCloud对Ribbon的一层封装，为每一个服务都创建了一个Spring ApplicationContext，每一个服务都有自己的client，load balancer 和 client configuration实例。</strong>这个<code>SpringClientFactory</code>非常重要，它是为每一个服务指定不同配置的基础例如不同的服务采用不同的负载均衡规则，就是通过这个机制实现的。</p>
<p>在SpringClientFactory.getLoadBalancer方法里，调用了<code>getInstance(name, ILoadBalancer.class);</code>跟到代码里去看是如何获取实例的，最后跟到父类里，发现是用map维护了服务和上下文的对应关系，serviceA -&gt; AnnotationConfigApplicationContext。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个ILoadBalancer的实例究竟是在哪里创建的呢？还是老办法，option + F7，去找一个叫XXXConfiguration的类，于是在RibbonClientConfiguration的类里，发现了Bean的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ILoadBalancer定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">                                     serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认是使用<strong>ZoneAwareLoadBalancer</strong>，父类是：DynamicServerListLoadBalancer，再往上的父类是BaseLoadBalancer。</p>
<blockquote>
<p>这里多说一句，其实RibbonClientConfiguration的加载，是在NamedContextFactory.createContext里加载的，而且优先级是最低的，具体可以看本文最后一节引用文章，现在不必细究，等把整体流程了解的差不多以后，再去看这种细节问题。</p>
</blockquote>
<h2 id="Ribbon如何获取到服务列表"><a href="#Ribbon如何获取到服务列表" class="headerlink" title="Ribbon如何获取到服务列表"></a>Ribbon如何获取到服务列表</h2><p>在ZoneAwareLoadBalancer中，并没有找到和服务列表相关的代码，去父类的构造方法看下，调用了restOfInit方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer，restOfInit方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> primeConnection = <span class="keyword">this</span>.isEnablePrimingConnections();</span><br><span class="line">  <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(<span class="keyword">false</span>);</span><br><span class="line">  <span class="comment">// 初始化并加载服务列表，会调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  enableAndInitLearnNewServersFeature();</span><br><span class="line">  <span class="comment">// 调用serverListImpl.getUpdatedListOfServers()</span></span><br><span class="line">  updateListOfServers();</span><br><span class="line">  <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="keyword">this</span>.getPrimeConnections() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getPrimeConnections()</span><br><span class="line">      .primeConnections(getReachableServers());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">  LOGGER.info(<span class="string">&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;</span>, clientConfig.getClientName(), <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看来serverListImpl，也就是ServerList就是获取服务列表的关键。那么这个ServerList是在构造方法里传入的，所以回到ZoneAwareLoadBalancer的Bean定义的地方，可以看到他是通过依赖注入获取到的。</p>
<p>通过IDEA看一下接口有哪些实现类：</p>
<p><img src="/img/spring-cloud/image-20200408233824757.png" alt="image-20200408233824757"></p>
<p>可以看到，针对不同的注册中心，有不同的实现类，例如ConsulServerList，NacosServiceList，ZookeeperServerList以及在spring cloud eureka包下面的DomainExtractingServerList。</p>
<p>由此可以断定，SpringCloud在和Ribbon和Eureka整合的时候，一定使用了DomainExtractingServerList这个类。更进一步的，找到了DomainExtractingServerList创建的地方，发现他又是包装了一层DiscoveryEnabledNIWSServerList，这个DiscoveryEnabledNIWSServerList是com.netflix.niws.loadbalancer;包下面的，在ribbon-eureka.jar里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration，ServerList的定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config,</span><br><span class="line">                                      Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">    config, eurekaClientProvider);</span><br><span class="line">  DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">    discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line">  <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面截图是DiscoveryEnabledNIWSServerList的getInitialListOfServers和getUpdatedListOfServers方法，在这里看到了前面熟悉的eurekaClient，通过eurekaClient获取到了实例列表，并且转成了List<DiscoveryEnabledServer>返回，我们在用IDEA分析源码的时候，真的是非常的方便，可以通过查看类或者方法的引用，来找到创建或者使用的代码。也可以很方便的通过继承关系查看，就找到可能的具体的实现。</p>
<p><img src="/img/spring-cloud/image-20200409210354113.png" alt="image-20200409210354113"></p>
<p>最后，将拿到的服务列表存入了成员变量allServerList中。</p>
<p><img src="/img/spring-cloud/image-20200409215159851.png" alt="image-20200409215159851"></p>
<p>已经找到了更新服务列表的地方，那么他是什么时候去更新的呢，实际上在restOfInit方法调用的enableAndInitLearnNewServersFeature方法里，就调用了一个更新器：serverListUpdater，他会定时去更新，在构造方法里，构造了PollingServerListUpdater的实例，他是在启动1秒后，每隔30秒就会执行一次，去从eureka client里将服务列表定时同步到LoadBalancer的allServerList中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableAndInitLearnNewServersFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LOGGER.info(<span class="string">&quot;Using serverListUpdater &#123;&#125;&quot;</span>, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">  <span class="comment">// 这里的updateAction，就是调用updateListOfServers()方法。</span></span><br><span class="line">  serverListUpdater.start(updateAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡算法如何选择一个server"><a href="#负载均衡算法如何选择一个server" class="headerlink" title="负载均衡算法如何选择一个server"></a>负载均衡算法如何选择一个server</h2><p>前面有提到，在获取到负载均衡器（ILoadBalancer）后，就会调用chooseServer方法去选择一个server，看了眼他的逻辑，对每个机房都搞了个LoadBalancer，最后还是调用的BaseLoadBalancer.chooseServer方法，也就是父类的chooseServer方法，咱们在这里，就找到了rule.choose(key)的调用，所以接下来，我们就重点关注一下rule是哪里来的，他的默认实现又是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseLoadBalancer.chooseServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    counter = createCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  counter.increment();</span><br><span class="line">  <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;&quot;</span>, name, key, e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在ZoneAwareLoadBalancer的定义类里，也就是RibbonClientConfiguration里，也声明了IRule的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RibbonClientConfiguration.ribbonRule</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">  &#125;</span><br><span class="line">  ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">  rule.initWithNiwsConfig(config);</span><br><span class="line">  <span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在ZoneAvoidanceRule里，并没有找到choose方法，看一眼他的层级结构，choose方法在父类PredicateBasedRule里。</p>
<p><img src="/img/spring-cloud/image-20200409221508995.png" alt="image-20200409221508995"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PredicateBasedRule.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来过滤服务列表的核心逻辑，可利用自己的实现进行个性化的实例过滤</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">  <span class="comment">// 过滤然后轮询选择服务列表</span></span><br><span class="line">  Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">  <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> server.get();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getPredicate().chooseRoundRobinAfterFiltering，先过滤后再用轮询算法选择一个Server。这个具体算法可以在incrementAndGetModulo里找到，算出一个索引值，然后去List里取一个server。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractServerPredicate.java </span></span><br><span class="line"><span class="comment">// 先过滤后，再用轮询算法一次取下一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先过滤服务列表</span></span><br><span class="line">  List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">  <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.absent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轮训算法计算索引值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> current = nextIndex.get();</span><br><span class="line">    <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">    <span class="keyword">if</span> (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/spring-cloud/image-20200409224739519.png" alt="image-20200409224739519"></p>
<p>在这里说一句题外话，其实在工作中，这个地方我们可以大做文章，比如编写自己的Rule，实现自己的负责均衡算法。也可以利用getEligibleServers的过滤服务实例机制，去实现自己Predicate，从而实现一些灰度发布等操作。关于SpringCloud的灰度发布，可参考开源框架Nepxion Discovery：<strong><a href="https://github.com/Nepxion/Discovery">https://github.com/Nepxion/Discovery</a></strong></p>
<h2 id="拿到server后如何发起真正的请求"><a href="#拿到server后如何发起真正的请求" class="headerlink" title="拿到server后如何发起真正的请求"></a>拿到server后如何发起真正的请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #RibbonLoadBalancerClient.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Server server = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">      server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">         .getLoadBalancerContext(serviceId);</span><br><span class="line">   RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      T returnVal = request.apply(serviceInstance);</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure>

<p>在选择到服务实例以后，RibbonLoadBalancerClient.execute()就要发起真正的调用了。用了一个回调，将被请求的服务器信息当作参数穿进去，完成了http的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T returnVal = request.apply(serviceInstance);</span><br></pre></td></tr></table></figure>

<p>所以回到LoadBalancerInterceptor类里，request是一个匿名内部类，在里面对request和服务实例进行了包装，将具体执行交给了ClientHttpRequestExecution。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadBalancerInterceptor.java</span></span><br><span class="line">requestFactory.createRequest(request, body, execution)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadBalancerRequestFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                               <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequest&lt;ClientHttpResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">apply</span><span class="params">(<span class="keyword">final</span> ServiceInstance instance)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, loadBalancer);</span><br><span class="line">      <span class="keyword">if</span> (transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : transformers) &#123;</span><br><span class="line">          serviceRequest = transformer.transformRequest(serviceRequest, instance);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> execution.execute(serviceRequest, body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了ClientHttpRequestExecution里面，其实已经到了spring-web的类里了，spring-web从ServiceRequestWrapper获取到真正的请求URL地址，发起了http请求。所以spring-web的源码，这里就不再去看了，但是需要关注ServiceRequestWrapper，ServiceRequestWrapper完成了对真实请求地址的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 奥秘所在类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpRequestWrapper</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceRequestWrapper</span><span class="params">(HttpRequest request, ServiceInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params">								 LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(request);</span><br><span class="line">		<span class="keyword">this</span>.instance = instance;</span><br><span class="line">		<span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写了HttpRequest的getURI方法，利用LoadBalancerClient获取到了真正的请求地址。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		URI uri = <span class="keyword">this</span>.loadBalancer.reconstructURI(</span><br><span class="line">				<span class="keyword">this</span>.instance, getRequest().getURI());</span><br><span class="line">		<span class="keyword">return</span> uri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RibbonLoadBalancerClient.java</span></span><br><span class="line"><span class="comment">// 利用服务实例的host和端口以及path信息，拼接出真正的请求地址</span></span><br><span class="line"><span class="comment">// http://serviceA/sayHello -&gt; http://192.168.10.1:8080/sayHello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(instance, <span class="string">&quot;instance can not be null&quot;</span>);</span><br><span class="line">  String serviceId = instance.getServiceId();</span><br><span class="line">  RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">    .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">  URI uri;</span><br><span class="line">  Server server;</span><br><span class="line">  <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">    RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">    server = ribbonServer.getServer();</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(),</span><br><span class="line">                        instance.getPort());</span><br><span class="line">    IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">    ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">    uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                           serverIntrospector, server);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>画个图总结下：</p>
<p><img src="/img/spring-cloud/image-20200410001159973.png" alt="image-20200410001159973"></p>
<h2 id="Ribbon-IPing检查服务是否存活"><a href="#Ribbon-IPing检查服务是否存活" class="headerlink" title="Ribbon IPing检查服务是否存活"></a>Ribbon IPing检查服务是否存活</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;Ping&quot; Discovery Client</span></span><br><span class="line"><span class="comment"> * i.e. we dont do a real &quot;ping&quot;. We just assume that the server is up if Discovery Client says so</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIWSDiscoveryPing</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerPing</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line">		    <span class="keyword">if</span> (server!=<span class="keyword">null</span> &amp;&amp; server <span class="keyword">instanceof</span> DiscoveryEnabledServer)&#123;</span><br><span class="line">	            DiscoveryEnabledServer dServer = (DiscoveryEnabledServer)server;	            </span><br><span class="line">	            InstanceInfo instanceInfo = dServer.getInstanceInfo();</span><br><span class="line">	            <span class="keyword">if</span> (instanceInfo!=<span class="keyword">null</span>)&#123;	                </span><br><span class="line">	                InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line">	                <span class="keyword">if</span> (status!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	                    isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">		    <span class="keyword">return</span> isAlive;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ribbon和eureka整合的时候，并不会真正的去检查服务是否存活，而是利用Discovery Client本来就会有定时更新服务列表的机制。</p>
<p>在BaseLoadBalancer类里，可以找到IPing的调用之处，他启动了一个定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">&quot;NFLoadBalancer-PingTimer-&quot;</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认是每隔30秒，就执行一次PingTask，task里用了一个读写锁完成了ping之后的服务实例列表计算，最后更新upServerList。</p>
<h2 id="其他几种自带的负载均衡规则"><a href="#其他几种自带的负载均衡规则" class="headerlink" title="其他几种自带的负载均衡规则"></a>其他几种自带的负载均衡规则</h2><p>BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。</p>
<p>AvailabilityFilteringRule：过滤掉那些一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态。</p>
<p>ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server。</p>
<p>RandomRule：随机选择一个Server。</p>
<p>RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server。</p>
<p>RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server。</p>
<p>ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用是一样的，ResponseTimeWeightedRule后来改名为WeightedResponseTimeRule。</p>
<p>WeightedResponseTimeRule：根据响应时间分配一个weight(权重)，响应时间越长，weight越小，被选中的可能性越低。</p>
<h2 id="服务宕机后Ribbon多久能感知到"><a href="#服务宕机后Ribbon多久能感知到" class="headerlink" title="服务宕机后Ribbon多久能感知到"></a>服务宕机后Ribbon多久能感知到</h2><p>在和eureka结合使用的情况下，因为eureka server是靠心跳来摘除服务实例，那么他是需要duration * 2 =180秒，eureka client 从server同步(recentlyChangedQueue)默认是需要30秒，Ribbon从Eureka Client同步也是30秒，所以最多可能需要240秒，也就是4分钟才能知道一个服务已经宕机了，他是有可能访问到宕机的服务，不过SpringCloud是借用了Hystrix降级和熔断的机制来解决这个问题，一定次数错误后会屏蔽某个实例。</p>
<p><img src="/img/spring-cloud/%E9%BB%98%E8%AE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="默认的负载均衡算法可能存在的问题"></p>
<h2 id="SpringCloud和Ribbon的全局配置和特定配置"><a href="#SpringCloud和Ribbon的全局配置和特定配置" class="headerlink" title="SpringCloud和Ribbon的全局配置和特定配置"></a>SpringCloud和Ribbon的全局配置和特定配置</h2><p>这有篇文章写的比较清晰，说明了SpringCloud在读取Ribbon配置的时候是通过懒加载去读取配置的，也就是第一次发起调用的时候，才会通过NamedContextFactory.createContext去初始化@RibbonClients和@RibbonClient指定的配置。 但是@RibbonClients和@RibbonClient的配置被放入NamedContextFactory的configurations字段中，是在RibbonClientConfigurationRegistrar这个类里，结合源码看看文章，就很清楚了。</p>
<p><a href="https://www.cnblogs.com/trust-freedom/p/11216280.html">https://www.cnblogs.com/trust-freedom/p/11216280.html</a></p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>ribnon</tag>
      </tags>
  </entry>
  <entry>
    <title>集成JWT到Spring Boot项目</title>
    <url>/2016/12/08/springcloud/spring-boot-jwt/</url>
    <content><![CDATA[<p>这篇文章我们来讲一下如何集成JWT到Spring Boot项目中来完成接口的权限验证。</p>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（ RFC 7519 ），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。<br>如何使用JWT？</p>
<p>在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。</p>
<a id="more"></a>
<p>因为用户的状态在服务端的内存中是不存储的，所以这是一种 无状态 的认证机制。服务端的保护路由将会检查请求头 Authorization 中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。</p>
<p>JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。<br>大概就是这样：<br><img src="http://img1.tuicool.com/UfIbUjj.png"></p>
<h1 id="Spring-Boot集成"><a href="#Spring-Boot集成" class="headerlink" title="Spring Boot集成"></a>Spring Boot集成</h1><p>我是勤劳的搬运工，<a href="http://www.jdon.com/dl/best/json-web-tokens-spring-cloud-microservices.html">这应该是翻译老外的东西</a>，项目地址：<a href="https://github.com/thomas-kendall/trivia-microservices%E3%80%82">https://github.com/thomas-kendall/trivia-microservices。</a></p>
<p>废话不多说了，我直接上代码,依然是搬运工。<br>我是gradle构建的，就是引入一些依赖的jar包。顺便推荐一下阿里云的中央仓库</p>
<pre><code>http://maven.aliyun.com/nexus/content/groups/public/</code></pre>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	compile(<span class="string">&#x27;org.springframework.boot:spring-boot-starter-aop&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;org.springframework.boot:spring-boot-starter-security&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;org.mybatis.spring.boot:mybatis-spring-boot-starter:1.1.1&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span>)</span><br><span class="line">    compile(<span class="string">&#x27;com.google.guava:guava:20.0&#x27;</span>)</span><br><span class="line">    compile(<span class="string">&#x27;com.alibaba:druid:0.2.9&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;org.apache.commons:commons-lang3:3.5&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;commons-collections:commons-collections:3.2.2&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;commons-codec:commons-codec:1.10&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;com.github.pagehelper:pagehelper:4.1.6&#x27;</span>)</span><br><span class="line">	compile(<span class="string">&#x27;io.jsonwebtoken:jjwt:0.6.0&#x27;</span>)</span><br><span class="line">	runtime(<span class="string">&#x27;mysql:mysql-connector-java&#x27;</span>)</span><br><span class="line">	compileOnly(<span class="string">&#x27;org.projectlombok:lombok&#x27;</span>)</span><br><span class="line">	testCompile(<span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个是类是产生token的主要类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/28 上午10:01.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonWebTokenUtility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SignatureAlgorithm signatureAlgorithm;</span><br><span class="line">    <span class="keyword">private</span> Key secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonWebTokenUtility</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不是真正安全的实践</span></span><br><span class="line">        <span class="comment">// 为了简单，我们存储一个静态key在这里，</span></span><br><span class="line">        signatureAlgorithm = SignatureAlgorithm.HS512;</span><br><span class="line">        String encodedKey =</span><br><span class="line">                <span class="string">&quot;L7A/6zARSkK1j7Vd5SDD9pSSqZlqF7mAhiOgRbgv9Smce6tf4cJnvKOjtKPxNNnWQj+2lQEScm3XIUjhW+YVZg==&quot;</span>;</span><br><span class="line">        secretKey = deserializeKey(encodedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createJsonWebToken</span><span class="params">(AuthTokenDetails authTokenDetails)</span> </span>&#123;</span><br><span class="line">        String token =</span><br><span class="line">                Jwts.builder().setSubject(authTokenDetails.getId().toString())</span><br><span class="line">                        .claim(<span class="string">&quot;username&quot;</span>, authTokenDetails.getUsername())</span><br><span class="line">                        .claim(<span class="string">&quot;roleNames&quot;</span>, authTokenDetails.getRoleNames())</span><br><span class="line">                        .setExpiration(authTokenDetails.getExpirationDate())</span><br><span class="line">                        .signWith(getSignatureAlgorithm(),</span><br><span class="line">                                getSecretKey()).compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">deserializeKey</span><span class="params">(String encodedKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decodedKey = Base64.getDecoder().decode(encodedKey);</span><br><span class="line">        Key key =</span><br><span class="line">                <span class="keyword">new</span> SecretKeySpec(decodedKey, getSignatureAlgorithm().getJcaName());</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">getSecretKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SignatureAlgorithm <span class="title">getSignatureAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> signatureAlgorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthTokenDetails <span class="title">parseAndValidate</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        AuthTokenDetails authTokenDetails = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims =</span><br><span class="line">                    Jwts.parser().setSigningKey(getSecretKey()).parseClaimsJws(token).getBody();</span><br><span class="line">            String userId = claims.getSubject();</span><br><span class="line">            String username = (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            List&lt;String&gt; roleNames = (List) claims.get(<span class="string">&quot;roleNames&quot;</span>);</span><br><span class="line">            Date expirationDate = claims.getExpiration();</span><br><span class="line"></span><br><span class="line">            authTokenDetails = <span class="keyword">new</span> AuthTokenDetails();</span><br><span class="line">            authTokenDetails.setId(Long.valueOf(userId));</span><br><span class="line">            authTokenDetails.setUsername(username);</span><br><span class="line">            authTokenDetails.setRoleNames(roleNames);</span><br><span class="line">            authTokenDetails.setExpirationDate(expirationDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authTokenDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">serializeKey</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        String encodedKey =</span><br><span class="line">                Base64.getEncoder().encodeToString(key.getEncoded());</span><br><span class="line">        <span class="keyword">return</span> encodedKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要一个定制授权过滤器，将能读取请求头部信息，在Spring中已经有一个这样的授权Filter称为：RequestHeaderAuthenticationFilter，我们只要扩展继承即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonWebTokenAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">RequestHeaderAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonWebTokenAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t throw exceptions if the header is missing</span></span><br><span class="line">        <span class="keyword">this</span>.setExceptionIfHeaderMissing(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the request header it will look for</span></span><br><span class="line">        <span class="keyword">this</span>.setPrincipalRequestHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticationManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，头部信息将被转换为Spring Authentication对象，名称为PreAuthenticatedAuthenticationToken<br>我们需要一个授权提供者读取这个记号，然后验证它，然后转换为我们自己的定制授权对象，就是把header里的token转化成我们自己的授权对象。然后把解析之后的对象返回给Spring Security，这里就相当于完成了token-&gt;session的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonWebTokenAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JsonWebTokenUtility tokenService = <span class="keyword">new</span> JsonWebTokenUtility();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        Authentication authenticatedUser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Only process the PreAuthenticatedAuthenticationToken</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getClass().</span><br><span class="line">                isAssignableFrom(PreAuthenticatedAuthenticationToken.class)</span><br><span class="line">                &amp;&amp; authentication.getPrincipal() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String tokenHeader = (String) authentication.getPrincipal();</span><br><span class="line">            UserDetails userDetails = parseToken(tokenHeader);</span><br><span class="line">            <span class="keyword">if</span> (userDetails != <span class="keyword">null</span>) &#123;</span><br><span class="line">                authenticatedUser =</span><br><span class="line">                        <span class="keyword">new</span> JsonWebTokenAuthentication(userDetails, tokenHeader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// It is already a JsonWebTokenAuthentication</span></span><br><span class="line">            authenticatedUser = authentication;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authenticatedUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserDetails <span class="title">parseToken</span><span class="params">(String tokenHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserDetails principal = <span class="keyword">null</span>;</span><br><span class="line">        AuthTokenDetails authTokenDetails =</span><br><span class="line">                tokenService.parseAndValidate(tokenHeader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authTokenDetails != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;GrantedAuthority&gt; authorities =</span><br><span class="line">                    authTokenDetails.getRoleNames().stream()</span><br><span class="line">                            .map(SimpleGrantedAuthority::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">            <span class="comment">// userId介入Spring Security</span></span><br><span class="line">            principal = <span class="keyword">new</span> User(authTokenDetails.getId().toString(), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    authorities);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                authentication.isAssignableFrom(</span><br><span class="line">                        PreAuthenticatedAuthenticationToken.class)||</span><br><span class="line">                        authentication.isAssignableFrom(</span><br><span class="line">                                JsonWebTokenAuthentication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>上面完成了JWT和Spring Boot的集成。<br>接下来我们再如何把自己的权限系统也接入Spring Security。<br>刚才已经展示了通过JsonWebTokenAuthenticationProvider的处理，我们已经能通过header的token来识别用户，并拿到他的角色和userId等信息。</p>
<p>配置Spring Security有3个不可缺的类。<br>首先配置拦截器，拦截所有的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/28 上午11:32.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSecurityInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractSecurityInterceptor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FilterInvocationSecurityMetadataSource securityMetadataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessDecisionManager</span><span class="params">(AccessDecisionManager accessDecisionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setAccessDecisionManager(accessDecisionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthenticationManager</span><span class="params">(AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        FilterInvocation fi = <span class="keyword">new</span> FilterInvocation(request, response, chain);</span><br><span class="line">        invoke(fi);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Object&gt; getSecureObjectClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterInvocation.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityMetadataSource <span class="title">obtainSecurityMetadataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.securityMetadataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterconfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是把我们自己的权限数据加载到Spring Security中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/28 上午11:33.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * 最核心的地方，就是提供某个资源对应的权限定义，即getAttributes方法返回的结果。</span></span><br><span class="line"><span class="comment"> * 此类在初始化时，应该取到所有资源及其对应角色的定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInvocationSecurityMetadataSourceService</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Collection&lt;ConfigAttribute&gt;&gt; resourceMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoInvocationSecurityMetadataSourceService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResourceDefine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 应当是资源为key， 权限为value。 资源通常为url， 权限就是那些以ROLE_为前缀的角色。 一个资源可以由多个权限来访问。</span></span><br><span class="line"><span class="comment">         * sparta</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Role r = <span class="keyword">new</span> Role();</span><br><span class="line">        r.setId(<span class="number">0L</span>);</span><br><span class="line">        r.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 假数据</span></span><br><span class="line">        List&lt;Role&gt; roles = Collections.singletonList(r); <span class="comment">// 替换为查询角色列表</span></span><br><span class="line">        resourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            ConfigAttribute ca = <span class="keyword">new</span> SecurityConfig(role.getName());</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            params.put(<span class="string">&quot;roleId&quot;</span>, role.getId());</span><br><span class="line">            <span class="comment">// 查询每个角色对于的权限,我这里假设直接查到了url</span></span><br><span class="line">            List&lt;String&gt; resources = Collections.singletonList(<span class="string">&quot;/user/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String url : resources) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 判断资源文件和权限的对应关系，如果已经存在相关的资源url，则要通过该url为key提取出权限集合，将权限增加到权限集合中。</span></span><br><span class="line"><span class="comment">                 * sparta</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (resourceMap.containsKey(url)) &#123;</span><br><span class="line"></span><br><span class="line">                    Collection&lt;ConfigAttribute&gt; value = resourceMap.get(url);</span><br><span class="line">                    value.add(ca);</span><br><span class="line">                    resourceMap.put(url, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Collection&lt;ConfigAttribute&gt; atts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    atts.add(ca);</span><br><span class="line">                    resourceMap.put(url, atts);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadResourceDefine();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据URL，找到相关的权限配置。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">        FilterInvocation filterInvocation = (FilterInvocation) object;</span><br><span class="line">        <span class="keyword">for</span> (String url : resourceMap.keySet()) &#123;</span><br><span class="line">            RequestMatcher requestMatcher = <span class="keyword">new</span> AntPathRequestMatcher(url);</span><br><span class="line">            HttpServletRequest httpRequest = filterInvocation.getHttpRequest();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (requestMatcher.matches(httpRequest)) &#123;</span><br><span class="line">                <span class="keyword">return</span> resourceMap.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们拿到了用户的角色，也拿到了系统里有的角色和权限，就需要判断他是否有这个权限了，配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangFan on 2016/11/28 下午12:19.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * AccessdecisionManager在Spring security中是很重要的。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在验证部分简略提过了，所有的Authentication实现需要保存在一个GrantedAuthority对象数组中。</span></span><br><span class="line"><span class="comment"> * 这就是赋予给主体的权限。 GrantedAuthority对象通过AuthenticationManager</span></span><br><span class="line"><span class="comment"> * 保存到 Authentication对象里，然后从AccessDecisionManager读出来，进行授权判断。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Spring Security提供了一些拦截器，来控制对安全对象的访问权限，例如方法调用或web请求。</span></span><br><span class="line"><span class="comment"> * 一个是否允许执行调用的预调用决定，是由AccessDecisionManager实现的。</span></span><br><span class="line"><span class="comment"> * 这个 AccessDecisionManager 被AbstractSecurityInterceptor调用，</span></span><br><span class="line"><span class="comment"> * 它用来作最终访问控制的决定。 这个AccessDecisionManager接口包含三个方法：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * void decide(Authentication authentication, Object secureObject,</span></span><br><span class="line"><span class="comment"> * List&lt;ConfigAttributeDefinition&gt; config) throws AccessDeniedException;</span></span><br><span class="line"><span class="comment"> * boolean supports(ConfigAttribute attribute);</span></span><br><span class="line"><span class="comment"> * boolean supports(Class clazz);</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 从第一个方法可以看出来，AccessDecisionManager使用方法参数传递所有信息，这好像在认证评估时进行决定。</span></span><br><span class="line"><span class="comment"> * 特别是，在真实的安全方法期望调用的时候，传递安全Object启用那些参数。</span></span><br><span class="line"><span class="comment"> * 比如，让我们假设安全对象是一个MethodInvocation。</span></span><br><span class="line"><span class="comment"> * 很容易为任何Customer参数查询MethodInvocation，</span></span><br><span class="line"><span class="comment"> * 然后在AccessDecisionManager里实现一些有序的安全逻辑，来确认主体是否允许在那个客户上操作。</span></span><br><span class="line"><span class="comment"> * 如果访问被拒绝，实现将抛出一个AccessDeniedException异常。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这个 supports(ConfigAttribute) 方法在启动的时候被</span></span><br><span class="line"><span class="comment"> * AbstractSecurityInterceptor调用，来决定AccessDecisionManager</span></span><br><span class="line"><span class="comment"> * 是否可以执行传递ConfigAttribute。</span></span><br><span class="line"><span class="comment"> * supports(Class)方法被安全拦截器实现调用，</span></span><br><span class="line"><span class="comment"> * 包含安全拦截器将显示的AccessDecisionManager支持安全对象的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute ca : configAttributes) &#123;</span><br><span class="line"></span><br><span class="line">            String needRole = ca.getAttribute();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ga 为用户所被赋予的权限。 needRole 为访问相应的资源应该具有的权限。</span></span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority ga : authentication.getAuthorities()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needRole.trim().equals(ga.getAuthority().trim())) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">&quot;没有权限进行操作！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们试试登录的接口：<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/login.png"></p>
<p>然后我们用这个token来调用另外一个接口。<br>我们先试试不传Token会返回什么</p>
<p><img src="http://7xs4nh.com1.z0.glb.clouddn.com/spring-boot-jwt-user-0.png"></p>
<p>判断没有登录，现在再来试试带上token的请求。<br>已经成功的请求到了数据。<br><img src="http://7xs4nh.com1.z0.glb.clouddn.com/spring-boot-jwt-1.png"></p>
<p>好了，核心配置就是这些，我把这些代码上传github上，有需要的可以下载下来看看。里面的角色和权限都是虚拟数据，应用还需要自行修改代码。<br><a href="https://github.com/sail-y/spring-boot-jwt">https://github.com/sail-y/spring-boot-jwt</a></p>
]]></content>
      <categories>
        <category>spring boot/cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul02-核心流程和源码分析</title>
    <url>/2020/05/11/springcloud/zuul02/</url>
    <content><![CDATA[<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>在看Zuul的原理之前，要先熟透Ribbon和Hystrix的原理，因为Zuul就是基于这2个组件来做的。</p>
<p>画个图概括下:</p>
<p><img src="/img/spring-cloud/Zuul%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B.jpg" alt="Zuul的核心流程"></p>
<a id="more"></a>

<h1 id="EnableZuulProxy"><a href="#EnableZuulProxy" class="headerlink" title="@EnableZuulProxy"></a>@EnableZuulProxy</h1><p>会自动开启一个ZuulProxyAutoConfiguration的自动装配，里面定义了很多的Bean，包括RouteLocator、过滤器等和的一些组件。他的父类<code>ZuulServerAutoConfiguration</code>，也包含了很多配置的定义，其中就包括了ZuulServlet，这个是zuul核心请求的入口，拦截所有的请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">zuulServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean servlet = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> ZuulServlet(),</span><br><span class="line">         <span class="keyword">this</span>.zuulProperties.getServletPattern());</span><br><span class="line">   <span class="comment">// The whole point of exposing this servlet is to provide a route that doesn&#x27;t</span></span><br><span class="line">   <span class="comment">// buffer requests.</span></span><br><span class="line">   servlet.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ZuulServlet"><a href="#ZuulServlet" class="headerlink" title="ZuulServlet"></a>ZuulServlet</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化RequestContext</span></span><br><span class="line">        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span></span><br><span class="line">        <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先调用pre 过滤器</span></span><br><span class="line">            preRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            <span class="comment">// 报错了，先是error过滤器</span></span><br><span class="line">            error(e);</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是 route 过滤器</span></span><br><span class="line">            route();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            postRoute();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 然后是post过滤器</span></span><br><span class="line">            postRoute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">            error(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNHANDLED_EXCEPTION_&quot;</span> + e.getClass().getName()));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			  <span class="comment">// 清理掉ThreadLocal</span></span><br><span class="line">        RequestContext.getCurrentContext().unset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>init方法，对RequestContext进行了初始化，他是用ThreadLocal实现的，用装饰器模式包装了Request和Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这个是用ThreadLocal实现的</span></span><br><span class="line">    RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">    <span class="comment">// 这个默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (bufferRequests) &#123;</span><br><span class="line">        ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.setRequest(servletRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ZuulServlet的代码就能看出来，过滤器的执行逻辑是先执行pre，然后是route，如果这2个filter报错了，就会先执行error，然后是post，但是如果在post阶段报错，就直接执行error。</p>
<p>然后还有一个类是<code>ZuulServletFilter</code>，这个类和<code>ZuulServlet</code>的代码几乎是一样的，只不过zuul提供了filter和servlet两种方式提供服务，默认情况下是<code>ZuulServlet</code>。</p>
<p>下面开始看Zuul自带的过滤器</p>
<h1 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h1><ul>
<li>-3：ServletDetectionFilter</li>
<li>-2：Servlet30WrapperFilter</li>
<li>-1：FromBodyWrapperFilter</li>
<li>1：DebugFilter</li>
<li>5：PreDecorationFilter</li>
</ul>
<p>所有的filter都是通过FilterProcessor.runFilters()方法来执行的，参数作为过滤器的类型来执行对应阶段的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runFilters(<span class="string">&quot;pre&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">        Debug.addRoutingDebug(<span class="string">&quot;Invoking &#123;&quot;</span> + sType + <span class="string">&quot;&#125; type filters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 根据指定的过滤器类型，比如pre，找到所有的pre类型的过滤器，并且是按照优先级排序的</span></span><br><span class="line">    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">            Object result = processZuulFilter(zuulFilter);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                bResult |= ((Boolean) result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServletDetectionFilter"><a href="#ServletDetectionFilter" class="headerlink" title="ServletDetectionFilter"></a>ServletDetectionFilter</h2><p>设置isDispatcherServletRequest=true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 就判断了下，然后设置了一个标识</span></span><br><span class="line">   <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequestWrapper) </span><br><span class="line">         &amp;&amp; isDispatcherServletRequest(request)) &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">true</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet30WrapperFilter"><a href="#Servlet30WrapperFilter" class="headerlink" title="Servlet30WrapperFilter"></a>Servlet30WrapperFilter</h2><p>用Servlet30RequestWrapper包裹了下request，说Zuul 1.2.2里有个bug，HttpServletRequestWrapper没有返回原生的request，所以包裹了以后，getRequest()方法返回原生的request。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   <span class="comment">// 不成立</span></span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      request = (HttpServletRequest) ReflectionUtils.getField(<span class="keyword">this</span>.requestField,</span><br><span class="line">            request);</span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用Servlet30RequestWrapper包装下</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (RequestUtils.isDispatcherServletRequest()) &#123;</span><br><span class="line">      <span class="comment">// If it&#x27;s going through the dispatcher we need to buffer the body</span></span><br><span class="line">      ctx.setRequest(<span class="keyword">new</span> Servlet30RequestWrapper(request));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FormBodyWrapperFilter"><a href="#FormBodyWrapperFilter" class="headerlink" title="FormBodyWrapperFilter"></a>FormBodyWrapperFilter</h2><p>只有在请求content-type为APPLICATION_FORM_URLENCODED或者MULTIPART_FORM_DATA的时候，才会执行这个filter，他一样也是会将用request用FormBodyRequestWrapper包裹一下，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = ctx.getRequest();</span><br><span class="line">   FormBodyRequestWrapper wrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequestWrapper) &#123;</span><br><span class="line">      HttpServletRequest wrapped = (HttpServletRequest) ReflectionUtils</span><br><span class="line">            .getField(<span class="keyword">this</span>.requestField, request);</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(wrapped);</span><br><span class="line">      ReflectionUtils.setField(<span class="keyword">this</span>.requestField, request, wrapper);</span><br><span class="line">      <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletRequestWrapper) &#123;</span><br><span class="line">         ReflectionUtils.setField(<span class="keyword">this</span>.servletRequestField, request, wrapper);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      wrapper = <span class="keyword">new</span> FormBodyRequestWrapper(request);</span><br><span class="line">      ctx.setRequest(wrapper);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ctx.getZuulRequestHeaders().put(<span class="string">&quot;content-type&quot;</span>, wrapper.getContentType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DebugFilter"><a href="#DebugFilter" class="headerlink" title="DebugFilter"></a>DebugFilter</h2><p>在http参数传一个?debug=true才会执行这个，然后就设置了2个属性，后续打日志的时候会用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HttpServletRequest request = RequestContext.getCurrentContext().getRequest();</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(request.getParameter(DEBUG_PARAMETER.get()))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ROUTING_DEBUG.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   ctx.setDebugRouting(<span class="keyword">true</span>);</span><br><span class="line">   ctx.setDebugRequest(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PreDecorationFilter"><a href="#PreDecorationFilter" class="headerlink" title="PreDecorationFilter"></a>PreDecorationFilter</h2><p>这个过滤器逻辑稍显复杂，也是核心的一个逻辑，承担了解析路由的工作</p>
<ol>
<li>解析请求url，拿到了请求的地址</li>
<li>根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置，这个routeLocator是SimpleRouteLocator，在这里可以做一定的定制化，将route给做到mysql里去。</li>
<li>将Route规则设置到RequestContext中，加了一些请求头</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="comment">// 拿到了请求的url path</span></span><br><span class="line">   <span class="keyword">final</span> String requestURI = <span class="keyword">this</span>.urlPathHelper.getPathWithinApplication(ctx.getRequest());</span><br><span class="line">   <span class="comment">// 根据请求的url，分析出来serviceId，然后读取到serviceId对应的route配置</span></span><br><span class="line">   Route route = <span class="keyword">this</span>.routeLocator.getMatchingRoute(requestURI);</span><br><span class="line">   <span class="keyword">if</span> (route != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String location = route.getLocation();</span><br><span class="line">      <span class="keyword">if</span> (location != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// route相关规则放进ctx</span></span><br><span class="line">         ctx.put(REQUEST_URI_KEY, route.getPath());</span><br><span class="line">         ctx.put(PROXY_KEY, route.getId());</span><br><span class="line">         <span class="keyword">if</span> (!route.isCustomSensitiveHeaders()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper</span><br><span class="line">                  .addIgnoredHeaders(<span class="keyword">this</span>.properties.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyRequestHelper.addIgnoredHeaders(route.getSensitiveHeaders().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (route.getRetryable() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.put(RETRYABLE_KEY, route.getRetryable());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (location.startsWith(HTTP_SCHEME+<span class="string">&quot;:&quot;</span>) || location.startsWith(HTTPS_SCHEME+<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">            ctx.setRouteHost(getUrl(location));</span><br><span class="line">            <span class="comment">// 添加了一些header</span></span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(FORWARD_LOCATION_PREFIX)) &#123;</span><br><span class="line">            ctx.set(FORWARD_TO_KEY,</span><br><span class="line">                  StringUtils.cleanPath(location.substring(FORWARD_LOCATION_PREFIX.length()) + route.getPath()));</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// set serviceId for use in filters.route.RibbonRequest</span></span><br><span class="line">            ctx.set(SERVICE_ID_KEY, location);</span><br><span class="line">            ctx.setRouteHost(<span class="keyword">null</span>);</span><br><span class="line">            ctx.addOriginResponseHeader(SERVICE_ID_HEADER, location);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddProxyHeaders()) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            addProxyHeaders(ctx, route);</span><br><span class="line">            String xforwardedfor = ctx.getRequest().getHeader(X_FORWARDED_FOR_HEADER);</span><br><span class="line">            String remoteAddr = ctx.getRequest().getRemoteAddr();</span><br><span class="line">            <span class="keyword">if</span> (xforwardedfor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               xforwardedfor = remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!xforwardedfor.contains(remoteAddr)) &#123; <span class="comment">// Prevent duplicates</span></span><br><span class="line">               xforwardedfor += <span class="string">&quot;, &quot;</span> + remoteAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.addZuulRequestHeader(X_FORWARDED_FOR_HEADER, xforwardedfor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isAddHostHeader()) &#123;</span><br><span class="line">            ctx.addZuulRequestHeader(HttpHeaders.HOST, toHostHeader(ctx.getRequest()));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;No route found for uri: &quot;</span> + requestURI);</span><br><span class="line"></span><br><span class="line">      String fallBackUri = requestURI;</span><br><span class="line">      String fallbackPrefix = <span class="keyword">this</span>.dispatcherServletPath; <span class="comment">// default fallback</span></span><br><span class="line">                                             <span class="comment">// servlet is</span></span><br><span class="line">                                             <span class="comment">// DispatcherServlet</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (RequestUtils.isZuulServletRequest()) &#123;</span><br><span class="line">         <span class="comment">// remove the Zuul servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;zuulServletPath=&quot;</span> + <span class="keyword">this</span>.properties.getServletPath());</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.properties.getServletPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced Zuul servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// remove the DispatcherServlet servletPath from the requestUri</span></span><br><span class="line">         log.debug(<span class="string">&quot;dispatcherServletPath=&quot;</span> + <span class="keyword">this</span>.dispatcherServletPath);</span><br><span class="line">         fallBackUri = fallBackUri.replaceFirst(<span class="keyword">this</span>.dispatcherServletPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">         log.debug(<span class="string">&quot;Replaced DispatcherServlet servlet path:&quot;</span> + fallBackUri);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fallBackUri.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         fallBackUri = <span class="string">&quot;/&quot;</span> + fallBackUri;</span><br><span class="line">      &#125;</span><br><span class="line">      String forwardURI = fallbackPrefix + fallBackUri;</span><br><span class="line">      forwardURI = forwardURI.replaceAll(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">      ctx.set(FORWARD_TO_KEY, forwardURI);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleRouteLocator"><a href="#SimpleRouteLocator" class="headerlink" title="SimpleRouteLocator"></a>SimpleRouteLocator</h3><p>这个就是用来读取和保存路由规则的辅助了，用Map维护了一个<code>private AtomicReference&lt;Map&lt;String, ZuulRoute&gt;&gt; routes = new AtomicReference&lt;&gt;();</code>，主要需要关注它的locateRoutes方法，可以继承这个类，然后重写locateRoutes方法，改为从数据库读取路由配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, ZuulRoute&gt; <span class="title">locateRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LinkedHashMap&lt;String, ZuulRoute&gt; routesMap = <span class="keyword">new</span> LinkedHashMap&lt;String, ZuulRoute&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ZuulRoute route : <span class="keyword">this</span>.properties.getRoutes().values()) &#123;</span><br><span class="line">      routesMap.put(route.getPath(), route);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> routesMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="route过滤器"><a href="#route过滤器" class="headerlink" title="route过滤器"></a>route过滤器</h1><ul>
<li>10：RibbonRoutingFilter</li>
<li>100：SimpleHostRoutingFilter</li>
<li>500：SendForwardFilter</li>
</ul>
<h2 id="RibbonRoutingFilter"><a href="#RibbonRoutingFilter" class="headerlink" title="RibbonRoutingFilter"></a>RibbonRoutingFilter</h2><p>如果这个请求是转发给服务的，就会用这个Filter通过Ribbon和Hystrix去执行对应的http请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理Ribbon相关内容</span></span><br><span class="line">      RibbonCommandContext commandContext = buildCommandContext(context);</span><br><span class="line">      <span class="comment">// 处理Hystrix，并发送请求</span></span><br><span class="line">      ClientHttpResponse response = forward(commandContext);</span><br><span class="line">      setResponse(response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ZuulException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RibbonCommandContext"><a href="#RibbonCommandContext" class="headerlink" title="RibbonCommandContext"></a>RibbonCommandContext</h3><p>对RequestContext里的数据做了解析，封装成了RibbonCommandContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RibbonCommandContext&#123;serviceId&#x3D;&#39;ServiceB&#39;, method&#x3D;&#39;GET&#39;, uri&#x3D;&#39;&#x2F;ServiceB&#x2F;user&#x2F;sayHello&#x2F;1&#39;, retryable&#x3D;false, headers&#x3D;&#123;accept&#x3D;[application&#x2F;json], cache-control&#x3D;[no-cache], user-agent&#x3D;[Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;65.0.3325.181 Safari&#x2F;537.36], content-type&#x3D;[application&#x2F;json], accept-language&#x3D;[zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8], x-forwarded-host&#x3D;[localhost:9000], x-forwarded-proto&#x3D;[http], x-forwarded-prefix&#x3D;[&#x2F;demo], x-forwarded-port&#x3D;[9000], x-forwarded-for&#x3D;[0:0:0:0:0:0:0:1], Accept-Encoding&#x3D;[gzip]&#125;, params&#x3D;&#123;name&#x3D;[张三], age&#x3D;[20]&#125;, requestEntity&#x3D;com.netflix.zuul.http.ServletInputStreamWrapper@22453c1d, requestCustomizers&#x3D;[], contentLength&#x3D;-1, loadBalancerKey&#x3D;null&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forward-commandContext"><a href="#forward-commandContext" class="headerlink" title="forward(commandContext);"></a>forward(commandContext);</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">forward</span><span class="params">(RibbonCommandContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Map&lt;String, Object&gt; info = <span class="keyword">this</span>.helper.debug(context.getMethod(),</span><br><span class="line">         context.getUri(), context.getHeaders(), context.getParams(),</span><br><span class="line">         context.getRequestEntity());</span><br><span class="line">   <span class="comment">// 这个代码没有什么新鲜的逻辑，看过Ribbon代码的话就知道，这里面就是封装了一个基于Ribbon和Hystrix的Command</span></span><br><span class="line">   RibbonCommand command = <span class="keyword">this</span>.ribbonCommandFactory.create(context);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ClientHttpResponse response = command.execute();</span><br><span class="line">      <span class="keyword">this</span>.helper.appendDebug(info, response.getRawStatusCode(), response.getHeaders());</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">return</span> handleException(info, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ribbonCommandFactory.create</code>最终创建的类是HttpClientRibbonCommand，这个类其实就是一个HystrixCommand，他实现了自己的run方法，在run方法里，就包含了执行请求的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractRibbonCommand#run()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line"></span><br><span class="line">   RQ request = createRequest();</span><br><span class="line">   RS response;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">boolean</span> retryableClient = <span class="keyword">this</span>.client <span class="keyword">instanceof</span> AbstractLoadBalancingClient</span><br><span class="line">         &amp;&amp; ((AbstractLoadBalancingClient)<span class="keyword">this</span>.client).isClientRetryable((ContextAwareRequest)request);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (retryableClient) &#123;</span><br><span class="line">      response = <span class="keyword">this</span>.client.execute(request, config);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用负载均衡客户端发起请求,这里面都是ribbon相关的代码了</span></span><br><span class="line">      response = <span class="keyword">this</span>.client.executeWithLoadBalancer(request, config);</span><br><span class="line">   &#125;</span><br><span class="line">   context.set(<span class="string">&quot;ribbonResponse&quot;</span>, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Explicitly close the HttpResponse if the Hystrix command timed out to</span></span><br><span class="line">   <span class="comment">// release the underlying HTTP connection held by the response.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.isResponseTimedOut()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">         response.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RibbonHttpResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SimpleHostRoutingFilter"><a href="#SimpleHostRoutingFilter" class="headerlink" title="SimpleHostRoutingFilter"></a>SimpleHostRoutingFilter</h2><p>如果请求是直接配host转发静态路由的，会走这个filter用apache http发送请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">   HttpServletRequest request = context.getRequest();</span><br><span class="line">   MultiValueMap&lt;String, String&gt; headers = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestHeaders(request);</span><br><span class="line">   MultiValueMap&lt;String, String&gt; params = <span class="keyword">this</span>.helper</span><br><span class="line">         .buildZuulRequestQueryParams(request);</span><br><span class="line">   String verb = getVerb(request);</span><br><span class="line">   InputStream requestEntity = getRequestBody(request);</span><br><span class="line">   <span class="keyword">if</span> (getContentLength(request) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      context.setChunkedRequestBody();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String uri = <span class="keyword">this</span>.helper.buildZuulRequestURI(request);</span><br><span class="line">   <span class="keyword">this</span>.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 利用Apache HttpComponent发送请求</span></span><br><span class="line">      CloseableHttpResponse response = forward(<span class="keyword">this</span>.httpClient, verb, uri, request,</span><br><span class="line">            headers, params, requestEntity);</span><br><span class="line">      setResponse(response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SendForwardFilter"><a href="#SendForwardFilter" class="headerlink" title="SendForwardFilter"></a>SendForwardFilter</h2><p>转发到自己本地的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      String path = (String) ctx.get(FORWARD_TO_KEY);</span><br><span class="line">      RequestDispatcher dispatcher = ctx.getRequest().getRequestDispatcher(path);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_FORWARD_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            dispatcher.forward(ctx.getRequest(), ctx.getResponse());</span><br><span class="line">            ctx.getResponse().flushBuffer();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h1><ul>
<li>900：LocationRewriteFilter</li>
<li>1000：SendResponseFilter </li>
</ul>
<h2 id="LocationRewriteFilter"><a href="#LocationRewriteFilter" class="headerlink" title="LocationRewriteFilter"></a>LocationRewriteFilter</h2><p>默认不执行，看响应结果是否需要重定向，如果是的话才会执行。</p>
<h2 id="SendResponseFilter"><a href="#SendResponseFilter" class="headerlink" title="SendResponseFilter"></a>SendResponseFilter</h2><p>这个就是添加了一些请求头，然后将响应写入Response，</p>
<ol>
<li>优先写入RequestContext.getCurrentContext().getResponseBody()的内容</li>
<li>然后才是context.getResponseDataStream()，也就是应用返回的内容</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      addResponseHeaders();</span><br><span class="line">      writeResponse();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeResponse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">		<span class="comment">// there is no body to send</span></span><br><span class="line">		<span class="keyword">if</span> (context.getResponseBody() == <span class="keyword">null</span></span><br><span class="line">				&amp;&amp; context.getResponseDataStream() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		HttpServletResponse servletResponse = context.getResponse();</span><br><span class="line">		<span class="keyword">if</span> (servletResponse.getCharacterEncoding() == <span class="keyword">null</span>) &#123; <span class="comment">// only set if not set</span></span><br><span class="line">			servletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		OutputStream outStream = servletResponse.getOutputStream();</span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 优先写入RequestContext.getCurrentContext().getResponseBody()的内容</span></span><br><span class="line">			<span class="keyword">if</span> (RequestContext.getCurrentContext().getResponseBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				String body = RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">				writeResponse(</span><br><span class="line">						<span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">								body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">						outStream);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">boolean</span> isGzipRequested = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">final</span> String requestEncoding = context.getRequest()</span><br><span class="line">					.getHeader(ZuulHeaders.ACCEPT_ENCODING);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (requestEncoding != <span class="keyword">null</span></span><br><span class="line">					&amp;&amp; HTTPRequestUtils.getInstance().isGzipped(requestEncoding)) &#123;</span><br><span class="line">				isGzipRequested = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 然后才是context.getResponseDataStream()，也就是应用返回的内容</span></span><br><span class="line">			is = context.getResponseDataStream();</span><br><span class="line">			InputStream inputStream = is;</span><br><span class="line">      <span class="comment">// ....省略部分代码</span></span><br></pre></td></tr></table></figure>

<h1 id="error过滤器"><a href="#error过滤器" class="headerlink" title="error过滤器"></a>error过滤器</h1><ul>
<li>0：SendErrorFilter</li>
</ul>
<h2 id="SendErrorFilter"><a href="#SendErrorFilter" class="headerlink" title="SendErrorFilter"></a>SendErrorFilter</h2><p>直接转发到<code>/error</code>路径，这个就是BasicErrorController的路径，所以要想定制异常消息，继承这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">      ZuulException exception = findZuulException(ctx.getThrowable());</span><br><span class="line">      HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>, exception.nStatusCode);</span><br><span class="line"></span><br><span class="line">      log.warn(<span class="string">&quot;Error during filtering&quot;</span>, exception);</span><br><span class="line">      request.setAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>, exception);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(exception.errorCause)) &#123;</span><br><span class="line">         request.setAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>, exception.errorCause);</span><br><span class="line">      &#125;</span><br><span class="line"> 	    <span class="comment">// 直接转发到/error路径，这个就是BasicErrorController，所以要想定制异常消息，继承这个类</span></span><br><span class="line">      RequestDispatcher dispatcher = request.getRequestDispatcher(</span><br><span class="line">            <span class="keyword">this</span>.errorPath);</span><br><span class="line">      <span class="keyword">if</span> (dispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ctx.set(SEND_ERROR_FILTER_RAN, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">if</span> (!ctx.getResponse().isCommitted()) &#123;</span><br><span class="line">            ctx.setResponseStatusCode(exception.nStatusCode);</span><br><span class="line">            dispatcher.forward(request, ctx.getResponse());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h1><p>![Zuul源码分析 (/img/spring-cloud/Zuul源码分析 (1).jpg)](/../../../Downloads/Zuul源码分析 (1).jpg)</p>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch06-_Search API</title>
    <url>/2018/09/21/elasticsearch/elasticSearch06/</url>
    <content><![CDATA[<p>此为龙果学院课程学习笔记，记录以后翻看</p>
<p>前面讲了简单的搜索、分词和映射，这篇文章讲ES的搜索API</p>
<h1 id="search-API"><a href="#search-API" class="headerlink" title="search API"></a>search API</h1><p>Search API的基本语法：</p>
<p>这是一个空查询，空查询将返回所有索引库（indices)中的所有文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>只用一个查询字符串，你就可以在一个、多个或者 _all 索引库（indices）和一个、多个或者所有types中查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /index_2014*/type1,type2/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>同时你可以使用 from 和 size 参数来分页：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>##一个带请求体的 GET 请求？</p>
</blockquote>
<blockquote>
<p>某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 GET 请求带有请求体的。 事实上，一些使用者对于 GET 请求可以带请求体感到非常的吃惊。</p>
</blockquote>
<blockquote>
<p>而事实是这个RFC文档 RFC 7231— 一个专门负责处理 HTTP 语义和内容的文档 — 并没有规定一个带有请求体的 GET 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些 — 特别是一些用于缓存和代理的服务器 — 则不允许。</p>
</blockquote>
<blockquote>
<p>对于一个查询请求，Elasticsearch 的工程师偏向于使用 GET 方式，因为他们觉得它比 POST 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 GET 请求并不被广泛支持，所以 search API 同时支持 POST 请求：</p>
</blockquote>
<blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;from&quot;</span>: <span class="number">30</span>,</span><br><span class="line"> <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的规则可以应用于任何需要带请求体的 GET API。</p>
</blockquote>
<h1 id="query-dsl"><a href="#query-dsl" class="headerlink" title="query dsl"></a>query dsl</h1><p>查询表达式(Query DSL)是一种非常灵活又富有表现力的 查询语言。 Elasticsearch 使用它可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。在你的应用中，你应该用它来编写你的查询语句。它可以使你的查询语句更灵活、更精确、易读和易调试。</p>
<p>要使用这种查询表达式，只需将查询语句传递给 <code>query</code> 参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Query-DSL-基本语法"><a href="#Query-DSL-基本语法" class="headerlink" title="Query DSL 基本语法"></a>Query DSL 基本语法</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        ARGUMENT: VALUE,</span><br><span class="line">        ARGUMENT: VALUE,...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    QUERY_NAME: &#123;</span><br><span class="line">        FIELD_NAME: &#123;</span><br><span class="line">            ARGUMENT: VALUE,</span><br><span class="line">            ARGUMENT: VALUE,...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/_search </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合多个搜索条件"><a href="#组合多个搜索条件" class="headerlink" title="组合多个搜索条件"></a>组合多个搜索条件</h2><p>利用bool查询进行组合搜索，数据准备：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/article/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my elasticsearch article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;es is very good&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /website/article/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my hadoop article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;hadoop is very good&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /website/article/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my elasticsearch article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;es is very bad&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索需求：title必须包含elasticsearch，content可以包含elasticsearch也可以不包含，author_id必须不为111</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/article/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;author_id&quot;</span>: <span class="string">&quot;111&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;website&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;article&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my elasticsearch article&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;es is very good&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;author_id&quot;</span>: <span class="number">110</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查询和过滤（query-amp-filter"><a href="#查询和过滤（query-amp-filter" class="headerlink" title="查询和过滤（query &amp; filter)"></a>查询和过滤（query &amp; filter)</h1><p>在ES中查找数据，除了查询还有过滤</p>
<h2 id="query与filter示例"><a href="#query与filter示例" class="headerlink" title="query与filter示例"></a>query与filter示例</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /company/employee/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;china&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;jiangsu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;nanjing&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;join_date&quot;</span>: <span class="string">&quot;2016-01-01&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /company/employee/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;china&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;shanxi&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;xian&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;marry&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">35</span>,</span><br><span class="line">  <span class="attr">&quot;join_date&quot;</span>: <span class="string">&quot;2015-01-01&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;join_date&quot;</span>: <span class="string">&quot;2016-01-01&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;gte&quot;</span>: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="filter与query对比"><a href="#filter与query对比" class="headerlink" title="filter与query对比"></a>filter与query对比</h2><ul>
<li>filter：仅仅只是按照搜索条件过滤出需要的数据而已，不计算任何相关度分数，对相关度没有任何影响。</li>
<li>query：会去计算每个document相对于搜索条件的相关度，并按照相关度进行排序。</li>
</ul>
<p>一般来说，如果你是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query；如果你只是要根据一些条件筛选出一部分数据，不关注其排序，那么用filter。</p>
<h2 id="filter与query性能比较"><a href="#filter与query性能比较" class="headerlink" title="filter与query性能比较"></a>filter与query性能比较</h2><ul>
<li>filter：不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据</li>
<li>query：相反，要计算相关度分数，按照分数进行排序，而且无法cache结果</li>
</ul>
<h1 id="query搜索实战"><a href="#query搜索实战" class="headerlink" title="query搜索实战"></a>query搜索实战</h1><h2 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match all查询"></a>match all查询</h2><p>match_all 查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h2><p>无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。</p>
<p>如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串，如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;my elasticsearch article&quot;</span> &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。</p>
</blockquote>
<h2 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi match查询"></a>multi match查询</h2><p>multi_match 查询可以在多个字段上执行相同的 match 查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>:    <span class="string">&quot;full text search&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fields&quot;</span>:   [ <span class="string">&quot;title&quot;</span>, <span class="string">&quot;body&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="range-查询"><a href="#range-查询" class="headerlink" title="range 查询"></a>range 查询</h2><p><code>range</code> 查询找出那些落在指定区间内的数字或者时间：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;gte&quot;</span>:  <span class="number">20</span>,</span><br><span class="line">            <span class="attr">&quot;lt&quot;</span>:   <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被允许的操作符如下：</p>
<p>gt 大于<br>gte 大于等于<br>lt 小于<br>lte 小于等于        </p>
<h2 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h2><p><code>term</code> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;age&quot;</span>:    <span class="number">26</span>           &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;date&quot;</span>:   <span class="string">&quot;2014-09-01&quot;</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;public&quot;</span>: <span class="literal">true</span>         &#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>:    <span class="string">&quot;full_text&quot;</span>  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>term</code> 查询对于输入的文本不 分析 ，所以它将给定的值进行精确查询。</p>
<h2 id="terms查询"><a href="#terms查询" class="headerlink" title="terms查询"></a>terms查询</h2><p><code>terms</code> 查询和 <code>term</code> 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123; <span class="attr">&quot;terms&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>: [ <span class="string">&quot;search&quot;</span>, <span class="string">&quot;full_text&quot;</span>, <span class="string">&quot;nosql&quot;</span> ] &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 term 查询一样，terms 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。</p>
<h2 id="exists-查询"><a href="#exists-查询" class="headerlink" title="exists 查询"></a>exists 查询</h2><p>这是2.x中的查询，现在已经不提供了，但是可以用filter来完成同样的效果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;exists&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;age&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>现实的查询需求从来都没有那么简单；它们需要在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤。为了构建类似的高级查询，你需要一种能够将多查询组合成单一查询的查询方法。</p>
<p>你可以用 <code>bool</code> 查询来实现你的需求。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数：</p>
<ul>
<li>must<br>  文档 <em>必须</em> 匹配这些条件才能被包含进来。</li>
<li>must_not<br>  文档 <em>必须不</em> 匹配这些条件才能被包含进来。</li>
<li>should<br>  如果满足这些语句中的任意语句，将增加 <code>_score</code> ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。</li>
<li>filter<br>  <em>必须</em> 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</li>
</ul>
<p>由于这是我们看到的第一个包含多个查询的查询，所以有必要讨论一下相关性得分是如何组合的。每一个子查询都独自地计算文档的相关性得分。一旦他们的得分被计算出来， bool 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。</p>
<p>下面的查询用于查找 title 字段匹配 how to make millions 并且不被标识为 spam 的文档。那些被标识为 starred 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 <em>两者</em> 都满足，那么它排名将更高：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;must&quot;</span>:     &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;how to make millions&quot;</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">&quot;must_not&quot;</span>: &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>:   <span class="string">&quot;spam&quot;</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">            &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;starred&quot;</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;date&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2014-01-01&quot;</span> &#125;&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加带过滤器（filter）的查询"><a href="#增加带过滤器（filter）的查询" class="headerlink" title="增加带过滤器（filter）的查询"></a>增加带过滤器（filter）的查询</h2><p>如果我们不想因为文档的时间而影响得分，可以用 filter 语句来重写前面的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;must&quot;</span>:     &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;how to make millions&quot;</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">&quot;must_not&quot;</span>: &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>:   <span class="string">&quot;spam&quot;</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">            &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;starred&quot;</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;date&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2014-01-01&quot;</span> &#125;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constant-score查询"><a href="#constant-score查询" class="headerlink" title="constant_score查询"></a>constant_score查询</h2><p>尽管没有 bool 查询使用这么频繁，constant_score 查询也是你工具箱里有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p>
<p>可以使用它来取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p>
<p>{<br>    “constant_score”:   {<br>        “filter”: {<br>            “term”: { “category”: “ebooks” }<br>        }<br>    }<br>}</p>
<blockquote>
<p>term 查询被放置在 constant_score 中，转成不评分的 filter。这种方式可以用来取代只有 filter 语句的 bool 查询。</p>
</blockquote>
<h1 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h1><p>查询可以变得非常的复杂，尤其 和不同的分析器与不同的字段映射结合时，理解起来就有点困难了。不过 <code>validate-query</code> API 可以用来验证查询是否合法。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;math&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;valid&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;org.elasticsearch.common.ParsingException: no [query] registered for [math]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说没有<code>math</code>这个查询，一看是单词写错了，应该是<code>match</code>。</p>
<p>这个一般用在那种特别复杂庞大的搜索下，比如写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>为了按照相关性来排序，需要将相关性表示为一个数值。在 Elasticsearch 中， <em>相关性得分</em> 由一个浮点数进行表示，并在搜索结果中通过 <code>_score</code> 参数返回， 默认排序是 <code>_score</code> 降序。</p>
<p>有时，相关性评分对你来说并没有意义。例如，下面的查询返回所有 user_id 字段包含 1 的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;term&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;user_id&quot;</span> : <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定制排序规则"><a href="#定制排序规则" class="headerlink" title="定制排序规则"></a>定制排序规则</h2><p>有时候我们查询的数据需要根据时间，数量之类的排序。我们可以使用 sort 参数进行实现：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/employee/_search </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;gte&quot;</span>: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;join_date&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String排序"><a href="#String排序" class="headerlink" title="String排序"></a>String排序</h2><p>如果对一个string field进行排序，结果往往不准确，因为分词后是多个单词，再排序就不是我们想要的结果了。</p>
<p>通常解决方案是，将一个string field建立两次索引，一个分词，用来进行搜索；一个不分词，用来进行排序。</p>
<p>实验一下，重新建索引，为<code>title</code>设置一个分词的，和一个不分词的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /website</span><br><span class="line">PUT /website </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;fielddata&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;post_date&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;author_id&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 ES2.x 版本字符串数据是没有 keyword 和 text 类型的，只有string类型，ES更新到5版本后，取消了 string 数据类型，代替它的是 keyword 和 text 数据类型，那么 keyword 和 text 有什么区别了？<br>Text 数据类型被用来索引长文本，比如说电子邮件的主体部分或者一款产品的介绍。这些文本会被分析，在建立索引前会将这些文本进行分词，转化为词的组合，建立索引。允许 ES来检索这些词语。text 数据类型不能用来排序和聚合。<br>Keyword 数据类型用来建立电子邮箱地址、姓名、邮政编码和标签等数据，不需要进行分词。可以被用来检索过滤、排序和聚合。keyword 类型字段只能用本身来进行检索。</p>
</blockquote>
<p>准备数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/article/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;first article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my first article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;post_date&quot;</span>: <span class="string">&quot;2017-01-01&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /website/article/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;second article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;this is my second article&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;post_date&quot;</span>: <span class="string">&quot;2017-01-02&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author_id&quot;</span>: <span class="number">110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>搜索：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/article/_search</span><br><span class="line">&#123; </span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /website/article/_search</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;title.raw&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关性评分"><a href="#相关性评分" class="headerlink" title="相关性评分"></a>相关性评分</h1><p>每个文档都有相关性评分，用一个正浮点数字段 <code>_score</code> 来表示 。 <code>_score</code> 的评分越高，相关性越高。</p>
<p>查询语句会为每个文档生成一个 _score 字段。简单来说，就是计算出一个索引中的文本，与搜索文本他们之间的关联匹配程度。</p>
<p>在 Elasticsearch 中, 标准的算法是 Term Frequency/Inverse Document Frequency, 简写为 TF/IDF, (5.0 以上版本, 改为了据说更先进的 BM25 算法)</p>
<ul>
<li>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关</li>
<li>Inverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关</li>
<li>Field-length norm：field长度越长，相关度越弱</li>
</ul>
<h2 id="理解评分标准"><a href="#理解评分标准" class="headerlink" title="理解评分标准"></a>理解评分标准</h2><p>当调试一条复杂的查询语句时， 想要理解 <code>_score</code> 究竟是如何计算是比较困难的。Elasticsearch 在 每个查询语句中都有一个 explain 参数，将 explain 设为 true 就可以得到更详细的信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/_search?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_shard&quot;</span>: <span class="string">&quot;[test_index][1]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_node&quot;</span>: <span class="string">&quot;LrOx5yeUQQaYbF4L13z5Zw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;_explanation&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;sum of:&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">              <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;weight(test_field:test in 0) [PerFieldSimilarity], result of:&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;score(doc=0,freq=1.0 = termFreq=1.0\n), product of:&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;docFreq&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;docCount&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;</span><br><span class="line">                      ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">0.88</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;termFreq=1.0&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1.2</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;parameter k1&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;parameter b&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;avgFieldLength&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;fieldLength&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;</span><br><span class="line">                      ]</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;match on required clause, product of:&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;# clause&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;*:*, product of:&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;boost&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;queryNorm&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_shard&quot;</span>: <span class="string">&quot;[test_index][3]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_node&quot;</span>: <span class="string">&quot;LrOx5yeUQQaYbF4L13z5Zw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;test_type&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;test client 2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;_explanation&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;sum of:&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">              <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;weight(test_field:test in 0) [PerFieldSimilarity], result of:&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">0.25316024</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;score(doc=0,freq=1.0 = termFreq=1.0\n), product of:&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;docFreq&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;docCount&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;</span><br><span class="line">                      ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">0.88</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;termFreq=1.0&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">1.2</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;parameter k1&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">0.75</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;parameter b&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;avgFieldLength&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="attr">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                          <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;fieldLength&quot;</span>,</span><br><span class="line">                          <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                        &#125;</span><br><span class="line">                      ]</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;match on required clause, product of:&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;# clause&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;*:*, product of:&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;details&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;boost&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;queryNorm&quot;</span>,</span><br><span class="line">                      <span class="attr">&quot;details&quot;</span>: []</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>它提供了 <code>_explanation</code> 。每个 入口都包含一个 description 、 value 、 details 字段，它分别告诉你计算的类型、计算结果和任何我们需要的计算细节。</p>
<p>因为我测试的版本是5.2，所以从结果看出并不是上面介绍的TF/IDF算法，大致可以看到IDF，依然存在，但是Term frequency和Field-length norm则改为了一个组合算法(tfNorm)。</p>
<p>具体可以参考文章 <a href="https://ruby-china.org/topics/31934">ElasticSearch 的分数 (_score) 是怎么计算得出 (2.X &amp; 5.X)</a></p>
<ul>
<li>tfNorm反映的该term在所有满足条件的doc中field中的重要性，一般来说，相同的freq 下，field的长度越短，那么取值就越高。</li>
<li>IDF反映的是term的影响因子，如果docCount很大，docFreq很小，标示该term在doc之间具有很好的分辨力，当然IDF值也就越大。</li>
</ul>
<h2 id="文档是如何被匹配上的"><a href="#文档是如何被匹配上的" class="headerlink" title="文档是如何被匹配上的"></a>文档是如何被匹配上的</h2><p>当 explain 选项加到某一文档上时， explain api 会帮助你理解为何这个文档会被匹配，更重要的是，一个文档为何没有被匹配。</p>
<p>请求路径为 /index/type/id/_explain ，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/7/_explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;test_field&quot;</span>: <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不只是我们之前看到的充分解释 ，我们现在有了一个 description 元素，它将告诉我们：</p>
<p><code>&quot;description&quot;: &quot;no match on required clause (test_field:world)&quot;,</code></p>
<h1 id="Doc-Values"><a href="#Doc-Values" class="headerlink" title="Doc Values"></a>Doc Values</h1><p>搜索的时候，要依靠倒排索引；排序的时候，需要依靠正排索引，看到每个document的每个field，然后进行排序，所谓的正排索引，其实就是doc values。在建立索引的时候，一方面会建立倒排索引，以供搜索用；一方面会建立正排索引，也就是doc values，以供排序，聚合，过滤等操作使用。doc values是被保存在磁盘上的，此时如果内存足够，os会自动将其缓存在内存中，性能还是会很高；如果内存不足够，os会将其写入磁盘上。</p>
<h1 id="分布式检索过程"><a href="#分布式检索过程" class="headerlink" title="分布式检索过程"></a>分布式检索过程</h1><p>讨论一下在分布式环境中搜索是怎么执行的，搜索被执行成一个两阶段过程，我们称之为 query then fetch 。</p>
<h2 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h2><p>在初始 <em>查询阶段</em> 时， 查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的 _优先队列_。</p>
<blockquote>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>一个 优先队列 仅仅是一个存有 top-n 匹配文档的有序列表。优先队列的大小取决于分页参数 from 和 size 。例如，如下搜索请求将需要足够大的优先队列来放入100条文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;from&quot;</span>: <span class="number">90</span>,</span><br><span class="line">   <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>查询过程分布式搜索</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0901.png" alt="查询过程分布式搜索"></p>
<p>查询阶段包含以下三个步骤:</p>
<ol>
<li>客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。</li>
<li>Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。</li>
<li>每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>
</ol>
<p>当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。</p>
<p>这个也跟前面说的deep paging问题有关，from + size 分页太深，每个分片都要返回大量的数据给协调节点，会消耗大量的带宽，内存，cpu。</p>
<p><strong>replica shard如何增加查询吞吐量</strong></p>
<p>第一步是广播请求到索引中每一个节点的分片拷贝。查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。 协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。</p>
<h2 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h2><p>查询阶段标识哪些文档满足 搜索请求，但是我们仍然需要取回这些文档。这是取回阶段的任务, 正如 图 “分布式搜索的取回阶段” 所展示的。</p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0902.png" alt="分布式搜索的取回阶段"></p>
<p>分布式阶段由以下步骤构成：</p>
<ol>
<li>协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。</li>
<li>每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。</li>
<li>一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>
</ol>
<p>协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { “from”: 90, “size”: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
<p>协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。</p>
<p>一般搜索，如果不加from和size，就默认搜索前10条，按照_score排序。</p>
<h1 id="搜索参数"><a href="#搜索参数" class="headerlink" title="搜索参数"></a>搜索参数</h1><p>有几个搜索参数可以影响搜索过程。</p>
<h2 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h2><p>preference 参数允许用来控制由哪些分片或节点来处理搜索请求。 它接受像 <code>_primary</code>, <code>_primary_first</code>, <code>_local</code>, <code>_only_node:xyz</code>, <code>_prefer_node:xyz</code>, 和 <code>_shards:2,3</code> 这样的值。</p>
<blockquote>
<h2 id="Bouncing-Results"><a href="#Bouncing-Results" class="headerlink" title="Bouncing Results"></a>Bouncing Results</h2><p>想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。</p>
</blockquote>
<blockquote>
<p>这就是所谓的 bouncing results 问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数为一个特定的任意值比如用户会话ID来解决。</p>
</blockquote>
<h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>通常分片处理完它所有的数据后再把结果返回给协同节点，协同节点把收到的所有结果合并为最终结果。</p>
<p>这意味着花费的时间是最慢分片的处理时间加结果合并的时间。如果有一个节点有问题，就会导致所有的响应缓慢。</p>
<p>参数 <code>timeout</code> 告诉 分片允许处理数据的最大时间。如果没有足够的时间处理所有数据，这个分片的结果可以是部分的，甚至是空数据。</p>
<h2 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h2><p>定制参数 routing ，它能够在索引时提供来确保相关的文档，比如属于某个用户的文档被存储在某个分片上。 在搜索的时候，不用搜索索引的所有分片，而是通过指定几个 routing 值来限定只搜索几个相关的分片，默认是<code>_id</code>路由，也可以指定字段<code>?routing=user_1,user2</code>。</p>
<h2 id="search-type"><a href="#search-type" class="headerlink" title="search_type"></a>search_type</h2><p>缺省的搜索类型是 query_then_fetch 。 在某些情况下，你可能想明确设置 search_type 为 dfs_query_then_fetch 来改善相关性精确度：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?search_type=dfs_query_then_fetch</span><br></pre></td></tr></table></figure>

<p>搜索类型 dfs_query_then_fetch 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。 </p>
<h1 id="scroll-查询"><a href="#scroll-查询" class="headerlink" title="scroll 查询"></a>scroll 查询</h1><p>如果是用from + size的查询方式，会有我们之前说的Deep Paging问题，而且ES默认也限制了size的大小最多只能是1w条。如果一次性要查出来比如10万条数据，那么性能会很差，此时一般会采取用scoll滚动查询，一批一批的查，直到所有数据都查询完处理完。</p>
<p>使用scoll滚动搜索，可以先搜索一批数据，然后下次再搜索一批数据，以此类推，直到搜索出全部的数据来。<br>scoll搜索会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照提供数据搜索，如果这个期间数据变更，是不会让用户看到的。<br>采用基于_doc进行排序的方式，性能较高。<br>每次发送scroll请求，我们还需要指定一个scoll参数，指定一个时间窗口，每次搜索请求只要在这个时间窗口内能完成就可以了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /test_index/test_type/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [ <span class="string">&quot;_doc&quot;</span> ],</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_scroll_id&quot;</span>: <span class="string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAOOqFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAADjqxZMck94NXllVVFRYVliRjRMMTN6NVp3AAAAAAAA46wWTHJPeDV5ZVVRUWFZYkY0TDEzejVadwAAAAAAAOOuFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAADjrRZMck94NXllVVFRYVliRjRMMTN6NVp3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;took&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>

<p>这个查询的返回结果包括一个字段 <code>_scroll_id</code>， 它是一个base64编码的长字符串 (((“scroll_id”))) 。 现在我们能传递字段 <code>_scroll_id</code> 到 <code>_search/scroll</code>查询接口获取下一批结果：下一次再发送scoll请求的时候，必须带上这个<code>scoll_id</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scroll&quot;</span>: <span class="string">&quot;1m&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;scroll_id&quot;</span> : <span class="string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAOOqFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAADjqxZMck94NXllVVFRYVliRjRMMTN6NVp3AAAAAAAA46wWTHJPeDV5ZVVRUWFZYkY0TDEzejVadwAAAAAAAOOuFkxyT3g1eWVVUVFhWWJGNEwxM3o1WncAAAAAAADjrRZMck94NXllVVFRYVliRjRMMTN6NVp3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个scroll查询返回的下一批结果。 尽管我们指定字段 size 的值为1000，我们有可能取到超过这个值数量的文档。 当查询的时候， 字段 size 作用于单个分片，所以每个批次实际返回的文档数量最大为 size * number_of_primary_shards 。</p>
<p>scoll看起来挺像分页的，但是其实使用场景不一样。分页主要是用来一页一页搜索，给用户看的；scoll主要是用来一批一批检索数据，让系统进行处理的。</p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>HystrixCommand执行源码分析</title>
    <url>/2020/05/09/springcloud/hystrix06/</url>
    <content><![CDATA[<h1 id="HystrixCommand-execute源码细节"><a href="#HystrixCommand-execute源码细节" class="headerlink" title="HystrixCommand.execute源码细节"></a>HystrixCommand.execute源码细节</h1><p>HystrixCommand会将任务丢到异步线程池里去执行，通过Future获取执行完毕的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queue()方法，是用来异步执行的command逻辑的，他会将command扔到线程池里去执行，但是这个方法不会等待线程执行完毕command，他会拿到一个Future对象，通过Future对象去获取command执行完毕的响应结果。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Future returned by Observable.toBlocking().toFuture() does not implement the</span></span><br><span class="line"><span class="comment"> * interruption of the execution thread when the &quot;mayInterrupt&quot; flag of Future.cancel(boolean) is set to true;</span></span><br><span class="line"><span class="comment"> * thus, to comply with the contract of Future, we must wrap around it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</span><br></pre></td></tr></table></figure>

<p>toObservable().toBlocking().toFuture();这行代码已经把command扔到线程池里去执行了，并且拿到了一个Future对象，没有办法在异常情况下终止Future对象对应的线程的执行，所以要对Future做一个包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>

<p>然后接下来就是对delegate做了包装，实现了一下cancel等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.get();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure>

<p>f.isDone()，通过future判断对应的那个线程是否完成了command的执行，然后调用f.get()会阻塞住，获取到Thread执行command返回的结果。</p>
<p>那我们就发现，在调用queue()方法后，就会通过线程池去执行command，然后在queue()方法中，会等待线程执行结束，如果线程执行结束了，就会返回future；即使执行失败了，也会根据情况，返回future，要不就是抛异常。</p>
<p>下面，我们接着分析<code>toObservable().toBlocking().toFuture();</code>核心逻辑，它实现了Hystrix几乎所有的核心逻辑，包括请求缓存、熔断、队列+线程池、线程异步执行、超时检测、异常处理、异常统计、熔断开关等。</p>
<h2 id="toObservable"><a href="#toObservable" class="headerlink" title="toObservable()"></a>toObservable()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Used <span class="keyword">for</span> asynchronous execution of command with a callback by subscribing to the &#123;<span class="meta">@link</span> Observable&#125;.</span><br></pre></td></tr></table></figure>

<p>获取到Observable后，Command还没有立即开始执行，只是将Command封装到了Observable对象。如果订阅了Observable对象，提供了回调接口，才会触发执行，并根据Command执行结果回调提供的接口。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">An eager &#123;@link Observable&#125; can be obtained from &#123;@link #observe()&#125;.</span><br></pre></td></tr></table></figure>

<p>如果希望获取到Observable对象就立即执行内部的Command的话，就不要调用toObservable()方法，可以去调用observe()方法</p>
<p>声明了一堆匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果状态是OBSERVABLE_CHAIN_CREATED</span></span><br><span class="line">        <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成false，并且用户的代码没有被执行过（HystrixCommand.run）</span></span><br><span class="line">            handleCommandEnd(<span class="keyword">false</span>); <span class="comment">//user code never ran</span></span><br><span class="line">          <span class="comment">// 如果状态是USER_CODE_EXECUTED</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) &#123;</span><br><span class="line">            <span class="comment">// 设置成true，并且用户的代码已经运行过了（HystrixCommand.run）</span></span><br><span class="line">          handleCommandEnd(<span class="keyword">true</span>); <span class="comment">//user code did run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>unsubscribeCommandCleanup</p>
<p>applyHystrixSemantics</p>
<p>wrapWithAllOnNextHooks</p>
<p>fireOnCompletedHook</p>
<p>然后基于上面的这些回调，去创建了Observable对象，因为创建Observable对象后，并不会被立马执行，所以在调用toBlocking()方法之后，才会触发执行call方法，再依次去执行上面的5个回调方法。因为Observable是rxjava的代码，所以toBlocking()的源码这里就不再跟进去看了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="comment">// 调用toBlocking方法后就会触发执行这里的代码了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个Command命令只能被执行一次，所以Command对象每次都是new</span></span><br><span class="line">        <span class="comment">// 刚开始状态是NOT_STARTED</span></span><br><span class="line">         <span class="comment">/* this is a stateful object so can only be used once */</span></span><br><span class="line">        <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</span><br><span class="line">            IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This instance can only be executed once. Please instantiate a new instance.&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO make a new error type for this</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">&quot; command executed multiple times - this is not permitted.&quot;</span>, ex, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 命令开始的时间戳</span></span><br><span class="line">        commandStartTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日志</span></span><br><span class="line">        <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</span><br><span class="line">            <span class="comment">// log this command execution regardless of what happened</span></span><br><span class="line">            <span class="comment">// 请求日志</span></span><br><span class="line">            <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentRequestLog.addExecutedCommand(_cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</span><br><span class="line">        <span class="keyword">final</span> String cacheKey = getCacheKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存RequestCache</span></span><br><span class="line">        <span class="comment">/* try from cache first */</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用回调创建了Observable对象</span></span><br><span class="line">        Observable&lt;R&gt; hystrixObservable =</span><br><span class="line">                Observable.defer(applyHystrixSemantics)</span><br><span class="line">                        .map(wrapWithAllOnNextHooks);</span><br><span class="line"></span><br><span class="line">        Observable&lt;R&gt; afterCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理Request cache</span></span><br><span class="line">        <span class="comment">// put in cache</span></span><br><span class="line">        <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// wrap it for caching</span></span><br><span class="line">            HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</span><br><span class="line">            HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</span><br><span class="line">            <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// another thread beat us so we&#x27;ll use the cached value instead</span></span><br><span class="line">                toCache.unsubscribe();</span><br><span class="line">                isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we just created an ObservableCommand so we cast and return it</span></span><br><span class="line">                afterCache = toCache.toObservable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            afterCache = hystrixObservable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> afterCache</span><br><span class="line">                .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></span><br><span class="line">                .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></span><br><span class="line">                .doOnCompleted(fireOnCompletedHook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>刚开始命令的状态是NOT_STARTED，设置为OBSERVABLE_CHAIN_CREATED</li>
<li>记录请求日志（默认启用，但是不处理）</li>
<li>从缓存读取（默认没有启用缓存）</li>
<li>得到Observable对象，将5个回调设置到对应doOnCompleted、doOnUnsubscribe等的方法里</li>
</ol>
<p>那实际上真正执行Command的代码，是在applyHystrixSemantics的回调里</p>
<h2 id="applyHystrixSemantics"><a href="#applyHystrixSemantics" class="headerlink" title="applyHystrixSemantics"></a>applyHystrixSemantics</h2><ol>
<li>applyHystrixSemantics.call()调用applyHystrixSemantics方法 </li>
<li>判断断路器是否打开</li>
<li>拿到一个信号量</li>
<li>执行executeCommandAndObserve</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mark that we&#x27;re starting execution on the ExecutionHook</span></span><br><span class="line">    <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></span><br><span class="line">    <span class="comment">// 这个类是ExecutionHookDeprecationWrapper，是内部类</span></span><br><span class="line">    executionHook.onStart(_cmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断路器是否打开，打开的话直接走降级逻辑</span></span><br><span class="line">    <span class="comment">/* determine if we&#x27;re allowed to execute */</span></span><br><span class="line">    <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</span><br><span class="line">        <span class="comment">// 这里会拿到信号量，如果不是使用SEMAPHORE的话，这里拿到的是一个什么都不干的TryableSemaphoreNoOp.DEFAULT</span></span><br><span class="line">        <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    executionSemaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* used to track userThreadExecutionTime */</span></span><br><span class="line">                executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br><span class="line">                <span class="comment">// 核心逻辑在executeCommandAndObserve里</span></span><br><span class="line">                <span class="keyword">return</span> executeCommandAndObserve(_cmd)</span><br><span class="line">                        .doOnError(markExceptionThrown)</span><br><span class="line">                        .doOnTerminate(singleSemaphoreRelease)</span><br><span class="line">                        .doOnUnsubscribe(singleSemaphoreRelease);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleShortCircuitViaFallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the TryableSemaphore this HystrixCommand should use for execution if not running in a separate thread.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> TryableSemaphore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果不是信号量的话，返回TryableSemaphoreNoOp.DEFAULT，啥也不干</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用SEMAPHORE</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// we didn&#x27;t find one cache so setup</span></span><br><span class="line">                executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</span><br><span class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></span><br><span class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> _s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return NoOp implementation since we&#x27;re not using SEMAPHORE isolation</span></span><br><span class="line">        <span class="comment">// 不用SEMAPHORE</span></span><br><span class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="executeCommandAndObserve"><a href="#executeCommandAndObserve" class="headerlink" title="executeCommandAndObserve"></a>executeCommandAndObserve</h2><p>executeCommandAndObserve代码，又是一堆回调，先把回调记录下来</p>
<ol>
<li>markEmits</li>
<li>markOnCompleted</li>
<li>handleFallback</li>
<li>setRequestContext</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This decorates &quot;Hystrix&quot; functionality around the run() Observable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> R</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandAndObserve</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;R&gt; markEmits = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</span><br><span class="line">                executionResult = executionResult.addEvent(HystrixEventType.EMIT);</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action0 markOnCompleted = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!commandIsScalar()) &#123;</span><br><span class="line">                <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</span><br><span class="line">                circuitBreaker.markSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            circuitBreaker.markNonSuccess();</span><br><span class="line">            Exception e = getExceptionFromThrowable(t);</span><br><span class="line">            executionResult = executionResult.setExecutionException(e);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                    eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</span><br><span class="line">            setRequestContextIfNeeded(currentRequestContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Observable&lt;R&gt; execution;</span><br><span class="line">    <span class="comment">// 是否开启超时，用线程池隔离去执行</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionTimeoutEnabled().get()) &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd)</span><br><span class="line">                .lift(<span class="keyword">new</span> HystrixObservableTimeoutOperator&lt;R&gt;(_cmd));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execution = executeCommandWithSpecifiedIsolation(_cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execution.doOnNext(markEmits)</span><br><span class="line">            .doOnCompleted(markOnCompleted)</span><br><span class="line">            .onErrorResumeNext(handleFallback)</span><br><span class="line">            .doOnEach(setRequestContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="executeCommandWithSpecifiedIsolation"><a href="#executeCommandWithSpecifiedIsolation" class="headerlink" title="executeCommandWithSpecifiedIsolation"></a>executeCommandWithSpecifiedIsolation</h2><p>继续往executeCommandWithSpecifiedIsolation方法里跟，到这里，就发现了他会判断你如果隔离策略是Thread，执行线程池相关逻辑，如果是信号量，执行信号量相关逻辑。</p>
<p>我们在这个代码里，去找一下跟线程池有关的代码到底在哪里，肯定是有一个队列+线程池。</p>
<ol>
<li>默认是线程隔离</li>
<li>命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是就报错</li>
<li>记录监控数据，命令开始</li>
<li>判断是否已经超时了（在执行run方法之前，就已经超时）</li>
<li>调用startCurrentThreadExecutingCommand方法，将要执行的一个命令，压入一个栈中</li>
<li>调用getUserExecutionObservable方法，在这个方法里，最终会去执行run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandWithSpecifiedIsolation</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认就是线程隔离的</span></span><br><span class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;</span><br><span class="line">        <span class="comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span></span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="comment">// 命令状态从OBSERVABLE_CHAIN_CREATED切换到USER_CODE_EXECUTED，不是花就报错</span></span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// 监控</span></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;</span><br><span class="line">                    <span class="comment">// the command timed out in the wrapping thread so we will return immediately</span></span><br><span class="line">                    <span class="comment">// and not increment any of the counters below or other such logic</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;timed out before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断线程的状态，从NOT_USING_THREAD，切换到STARTED</span></span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;</span><br><span class="line">                    <span class="comment">//we have not been unsubscribed, so should proceed</span></span><br><span class="line">                    HystrixCounters.incrementGlobalConcurrentThreads();</span><br><span class="line">                    threadPool.markThreadExecution();</span><br><span class="line">                    <span class="comment">// store the command that is being run</span></span><br><span class="line">                    <span class="comment">// 将要执行的一个命令，压入一个栈中</span></span><br><span class="line">                    endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                    executionResult = executionResult.setExecutedInThread();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这几行代码也没干啥</span></span><br><span class="line">                        executionHook.onThreadStart(_cmd);</span><br><span class="line">                        executionHook.onRunStart(_cmd);</span><br><span class="line">                        executionHook.onExecutionStart(_cmd);</span><br><span class="line">                        <span class="comment">// run方法最终执行的地方</span></span><br><span class="line">                        <span class="keyword">return</span> getUserExecutionObservable(_cmd);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//command has already been unsubscribed, so return immediately</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;unsubscribed before executing run()&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnTerminate(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and received terminal, then no need to clean up (I don&#x27;t think this is possible)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was unsubscribed, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    handleThreadEnd(_cmd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;</span><br><span class="line">                    <span class="comment">//if it was never started and was cancelled, then no need to clean up</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if it was terminal, then other cleanup handled it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                executionResult = executionResult.setExecutionOccurred();</span><br><span class="line">                <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;execution attempted while in state : &quot;</span> + commandState.get().name()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</span><br><span class="line">                <span class="comment">// semaphore isolated</span></span><br><span class="line">                <span class="comment">// store the command that is being run</span></span><br><span class="line">                endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executionHook.onRunStart(_cmd);</span><br><span class="line">                    executionHook.onExecutionStart(_cmd);</span><br><span class="line">                    <span class="keyword">return</span> getUserExecutionObservable(_cmd);  <span class="comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn&#x27;t throw</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//If the above hooks throw, then use that as the result of the run method</span></span><br><span class="line">                    <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getUserExecutionObservable"><a href="#getUserExecutionObservable" class="headerlink" title="getUserExecutionObservable"></a>getUserExecutionObservable</h2><p>看到这里后，run方法就已经执行了，但是回过头想一下，这个Hystrix是基于队列和线程池去执行的，那怎么没看见跟线程池有关的代码呢在哪呢，前面一个又一个的Observable，互相触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getUserExecutionObservable</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</span><br><span class="line">    Observable&lt;R&gt; userObservable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这行代码里的Func0.call()会执行HystrixCommand的run方法</span></span><br><span class="line">        userObservable = getExecutionObservable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// the run() method is a user provided implementation so can throw instead of using Observable.onError</span></span><br><span class="line">        <span class="comment">// so we catch it here and turn it into Observable.error</span></span><br><span class="line">        userObservable = Observable.error(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userObservable</span><br><span class="line">            .lift(<span class="keyword">new</span> ExecutionHookApplication(_cmd))</span><br><span class="line">            .lift(<span class="keyword">new</span> DeprecatedOnRunHookApplication(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCommand.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里就是执行HystrixCommand的run方法了</span></span><br><span class="line">                <span class="keyword">return</span> Observable.just(run());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.error(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span></span><br><span class="line">            executionThread.set(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那从代码执行的层面没有找到，我们去找一下，threadPool这个变量，是在什么时候被使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</span><br></pre></td></tr></table></figure>

<h1 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h1><p>在AbstractCommand的构造方法中，就有一行初始化线程池的代码initThreadPool，这就会根据threadPoolKey去创建对应的线程池，线程池的相关参数来自于HystrixThreadPoolProperties.Setter，维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池。</p>
<p>可配置的属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">hystrix.threadpool.ServiceA.allowMaximumSizeToDivergeFromCoreSize</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.keepAliveTimeMinutes</span> = <span class="string">1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maximumSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.coreSize</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.maxQueueSize</span> = <span class="string">-1</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.queueSizeRejectionThreshold</span> = <span class="string">5</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.numBuckets</span> = <span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.ServiceA.metrics.rollingStats.timeInMilliseconds</span> = <span class="string">10000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixThreadPool <span class="title">initThreadPool</span><span class="params">(HystrixThreadPool fromConstructor, HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get the default implementation of HystrixThreadPool</span></span><br><span class="line">        <span class="keyword">return</span> HystrixThreadPool.Factory.getInstance(threadPoolKey, threadPoolPropertiesDefaults);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fromConstructor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="comment">// 维护了一个map，key就是threadPoolKey，一个key就对应了一个线程池</span></span><br><span class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> HystrixThreadPool <span class="title">getInstance</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work</span></span><br><span class="line">    String key = threadPoolKey.name();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should find it for all but the first time</span></span><br><span class="line">    HystrixThreadPool previouslyCached = threadPools.get(key);</span><br><span class="line">    <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> previouslyCached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we get here this is the first time so we need to initialize</span></span><br><span class="line">    <span class="keyword">synchronized</span> (HystrixThreadPool.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!threadPools.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 创建线程池</span></span><br><span class="line">            threadPools.put(key, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadPools.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolDefault</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);</span><br><span class="line">    HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">this</span>.queueSize = properties.maxQueueSize().get();</span><br><span class="line">		<span class="comment">// 用这个线程池</span></span><br><span class="line">    <span class="keyword">this</span>.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,</span><br><span class="line">            concurrencyStrategy.getThreadPool(threadPoolKey, properties),</span><br><span class="line">            properties);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.metrics.getThreadPool();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">this</span>.threadPool.getQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* strategy: HystrixMetricsPublisherThreadPool */</span></span><br><span class="line">    HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, <span class="keyword">this</span>.metrics, <span class="keyword">this</span>.properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池初始化的参数，线程池大小的设置"><a href="#线程池初始化的参数，线程池大小的设置" class="headerlink" title="线程池初始化的参数，线程池大小的设置"></a>线程池初始化的参数，线程池大小的设置</h2><p>仔细看一下线程池构造的代码：</p>
<ol>
<li>构建了一个 ThreadFactory，这个就是为了给线程起名字，Hystrix开头的名字</li>
<li>hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队，如果满了就reject了。否则就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去queue排队，如果queue也满了，就会增加core-size到maximumSize，还不够就reject掉了。</li>
<li>默认配置：线程池：10，不可动态增加线程（hystrix.threadpool.ServiceA.maximumSize无效），queue：SynchronousQueue，不支持排队。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(<span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadFactory这个就是为了给线程起名字，Hystrix开头的名字</span></span><br><span class="line">    <span class="keyword">final</span> ThreadFactory threadFactory = getThreadFactory(threadPoolKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dynamicCoreSize = threadPoolProperties.coreSize().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxQueueSize = threadPoolProperties.maxQueueSize().get();</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = getBlockingQueue(maxQueueSize);</span><br><span class="line">	  <span class="comment">// 默认是false</span></span><br><span class="line">    <span class="keyword">if</span> (allowMaximumSizeToDivergeFromCoreSize) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dynamicMaximumSize = threadPoolProperties.maximumSize().get();</span><br><span class="line">        <span class="keyword">if</span> (dynamicCoreSize &gt; dynamicMaximumSize) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Hystrix ThreadPool configuration at startup for : &quot;</span> + threadPoolKey.name() + <span class="string">&quot; is trying to set coreSize = &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot; and maximumSize = &quot;</span> + dynamicMaximumSize + <span class="string">&quot;.  Maximum size will be set to &quot;</span> +</span><br><span class="line">                    dynamicCoreSize + <span class="string">&quot;, the coreSize value, since it must be equal to or greater than the coreSize value&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到线程池队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are using SynchronousQueue if maxQueueSize &lt;= 0 (meaning a queue is not wanted).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * SynchronousQueue will do a handoff from calling thread to worker thread and not allow queuing which is what we want.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Queuing results in added latency and would only occur when the thread-pool is full at which point there are latency issues</span></span><br><span class="line"><span class="comment">     * and rejecting is the preferred solution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// hystrix.threadpool.ServiceA.maxQueueSize = -1，直接返回SynchronousQueue，这是一个同步队列，也就是收到请求后直接创建线程，不会去排队</span></span><br><span class="line">    <span class="keyword">if</span> (maxQueueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 就会返回LinkedBlockingQueue,优先用core-size的线程数量去处理，如果满了就去排队，如果排队的也满了，就会增加core-size到maximumSize，还不够就拒绝掉了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxQueueSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HystrixThreadPool-getScheduler"><a href="#HystrixThreadPool-getScheduler" class="headerlink" title="HystrixThreadPool.getScheduler"></a>HystrixThreadPool.getScheduler</h2><p>线程池初始化后，回到之前<a href="#executeCommandWithSpecifiedIsolation">executeCommandWithSpecifiedIsolation</a>的代码里，他的subscribeOn方法，在订阅Observable的时候，调用了HystrixThreadPool.getScheduler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line">.subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>这就搞了个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HystrixThreadPool.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">(Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了允许动态调整线程池大家，就修改配置</span></span><br><span class="line">    touchConfig();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), <span class="keyword">this</span>, shouldInterruptThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就到了内部类HystrixContextSchedulerWorker里，看他的schedule方法</p>
<h2 id="线程池执行，以及判断线程池是否满了"><a href="#线程池执行，以及判断线程池是否满了" class="headerlink" title="线程池执行，以及判断线程池是否满了"></a>线程池执行，以及判断线程池是否满了</h2><p>假设core-size=10，queueSizeRejectionThreshold=5</p>
<p>首先会将任务不断的给线程池，让线程池来处理，如果10个线程都满了，此时就会进入队列来排队。如果此时队列排队的请求是3个，那么3&lt;5，还可以继续发送请求，进行排队。当队列数量达到5个以后，也会抛出RejectedExecutionException异常。</p>
<ol>
<li>如果queueSize小于0，则表示没有队列</li>
<li>如果当前队列小于queueSizeRejectionThreshold，表示还有空间</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否还有空间，没有就拒绝了</span></span><br><span class="line">        <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Rejected command because thread-pool queueSize is at rejection threshold.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action), delayTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// we don&#x27;t have a queue so we won&#x27;t look for space but instead</span></span><br><span class="line">        <span class="comment">// let the thread-pool reject or not</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HystrixContexSchedulerAction包含了回调HystrxCommand.run方法的逻辑</p>
<p>最后在<code>ThreadPoolWorker</code>中，找到了提交到线程的代码逻辑，Action0就是HystrixContexSchedulerAction。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscription.isUnsubscribed()) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is internal RxJava API but it is too useful.</span></span><br><span class="line">    ScheduledAction sa = <span class="keyword">new</span> ScheduledAction(action);</span><br><span class="line"></span><br><span class="line">    subscription.add(sa);</span><br><span class="line">    sa.addParent(subscription);</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();</span><br><span class="line">    FutureTask&lt;?&gt; f = (FutureTask&lt;?&gt;) executor.submit(sa);</span><br><span class="line">    sa.add(<span class="keyword">new</span> FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，Hystrix基于线程池的基本执行逻辑一句分析完成，画个图总结一下</p>
<p><img src="/img/spring-cloud/Hystrix%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="Hystrix执行原理图"></p>
<h1 id="超时监测"><a href="#超时监测" class="headerlink" title="超时监测"></a>超时监测</h1><p>Hystrix超时计算的代码在HystrixObservableTimeoutOperator里，里面就有一个用于计算超时的监听器，如果在命令超时了，命令的状态还是NOT_EXECUTED，就将状态设置成TIMED_OUT，并抛出一个HystrixTimeoutException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimerListener listener = <span class="keyword">new</span> TimerListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath</span></span><br><span class="line">        <span class="comment">// otherwise it means we lost a race and the run() execution completed or did not start		</span></span><br><span class="line">        <span class="keyword">if</span> (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) &#123;</span><br><span class="line">            <span class="comment">// report timeout failure</span></span><br><span class="line">            originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shut down the original request</span></span><br><span class="line">            s.unsubscribe();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> HystrixContextRunnable timeoutRunnable = <span class="keyword">new</span> HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    child.onError(<span class="keyword">new</span> HystrixTimeoutException());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            timeoutRunnable.run();</span><br><span class="line">            <span class="comment">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntervalTimeInMilliseconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalCommand.properties.executionTimeoutInMilliseconds().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将这个监听器放到了HystrixTimer里，在这里判断超时的时候回调</span></span><br><span class="line"><span class="keyword">final</span> Reference&lt;TimerListener&gt; tl = HystrixTimer.getInstance().addTimerListener(listener);</span><br><span class="line"><span class="comment">// 放回到Command中</span></span><br><span class="line">originalCommand.timeoutTimer.set(tl);</span><br></pre></td></tr></table></figure>

<p>创建线程，并按照时间执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addTimerListener</span><span class="params">(<span class="keyword">final</span> TimerListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化了HystrixTimer线程池，大小是4</span></span><br><span class="line">    startThreadIfNeeded();</span><br><span class="line">    <span class="comment">// add the listener</span></span><br><span class="line"></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                listener.tick();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed while ticking TimerListener&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">		<span class="comment">// 利用前面初始化的线程池，每隔1秒钟执行一次r（也就是TimerListener)，这个时间就是Command设置的超时是时间</span></span><br><span class="line">    ScheduledFuture&lt;?&gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TimerReference(listener, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令执行完成以后，HystrixCommand的isCommandTimedOut的状态就会变成COMPLETED，所以在定时调度的时候不会进入判断条件。同时在任务处理完成也会清理掉定时任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotTimedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED</span></span><br><span class="line">    <span class="keyword">return</span> originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||</span><br><span class="line">            originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommandEnd</span><span class="params">(<span class="keyword">boolean</span> commandExecutionStarted)</span> </span>&#123;</span><br><span class="line">    Reference&lt;TimerListener&gt; tl = timeoutTimer.get();</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tl.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/spring-cloud/Hystrix%E8%B6%85%E6%97%B6%E5%8E%9F%E7%90%86.jpg" alt="Hystrix超时原理"></p>
<p>然后超时的降级，下面的文章再看。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>超时、命令执行过程中，线程满了，都会抛出异常，那Hystrix在这种情况下都会执行降级逻辑，我们去找一下处理这些异常，然后执行降级逻辑的代码在哪里。其实就在<a href="#executeCommandAndObserve">executeCommandAndObserve</a>方法中的<code>handleFallback</code></p>
<p>在这里就发现，所有的异常都是handleFallback处理的，其实就是拒绝、超时、失败，都会执行降级逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractCommand.java</span></span><br><span class="line"><span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        circuitBreaker.markNonSuccess();</span><br><span class="line">        Exception e = getExceptionFromThrowable(t);</span><br><span class="line">        executionResult = executionResult.setExecutionException(e);</span><br><span class="line">        <span class="comment">// 拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">          <span class="comment">// 超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleTimeoutViaFallback();</span><br><span class="line">          <span class="comment">// 失败</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleBadRequestByEmittingError(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleFailureViaFallback(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>这些就是fallback的处理，最终会调用getFallbackOrThrowException，然后执行用户定义的fallback方法</p>
<p>handleSemaphoreRejectionViaFallback<br>handleShortCircuitViaFallback<br>handleThreadPoolRejectionViaFallback<br>handleTimeoutViaFallback<br>handleFailureViaFallback</p>
<h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p>在多次异常降级后，熔断器就会打开了，接着就分析一下熔断器是如何打开的</p>
<p>先去看初始化的代码，在HystrixCommand构造方法中，会初始化熔断器</p>
<ol>
<li>一个Command Key就对应了一个熔断器</li>
<li>在初始化HystrixCircuitBreakerImpl的时候，会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</li>
<li>在最近的一个时间窗口以内（10s），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</li>
<li>反之，如果totalRequests（总请求数量）&gt;= circuitBreakerRequestVolumeThreshold（默认是20），就会进入下一步的尝试</li>
<li>如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</li>
<li>反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixCircuitBreaker <span class="title">initCircuitBreaker</span><span class="params">(<span class="keyword">boolean</span> enabled, HystrixCircuitBreaker fromConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandGroupKey groupKey, HystrixCommandKey commandKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// get the default implementation of HystrixCircuitBreaker</span></span><br><span class="line">            <span class="comment">// 拿的是HystrixCircuitBreakerImpl</span></span><br><span class="line">            <span class="keyword">return</span> HystrixCircuitBreaker.Factory.getInstance(commandKey, groupKey, properties, metrics);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fromConstructor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NoOpCircuitBreaker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HystrixCircuitBreakerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, <span class="keyword">final</span> HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//On a timer, this will set the circuit between OPEN/CLOSED as command executions occur</span></span><br><span class="line">    <span class="comment">// 会监听拒绝、异常、超时等数据，从统计信息metrics里拿的数据</span></span><br><span class="line">    Subscription s = subscribeToStream();</span><br><span class="line">    activeSubscription.set(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Subscription <span class="title">subscribeToStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This stream will recalculate the OPEN/CLOSED status on every onNext from the health stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> metrics.getHealthCountsStream()</span><br><span class="line">            .observe()</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Subscriber&lt;HealthCounts&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最近10秒钟的统计信息</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(HealthCounts hc)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 在最近的一个时间窗口以内（10秒），totalRequests（总请求数量）小于circuitBreakerRequestVolumeThreshold（默认是20），那就什么都不干</span></span><br><span class="line">                    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">                    <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                        <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></span><br><span class="line">                        <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                        <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                        <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                        <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 进入下一步的尝试</span></span><br><span class="line">                        <span class="comment">// 如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，5次，20%） &lt; circuitBreakerErrorThresholdPercentage（默认是50%）什么都不干</span></span><br><span class="line">                        <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                            <span class="comment">//we are not past the minimum error threshold for the stat window,</span></span><br><span class="line">                            <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                            <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                            <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                            <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> </span><br><span class="line">                            <span class="comment">// 反之，如果最近一个时间窗口（默认是10s）内的异常请求次数所占的比例（25次请求，20次，80%） &gt;= circuitBreakerErrorThresholdPercentage（默认是50%），此时就会打开熔断开关</span></span><br><span class="line">                            <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></span><br><span class="line">                            <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</span><br><span class="line">                                circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="熔断器打开后，请求直接降级"><a href="#熔断器打开后，请求直接降级" class="headerlink" title="熔断器打开后，请求直接降级"></a>熔断器打开后，请求直接降级</h2><p>就是在在<a href="#applyHystrixSemantics">applyHystrixSemantics</a>这里的代码，就会先判断人熔断器的状态，如果熔断器打开了，就直接走降级逻辑了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -1 就是可以执行请求，断路器没有打开</span></span><br><span class="line">    <span class="keyword">if</span> (circuitOpened.get() == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAfterSleepWindow()) &#123;</span><br><span class="line">            <span class="comment">// 状态搞为半打开，让一个请求执行试一下</span></span><br><span class="line">            <span class="comment">// 如果失败了，那么还是OPEN，handleFallback -&gt; circuitBreaker.markNonSuccess();同时会更新熔断的时间戳</span></span><br><span class="line">            <span class="comment">// 如果请求成功，markEmits/markOnCompleted,circuitBreaker.markSuccess(),关闭熔断器。会变成CLOSED</span></span><br><span class="line">            <span class="keyword">if</span> (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) &#123;</span><br><span class="line">                <span class="comment">//only the first request after sleep window should execute</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过了一个circuitBreakerSleepWindowInMilliseconds时间以后，这个时间默认是5秒</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAfterSleepWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> circuitOpenTime = circuitOpened.get();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> sleepWindowTime = properties.circuitBreakerSleepWindowInMilliseconds().get();</span><br><span class="line">    <span class="keyword">return</span> currentTime &gt; circuitOpenTime + sleepWindowTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to close the circuit - it resets the stream to start it over from 0</span></span><br><span class="line">        metrics.resetStream();</span><br><span class="line">        Subscription previousSubscription = activeSubscription.get();</span><br><span class="line">        <span class="keyword">if</span> (previousSubscription != <span class="keyword">null</span>) &#123;</span><br><span class="line">            previousSubscription.unsubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        Subscription newSubscription = subscribeToStream();</span><br><span class="line">        activeSubscription.set(newSubscription);</span><br><span class="line">        circuitOpened.set(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markNonSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.compareAndSet(Status.HALF_OPEN, Status.OPEN)) &#123;</span><br><span class="line">        <span class="comment">//This thread wins the race to re-open the circuit - it resets the start time for the sleep window</span></span><br><span class="line">        circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="画图总结"><a href="#画图总结" class="headerlink" title="画图总结"></a>画图总结</h2><p><img src="/img/spring-cloud/Hystrix%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86-9119853.jpg" alt="Hystrix熔断器的中断原理"></p>
<h1 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h1><p><a href="#toObservable">toObservable</a> 方法里包含了请求缓存的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* try from cache first */</span></span><br><span class="line"><span class="keyword">if</span> (requestCacheEnabled) &#123;</span><br><span class="line">    HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        isResponseFromCache = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用缓存架构实战3-Redis高可用集群实战</title>
    <url>/2018/02/15/cache/cache03/</url>
    <content><![CDATA[<p>此为龙果学院课程笔记，记录以供以后翻看</p>
<h1 id="Redis高可用集群实战"><a href="#Redis高可用集群实战" class="headerlink" title="Redis高可用集群实战"></a>Redis高可用集群实战</h1><h2 id="如何做到99-99-高可用性"><a href="#如何做到99-99-高可用性" class="headerlink" title="如何做到99.99%高可用性"></a>如何做到99.99%高可用性</h2><ol>
<li><p>什么叫99.99%的高可用性？</p>
<p> 在365天 * 99.99%的时间内，你的系统都是可以对外提供服务的，那就是高可用性，99.99%。</p>
</li>
<li><p>redis不可用是什么？单实例不可用？主从架构不可用？不可用的后果是什么？</p>
<p> 如果是master进程被杀了，或者系统宕机了，那就无法提供服务了。但是如果是集群中某一个slave挂掉了，没问题，还有其他的slave可以提供服务。</p>
</li>
<li><p>Redis怎么才能做到高可用？</p>
<p> 如果master挂了怎么办？Redis有个故障转移功能，如果master node故障时，自动检测，并且将某个slave node自动切换为master node，也可以叫做主备切换，这实现了redis主从架构下的高可用性，这其中会用到Redis的哨兵架构（它会去检测）。<br> 一旦master故障，在很短的时间内，就会切换到另外一个master上去，可能就几分钟，或者几秒钟是不可用的。    </p>
</li>
</ol>
<a id="more"></a>

<h2 id="Redis哨兵架构介绍"><a href="#Redis哨兵架构介绍" class="headerlink" title="Redis哨兵架构介绍"></a>Redis哨兵架构介绍</h2><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p>
<p>哨兵是redis集群架构中非常重要的一个组件，主要功能如下：</p>
<ol>
<li>集群监控，负责监控redis master和slave进程是否正常工作。</li>
<li>消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移，如果master node挂掉了，会自动转移到slave node上。</li>
<li>配置中心，如果故障转移发生了，通知client客户端新的master地址。</li>
</ol>
<p>哨兵本身也是分布式的，作为一个哨兵集群去运行，互相协同工作：</p>
<ol>
<li>执行故障转移时，判断一个master node是宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就坑爹了。</li>
</ol>
<h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><ol>
<li><strong>哨兵至少需要3个实例</strong>，来保证自己的健壮性</li>
<li>哨兵 + redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</li>
<li>对于哨兵 + redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练</li>
</ol>
<h4 id="为什么redis哨兵集群只有2个节点无法正常工作？"><a href="#为什么redis哨兵集群只有2个节点无法正常工作？" class="headerlink" title="为什么redis哨兵集群只有2个节点无法正常工作？"></a>为什么redis哨兵集群只有2个节点无法正常工作？</h4><p>哨兵集群必须部署2个以上节点，如果哨兵集群仅仅部署了个2个哨兵实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>

<p>Configuration: quorum = 1（如果有quorum个哨兵投票选举，就认为master宕机，进行切换）</p>
<p>上图中2个哨兵，master宕机，s1和s2中只要有1个哨兵认为master宕机就可以进行切换，同时s1和s2中会选举出一个哨兵来执行故障转移。这个时候，它需要大多数(majority)哨兵都是运行的，2个哨兵的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），如果2个哨兵都运行着，就可以允许执行故障转移。但是，如果整个M1和S1运行的机器宕机了，那么哨兵只有1个了，此时就没有majority(大多数的哨兵)来允许执行故障转移，虽然另外一台机器还有一个R1，但是故障转移不会执行。</p>
<h4 id="经典的3节点哨兵集群"><a href="#经典的3节点哨兵集群" class="headerlink" title="经典的3节点哨兵集群"></a>经典的3节点哨兵集群</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>

<p>Configuration: quorum = 2，majority</p>
<p>如果M1所在机器宕机了，那么三个哨兵还剩下2个，S2和S3可以一致认为master宕机，然后选举出一个来执行故障转移。</p>
<h3 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h3><p>主备切换的过程，可能会导致数据丢失</p>
<ol>
<li><p>异步复制导致的数据丢失</p>
<p> 因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。</p>
</li>
<li><p>脑裂导致的数据丢失</p>
<p> <img src="/img/cache/cache03-1.png"><br> 脑裂，也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master，这个时候，集群里就会有两个master，也就是所谓的脑裂。此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了，因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。</p>
</li>
</ol>
<h4 id="解决异步复制和脑裂导致的数据丢失"><a href="#解决异步复制和脑裂导致的数据丢失" class="headerlink" title="解决异步复制和脑裂导致的数据丢失"></a>解决异步复制和脑裂导致的数据丢失</h4><p>有2个参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>要求至少有1个slave，数据复制和同步的延迟不能超过10秒，如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了，上面两个配置可以减少异步复制和脑裂导致的数据丢失。</p>
<ol>
<li><p>减少异步复制的数据丢失</p>
<p> 有了min-slaves-max-lag这个配置，就可以确保一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内。</p>
</li>
</ol>
<ol start="2">
<li><p>减少脑裂的数据丢失</p>
<p> 如果一个master出现了脑裂，跟其他slave丢了连接，上面的配置就确保了如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝客户端新的写请求，因此在脑裂场景下，最多就丢失10秒的数据。</p>
</li>
</ol>
<h2 id="哨兵原理详解"><a href="#哨兵原理详解" class="headerlink" title="哨兵原理详解"></a>哨兵原理详解</h2><h3 id="sdown和odown转换机制"><a href="#sdown和odown转换机制" class="headerlink" title="sdown和odown转换机制"></a>sdown和odown转换机制</h3><p>sdown和odown是两种失败状态。sdown是主观宕机，就是一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机。</p>
<p>odown是客观宕机，如果<code>quorum</code>数量的哨兵都觉得一个master宕机了，那么就是客观宕机。</p>
<p>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了<code>is-master-down-after-milliseconds</code>参数指定的毫秒数之后，就主观认为master宕机。</p>
<p>sdown到odown转换的条件很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机。</p>
<h3 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h3><p>哨兵互相之间的发现，是通过redis的<code>pub/sub</code>系统实现的，每个哨兵都会往<code>__sentinel__:hello</code>这个channel里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在，每隔两秒钟，每个哨兵都会往自己监控的某个master+slaves对应的<code>__sentinel__:hello</code> channel里发送一个消息，内容是自己的host、ip和runid还有对这个master的监控配置。</p>
<p>每个哨兵也会去监听自己监控的每个master+slaves对应的<code>__sentinel__:hello </code>channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在。每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p>
<h3 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h3><p>哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave在复制现有master的数据; 如果slave连接到了一个错误的master上，比如故障转移之后，哨兵会确保它们连接到正确的master上。</p>
<h3 id="slave-gt-master选举算法"><a href="#slave-gt-master选举算法" class="headerlink" title="slave-&gt;master选举算法"></a>slave-&gt;master选举算法</h3><p>如果一个master被认为odown了，而且majority（大多数）哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave。</p>
<p>选举会考虑slave的一些因素：</p>
<ol>
<li>跟master断开连接的时长</li>
<li>slave优先级</li>
<li>复制offset</li>
<li>run id</li>
</ol>
<p>如果一个slave跟master断开连接已经超过了<code>down-after-milliseconds</code>的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master。</p>
<p>接下来会对slave进行排序：</p>
<ol>
<li>按照slave优先级进行排序，<code>slave priority</code>越低，优先级就越高。</li>
<li>如果<code>slave priority</code>相同，那么看<code>replica offset</code>，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li>
<li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li>
</ol>
<h3 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h3><p>每次一个哨兵要做主备切换，首先需要<code>quorum</code>数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还得得到majority哨兵的授权，才能正式执行切换。</p>
<p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，那么就3个哨兵授权就可以执行切换。</p>
<p>但是如果quorum &gt;= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换。</p>
<h3 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h3><p>哨兵会对一套redis master+slave进行监控，有相应的监控的配置，要执行切换的那个哨兵，会从要切换到的新master（salve-&gt;master）节点那里得到一个<code>configuration epoch</code>，这就是一个version号，每次切换的version号都必须是唯一的。</p>
<p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的<code>configuration epoch</code>，作为新的version号。</p>
<h3 id="configuraiton传播"><a href="#configuraiton传播" class="headerlink" title="configuraiton传播"></a>configuraiton传播</h3><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他的哨兵，就是通过之前说的pub/sub消息机制，这里之前的version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p>
<h2 id="哨兵集群实战"><a href="#哨兵集群实战" class="headerlink" title="哨兵集群实战"></a>哨兵集群实战</h2><p>动手实操，练习如何操作部署哨兵集群，如何基于哨兵进行故障转移，还有一些企业级的配置方案。</p>
<h3 id="哨兵的配置文件"><a href="#哨兵的配置文件" class="headerlink" title="哨兵的配置文件"></a>哨兵的配置文件</h3><p>每一个哨兵都可以去监控多个maser-slaves的主从架构，相同的一套哨兵集群，可以去监控不同的多个redis主从集群，只需要给每个redis主从集群分配一个逻辑的名称。</p>
<p><code>sentinel.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定对一个master的监控，给监控的master指定的一个名称，后面分布式集群架构里会讲到，可以配置多个master做数据拆分。</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 超过多少毫秒跟一个redis实例断了连接，哨兵就可能认为这个redis实例挂了</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line"><span class="comment"># 执行故障转移的timeout超时时长</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># 新的master切换之后，同时有多少个slave被切换到去连接新master，重新做同步，数字越低，花费的时间越多</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 上面的三个配置，都是针对某个监控的master配置的，给其指定上面分配的名称即可</span></span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 </span><br></pre></td></tr></table></figure>

<p>上面这段配置，就监控了两个master node。这是最小的哨兵配置，如果发生了master-slave故障转移，或者新的哨兵进程加入哨兵集群，那么哨兵会自动更新自己的配置文件。</p>
<pre><code>sentinel monitor master-group-name hostname port quorum</code></pre>
<p><strong>quorum</strong>的解释如下：</p>
<ol>
<li>至少多少个哨兵要一致同意，master进程挂掉了，或者slave进程挂掉了，或者要启动一个故障转移操作</li>
<li>quorum是用来识别故障的，真正执行故障转移的时候，还是要在哨兵集群执行选举，选举一个哨兵进程出来执行故障转移操作</li>
<li>假设有5个哨兵，quorum设置了2，那么如果5个哨兵中的2个都认为master挂掉了; 2个哨兵中的一个就会做一个选举，选举一个哨兵出来，执行故障转移; 如果5个哨兵中有3个哨兵都是运行的，那么故障转移就会被允许执行</li>
</ol>
<p>假设你的redis是1个master，4个slave，然后master宕机了，4个slave中有1个切换成了master，剩下3个slave就要挂到新的master上面去，这个时候，如果<code>parallel-syncs</code>是1，那么3个slave，一个一个地挂接到新的master上面去，1个挂接完，而且从新的master sync完数据之后，再挂接下一个。如果<code>parallel-syncs</code>是3，那么一次性就会把所有slave挂接到新的master上去。</p>
<h3 id="在eshop-cache03上再部署一个Redis"><a href="#在eshop-cache03上再部署一个Redis" class="headerlink" title="在eshop-cache03上再部署一个Redis"></a>在eshop-cache03上再部署一个Redis</h3><blockquote>
<p>eshop-cache03是我本机安装的又一台虚拟机。</p>
</blockquote>
<p>先安装好Redis，但是不用启动，接下来做哨兵的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.1-src.tar.gz</span><br><span class="line">tar -xzvf tcl8.6.1-src.tar.gz</span><br><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;tcl8.6.1&#x2F;unix&#x2F;</span><br><span class="line">.&#x2F;configure  </span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">使用redis-3.2.8.tar.gz</span><br><span class="line">tar -zxvf redis-3.2.8.tar.gz</span><br><span class="line">cd redis-3.2.8</span><br><span class="line">make &amp;&amp; make test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/sentinel</span><br><span class="line">mkdir -p /var/sentinel/5000</span><br><span class="line">vi /etc/sentinel/5000.conf</span><br></pre></td></tr></table></figure>

<p><code>5000.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 5000</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.201</span><br><span class="line">dir /var/sentinel/5000</span><br><span class="line">sentinel monitor mymaster 192.168.2.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">port 5000</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.202</span><br><span class="line">dir /var/sentinel/5000</span><br><span class="line">sentinel monitor mymaster 192.168.2.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">port 5000</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.203</span><br><span class="line">dir /var/sentinel/5000</span><br><span class="line">sentinel monitor mymaster 192.168.2.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>

<p>注意这是3段哨兵的配置，分别在我的3台虚拟机上进行配置。哨兵默认用26379端口，默认不能跟其他机器在指定端口连通，只能在本地访问，所以要改一下<code>bind</code>配置，把三台redis实例的ip都加上。</p>
<h3 id="启动哨兵进程"><a href="#启动哨兵进程" class="headerlink" title="启动哨兵进程"></a>启动哨兵进程</h3><p>在eshop-cache01、eshop-cache02、eshop-cache03三台机器上，分别启动三个哨兵进程，组成一个集群，观察一下日志的输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel &#x2F;etc&#x2F;sentinel&#x2F;5000.conf</span><br><span class="line">redis-server &#x2F;etc&#x2F;sentinel&#x2F;5000.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1318:X 16 Feb 18:59:15.097 # +monitor master mymaster 192.168.2.201 6379 quorum 2</span><br><span class="line">1318:X 16 Feb 18:59:15.099 * +slave slave 192.168.2.202:6379 192.168.2.202 6379 @ mymaster 192.168.2.201 6379</span><br><span class="line">1318:X 16 Feb 18:59:15.177 * +sentinel sentinel 6f6009aac859757a296467f11f68af7284e4c9ff 192.168.2.202 5000 @ mymaster 192.168.2.201 6379</span><br><span class="line">1318:X 16 Feb 18:59:16.861 * +sentinel sentinel 4fbf75c6fcbfdd09fe8460b6e12006561567f24d 192.168.2.203 5000 @ mymaster 192.168.2.201 6379</span><br></pre></td></tr></table></figure>
<p>日志里会显示出来，每个哨兵都能去监控到对应的redis master，并能够自动发现对应的slave。</p>
<p>哨兵之间，互相会自动进行发现，用的就是之前说的pub/sub，消息发布和订阅channel消息系统和机制。</p>
<h3 id="检查哨兵状态"><a href="#检查哨兵状态" class="headerlink" title="检查哨兵状态"></a>检查哨兵状态</h3><p>redis-cli -h 192.168.2.201 -p 5000</p>
<p>sentinel master mymaster<br>SENTINEL slaves mymaster<br>SENTINEL sentinels mymaster</p>
<p>SENTINEL get-master-addr-by-name mymaster</p>
<h2 id="哨兵管理和容灾演练"><a href="#哨兵管理和容灾演练" class="headerlink" title="哨兵管理和容灾演练"></a>哨兵管理和容灾演练</h2><h3 id="哨兵节点的增加和删除"><a href="#哨兵节点的增加和删除" class="headerlink" title="哨兵节点的增加和删除"></a>哨兵节点的增加和删除</h3><p>如果是增加sentinel，会自动发现。</p>
<p>删除sentinel的步骤：</p>
<ol>
<li>停止sentinel进程</li>
<li>SENTINEL RESET *，在所有sentinel上执行，清理所有的master状态</li>
<li>SENTINEL MASTER mastername，在所有sentinel上执行，查看所有sentinel对数量是否达成了一致</li>
</ol>
<h3 id="slave的永久下线"><a href="#slave的永久下线" class="headerlink" title="slave的永久下线"></a>slave的永久下线</h3><p>让master摘除某个已经下线的slave：<code>SENTINEL RESET mastername</code>，在所有的哨兵上面执行.</p>
<h3 id="slave切换为Master的优先级"><a href="#slave切换为Master的优先级" class="headerlink" title="slave切换为Master的优先级"></a>slave切换为Master的优先级</h3><p>slave-&gt;master选举优先级：<code>slave-priority</code>，值越小优先级越高</p>
<h3 id="基于哨兵集群架构下的安全认证"><a href="#基于哨兵集群架构下的安全认证" class="headerlink" title="基于哨兵集群架构下的安全认证"></a>基于哨兵集群架构下的安全认证</h3><p>每个slave都有可能切换成master，所以每个实例都要配置两个指令</p>
<p>master上启用安全认证，<code>requirepass</code><br>master连接口令，<code>masterauth</code></p>
<p>sentinel配置：<code>sentinel auth-pass &lt;master-group-name&gt; &lt;pass&gt;</code></p>
<h3 id="容灾演练"><a href="#容灾演练" class="headerlink" title="容灾演练"></a>容灾演练</h3><p>通过哨兵看一下当前的master：<code>SENTINEL get-master-addr-by-name mymaster</code>。</p>
<p>把master节点kill -9掉，pid文件也删除掉。</p>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1336:X 16 Feb 22:05:18.458 # -sdown master mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:18.458 # -odown master mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:18.458 # +selected-slave slave 192.168.2.202:6379 192.168.2.202 6379 @ mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:18.458 * +failover-state-send-slaveof-noone slave 192.168.2.202:6379 192.168.2.202 6379 @ mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:18.559 * +failover-state-wait-promotion slave 192.168.2.202:6379 192.168.2.202 6379 @ mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:19.417 # +promoted-slave slave 192.168.2.202:6379 192.168.2.202 6379 @ mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:19.417 # +failover-state-reconf-slaves master mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:19.486 # +failover-end master mymaster 192.168.2.201 6379</span><br><span class="line">1336:X 16 Feb 22:05:19.486 # +switch-master mymaster 192.168.2.201 6379 192.168.2.202 6379</span><br><span class="line">1336:X 16 Feb 22:05:19.486 * +slave slave 192.168.2.201:6379 192.168.2.201 6379 @ mymaster 192.168.2.202 6379</span><br><span class="line">1336:X 16 Feb 22:05:29.593 * +convert-to-slave slave 192.168.2.201:6379 192.168.2.201 6379 @ mymaster 192.168.2.202 6379</span><br></pre></td></tr></table></figure>

<p>查看sentinel的日志，是否出现+sdown字样，识别出了master的宕机问题; 然后出现+odown字样，就是指定的quorum哨兵数量，都认为master宕机了。</p>
<ol>
<li>三个哨兵进程都认为master是sdown了</li>
<li>超过quorum指定的哨兵进程都认为sdown之后，就变为odown</li>
<li>哨兵1是被选举为要执行后续的主备切换的那个哨兵</li>
<li>哨兵1去新的master（slave）获取了一个新的config version</li>
<li>尝试执行failover</li>
<li>投票选举出一个slave去切换成master，每个哨兵都会执行一次投票</li>
<li><code>failover-state-send-slaveof-noone</code>，不让它去做任何节点的slave了; 把slave提拔成master; 旧的master认为不再是master了</li>
<li>哨兵就自动认为之前的201:6379变成了slave了，202:6379变成了master了</li>
<li>哨兵去探查了一下201:6379这个salve的状态，认为它sdown了</li>
</ol>
<p>所有哨兵选举出了一个实例，来执行主备切换操作，可以看到投票的日志<code>xxx voted for xxxx</code>。如果majority的哨兵都存活着，那么就会执行主备切换操作，刚才日志里也看到了，<code>+switch-master mymaster 192.168.2.201 6379 192.168.2.202 6379</code>。</p>
<p>再通过哨兵看一下master：SENTINEL get-master-addr-by-name mymaster</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@eshop-cache01 ~]<span class="comment"># redis-cli -h 192.168.2.201 -p 5000</span></span><br><span class="line">192.168.2.201:5000&gt; SENTINEL get-master-addr-by-name mymaster</span><br><span class="line">1) <span class="string">&quot;192.168.2.202&quot;</span></span><br><span class="line">2) <span class="string">&quot;6379&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到master已经变成<code>192.168.2.202:6379</code>了，接下来我们试试故障恢复，再将旧的master重新启动，查看是否被哨兵自动切换成slave节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@eshop-cache01 ~]<span class="comment"># /etc/init.d/redis_6379 start</span></span><br></pre></td></tr></table></figure>

<p>重新看一下202上的<code>info replication</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.2.202:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.2.201,port=6379,state=online,offset=219972,lag=1</span><br></pre></td></tr></table></figure>
<p>发现201它变成了一个slave了。</p>
<p>所以容灾的演练的步骤是：</p>
<ol>
<li>手动杀掉master</li>
<li>哨兵能否执行主备切换，将slave切换为master</li>
<li>哨兵完成主备切换后，新的master能否使用</li>
<li>故障恢复，将旧的master重新启动</li>
<li>哨兵能否自动将旧的master变为slave，挂接到新的master上面去，而且也是可以使用的</li>
</ol>
<h3 id="哨兵的生产环境部署"><a href="#哨兵的生产环境部署" class="headerlink" title="哨兵的生产环境部署"></a>哨兵的生产环境部署</h3><p>配置文件改成后台运行，然后把日志路径配置上。</p>
<pre><code>daemonize yes
logfile /var/log/sentinel/5000.log
mkdir -p /var/log/sentinel</code></pre>
<h2 id="如何让Redis支持1T以上大数据"><a href="#如何让Redis支持1T以上大数据" class="headerlink" title="如何让Redis支持1T以上大数据"></a>如何让Redis支持1T以上大数据</h2><h3 id="单Master的redis在海量数据面前的瓶颈"><a href="#单Master的redis在海量数据面前的瓶颈" class="headerlink" title="单Master的redis在海量数据面前的瓶颈"></a>单Master的redis在海量数据面前的瓶颈</h3><p>Master节点的数据和slave节点的数据是一样的，master最大能容纳多大的数据量，那么slave也就只能容纳多大的数据量。</p>
<p>Redis的缓存清理算法，将旧的很少使用的数据，给清除出内存，然后保证内存中，就只有固定大小的内存，不可能超过master内存的物理上线。</p>
<p>但是如果要让Redis保存1T以上的数据在缓存里，供系统高性能的查询和运行，在单机Master的情况下，目前几乎是不可能达到的。</p>
<h3 id="怎么才能够突破单机瓶颈，让redis支撑海量数据？"><a href="#怎么才能够突破单机瓶颈，让redis支撑海量数据？" class="headerlink" title="怎么才能够突破单机瓶颈，让redis支撑海量数据？"></a>怎么才能够突破单机瓶颈，让redis支撑海量数据？</h3><p>如果要支撑更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了，单台服务器是32GB，30台左右就可以支撑1T的数据量了。</p>
<h3 id="Redis集群架构"><a href="#Redis集群架构" class="headerlink" title="Redis集群架构"></a>Redis集群架构</h3><p>Redis集群架构支持N个master node，每个master node都可以挂载多个slave node，依然是读写分离的架构，对于每个master来说，写就写到master，然后读就从master对应的slave去读。</p>
<p>集群高可用：因为每个master都有slave节点，那么如果master挂掉，redis cluster的的机制，就会自动将某个slave切换成master。</p>
<p>redis cluster = 多master + 读写分离 + 高可用。</p>
<p>所以只需要基于redis cluster去搭建redis集群即可，<strong>不需要</strong>手工去搭建replication复制+主从架构+读写分离+哨兵集群+高可用。</p>
<h3 id="redis-cluster-vs-replication-sentinel"><a href="#redis-cluster-vs-replication-sentinel" class="headerlink" title="redis cluster vs. replication + sentinel"></a>redis cluster vs. replication + sentinel</h3><p>如果数据量很少，主要是为了承载高并发高性能的场景，比如你的缓存一般就几个G，单机足够了。</p>
<p>如果是<strong>replication</strong>架构，一个mater，多个slave，需要几个slave跟要求的读吞吐量有关系，然后搭建一个sentinel集群，去保证redis主从架构的高可用性，就能满足需求了。<strong>redis cluster</strong>主要是针对<strong>海量数据+高并发+高可用</strong>的场景，如果数据量很大，那么建议就用<strong>redis cluster</strong>。</p>
<h3 id="分布式数据存储的核心算法"><a href="#分布式数据存储的核心算法" class="headerlink" title="分布式数据存储的核心算法"></a>分布式数据存储的核心算法</h3><p>随着技术的进步，算法的进阶：</p>
<pre><code>hash算法 -&gt; 一致性hash算法（memcached） -&gt; redis cluster，hash slot算法</code></pre>
<p>用不同的算法，就决定了在多个master节点的时候，数据如何分布到这些节点上去。</p>
<ol>
<li><p>hash算法</p>
<p> <img src="/img/cache/%E6%9C%80%E8%80%81%E5%9C%9F%E7%9A%84hash%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%BC%8A%E7%AB%AF.png" alt="最老土的hash算法以及弊端"></p>
<p> 先是通过对key计算hash值，然后对节点数量（3）取模，取模结果一定是0~2之间，小于节点数量，然后根据索引去对应节点删取数据。如果某一个master宕机了，所有请求过来都会重新基于新的节点数量（2）去取模，此时所有数据都无法获取到，大量的流量会涌入到数据库中，几乎100%的缓存都可能失效了。</p>
</li>
<li><p>一致性hash算法</p>
<p> <img src="/img/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%B2%E8%A7%A3%E5%92%8C%E4%BC%98%E7%82%B9.png" alt="一致性hash算法的讲解和优点"></p>
<p> 同样是先是通过对key计算hash值，然后用hash值落在圆环上的某个点，然后顺时针去寻找最近的一个节点。这个算法保证了如果某一台master宕机，只有之前那台master上的数据会受到影响，因为顺时针会找到下一个节点，还是找不到数据，此时只有1/3的数据找不到，流量会涌入到数据库中，重新查询一次。但是一致性hash算法也有一个问题，那就是换缓存热点数据问题，可能集中在某个hash区间的值特别多，会导致大量数据都涌入同一个master内，造成master的热点问题，性能出现瓶颈。</p>
</li>
<li><p>优化一致性hash算法</p>
<p> <img src="/img/cache/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E7%9A%84%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="一致性hash算法的虚拟节点实现负载均衡"></p>
<p> 为了解决缓存热点数据问题，增加了虚拟节点的概念，如上图的黑色圆圈。给每个master都做了均匀分布的虚拟节点。这样的话，在每个区间内，大量的数据都会均分到不同的节点上，而不是按照顺时针的顺序去涌入同一个master内。</p>
</li>
<li><p>hash slot算法</p>
<p> ![redis cluster hash slot算法](/img/cache/redis cluster hash slot算法.png)</p>
<p> Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<pre><code> * 节点 A 包含 0 到 5500号哈希槽
 * 节点 B 包含5501 到 11000 号哈希槽
 * 节点 C 包含11001 到 16384号哈希槽</code></pre>
<p> 这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
</li>
</ol>
<h2 id="Redis-Cluster介绍"><a href="#Redis-Cluster介绍" class="headerlink" title="Redis Cluster介绍"></a>Redis Cluster介绍</h2><p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。</p>
<p> Redis 集群的优势:</p>
<ol>
<li>自动将数据进行分片，每个master上放一部分数据。</li>
<li>提供内置的高可用支持，部分master不可用时，还是可以继续工作。</li>
</ol>
<h3 id="Redis-Cluster实战部署"><a href="#Redis-Cluster实战部署" class="headerlink" title="Redis Cluster实战部署"></a>Redis Cluster实战部署</h3><p>Redis Cluster会自动去做master+slave架构的复制和读写分离，以及master+slave的高可用+主备切换，支持多个master的hash slot分布式数据存储，所以我们之前的redis主从，哨兵集群，全部都不需要了。</p>
<h4 id="Redis-Cluster的重要配置"><a href="#Redis-Cluster的重要配置" class="headerlink" title="Redis Cluster的重要配置"></a>Redis Cluster的重要配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster-enabled &lt;yes/no&gt;</span><br><span class="line"></span><br><span class="line">cluster-config-file &lt;filename&gt;：这是指定一个文件，供cluster模式下的redis实例保存集群状态，包括集群中其他机器的信息，比如节点的上线和下线，故障转移，不是我们去维护的，给它指定一个文件，让redis自己去维护。</span><br><span class="line"></span><br><span class="line">cluster-node-timeout &lt;milliseconds&gt;：节点存活超时时长，超过一定时长，认为节点宕机，master宕机的话就会触发主备切换，slave宕机就不会提供服务。</span><br></pre></td></tr></table></figure>

<h4 id="在三台机器上启动6个redis实例"><a href="#在三台机器上启动6个redis实例" class="headerlink" title="在三台机器上启动6个redis实例"></a>在三台机器上启动6个redis实例</h4><p>redis cluster集群，要求至少3个master去组成一个高可用，健壮的分布式的集群，每个master都建议至少给一个slave，所以3个master，3个slave，这是最少的要求。如果是正式环境下，建议在6台机器上去搭建，是为了保证每个master都跟自己的slave不在同一台机器上，自然是6台自然更好，否则机器挂了，一个master+一个slave就死了，集群也就不可用了。</p>
<p>我的虚拟机为了方便测试，使用3台机器去搭建6个redis实例的redis cluster。</p>
<p>先创建目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/redis-cluster</span><br><span class="line">mkdir -p /var/<span class="built_in">log</span>/redis</span><br></pre></td></tr></table></figure>

<p>201：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/redis/7001</span><br><span class="line">mkdir -p /var/redis/7002</span><br></pre></td></tr></table></figure>
<p>202：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/redis/7003</span><br><span class="line">mkdir -p /var/redis/7004</span><br></pre></td></tr></table></figure>

<p>203：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/redis/7005</span><br><span class="line">mkdir -p /var/redis/7006</span><br></pre></td></tr></table></figure>

<p>写六份配置文件分别对应7001~7006，/etc/redis/7001.conf，每台机器上2个实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 7001</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /etc/redis-cluster/node-7001.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">daemonize	yes							</span><br><span class="line">pidfile		/var/run/redis_7001.pid 						</span><br><span class="line">dir 		/var/redis/7001		</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/7001.log</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.201</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>将上面的配置文件，在/etc/redis下放6个，分别为: 7001.conf，7002.conf，7003.conf，7004.conf，7005.conf，7006.conf，至少要用3个master节点启动，每个master加一个slave节点，先选择6个节点，启动6个实例。</p>
<h4 id="准备生产环境的启动脚本"><a href="#准备生产环境的启动脚本" class="headerlink" title="准备生产环境的启动脚本"></a>准备生产环境的启动脚本</h4><p>在/etc/init.d下，放6个启动脚本，分别为: <code>redis_7001, redis_7002, redis_7003, redis_7004, redis_7005, redis_7006</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">cp redis_6379 redis_7001</span><br><span class="line">vi redis_7001 </span><br></pre></td></tr></table></figure>
<p>将<code>REDISPORT</code>修改为7001~7006对应的端口号。</p>
<p>检查一下3台机器上的配置文件，目录是否都已经准备好，然后分别在3台机器上，启动6个redis实例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@eshop-cache01 redis]<span class="comment"># /etc/init.d/redis_7001 start</span></span><br><span class="line">[root@eshop-cache01 redis]<span class="comment"># /etc/init.d/redis_7002 start</span></span><br><span class="line">[root@eshop-cache02 init.d]<span class="comment"># /etc/init.d/redis_7003 start</span></span><br><span class="line">[root@eshop-cache02 init.d]<span class="comment"># /etc/init.d/redis_7004 start</span></span><br><span class="line">[root@eshop-cache03 init.d]<span class="comment"># /etc/init.d/redis_7005 start</span></span><br><span class="line">[root@eshop-cache03 init.d]<span class="comment"># /etc/init.d/redis_7006 start</span></span><br></pre></td></tr></table></figure>

<h4 id="创建Redis集群"><a href="#创建Redis集群" class="headerlink" title="创建Redis集群"></a>创建Redis集群</h4><p>创建集群的工具是用的<code>redis-trib</code>，它是用ruby写的，所以我们得先安装ruby环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install –y gcc* openssl* wget</span><br><span class="line">wget https:&#x2F;&#x2F;cache.ruby-lang.org&#x2F;pub&#x2F;ruby&#x2F;2.3&#x2F;ruby-2.3.1.tar.gz</span><br><span class="line">tar -zxvf ruby-2.3.1.tar.gz</span><br><span class="line">cd ruby-2.3.1</span><br><span class="line">.&#x2F;configure -prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ruby</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -sf &#x2F;usr&#x2F;local&#x2F;ruby&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;rubygems.org&#x2F;downloads&#x2F;redis-3.3.0.gem</span><br><span class="line">gem install -l .&#x2F;redis-3.3.0.gem</span><br><span class="line">gem list --check redis gem</span><br></pre></td></tr></table></figure>
<p>我在安装的时候遇到一个错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install -l ./redis-3.3.0.gem</span><br><span class="line">ERROR:  Loading <span class="built_in">command</span>: install (LoadError)</span><br><span class="line">	cannot load such file -- zlib</span><br><span class="line">ERROR:  While executing gem ... (NoMethodError)</span><br><span class="line">    undefined method `invoke_with_build_args<span class="string">&#x27; for nil:NilClass</span></span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel</span><br><span class="line"><span class="built_in">cd</span> ruby-2.3.1/ext/zlib  </span><br><span class="line">ruby ./extconf.rb  </span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<p>然后安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install -l .&#x2F;redis-3.3.0.gem</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;redis-4.0.8&#x2F;src&#x2F;redis-trib.rb &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">redis-trib.rb create --replicas 1 192.168.2.201:7001 192.168.2.201:7002 192.168.2.202:7003 192.168.2.202:7004 192.168.2.203:7005 192.168.2.203:7006</span><br></pre></td></tr></table></figure>

<p>–replicas: 每个master有几个slave</p>
<p>6台机器，3个master，3个slave，尽量自己让master和slave不在一台机器上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@eshop-cache01 <span class="built_in">local</span>]<span class="comment"># redis-trib.rb create --replicas 1 192.168.2.201:7001 192.168.2.201:7002 192.168.2.202:7003 192.168.2.202:7004 192.168.2.203:7005 192.168.2.203:7006</span></span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.2.201:7001</span><br><span class="line">192.168.2.202:7003</span><br><span class="line">192.168.2.203:7005</span><br><span class="line">Adding replica 192.168.2.202:7004 to 192.168.2.201:7001</span><br><span class="line">Adding replica 192.168.2.203:7006 to 192.168.2.202:7003</span><br><span class="line">Adding replica 192.168.2.201:7002 to 192.168.2.203:7005</span><br><span class="line">M: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">S: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   replicates 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join......</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7001)</span><br><span class="line">M: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>可以检查一下集群的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb check 192.168.2.201:7001</span><br></pre></td></tr></table></figure>


<h4 id="Redis-Cluster测试"><a href="#Redis-Cluster测试" class="headerlink" title="Redis Cluster测试"></a>Redis Cluster测试</h4><p>接下来对刚才搭建的集群做一些测试，<strong>Redis Cluster</strong>提供了多个master，数据可以分布式存储在多个master上; 每个master都带着slave，自动就做读写分离; 某个master如果故障，那么就会自动将slave切换成master，从而达到高可用。</p>
<h5 id="实验多master写入-gt-海量数据的分布式存储"><a href="#实验多master写入-gt-海量数据的分布式存储" class="headerlink" title="实验多master写入 -&gt; 海量数据的分布式存储"></a>实验多master写入 -&gt; 海量数据的分布式存储</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@eshop-cache01 <span class="built_in">local</span>]<span class="comment"># redis-cli -h 192.168.2.201 -p 7001</span></span><br><span class="line">192.168.2.201:7001&gt; <span class="built_in">set</span> mykey1 v1</span><br><span class="line">OK</span><br><span class="line">192.168.2.201:7001&gt; <span class="built_in">set</span> mykey2 v2</span><br><span class="line">(error) MOVED 14119 192.168.2.203:7005</span><br><span class="line">192.168.2.201:7001&gt; <span class="built_in">set</span> mykey3 v3</span><br><span class="line">(error) MOVED 9990 192.168.2.202:7003</span><br></pre></td></tr></table></figure>
<p>我们在redis cluster写入数据的时候，其实是可以将请求发送到任意一个master上去执行的。但是，每个master都会计算这个key对应的CRC16值，然后对16384个<strong>hash slot</strong>取模，找到key对应的<strong>hash slot</strong>，找到hash slot对应的master。如果对应的master就在自己本地的话，set mykey1 v1，mykey1这个key对应的hashslot就在自己本地，那么自己就处理掉了。但是如果计算出来的hashslot在其他master上，那么就会给客户端返回一个moved error，告诉你，你得到哪个master上去执行这条写入的命令。<strong>什么叫做多master的写入，就是每条数据只能存在于一个master上，不同的master负责存储不同的数据，分布式的数据存储。100w条数据，5个master，每个master就负责存储20w条数据，分布式数据存储。</strong></p>
<p>所以我们需要去7005和7003实例上执行后面2条语句。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.2.202 -p 7003</span><br><span class="line">192.168.2.202:7003&gt; <span class="built_in">set</span> mykey3 v3</span><br><span class="line">OK</span><br><span class="line">redis-cli -h 192.168.2.203 -p 7005</span><br><span class="line">192.168.2.203:7005&gt; <span class="built_in">set</span> mykey2 v2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h5 id="实验不同master各自的slave读取-gt-读写分离"><a href="#实验不同master各自的slave读取-gt-读写分离" class="headerlink" title="实验不同master各自的slave读取 -&gt; 读写分离"></a>实验不同master各自的slave读取 -&gt; 读写分离</h5><p>刚才是写入数据，现在我们去各自的从节点试试取数据，根据之前是日志分析，我们知道每台master的从节点信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Adding replica 192.168.2.202:7004 to 192.168.2.201:7001</span><br><span class="line">Adding replica 192.168.2.203:7006 to 192.168.2.202:7003</span><br><span class="line">Adding replica 192.168.2.201:7002 to 192.168.2.203:7005</span><br></pre></td></tr></table></figure>

<p>试试看，发现读不到，原来在redis cluster中，如果你要在slave读取数据，那么需要带先执行<code>readonly</code>指令，再<code>get mykey1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.2.202 -p 7004</span><br><span class="line">192.168.2.202:7004&gt; get mykey1</span><br><span class="line">(error) MOVED 1860 192.168.2.201:7001</span><br><span class="line">192.168.2.202:7004&gt; <span class="built_in">readonly</span></span><br><span class="line">OK</span><br><span class="line">192.168.2.202:7004&gt; get mykey1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>实际上Redis的客户端是可以帮我们自动路由的，只需要在连接的时候加上<code>-c</code>的参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.2.201 -p 7001 -c</span><br><span class="line">192.168.2.201:7001&gt; <span class="built_in">set</span> mykey2 v2</span><br><span class="line">-&gt; Redirected to slot [14119] located at 192.168.2.203:7005</span><br><span class="line">OK</span><br><span class="line">192.168.2.203:7005&gt; get mykey1</span><br><span class="line">-&gt; Redirected to slot [1860] located at 192.168.2.201:7001</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们发现实验redis cluster的读写分离的时候，会发现有一定的限制性，因为默认情况下，redis cluster的核心的理念，主要是用slave做高可用的，每个master挂一两个slave，主要是做数据的热备，还有master故障时的主备切换，<strong>它的侧重点在高可用，而不是读写分离。</strong></p>
<p>redis cluster默认是不支持slave节点读或者写的，跟我们手动基于<code>replication</code>搭建的主从架构不一样。想要在从节点上读取数据，必须要先执行<code>readonly</code>指令。</p>
<p>虽然Redis Cluster的主从架构出来了，但是要做读写分离，就复杂了一点，jedis客户端，对redis cluster的读写分离支持不太好。默认是读和写都到master上去执行，如果你要让最流行的<code>jedis</code>做redis cluster的读写分离的访问，那可能还得自己修改一点jedis的源码，成本比较高。要不然你就是自己基于<code>jedis</code>，封装一下，自己做一个redis cluster的读写分离的访问api。</p>
<p>核心的思路是这样：**<code>redis cluster</code>就没有所谓的读写分离的概念了。读写分离是为了要建立一主多从的架构，才能横向任意扩展slave node去支撑更大的读吞吐量。redis cluster的架构下，实际上本身master就是可以任意扩展的，你如果要支撑更大的读吞吐量，或者写吞吐量，或者数据量，直接对master进行横向扩展就可以了，也能实现支撑更高的读吞吐的效果。**</p>
<h5 id="实验自动故障切换-gt-高可用性"><a href="#实验自动故障切换-gt-高可用性" class="headerlink" title="实验自动故障切换 -&gt; 高可用性"></a>实验自动故障切换 -&gt; 高可用性</h5><p>我现在把201上的7001给杀掉，看202的7004是否会接替它的位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb check 192.168.2.201:7002</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7002)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>202:7004</code>已经变成了master，现在去7004上获取<code>mykey1</code>的值，看看是否能获取到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.2.202 -p 7004</span><br><span class="line">192.168.2.202:7004&gt; get mykey1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>再试着把201:7001给重新启动，它将自动作为slave挂载到了202:7004上面去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/redis_7001 start</span><br><span class="line">Starting Redis server...</span><br><span class="line">redis-trib.rb check 192.168.2.201:7002</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7002)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">S: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates cc8a78087798e148b257d2ae33815a25715109e8</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>进一步验证，<code>slave0:ip=192.168.2.201,port=7001,state=online,offset=4565,lag=1</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.2.202 -p 7004</span><br><span class="line">192.168.2.202:7004&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.2.201,port=7001,state=online,offset=4565,lag=1</span><br><span class="line">master_replid:38c489e10e3ede8290476aefec3e0ca9822f056e</span><br><span class="line">master_replid2:6451a5d9f0c94fd5191b94898181424c39a24528</span><br><span class="line">master_repl_offset:4565</span><br><span class="line">second_repl_offset:4300</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:4565</span><br></pre></td></tr></table></figure>


<h4 id="Redis-Cluster水平扩容"><a href="#Redis-Cluster水平扩容" class="headerlink" title="Redis Cluster水平扩容"></a>Redis Cluster水平扩容</h4><p>之前说了不建议在Redis Cluster上做读写分离，建议直接对master进行水平扩容来横向扩展读写吞吐量，还有支撑海量数据。</p>
<p>假设redis单机，读吞吐是5w/s，写吞吐2w/s。扩展redis到5台master，读吞吐可以达到总量25w/s QPS，写可以达到10w/s QPS。扩容到5台master，能支撑的总的缓存数据量就是30G，40G，如果是100台，那就是600G，800G，甚至1T+的海量数据。</p>
<p>单机Redis的内存一般就6G、8G，如果内存太大，fork类操作的时候很耗时，会导致请求延时的问题。</p>
<p>Redis扩容方法：</p>
<h5 id="加入新master"><a href="#加入新master" class="headerlink" title="加入新master"></a>加入新master</h5><p>203上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/redis/7007</span><br><span class="line"><span class="built_in">cd</span> /etc/redis</span><br><span class="line">cp 7006.conf 7007.conf</span><br><span class="line">vi 7007.conf</span><br><span class="line"><span class="comment"># 改一下里面的配置</span></span><br><span class="line">port 7007</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /etc/redis-cluster/node-7007.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">daemonize	yes							</span><br><span class="line">pidfile		/var/run/redis_7007.pid 						</span><br><span class="line">dir 		/var/redis/7007		</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/7007.log</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.203</span><br><span class="line">appendonly yes</span><br><span class="line">	</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">cp redis_7006 redis_7007</span><br><span class="line">vi redis_7007</span><br><span class="line"><span class="comment"># REDISPORT=7007</span></span><br><span class="line">	</span><br><span class="line">/etc/init.d/redis_7007 start</span><br></pre></td></tr></table></figure>

<p>启动完成后，加入master，在201上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb add-node 192.168.2.203:7007 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Adding node 192.168.2.203:7007 to cluster 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7001)</span><br><span class="line">S: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates cc8a78087798e148b257d2ae33815a25715109e8</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.2.203:7007 to make it join the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<p>确认一下，发现新加入的7007的master没有被分配任何的slot，所以还要需要处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb check 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7001)</span><br><span class="line">S: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates cc8a78087798e148b257d2ae33815a25715109e8</span><br><span class="line">M: 5fe91cff7ab6c20b2e2ccc0815b0a7227119f52e 192.168.2.203:7007</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<h5 id="reshard一些数据过去"><a href="#reshard一些数据过去" class="headerlink" title="reshard一些数据过去"></a>reshard一些数据过去</h5><p>resharding的意思就是把一部分hash slot从一些node上迁移到另外一些node上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb reshard 192.168.2.201:7001</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 4096</span><br><span class="line">What is the receiving node ID? 5fe91cff7ab6c20b2e2ccc0815b0a7227119f52e</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:cc8a78087798e148b257d2ae33815a25715109e8</span></span><br><span class="line">Source node <span class="comment">#2:5183cdee2295a07af3e98226887da2a645d979d1</span></span><br><span class="line">Source node <span class="comment">#3:a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span></span><br><span class="line">Source node <span class="comment">#4:done</span></span><br></pre></td></tr></table></figure>

<p>要把之前3个master算上，总共4096个hashslot迁移到新的第四个master上去，</p>
<h5 id="添加node作为slave"><a href="#添加node作为slave" class="headerlink" title="添加node作为slave"></a>添加node作为slave</h5><p>203执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/redis/7008</span><br><span class="line"><span class="built_in">cd</span> /etc/redis</span><br><span class="line">cp 7006.conf 7008.conf</span><br><span class="line">vi 7008.conf</span><br><span class="line"><span class="comment"># 改一下里面的配置</span></span><br><span class="line">port 7008</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /etc/redis-cluster/node-7008.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">daemonize	yes							</span><br><span class="line">pidfile		/var/run/redis_7008.pid 						</span><br><span class="line">dir 		/var/redis/7008		</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/7008.log</span><br><span class="line"><span class="built_in">bind</span> 192.168.2.203</span><br><span class="line">appendonly yes</span><br><span class="line">	</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/</span><br><span class="line">cp redis_7006 redis_7008</span><br><span class="line">vi redis_7008</span><br><span class="line"><span class="comment"># REDISPORT=7008</span></span><br><span class="line">	</span><br><span class="line">/etc/init.d/redis_7008 start</span><br></pre></td></tr></table></figure>

<p>201执行，将新的节点挂载到7004<code>cc8a78087798e148b257d2ae33815a25715109e8 </code>上面去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb add-node --slave --master-id cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.203:7008 192.168.2.201:7001</span><br></pre></td></tr></table></figure>

<h5 id="删除node"><a href="#删除node" class="headerlink" title="删除node"></a>删除node</h5><p>先用resharding将数据都移除到其他节点，确保node为空之后，才能执行remove操作，之前7007上是4096个slot，所以要移动3次，分别是移动1365个slot到7003，1365个slot到7004，1366个slot到7005上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb reshard 192.168.2.201:7001</span><br><span class="line">redis-trib.rb del-node 192.168.2.201:7001 5fe91cff7ab6c20b2e2ccc0815b0a7227119f52e</span><br><span class="line">&gt;&gt;&gt; Removing node 5fe91cff7ab6c20b2e2ccc0815b0a7227119f52e from cluster 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br></pre></td></tr></table></figure>

<p>当你清空了一个master的hashslot时，redis cluster就会自动将其slave挂载到其他master上去，这个时候就只要删除掉master就可以了。</p>
<h4 id="Redis-Cluster的Slave自动迁移"><a href="#Redis-Cluster的Slave自动迁移" class="headerlink" title="Redis Cluster的Slave自动迁移"></a>Redis Cluster的Slave自动迁移</h4><p>比如现在有10个master，每个有1个对应的slave，然后现在新增了3个slave作为冗余，有的master就有2个slave了，出现了salve冗余。这个时候如果某个master的slave挂了，那么redis cluster会自动迁移一个冗余的slave给那个挂掉slave的master。</p>
<p>它可以避免这样一个场景：如果你每个master只有一个slave，万一某一个slave死了，然后很快，master也死了，那可用性就降低了。但是如果你给整个集群挂载了一些冗余slave，那么某个master的slave死了，冗余的slave会被自动迁移过去，作为master的新slave，此时即使那个master也死了，还是有一个slave会切换成master的。</p>
<p>上面的实验中有一个master是有冗余slave的，直接让其他master其中的一个slave死掉，然后看有冗余slave会不会自动挂载到那个master，<code>203:7005</code>的master，冗余了一个slave。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb check 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7001)</span><br><span class="line">S: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:1365-6825 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 77aa78066b1a542e501bd9a0691f5f923529c482 192.168.2.203:7008</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates cc8a78087798e148b257d2ae33815a25715109e8</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:6826,10923-16383 (5462 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:0-1364,6827-10922 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>现在把<code>203:7008</code>给kill掉，并删除pidfile，这样<code>202:7004</code>就没有slave了，看看Redis Cluster会做些什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-trib.rb check 192.168.2.201:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.2.201:7001)</span><br><span class="line">S: 158414bbcaa2cf0b9b30a81d2e31fb35ba5b4972 192.168.2.201:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates cc8a78087798e148b257d2ae33815a25715109e8</span><br><span class="line">S: 19f6027db2837cc56dd581a3c826a687d096207a 192.168.2.203:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43</span><br><span class="line">M: cc8a78087798e148b257d2ae33815a25715109e8 192.168.2.202:7004</span><br><span class="line">   slots:1365-6825 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 5183cdee2295a07af3e98226887da2a645d979d1 192.168.2.203:7005</span><br><span class="line">   slots:6826,10923-16383 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8861dda48f95e748bc0e7df2757cdc723c897f28 192.168.2.201:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5183cdee2295a07af3e98226887da2a645d979d1</span><br><span class="line">M: a7d09608d3669b0bff9152dc4c62fc2f8e5c2e43 192.168.2.202:7003</span><br><span class="line">   slots:0-1364,6827-10922 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>可以看到，之前<code>203:7005</code>是有2个slave的，Redis Cluster在7008挂掉以后，自动将<code>201:7001</code>作为slave挂载到了<code>202:7004</code>下面。</p>
<h3 id="Redis-Cluster核心原理"><a href="#Redis-Cluster核心原理" class="headerlink" title="Redis Cluster核心原理"></a>Redis Cluster核心原理</h3><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><h5 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h5><p>redis cluster节点间采取gossip协议进行通信，集群本身有很多元数据，比如hashslot和节点之间的映射，master和slave之间的关系，故障信息等等。</p>
<p>像集中式的存储，例如采用zookeeper集中式的维护和存储元数据。举个例子，集群元数据集中式存储的一个典型的代表，就是大数据领域里面的storm（分布式的大数据实时计算引擎），集中式的元数据存储架构底层是基于zookeeper（分布式协调中间件）的集群，这样来维护所有集群的元数据。</p>
<p>gossip跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，每个节点都持有一份元数据，互相之间不断通信，保持整个集群所有节点的数据是完整的。</p>
<p><code>集中式</code>：<strong>好处在于，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到; 不好在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力。</strong></p>
<p><code>gossip</code>：<strong>好处在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续发到所有节点上去更新，有一定的延时，降低了压力; 缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。</strong></p>
<h5 id="10000端口"><a href="#10000端口" class="headerlink" title="10000端口"></a>10000端口</h5><p>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口。每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他节点接收到ping之后返回pong。</p>
<h5 id="交换的信息"><a href="#交换的信息" class="headerlink" title="交换的信息"></a>交换的信息</h5><p>节点之间相互交换信息包括故障信息，节点的增加和移除，hash slot信息，等等。</p>
<h4 id="gossip协议-1"><a href="#gossip协议-1" class="headerlink" title="gossip协议"></a>gossip协议</h4><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等。</p>
<ul>
<li><p>ping: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据。</p>
</li>
<li><p>meet: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信。</p>
<p>  <code>redis-trib.rb add-node</code>其实内部就是发送了一个gossip meet消息，给新加入的节点，通知那个节点去加入我们的集群。</p>
</li>
<li><p>pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新。</p>
</li>
<li><p>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
</li>
</ul>
<p>ping很频繁，而且要携带一些元数据，所以可能会加重网络负担，每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。当然如果发现某个节点通信延时达到了<code>cluster_node_timeout / 2</code>，那么立即发送ping，避免数据交换延时过长，落后的时间太长了，比如说，两个节点之间都10分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。<code>cluster_node_timeout</code>可以调整，如果值比较大，那么会降低发送的频率，每次ping的目的一个是带上自己节点的信息，还有就是带上1/10其他节点的信息一起发送出去，跟其他节点进行数据交换。每次至少发给3个其他节点，最多发送总节点-2个其他节点。</p>
<h3 id="面向集群的jedis内部实现原理"><a href="#面向集群的jedis内部实现原理" class="headerlink" title="面向集群的jedis内部实现原理"></a>面向集群的jedis内部实现原理</h3><p>jedis cluster api与redis cluster集群交互的一些基本原理。</p>
<h4 id="基于重定向的客户端"><a href="#基于重定向的客户端" class="headerlink" title="基于重定向的客户端"></a>基于重定向的客户端</h4><ol>
<li><p>请求重定向</p>
<p> 客户端可能会挑选任意一个redis实例去发送命令，每个redis实例接收到命令，都会计算key对应的hash slot，如果在本地就在本地处理，否则返回moved给客户端，让客户端进行重定向。<code>cluster keyslot mykey</code>，可以查看一个key对应的hash slot是什么。用redis-cli的时候，可以加入-c参数，支持自动的请求重定向，redis-cli接收到moved之后，会自动重定向到对应的节点执行命令。</p>
</li>
<li><p>计算hash slot</p>
<p> 计算hash slot的算法，就是根据key计算CRC16值，然后对16384取模，拿到对应的hash slot。用hash tag可以手动指定key对应的slot，同一个hash tag下的key，都会在一个hash slot中，比如<code>set mykey1:&#123;100&#125;</code>和<code>set mykey2:&#123;100&#125;</code>。</p>
</li>
<li><p>hash slot查找</p>
<p> 节点间通过gossip协议进行数据交换，这样就知道每个hash slot在哪个节点上。</p>
</li>
</ol>
<h4 id="smart-jedis"><a href="#smart-jedis" class="headerlink" title="smart jedis"></a>smart jedis</h4><ol>
<li><p>什么是smart jedis</p>
<p> <strong>基于重定向的客户端，很消耗网络IO，因为大部分情况下，可能都会出现一次请求重定向，才能找到正确的节点。</strong>所以大部分的客户端，比如java redis客户端，就是jedis，都是smart的，本地维护一份hashslot -&gt; node的映射表，大部分情况下，直接走本地缓存就可以找到hashslot -&gt; node，不需要通过节点进行moved重定向。</p>
</li>
<li><p>JedisCluster的工作原理</p>
<p> 在JedisCluster初始化的时候，就会随机选择一个node，初始化hashslot -&gt; node映射表，同时为每个节点创建一个JedisPool连接池。每次基于JedisCluster执行操作，首先JedisCluster都会在本地计算key的hashslot，然后在本地映射表找到对应的节点。如果那个node正好还是持有那个hashslot，那么就ok; 如果进行了reshard这样的操作，可能hashslot已经不在那个node上了，就会返回moved，那么利用该节点的元数据，更新本地的hashslot -&gt; node映射表缓存。重复上面几个步骤，直到找到对应的节点，如果重试超过5次，那么就报错，JedisClusterMaxRedirectionException。jedis老版本，可能会出现在集群某个节点故障还没完成自动切换恢复时，频繁更新hash slot，频繁ping节点检查活跃，导致大量网络IO开销，jedis最新版本，对于这些过度的hash slot更新和ping，都进行了优化，避免了类似问题。</p>
</li>
<li><p>hashslot迁移和ask重定向</p>
<p> 如果hash slot正在迁移，那么会返回ask重定向给jedis，jedis接收到ask重定向之后，会重新定位到目标节点去执行，但是因为ask发生在hash slot迁移过程中，所以JedisCluster API收到ask是不会更新hashslot本地缓存。如果确定hashslot已经迁移完了，moved还是会更新本地hashslot-&gt;node映射表缓存的。</p>
</li>
</ol>
<h3 id="Redis-Cluster高可用性与主备切换原理"><a href="#Redis-Cluster高可用性与主备切换原理" class="headerlink" title="Redis Cluster高可用性与主备切换原理"></a>Redis Cluster高可用性与主备切换原理</h3><p>redis cluster的高可用的原理，几乎跟哨兵是类似的</p>
<ol>
<li><p>判断节点宕机</p>
<p> 如果一个节点认为另外一个节点宕机，那么就是pfail，主观宕机。</p>
<p> 如果多个节点都认为另外一个节点宕机了，那么就是fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown。</p>
<p> 在<code>cluster-node-timeout</code>内，某个节点一直没有返回pong，那么就被认为pfail。</p>
<p> 如果一个节点认为某个节点pfail了，那么会在gossip ping消息中，ping给其他节点，如果超过半数的节点都认为pfail了，那么就会变成fail。</p>
</li>
<li><p>从节点过滤</p>
<p> 对宕机的master node，从其所有的slave node中，选择一个切换成master node。检查每个slave node与master node断开连接的时间，如果超过了<code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就没有资格切换成master，这个从节点超时过滤的步骤也是跟哨兵是一样。</p>
</li>
<li><p>从节点选举</p>
<blockquote>
<p>哨兵：对所有从节点进行排序，先排slave priority，然后offset，最后是run id</p>
</blockquote>
<p> 每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举</p>
<p> 所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master</p>
<p> 从节点执行主备切换，从节点切换为主节点</p>
</li>
<li><p>与哨兵比较</p>
<p> 整个流程跟哨兵相比，非常类似，所以说redis cluster功能强大，直接集成了replication和sentinal的功能。</p>
</li>
</ol>
<h2 id="Redis在实践中的常见问题以及优化思路"><a href="#Redis在实践中的常见问题以及优化思路" class="headerlink" title="Redis在实践中的常见问题以及优化思路"></a>Redis在实践中的常见问题以及优化思路</h2><h3 id="fork耗时导致高并发请求延时"><a href="#fork耗时导致高并发请求延时" class="headerlink" title="fork耗时导致高并发请求延时"></a>fork耗时导致高并发请求延时</h3><p>RDB和AOF的时候，其实生成RDB快照，AOF rewrite会有耗费磁盘IO的过程，主进程fork子进程。fork的时候，子进程是需要拷贝父进程的空间内存页表的，也是会耗费一定的时间的，一般来说，如果父进程内存有1个G的数据，那么fork可能会耗费在20ms左右，如果是10G~30G，那么就会耗费20 * 10，甚至20 * 30，也就是几百毫秒的时间。</p>
<p><code>info stats</code>中的latest_fork_usec，可以看到最近一次fork的时长。redis单机QPS一般在几万，fork可能一下子就会拖慢几万条操作的请求时长，从几毫秒变成1秒。</p>
<p>优化思路：</p>
<p>fork耗时跟redis主进程的内存有关系，一般控制redis的内存在10GB以内，slave -&gt; master，全量复制很耗时。</p>
<h3 id="AOF的阻塞问题"><a href="#AOF的阻塞问题" class="headerlink" title="AOF的阻塞问题"></a>AOF的阻塞问题</h3><p>redis将数据写入AOF缓冲区，单独开一个线程做fsync操作，每秒一次。但是redis主线程会检查两次fsync的时间，如果距离上次fsync时间超过了2秒，那么<strong>数据写请求</strong>就会阻塞。everysec，最多丢失2秒的数据，一旦fsync超过2秒的延时，整个redis就被拖慢。</p>
<p>优化思路：</p>
<p>优化硬盘写入速度，建议采用SSD，不要用普通的机械硬盘，SSD，大幅度提升磁盘读写的速度。</p>
<h3 id="主从复制延迟问题"><a href="#主从复制延迟问题" class="headerlink" title="主从复制延迟问题"></a>主从复制延迟问题</h3><p>主从复制可能会超时严重，这个时候需要良好的监控和报警机制。在<code>info replication</code>中，可以看到master和slave复制的offset，做一个差值就可以看到对应的延迟量，如果延迟过多，那么就进行报警。这个问题主要是做好监控。</p>
<h3 id="主从复制风暴问题"><a href="#主从复制风暴问题" class="headerlink" title="主从复制风暴问题"></a>主从复制风暴问题</h3><p>如果一下子让多个slave从master去执行全量复制，一份大的rdb同时发送到多个slave，会导致网络带宽被严重占用。如果一个master真的要挂载多个slave，那尽量用树状结构，不要用星型结构。</p>
<h3 id="vm-overcommit-memory"><a href="#vm-overcommit-memory" class="headerlink" title="vm.overcommit_memory"></a>vm.overcommit_memory</h3><p>0: 检查有没有足够内存，没有的话申请内存失败<br>1: 允许使用内存直到用完为止<br>2: 内存地址空间不能超过swap + 50%</p>
<p>如果是0的话，可能导致类似fork等操作执行失败，申请不到足够的内存空间</p>
<pre><code>cat /proc/sys/vm/overcommit_memory
echo &quot;vm.overcommit_memory=1&quot; &gt;&gt; /etc/sysctl.conf
sysctl vm.overcommit_memory=1</code></pre>
<h3 id="swapiness"><a href="#swapiness" class="headerlink" title="swapiness"></a>swapiness</h3><pre><code>cat /proc/version，查看linux内核版本</code></pre>
<p>如果linux内核版本&lt;3.5，那么swapiness设置为0，这样系统宁愿swap也不会oom killer（杀掉进程）<br>如果linux内核版本&gt;=3.5，那么swapiness设置为1，这样系统宁愿swap也不会oom killer</p>
<p>这样可以保证redis不会被杀掉</p>
<pre><code>echo 0 &gt; /proc/sys/vm/swappiness
echo vm.swapiness=0 &gt;&gt; /etc/sysctl.conf</code></pre>
<h3 id="最大打开文件句柄"><a href="#最大打开文件句柄" class="headerlink" title="最大打开文件句柄"></a>最大打开文件句柄</h3><pre><code>ulimit -n 10032 10032</code></pre>
<p>去上网搜一下，不同的操作系统，版本，设置的方式都不太一样</p>
<h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp backlog"></a>tcp backlog</h3><pre><code>cat /proc/sys/net/core/somaxconn
echo 511 &gt; /proc/sys/net/core/somaxconn</code></pre>
<h2 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h2><p>如果你的数据量不大，单master就可以容纳，一般来说你的缓存的总量在10G以内就可以，那么建议按照以下架构去部署redis。</p>
<p>redis持久化+备份方案+容灾方案+replication（主从+读写分离）+sentinal（哨兵集群，3个节点，高可用性），可以支撑的数据量在10G以内，可以支撑的写QPS在几万左右，可以支撑的读QPS可以上10万以上（随你的需求，水平扩容slave节点就可以），可用性在99.99%。</p>
<p>如果你的数据量很大，比如（国内排名前三的大电商网站，x宝，x东，x宁易购），数据量是很大的，redis cluster多master分布式存储数据，可以水平扩容。如果要支撑更多的数据量，1T+以上没问题，只要扩容master即可，读写QPS分别都达到几十万都没问题，只要扩容master，redis cluster对读写分离支持不太好，需要执行<code>readonly</code>才能去slave上读。</p>
<p>Redis Cluster支撑99.99%可用性也没问题，slave -&gt; master的主备切换，冗余slave去进一步提升可用性的方案（每个master挂一个slave，但是整个集群再加个3个slave冗余一下）。</p>
]]></content>
      <categories>
        <category>高可用缓存架构实战</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>并发源码-volatile</title>
    <url>/2020/10/22/jdk/%E5%B9%B6%E5%8F%9102/</url>
    <content><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>先说结论，volatile是非常常用的东西，他保证了可见性和有序性。这2个特性分别涉及了JVM的底层原理，最常用的场景，就是共享变量加volatile修饰，这样不同的线程来修改的时候，才能即时的识别到改变，比如标志位、开关等。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务实例是否在运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主内存以及cpu的多级缓存模型"><a href="#主内存以及cpu的多级缓存模型" class="headerlink" title="主内存以及cpu的多级缓存模型"></a>主内存以及cpu的多级缓存模型</h2><p>先看下计算机CPU的多级缓存模型，为什么要讲这个，因为这个就是volatile的基本原理。</p>
<p>volatile的作用就是一个线程修改了一个变量的值以后，另外一个变量立马就能看到最新的值。</p>
<p>我们得先知道，为什么在不加volatile的情况下，它不一定能看到最新的值。</p>
<p>计算机如果频繁的跟主内存做交互的话，性能也是比较差的，所以CPU有自己的缓存，用来提升CPU计算的效率，我们买电脑，也会看到CPU参数里有L1,L2,L3缓存的。</p>
<p>然后CPU读写数据，会先从主内存读取到缓存中，然后频繁的读写，都是在缓存里操作的，缓存的数据会不定时的刷入到主内存中。</p>
<p>![image-20201022104203084](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022104203084.png)</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>那么这么设计有什么问题呢，在正常情况下是没有问题的，但是在多线程并发的情况下，就会有问题了，可能每个线程持有flag的值，是不一样的。</p>
<p>比如线程0先读取了falg=1，然后线程1写入了flag=7， 这时候主内存里已经是flag=7了，线程0和线程1看到flag的值，就是不一样的。</p>
<p>![image-20201022105039663](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022105039663.png)</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>最早的时候，有一个总线加锁的机制，有点类似于悲观锁，一个CPU读取了一个数据后，会通过一个总线，就对这块内存（数据）进行加锁，然后其他CPU就无法再读和写这个数据了，只有当这个CPU修改完成后，其他CPU就可以读到最新的数据，这个效率比较低下，基本成串行化执行了。</p>
<p>所以后面就有了MESI协议，缓存一致性协议。</p>
<p>在MESI缓存一致性协议的保证下，就能保证在多线程并发读写变量，及时感知到了。</p>
<p><strong>未完。。待补充</strong></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型跟CPU缓存模型是类似的，它是基于CPU模型来建立的Java内存模型，只是Java内存模型是标准化的，屏蔽了底层计算机和操作系统的区别。</p>
<p>在Java里，内存分线程工作内存和主内存，他们之间的读写，是用JVM底层的指令完成的。</p>
<ul>
<li>read（从主存读取）</li>
<li>load（将主存读取到的值写入工作内存）</li>
<li>use（从工作内存读取数据来计算）</li>
<li>assign（将计算好的值重新赋值到工作内存中）</li>
<li>store（将工作内存数据写入主存）</li>
<li>write（将store过去的变量值赋值给主存中的变量）</li>
</ul>
<p>![image-20201022135613828](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022135613828.png)</p>
<p>以这个图为例，线程1从主内存读取flag变量，并进行了修改，写入到了工作内存，有可能它只是在工作内存中，没有存入主内存，也就是还没有执行store和write指令，那么线程2来读取flag变量，读到的就依然还是0。</p>
<h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><p>如果变量加了volatile修饰，他就能保证<strong>线程1在执行了assign指令后，马上就跟着执行store+write指令</strong>，将数据写入到主内存中，然后还<strong>将其他线程的工作内存中值，标记为过期</strong>。线程2在发现变量过期以后，会<strong>重新从主内存中读取新的值</strong>，从而保证可见性。</p>
<h2 id="volatile无法保证原子性"><a href="#volatile无法保证原子性" class="headerlink" title="volatile无法保证原子性"></a>volatile无法保证原子性</h2><p>在Java里，像i++这种操作，他在底层执行的时候是多个指令，分别是读取和写入，既然涉及2个操作，就完全有可能在2个线程都读取后，一个线程才完成写入操作，他们读取和写入值，就是一样的。</p>
<h2 id="volatile底层原理"><a href="#volatile底层原理" class="headerlink" title="volatile底层原理"></a>volatile底层原理</h2><h3 id="lock指令"><a href="#lock指令" class="headerlink" title="lock指令"></a>lock指令</h3><p>前面说了volatile是如何保证可见性的，但是在计算机底层，到底发送了什么指令来实现的效果呢？</p>
<p>对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改。</p>
<p>如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了。</p>
<p>lock前缀指令 + MESI缓存一致性协议保证了可见性。</p>
<h3 id="内存屏障：禁止重排序"><a href="#内存屏障：禁止重排序" class="headerlink" title="内存屏障：禁止重排序"></a>内存屏障：禁止重排序</h3><p>volatile可以保证有序性，那么它是如何做到的呢？</p>
<p>它是通过内存屏障来实现的，有这么几种内存屏障，分别对应几种场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load1：</span><br><span class="line"><span class="keyword">int</span> localVar = <span class="keyword">this</span>.variable</span><br><span class="line">LoadLoad屏障</span><br><span class="line">Load2：</span><br><span class="line"><span class="keyword">int</span> localVar = <span class="keyword">this</span>.variable2</span><br></pre></td></tr></table></figure>

<p><strong>LoadLoad屏障</strong>：Load1；LoadLoad；Load2，确保Load1数据的装载先于Load2后所有装载指令，他的意思，Load1对应的代码和Load2对应的代码，是不能指令重排的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Store1：</span><br><span class="line"><span class="keyword">this</span>.variable = <span class="number">1</span></span><br><span class="line">StoreStore屏障</span><br><span class="line">Store2：</span><br><span class="line"><span class="keyword">this</span>.variable2 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>StoreStore屏障</strong>：Store1；StoreStore；Store2，确保Store1的数据一定刷回主存，对其他cpu可见，先于Store2以及后续指令</p>
<p>以及</p>
<p><strong>LoadStore屏障</strong>：Load1；LoadStore；Store2，确保Load1指令的数据装载，先于Store2以及后续指令</p>
<p><strong>StoreLoad屏障</strong>：Store1；StoreLoad；Load2，确保Store1指令的数据一定刷回主存，对其他cpu可见，先于Load2以及后续指令的数据装载</p>
<p>怎么理解这几个屏障呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> variable = <span class="number">1</span></span><br><span class="line"><span class="comment">// StoreStore屏障</span></span><br><span class="line"><span class="comment">// 写入变量，这是store操作</span></span><br><span class="line"><span class="keyword">this</span>.variable = <span class="number">2</span>  </span><br><span class="line"><span class="comment">// StoreLoad屏障</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 从主内存中读取变量，是load操作</span></span><br><span class="line"><span class="keyword">int</span> localVariable = <span class="keyword">this</span>.variable</span><br><span class="line"><span class="comment">// LoadLoad屏障</span></span><br><span class="line"><span class="comment">// LoadStore屏障</span></span><br></pre></td></tr></table></figure>

<p>对于volatile修饰变量的读写操作，都会加入内存屏障。</p>
<p>每个volatile写操作前面，都会加入StoreStore屏障，禁止普通写和volatile写重排，每个volatile写操作后面，会加入StoreLoad屏障，禁止跟后面的volatile读/写重排。</p>
<p>每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止后面的普通写和volatile读重排</p>
<p>![07_volatile和内存屏障](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/07_volatile和内存屏障.png)</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发源码-Atomic</title>
    <url>/2020/10/22/jdk/%E5%B9%B6%E5%8F%9104/</url>
    <content><![CDATA[<h1 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h1><p>AtomicInteger，可实现原子化的操作，不需要加锁，他底层是通过CAS实现的，看下使用方式</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger j = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        synchronizedAdd();</span><br><span class="line"></span><br><span class="line">        atomicAdd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 加锁后变慢</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (AtomicIntegerDemo.class) &#123;</span><br><span class="line">                        System.out.println(++i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(j.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicLong、AtomicBoolean、AtomicReference、LongAdder等类，都是不加锁的，效率比较高，在项目中可以多用下。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><blockquote>
<p>判断此时此刻是否是某个值，如果是，则修改，如果不是则重新查询一个最新的值，再次执行判断，这个操作叫做CAS，Compare and Set。</p>
</blockquote>
<p>Atomic原子类底层核心的原理就是CAS，每次尝试修改的时候都先对比一下，有没有人修改过这个值，没有人修改就自己修改，如果有人修改过，就重新查出来最新的值，再次重复那个过程。</p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Atomic原子类，底层是通过JDK提供的Unsafe类去实现的，这个类不能由用户来实例化的，我们在自己的代码也无法去使用它的方法，他会在源码检查类加载器类型，如果非Bootstrap classloader就会抛异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 这里有判断，如果类加载器不对，就报错了</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后他具体实现Unsafe封装了一些不安全的操作，例如CAS操作的代码，比较底层，下面开始看下源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录了当前对象里value在内存中的偏移量</span></span><br><span class="line">        <span class="comment">// 这个偏移量，是不会发生变化的，后续的CAS操作，会用到这个值，非常关键</span></span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体保存int值的变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>incrementAndGet源码，是如何完成原子操作的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用了Unsafe的方法，并将自己传入</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var1 = AtomicInteger</span></span><br><span class="line"><span class="comment">// var2 = valueOffset</span></span><br><span class="line"><span class="comment">// var4 = 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 会用getIntVolatile方法</span></span><br><span class="line">		<span class="comment">// 从AtomicInteger对象实例，根据valueOffset偏移量，知道了value这个字段的位置</span></span><br><span class="line">		<span class="comment">// 去获取到当前的value的值</span></span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    <span class="comment">// compareAndSwapInt()，CAS方法，是Native的方法</span></span><br><span class="line">    <span class="comment">// var5，也就是原始值，假设是1，他会用这个值，和AtomicInteger的value值compare，如果是一样</span></span><br><span class="line">    <span class="comment">// 就会set，也就是将value的值给设置为：var5=l（之前拿到的值） + 1（递增的值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果var5=l（获取到的值），跟AtomicInteger + valueOffset获取到的当前的值，不一样的话</span></span><br><span class="line">    <span class="comment">// 此时compareAndSwapInt方法就会返回false，然后while循环就会自动进入下一轮</span></span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="comment">// 如果是cas成功后，还是会返回一个var5=l，这是旧的值，所以incrementAndGet()最后会自己+1再返回</span></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS底层，是通过CPU指令来完成的，对一小块内存进行加锁，保证他的原子性。</p>
<h2 id="Atomic类CAS的三个缺点"><a href="#Atomic类CAS的三个缺点" class="headerlink" title="Atomic类CAS的三个缺点"></a>Atomic类CAS的三个缺点</h2><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>比如本来这个值，一开始是A，后来变成了B，然后又变成了A，假设代码期望A就设置新的值，结果线程1A-&gt;B-&gt;，他将值设置了回去，然后线程2发现确实是A，然后就cas成功了，他无法识别值是否发生过变化。从 Java 1.5 开始，JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题，会比较两个值的引用是否一致，如果一致，才会设置新值。</p>
<h4 id="无限循环问题"><a href="#无限循环问题" class="headerlink" title="无限循环问题"></a>无限循环问题</h4><p>上面源码看了，cas在有无限循环在里面的，在高并发场景下，多线程频繁并发修改，可能有的线程就会循环很多次才能cas成功，这个问题在JDK 1.8引入了LongAdder来解决，他采用分段CAS的思路。</p>
<h4 id="多变量原子问题"><a href="#多变量原子问题" class="headerlink" title="多变量原子问题"></a>多变量原子问题</h4><p>AtomicInteger，只保证了一个int变量的原子操作，多个变量可以用AtomicReference，将多个变量封装到一个对象里，然后他会检查这个对象的引用是不是一个。</p>
<h1 id="LongAddr"><a href="#LongAddr" class="headerlink" title="LongAddr"></a>LongAddr</h1><p>针对无线循环的问题JDK 1.8引入了LongAdder，我们来看一下他是如何提升性能的。</p>
<p>LongAdder里面有一个cell数组，cell是在Striped64中的静态内部类，每个cell维护自己的value，AtomicInteger中仅维护一个全局的value，调用sum将所有cell的value和base相加就是最终的值。</p>
<p>这样就实现了分段CAS，减少并发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20201022193908559](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022193908559.png)</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发源码-锁</title>
    <url>/2020/10/23/jdk/%E5%B9%B6%E5%8F%9103/</url>
    <content><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized就是加锁，一旦加锁以后，就只能当前线程访问和修改加锁的变量，其他线程只能阻塞等待，这就保证了原子性。</p>
<p>synchronized可以锁两种对象，一种是对某个实例对象进行加锁，一种是对类进行加锁。对类加锁，本质上也是对实例加锁，只不过是对class对象进行加锁。</p>
<p>如果用synchronized修饰普通方法，那就是对当前类的实例进行加锁。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用synchronized修饰静态方法，那就是对当前类的class对象进行加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(Demo.class) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized涉及到jvm底层的两个指令，分别是monitorenter和monitorexit两个指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">monitorenter</span><br><span class="line"><span class="comment">// 代码对应的指令</span></span><br><span class="line">monitorexit</span><br></pre></td></tr></table></figure>

<p>每个对象都有一个关联的monitor属性，比如一个对象实例就有一个monitor，一个类的class对象也有一个monitor，如果要对这个对象进行加锁，那么必须获取这个对象关联的monitor的lock锁。</p>
<p>原理大概就是，monitor里有一个从0开始的计数器，如果一个线程要获取monitor的锁，就看他的计数器是不是0，如果是0，说明没人获取锁，然后拿到锁以后就加1。</p>
<p>同时，monitor是支持重入锁的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line"><span class="comment">// 一大堆的代码</span></span><br><span class="line">  <span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line">  <span class="comment">// 一大堆的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就对同一个对象，加了两次锁，猜一下就知道，他原理肯定是每次进到synchronized(myObject)代码的时候，先看对象的monitor里的计数器是不是0，如果是0，就直接获取锁，并把对象里的monitor的计数器加1，如果不是0，看加锁的时候是不是同一个线程，如果是，就再加1，如果不是同一个线程呢，那就阻塞等待吧。</p>
<p>然后执行代码代码块退出的时候，会执行monitorexit的指令，此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0。</p>
<p>然后之前阻塞的线程，再次竞争锁，但是只有一个线程可以拿到锁。</p>
<p>![image-20201022162819834](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022162819834.png)</p>
<h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p>对于有锁的代码，也就离不开wait和notify的使用，在加锁的代码中，可以wait挂起线程，并释放锁，除非其他线程对同一个对象调用notify，线程被唤醒，然后再次尝试获取锁。</p>
<p>wait与notify，跟synchronized是同样的原理，都是monitor，对象的monitor里，除了计数器，还有一个叫wait set的变量，加锁的时候，会对对象的monitor的计数器+1，如果调用wait方法，会将当前线程的id之类的东西，加入到monitor的wait set中，如果对这个对象调用notifyAll()，就会清空wait set，并同时唤醒所有线程。</p>
<p>![image-20201022163420129](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201022163420129.png)</p>
<p>面试有个经常问的问题，wait与sleep的区别：前者释放锁，后者不释放锁</p>
<p>wait()，必须是有人notify唤醒他</p>
<p>wait(timeout)，阻塞一段时间，然后自己唤醒，继续争抢锁</p>
<p>wait与notify，必须在synchronized代码块中使用，因为必须是拥有monitor lock的线程才可以执行wait与notify操作</p>
<p>因此wait与notify，必须与synchornized一起，对同一个对象进行使用，这样他们对应的monitor才是一样的</p>
<p> notify()与notifyall()：前者就唤醒block状态的一个线程，后者唤醒block状态的所有线程</p>
<h2 id="synchronized能不能保证可见性"><a href="#synchronized能不能保证可见性" class="headerlink" title="synchronized能不能保证可见性"></a>synchronized能不能保证可见性</h2><p>synchronized是可以保证可见性的，那么单例模式双检锁的volatile，是做什么用的呢？看下面的解释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile在这里的作用是为了防止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = <span class="keyword">new</span> Socket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized本身就是可以保证可见性的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                    <span class="comment">// 对象的初始化是分为几个步骤的：初始化一块内存空间，给对象里的变量进行初始化，执行构造方法等等</span></span><br><span class="line">                    <span class="comment">// 有可能会出现指令重排，有可能会导致DoubleCheckSingleton里的字段还没有在构造函数里初始化，比如socket，还是null</span></span><br><span class="line">                    <span class="comment">// 但是内存空间已经分配好了，指针也分配了，也就是instance变量不是null</span></span><br><span class="line">                    <span class="comment">// 此时另外一个线程来调用的时候，发现instance不是null，然后返回，马上进行相关调用，结果发现socket是null，调用失败</span></span><br><span class="line">                    <span class="comment">// volatile有内存屏障，写操作后有storeload屏障，会保证写完之前不能被读到</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>Java除了使用关键字synchronized外，还可以使用ReentrantLock实现独占锁的功能。而且ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。而且ReentrantLock还支持读写锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻一下ReentrantLock的源码，发现它是基于<strong>AbstractQueuedSynchronizer</strong>做的，也就是我们平常说的AQS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认就构造了一个非公平锁，NonfairSync是基于AQS实现的组件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的lock方法， 也是直接调用了sync的lock()方法，ReentrantLock在加锁的时候，就是直接基于Sync来实现的lock操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Sync，是一个抽象的静态类，他继承自AbstractQueuedSynchronizer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><strong>AbstractQueuedSynchronizer</strong>，抽象队列同步器。</p>
<p>ReentractLock和ReadWriteReentractLock，这个锁的API都是基于AQS来实现的，我们一般也没有直接用AQS的API来做开发，但是并发包里的很多类，都是基于AQS来实现的。截图看下，除了锁，还有Semaphore，CountDownLatch，ThreadPoolExecutor这些。</p>
<p>![image-20201027140545860](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201027140545860.png)</p>
<p>AQS是一个双向链表，或者说一个双端队列，原理大致如图，通过state核心变量控制是否加锁成功，并记录加锁的线程，等待锁的线程，放入队列中</p>
<p>![image-20201027154725975](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/image-20201027154725975.png)</p>
<h3 id="lock加锁"><a href="#lock加锁" class="headerlink" title="lock加锁"></a>lock加锁</h3><p>AQS中使用了大量的CAS操作来实现加锁和释放锁的代码，AQS里有一个核心变量，state，代表了锁的状态，0就是没线程加锁，1就是有线程加锁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>所以加锁的代码其实很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cas操作修改state变量，state=1表示已经有线程获取到了锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 当前获取到锁的线程是谁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 没有获取到锁，排队</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h4><p>acquire(1); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用到NonfairSync的tryAcquire()方法，通过不复杂的代码，实现了锁的重入，如果加锁的线程和当前线程是同一个线程，就state+1，并返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// volatile在JDK源码中得到了大量的运用</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 同一个线程调用lock方法，所以state不为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并且当前线程和加锁的线程是相同的，那就再次加锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 所以state + 1 = 2</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改state，volatile保证了可见性</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他线程，就走到这了，加锁失败了，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回false以后，就要执行addWaiter，构造AQS等待队列里的等待节点了</p>
<h4 id="入队等待"><a href="#入队等待" class="headerlink" title="入队等待"></a>入队等待</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个加锁失败</span></span><br><span class="line">    <span class="comment">// 调用acquireQueued入队</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// addWaiter(Node.EXCLUSIVE),表示这是一个独占锁的等待节点，另外的还有共享锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成了一个Node，mode = EXCLUSIVE（排他锁，尝试获取一个排他锁，但是失败了）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// tail刚开始是null，把当前队列的尾巴，设置当前节点的pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个入队的线程直接到这里来了</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下Node的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个线程无法获取到锁的话，会进入一个阻塞等待的状态</span></span><br><span class="line"><span class="comment">// 卡住不动，线程挂起，阻塞状态又细分为很多种不同的阻塞状态：</span></span><br><span class="line"><span class="comment">// CANCELED、SIGNAL、CONDITION、PROPAGATE</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="comment">// 一个节点可以有上一个节点，prev指针，指向了Node的上一个Node</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="comment">// 一个节点还可以有下一个节点，next指针，指向了Node的下一个Node</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">// Node里面封装了一个线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"><span class="comment">// 可以认为是下一个等待线程</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>加锁失败的话，就将当前线程封装成一个Node，并且有prev何next指针，所以如果有多个处于阻塞等待状态的线程，封装后的Node组成了一个双向链表，也就成了一个队列。</p>
<p>![AQS原理-双向链表](/Users/yangfan/Nutstore Files/code/blog/source/img/jdk/AQS原理-双向链表.png)</p>
<p>接着看一下入队的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1:第一个入队的Node，tail是null</span></span><br><span class="line">        <span class="comment">// 3: 循环第二次，tail=空Node</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 2:走到这里，用cas将head设置为空节点，然后tail也是空节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 循环没有退出，继续执行循环</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4:node.prev=空Node</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 5：用cas将当前节点设置为tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 6：讲当前节点设置为之前tail的next</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是**addWaiter(Node.EXCLUSIVE)**的逻辑，构造完Node节点后，然后就开始进行线程的入队操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取到node的前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 再尝试一次加锁，如果加锁成功了，那当前节点就变成head了</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
